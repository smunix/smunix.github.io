<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!-- Mirrored from cis.upenn.edu/~cis194/fall16/lectures/09-more-applicative.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 20 Dec 2016 17:05:54 GMT -->
<head>
  <META http-equiv="Content-Type" content="text/html; charset='UTF-8'">
  <title>CIS194</title>

  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <link href="../css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>

  <div id="canvas">
    <div id="nav">
     <p><a href="../index-2.html">CIS 194</a> | <a href="../policies.html">Policies</a> | <a href="../resources.html">Resources</a> | <a href="../final.html">Final Project</a></p>
   </div>

    
    <div id="topic">
    More Applicative
    </div>
    

    
    <div role="nav" id="toc">
     <ul>
<li><a href="#the-parser">The parser</a></li>
<li><a href="#newtypes">newtypes</a></li>
<li><a href="#ebnf-producing-code">EBNF producing code</a><ul>
<li><a href="#an-ebnf-library">An EBNF library</a></li>
<li><a href="#grammar-combinators">Grammar combinators</a><ul>
<li><a href="#the-definition">The definition</a></li>
<li><a href="#primitive-combinators">Primitive combinators</a></li>
<li><a href="#instances">Instances</a></li>
<li><a href="#derived-combinators">Derived combinators</a></li>
<li><a href="#loops-and-laws">Loops and laws</a></li>
<li><a href="#ebnf-for-csv-files">EBNF for CSV files</a></li>
</ul></li>
<li><a href="#tracking-productions">Tracking productions</a></li>
</ul></li>
<li><a href="#combining-parsers-and-grammers">Combining Parsers and Grammers</a><ul>
<li><a href="#the-ini-file-parser">The INI file parser</a></li>
<li><a href="#a-new-main">A new main</a></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
    </div>
    


    <div id="content">
      <p>Today we will not learn much new stuff, but rather dwell a bit on the <code>Monad</code> vs. <code>Applicative</code> distinction, and see a rather impressive example abstraction due to these concepts, and due to type classes.</p>
<p>The code for the lecture needs</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Char</span>
<span class="kw">import </span><span class="dt">Data.Maybe</span>
<span class="kw">import </span><span class="dt">Data.List</span>

<span class="kw">import </span><span class="dt">System.Environment</span>
<span class="kw">import </span><span class="dt">System.IO</span>
<span class="kw">import </span><span class="dt">System.Exit</span></code></pre></div>
<h1 id="the-parser">The parser</h1>
<p>Here is a parser as introduced in last week’s homework:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Parser</span> a <span class="fu">=</span> <span class="dt">P</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">String</span>))

<span class="ot">runParser ::</span> <span class="dt">Parser</span> t <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (t, <span class="dt">String</span>)
runParser (<span class="dt">P</span> p) <span class="fu">=</span> p

<span class="ot">parse ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
parse p input <span class="fu">=</span> <span class="kw">case</span> runParser p input <span class="kw">of</span>
    <span class="dt">Just</span> (result, <span class="st">&quot;&quot;</span>) <span class="ot">-&gt;</span> <span class="dt">Just</span> result
    _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span> <span class="co">-- handles both no result and leftover input</span>

<span class="ot">noParserP ::</span> <span class="dt">Parser</span> a
noParserP <span class="fu">=</span> <span class="dt">P</span> (\_ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>)

<span class="ot">pureParserP ::</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
pureParserP x <span class="fu">=</span> <span class="dt">P</span> (\input <span class="ot">-&gt;</span> <span class="dt">Just</span> (x,input))

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Parser</span> <span class="kw">where</span>
    fmap f p <span class="fu">=</span> <span class="dt">P</span> p'
      <span class="kw">where</span>
        p' input <span class="fu">=</span> <span class="kw">case</span> runParser p input <span class="kw">of</span>
            <span class="dt">Just</span> (result, rest) <span class="ot">-&gt;</span> <span class="dt">Just</span> (f result, rest)
            <span class="dt">Nothing</span>             <span class="ot">-&gt;</span> <span class="dt">Nothing</span>

<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Parser</span> <span class="kw">where</span>
    pure <span class="fu">=</span> pureParserP
    p1 <span class="fu">&lt;*&gt;</span> p2 <span class="fu">=</span> <span class="dt">P</span> <span class="fu">$</span> \input <span class="ot">-&gt;</span> <span class="kw">do</span>
        (f, rest1) <span class="ot">&lt;-</span> runParser p1 input
        (x, rest2) <span class="ot">&lt;-</span> runParser p2 rest1
        return (f x, rest2)


<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Parser</span> <span class="kw">where</span>
    return <span class="fu">=</span> pure
    p1 <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> <span class="dt">P</span> <span class="fu">$</span> \input <span class="ot">-&gt;</span> <span class="kw">do</span>
        (x, rest1) <span class="ot">&lt;-</span> runParser p1 input
        runParser (k x) rest1

<span class="ot">anyCharP ::</span> <span class="dt">Parser</span> <span class="dt">Char</span>
anyCharP <span class="fu">=</span> <span class="dt">P</span> <span class="fu">$</span> \input <span class="ot">-&gt;</span> <span class="kw">case</span> input <span class="kw">of</span>
    (c<span class="fu">:</span>rest) <span class="ot">-&gt;</span> <span class="dt">Just</span> (c, rest)
    []       <span class="ot">-&gt;</span> <span class="dt">Nothing</span>

<span class="ot">charP ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> ()
charP c <span class="fu">=</span> <span class="kw">do</span>
    c' <span class="ot">&lt;-</span> anyCharP
    <span class="kw">if</span> c <span class="fu">==</span> c' <span class="kw">then</span> return ()
               <span class="kw">else</span> noParserP

<span class="ot">anyCharButP ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span>
anyCharButP c <span class="fu">=</span> <span class="kw">do</span>
    c' <span class="ot">&lt;-</span> anyCharP
    <span class="kw">if</span> c <span class="fu">/=</span> c' <span class="kw">then</span> return c'
               <span class="kw">else</span> noParserP

<span class="ot">letterOrDigitP ::</span> <span class="dt">Parser</span> <span class="dt">Char</span>
letterOrDigitP <span class="fu">=</span> <span class="kw">do</span>
    c <span class="ot">&lt;-</span> anyCharP
    <span class="kw">if</span> isAlphaNum c <span class="kw">then</span> return c <span class="kw">else</span> noParserP

<span class="ot">orElseP ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
orElseP p1 p2 <span class="fu">=</span> <span class="dt">P</span> <span class="fu">$</span> \input <span class="ot">-&gt;</span> <span class="kw">case</span> runParser p1 input <span class="kw">of</span>
    <span class="dt">Just</span> r <span class="ot">-&gt;</span> <span class="dt">Just</span> r
    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> runParser p2 input

<span class="ot">manyP ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> [a]
manyP p <span class="fu">=</span> (pure (<span class="fu">:</span>) <span class="fu">&lt;*&gt;</span> p <span class="fu">&lt;*&gt;</span> manyP p) <span class="ot">`orElseP`</span> pure []

<span class="ot">many1P ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> [a]
many1P p <span class="fu">=</span> pure (<span class="fu">:</span>) <span class="fu">&lt;*&gt;</span> p <span class="fu">&lt;*&gt;</span> manyP p

<span class="ot">sepByP ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> () <span class="ot">-&gt;</span> <span class="dt">Parser</span> [a]
sepByP p1 p2 <span class="fu">=</span> ((<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> p1 <span class="fu">&lt;*&gt;</span> (manyP (p2 <span class="fu">*&gt;</span> p1))) <span class="ot">`orElseP`</span> pure []</code></pre></div>
<p>It differs slightly from the example homework solution:</p>
<ul>
<li>It has <code>P</code> appended to all the definitions, to avoid name clashes later.</li>
<li>It uses <code>newtype</code> instead of <code>data</code>.</li>
<li>It uses <code>pure (:) &lt;*&gt;</code> instead of <code>(:) &lt;$&gt;</code>. Of course, these expressions are the same; this is for didactic reasons later.</li>
<li>Some monadic operations (<code>return</code>, <code>(&gt;&gt;)</code>) are replaced their applicative counterparts (<code>pure</code>, <code>(*&gt;)</code>).</li>
</ul>
<h1 id="newtypes">newtypes</h1>
<p>So what is this <code>newtype</code> about? Two weeks ago we visualized the memory representation of data in Haskell, and we saw that a constructor like <code>Just</code> is a box of its own, with a pointer to the actual data. This was necessary to distinguish it from <code>Nothing</code>.</p>
<p>But for a type such as</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Parser</span> a <span class="fu">=</span> <span class="dt">P</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">String</span>))</code></pre></div>
<p>where there is <em>exactly one</em> constructor with <em>exactly one</em> parameter, this box does not really add anything. The only point of using <code>data</code> here is to give the type <code>String -&gt; Maybe (a, String)</code> a new, separate name – operationally, these two types are isomorphic, and we’d rather not have this box.</p>
<p>By writing</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Parser</span> a <span class="fu">=</span> <span class="dt">P</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">String</span>))</code></pre></div>
<p>we avoid the indirection. Using this keyword, we still get a new, separate type, and on the language level, not much changes – we produce values of type <code>Parser</code> using <code>P</code>, and get hold of the function by pattern matching. But the operational overhead is eliminated.</p>
<p>Contrast this with <code>type</code> which introduces only a synonym, so does not incur an operational overhead, but also does not introduce a separate type.</p>
<h1 id="ebnf-producing-code">EBNF producing code</h1>
<p>Usually when we write a parser for a file format, we might also want to have a formal specification of the format, commonly given as an <a href="https://en.wikipedia.org/wiki/Extended_Backus–Naur_Form">EBNF syntax</a>. Here, for example, for CSV files:</p>
<pre><code>cell = '&quot;', {not-quote}, '&quot;';
line = (cell, {',', cell} | ''), newline;
csv  = {line};</code></pre>
<h2 id="an-ebnf-library">An EBNF library</h2>
<p>It is straight-forward to create a Haskell data type to represent an EBNF syntax description. Here is a simple EBNF library (data type and pretty-printer) for your convenience:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">RHS</span>
  <span class="fu">=</span> <span class="dt">Terminal</span> <span class="dt">String</span>
  <span class="fu">|</span> <span class="dt">NonTerminal</span> <span class="dt">String</span>
  <span class="fu">|</span> <span class="dt">Choice</span> <span class="dt">RHS</span> <span class="dt">RHS</span>
  <span class="fu">|</span> <span class="dt">Sequence</span> <span class="dt">RHS</span> <span class="dt">RHS</span>
  <span class="fu">|</span> <span class="dt">Optional</span> <span class="dt">RHS</span>
  <span class="fu">|</span> <span class="dt">Repetition</span> <span class="dt">RHS</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)

<span class="ot">mkChoices ::</span> <span class="dt">RHS</span> <span class="ot">-&gt;</span> [<span class="dt">RHS</span>] <span class="ot">-&gt;</span> <span class="dt">RHS</span>
mkChoices <span class="fu">=</span> foldl <span class="dt">Choice</span>

<span class="ot">mkSequences ::</span> <span class="dt">RHS</span> <span class="ot">-&gt;</span> [<span class="dt">RHS</span>] <span class="ot">-&gt;</span> <span class="dt">RHS</span>
mkSequences <span class="fu">=</span> foldl <span class="dt">Sequence</span>

<span class="ot">ppRHS ::</span> <span class="dt">RHS</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
ppRHS <span class="fu">=</span> go <span class="dv">0</span>
  <span class="kw">where</span>
    go _ (<span class="dt">Terminal</span> s)     <span class="fu">=</span> surround <span class="st">&quot;'&quot;</span> <span class="st">&quot;'&quot;</span> <span class="fu">$</span> concatMap quote s
    go _ (<span class="dt">NonTerminal</span> s)  <span class="fu">=</span> s
    go a (<span class="dt">Choice</span> x1 x2)   <span class="fu">=</span> p a <span class="dv">1</span> <span class="fu">$</span> go <span class="dv">1</span> x1 <span class="fu">++</span> <span class="st">&quot; | &quot;</span> <span class="fu">++</span> go <span class="dv">1</span> x2
    go a (<span class="dt">Sequence</span> x1 x2) <span class="fu">=</span> p a <span class="dv">2</span> <span class="fu">$</span> go <span class="dv">2</span> x1 <span class="fu">++</span> <span class="st">&quot;, &quot;</span>  <span class="fu">++</span> go <span class="dv">2</span> x2
    go _ (<span class="dt">Optional</span> x)     <span class="fu">=</span> surround <span class="st">&quot;[&quot;</span> <span class="st">&quot;]&quot;</span> <span class="fu">$</span> go <span class="dv">0</span> x
    go _ (<span class="dt">Repetition</span> x)   <span class="fu">=</span> surround <span class="st">&quot;{&quot;</span> <span class="st">&quot;}&quot;</span> <span class="fu">$</span> go <span class="dv">0</span> x

    surround c1 c2 x <span class="fu">=</span> c1 <span class="fu">++</span> x <span class="fu">++</span> c2

    p a n <span class="fu">|</span> a <span class="fu">&gt;</span> n     <span class="fu">=</span> surround <span class="st">&quot;(&quot;</span> <span class="st">&quot;)&quot;</span>
          <span class="fu">|</span> otherwise <span class="fu">=</span> id

    quote <span class="ch">'\''</span> <span class="fu">=</span> <span class="st">&quot;\\'&quot;</span>
    quote <span class="ch">'\\'</span> <span class="fu">=</span> <span class="st">&quot;\\\\&quot;</span>
    quote c    <span class="fu">=</span> [c]

<span class="kw">type</span> <span class="dt">Production</span> <span class="fu">=</span> (<span class="dt">String</span>, <span class="dt">RHS</span>)
<span class="kw">type</span> <span class="dt">BNF</span> <span class="fu">=</span> [<span class="dt">Production</span>]

<span class="ot">ppBNF ::</span> <span class="dt">BNF</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
ppBNF <span class="fu">=</span> unlines <span class="fu">.</span> map (\(i,rhs) <span class="ot">-&gt;</span> i <span class="fu">++</span> <span class="st">&quot; = &quot;</span> <span class="fu">++</span> ppRHS rhs <span class="fu">++</span> <span class="st">&quot;;&quot;</span>)</code></pre></div>
<h2 id="grammar-combinators">Grammar combinators</h2>
<p>We had a good time writing combinators that create complex parsers from primitive pieces. Let us do the same for EBNF grammars. We could simply work on the <code>RHS</code> type directly, but we can do something more nifty: We create a data type that keeps track, via a <em>phantom</em> type parameter, of what Haskell type the given EBNF syntax is the specification:</p>
<h3 id="the-definition">The definition</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Grammar</span> a <span class="fu">=</span> <span class="dt">G</span> <span class="dt">RHS</span>

<span class="ot">ppGrammar ::</span> <span class="dt">Grammar</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>
ppGrammar (<span class="dt">G</span> rhs) <span class="fu">=</span> ppRHS rhs</code></pre></div>
<p>So a value of type <code>Grammar t</code> is a description of the textual representation of the Haskell type <code>t</code>.</p>
<h3 id="primitive-combinators">Primitive combinators</h3>
<p>Here is one simple example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">anyCharG ::</span> <span class="dt">Grammar</span> <span class="dt">Char</span>
anyCharG <span class="fu">=</span> <span class="dt">G</span> (<span class="dt">NonTerminal</span> <span class="st">&quot;char&quot;</span>)</code></pre></div>
<p>Here is another one. This one does not describe any interesting Haskell type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">charG ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Grammar</span> ()
charG c <span class="fu">=</span> <span class="dt">G</span> (<span class="dt">Terminal</span> [c])</code></pre></div>
<p>A combinator that creates new grammars from two existing grammars:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">orElseG ::</span> <span class="dt">Grammar</span> a <span class="ot">-&gt;</span> <span class="dt">Grammar</span> a <span class="ot">-&gt;</span> <span class="dt">Grammar</span> a
orElseG (<span class="dt">G</span> rhs1) (<span class="dt">G</span> rhs2) <span class="fu">=</span> <span class="dt">G</span> (<span class="dt">Choice</span> rhs1 rhs2)</code></pre></div>
<h3 id="instances">Instances</h3>
<p>We want to use our nice type classes for type constructors to work with these values:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Grammar</span> <span class="kw">where</span>
    fmap _ (<span class="dt">G</span> rhs) <span class="fu">=</span> <span class="dt">G</span> rhs

<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Grammar</span> <span class="kw">where</span>
    pure x <span class="fu">=</span> <span class="dt">G</span> (<span class="dt">Terminal</span> <span class="st">&quot;&quot;</span>)
    (<span class="dt">G</span> rhs1) <span class="fu">&lt;*&gt;</span> (<span class="dt">G</span> rhs2) <span class="fu">=</span> <span class="dt">G</span> (<span class="dt">Sequence</span> rhs1 rhs2)</code></pre></div>
<p>Note how the <code>Functor</code> instance does not actually use the function. How should it? There are no values inside a <code>Grammar</code>!</p>
<p>We cannot define a <code>Monad</code> instance for <code>Grammar</code>: We would start with <code>(G rhs1) &gt;&gt;= k = …</code>, but there is simply no way of getting a value of type <code>a</code> that we can feed to <code>k</code>. So we will do without a <code>Monad</code> instance. This is interesting, and we will come back to that later.</p>
<h3 id="derived-combinators">Derived combinators</h3>
<p>Like with the parser, we can now begin to build on the primitive example to build more complicated combinators:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">manyG ::</span> <span class="dt">Grammar</span> a <span class="ot">-&gt;</span> <span class="dt">Grammar</span> [a]
manyG p <span class="fu">=</span> (pure (<span class="fu">:</span>) <span class="fu">&lt;*&gt;</span> p <span class="fu">&lt;*&gt;</span> manyG p) <span class="ot">`orElseG`</span> pure []

<span class="ot">many1G ::</span> <span class="dt">Grammar</span> a <span class="ot">-&gt;</span> <span class="dt">Grammar</span> [a]
many1G p <span class="fu">=</span> pure (<span class="fu">:</span>) <span class="fu">&lt;*&gt;</span> p <span class="fu">&lt;*&gt;</span> manyG p

<span class="ot">sepByG ::</span> <span class="dt">Grammar</span> a <span class="ot">-&gt;</span> <span class="dt">Grammar</span> () <span class="ot">-&gt;</span> <span class="dt">Grammar</span> [a]
sepByG p1 p2 <span class="fu">=</span> ((<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> p1 <span class="fu">&lt;*&gt;</span> (manyG (p2 <span class="fu">*&gt;</span> p1))) <span class="ot">`orElseG`</span> pure []</code></pre></div>
<h3 id="loops-and-laws">Loops and laws</h3>
<p>Lets run a small example</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">dottedWordsG ::</span> <span class="dt">Grammar</span> [<span class="dt">String</span>]
dottedWordsG <span class="fu">=</span> many1G (manyG anyCharG <span class="fu">&lt;*</span> charG <span class="ch">'.'</span>)</code></pre></div>
<pre><code>*Main&gt; putStrLn $ ppGrammar dottedWordsG
'', ('', char, ('', char, ('', char, ('', char, ('', char, ('', …</code></pre>
<p>Oh my, that is not good. Looks like the recursion in <code>manyG</code> does not work well, so we need to avoid that. But anyways we want to be explicit in the EBNF grammars about where something can be repeated, so let us make <code>many</code> primitive as well:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">manyG ::</span> <span class="dt">Grammar</span> a <span class="ot">-&gt;</span> <span class="dt">Grammar</span> [a]
manyG (<span class="dt">G</span> rhs) <span class="fu">=</span> <span class="dt">G</span> (<span class="dt">Repetition</span> rhs)</code></pre></div>
<p>With this definition, we already get a simple grammar for <code>dottedWordsG</code>:</p>
<pre><code>*Main&gt; putStrLn $ ppGrammar dottedWordsG
'', {char}, '.', {{char}, '.'}</code></pre>
<p>This already looks like a proper EBNF grammar. One thing that is not nice about it is that there is an empty string (<code>''</code>) in a sequence (<code>…,…</code>). We do not want that.</p>
<p>Why is it there in the first place? Because our <code>Applicative</code> instance is not lawful! Remember that <code>pure id &lt;*&gt; g == g</code> should hold. One way to achieve that is to improve the <code>Applicative</code> instance to optimize this case away:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Grammar</span> <span class="kw">where</span>
    pure x <span class="fu">=</span> <span class="dt">G</span> (<span class="dt">Terminal</span> <span class="st">&quot;&quot;</span>)
    <span class="dt">G</span> (<span class="dt">Terminal</span> <span class="st">&quot;&quot;</span>) <span class="fu">&lt;*&gt;</span> <span class="dt">G</span> rhs2 <span class="fu">=</span> <span class="dt">G</span> rhs2
    <span class="dt">G</span> rhs1 <span class="fu">&lt;*&gt;</span> <span class="dt">G</span> (<span class="dt">Terminal</span> <span class="st">&quot;&quot;</span>) <span class="fu">=</span> <span class="dt">G</span> rhs1
    (<span class="dt">G</span> rhs1) <span class="fu">&lt;*&gt;</span> (<span class="dt">G</span> rhs2) <span class="fu">=</span> <span class="dt">G</span> (<span class="dt">Sequence</span> rhs1 rhs2)</code></pre></div>
<p>Now we get what we want:</p>
<pre><code>*Main&gt; putStrLn $ ppGrammar dottedWordsG
{char}, '.', {{char}, '.'}</code></pre>
<h3 id="ebnf-for-csv-files">EBNF for CSV files</h3>
<p>We had a parser for CSV files:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseCSVP ::</span> <span class="dt">Parser</span> [[<span class="dt">String</span>]]
parseCSVP <span class="fu">=</span> manyP parseLine
  <span class="kw">where</span>
    parseLine <span class="fu">=</span> parseCell <span class="ot">`sepByP`</span> charP <span class="ch">','</span> <span class="fu">&lt;*</span> charP <span class="ch">'\n'</span>
    parseCell <span class="fu">=</span> <span class="kw">do</span>
        charP <span class="ch">'&quot;'</span>
        content <span class="ot">&lt;-</span> manyP (anyCharButP <span class="ch">'&quot;'</span>)
        charP <span class="ch">'&quot;'</span>
        return content</code></pre></div>
<p>We want to derive the <code>Grammar</code> for <code>CSV</code> files from that. First we transform it into using only applicative operators:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseCSVP ::</span> <span class="dt">Parser</span> [[<span class="dt">String</span>]]
parseCSVP <span class="fu">=</span> manyP parseLine
  <span class="kw">where</span>
    parseLine <span class="fu">=</span> parseCell <span class="ot">`sepByP`</span> charG <span class="ch">','</span> <span class="fu">&lt;*</span> charP <span class="ch">'\n'</span>
    parseCell <span class="fu">=</span> charP <span class="ch">'&quot;'</span> <span class="fu">*&gt;</span> manyP (anyCharButP <span class="ch">'&quot;'</span>) <span class="fu">&lt;*</span> charP <span class="ch">'&quot;'</span></code></pre></div>
<p>And now we try to rewrite the code to produce <code>Grammar</code> instead of <code>Parser</code>. This is straight forward with the exception of <code>anyCharButP</code>. The parser code for that in inherently monadic, and we just do not have a monad instance. So we work around the issue by making that a “primitive” grammar, i.e. introducing a non-terminal in the EBNF without a production rule – pretty much like we did for <code>anyCharG</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">primitiveG ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Grammar</span> a
primitiveG s <span class="fu">=</span> <span class="dt">G</span> (<span class="dt">NonTerminal</span> s)

<span class="ot">parseCSVG ::</span> <span class="dt">Grammar</span> [[<span class="dt">String</span>]]
parseCSVG <span class="fu">=</span> manyG parseLine
  <span class="kw">where</span>
    parseLine <span class="fu">=</span> parseCell <span class="ot">`sepByG`</span> charG <span class="ch">','</span> <span class="fu">&lt;*</span> charG <span class="ch">'\n'</span>
    parseCell <span class="fu">=</span> charG <span class="ch">'&quot;'</span> <span class="fu">*&gt;</span> manyG (primitiveG <span class="st">&quot;not-quote&quot;</span>) <span class="fu">&lt;*</span> charG <span class="ch">'&quot;'</span></code></pre></div>
<p>Of course the names <code>parse…</code> are not quite right any more, but let’s just leave that for now.</p>
<p>Here is the result:</p>
<pre><code>*Main&gt; putStrLn $ ppGrammar parseCSVG
{('&quot;', {not-quote}, '&quot;', {',', '&quot;', {not-quote}, '&quot;'} | ''), '
'}</code></pre>
<p>The line break is weird. We do not really want newlines in the grammar. So let’s make that primitive as well, and replace <code>charG '\n'</code> with <code>newlineG</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">newlineG ::</span> <span class="dt">Grammar</span> ()
newlineG <span class="fu">=</span> primitiveG <span class="st">&quot;newline&quot;</span></code></pre></div>
<p>Now we get</p>
<pre><code>*Main&gt; putStrLn $ ppGrammar parseCSVG
{('&quot;', {not-quote}, '&quot;', {',', '&quot;', {not-quote}, '&quot;'} | ''), newline}</code></pre>
<p>which is nice and correct, but not quite the easily readable EBNF that we saw further up.</p>
<h2 id="tracking-productions">Tracking productions</h2>
<p>We currently let our grammars produce only the right-hand side of one EBNF production, but really, we want to produce a RHS that may refer to other productions. So let us change the type accordingly:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Grammar</span> a <span class="fu">=</span> <span class="dt">G</span> (<span class="dt">BNF</span>, <span class="dt">RHS</span>)

<span class="ot">ppGrammar ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Grammar</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>
ppGrammar main (<span class="dt">G</span> (prods, rhs)) <span class="fu">=</span> ppBNF <span class="fu">$</span> prods <span class="fu">++</span> [(main, rhs)]</code></pre></div>
<p>Now we have to adjust all our primitive combinators (but not the derived ones):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">charG ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Grammar</span> ()
charG c <span class="fu">=</span> <span class="dt">G</span> ([], <span class="dt">Terminal</span> [c])

<span class="ot">anyCharG ::</span> <span class="dt">Grammar</span> <span class="dt">Char</span>
anyCharG <span class="fu">=</span> <span class="dt">G</span> ([], <span class="dt">NonTerminal</span> <span class="st">&quot;char&quot;</span>)

<span class="ot">manyG ::</span> <span class="dt">Grammar</span> a <span class="ot">-&gt;</span> <span class="dt">Grammar</span> [a]
manyG (<span class="dt">G</span> (prods, rhs)) <span class="fu">=</span> <span class="dt">G</span> (prods, <span class="dt">Repetition</span> rhs)

<span class="ot">mergeProds ::</span> [<span class="dt">Production</span>] <span class="ot">-&gt;</span> [<span class="dt">Production</span>] <span class="ot">-&gt;</span> [<span class="dt">Production</span>]
mergeProds prods1 prods2 <span class="fu">=</span> nub <span class="fu">$</span> prods1 <span class="fu">++</span> prods2

<span class="ot">orElseG ::</span> <span class="dt">Grammar</span> a <span class="ot">-&gt;</span> <span class="dt">Grammar</span> a <span class="ot">-&gt;</span> <span class="dt">Grammar</span> a
orElseG (<span class="dt">G</span> (prods1, rhs1)) (<span class="dt">G</span> (prods2, rhs2))
    <span class="fu">=</span> <span class="dt">G</span> (mergeProds prods1 prods2, <span class="dt">Choice</span> rhs1 rhs2)

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Grammar</span> <span class="kw">where</span>
    fmap _ (<span class="dt">G</span> bnf) <span class="fu">=</span> <span class="dt">G</span> bnf

<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Grammar</span> <span class="kw">where</span>
    pure x <span class="fu">=</span> <span class="dt">G</span> ([], <span class="dt">Terminal</span> <span class="st">&quot;&quot;</span>)
    <span class="dt">G</span> (prods1, <span class="dt">Terminal</span> <span class="st">&quot;&quot;</span>) <span class="fu">&lt;*&gt;</span> <span class="dt">G</span> (prods2, rhs2)
        <span class="fu">=</span> <span class="dt">G</span> (mergeProds prods1 prods2, rhs2)
    <span class="dt">G</span> (prods1, rhs1) <span class="fu">&lt;*&gt;</span> <span class="dt">G</span> (prods2, <span class="dt">Terminal</span> <span class="st">&quot;&quot;</span>)
        <span class="fu">=</span> <span class="dt">G</span> (mergeProds prods1 prods2, rhs1)
    <span class="dt">G</span> (prods1, rhs1) <span class="fu">&lt;*&gt;</span> <span class="dt">G</span> (prods2, rhs2)
        <span class="fu">=</span> <span class="dt">G</span> (mergeProds prods1 prods2, <span class="dt">Sequence</span> rhs1 rhs2)

<span class="ot">primitiveG ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Grammar</span> a
primitiveG s <span class="fu">=</span> <span class="dt">G</span> (<span class="dt">NonTerminal</span> s)</code></pre></div>
<p>The use of <code>nub</code> when combining productions removes duplicates that might be used in different parts of the grammar. Not efficient, but good enough for now.</p>
<p>Did we gain anything? Not yet:</p>
<pre><code>*Main&gt; putStr $ ppGrammar &quot;csv&quot; (parseCSVG)
csv = {('&quot;', {not-quote}, '&quot;', {',', '&quot;', {not-quote}, '&quot;'} | ''), newline};</code></pre>
<p>But we can now introduce a function that lets us tell the system where to give names to a piece of grammar:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">nonTerminal ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Grammar</span> a <span class="ot">-&gt;</span> <span class="dt">Grammar</span> a
nonTerminal name (<span class="dt">G</span> (prods, rhs))
  <span class="fu">=</span> <span class="dt">G</span> (prods <span class="fu">++</span> [(name, rhs)], <span class="dt">NonTerminal</span> name)</code></pre></div>
<p>Ample use of this in <code>parseCSVG</code> yields the desired result:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseCSVG ::</span> <span class="dt">Grammar</span> [[<span class="dt">String</span>]]
parseCSVG <span class="fu">=</span> manyG parseLine
  <span class="kw">where</span>
    parseLine <span class="fu">=</span> nonTerminal <span class="st">&quot;line&quot;</span> <span class="fu">$</span>
        parseCell <span class="ot">`sepByG`</span> charG <span class="ch">','</span> <span class="fu">&lt;*</span> newline
    parseCell <span class="fu">=</span> nonTerminal <span class="st">&quot;cell&quot;</span> <span class="fu">$</span>
        charG <span class="ch">'&quot;'</span> <span class="fu">*&gt;</span> manyG (primitiveG <span class="st">&quot;not-quote&quot;</span>) <span class="fu">&lt;*</span> charG <span class="ch">'&quot;</span></code></pre></div>
<pre><code>*Main&gt; putStr $ ppGrammar &quot;csv&quot; (parseCSVG)
cell = '&quot;', {not-quote}, '&quot;';
line = (cell, {',', cell} | ''), newline;
csv = {line};</code></pre>
<p>This is great!</p>
<h1 id="combining-parsers-and-grammers">Combining Parsers and Grammers</h1>
<p>But note how simliar <code>parseCSVG</code> and <code>parseCSVP</code> are! Would it not be great if we could implement that functionaliy only once, and get both a parser <em>and</em> a grammar description out of it? This way, the two would never be out of sync!</p>
<p>And surely this must be possible. The tool to reach for is of course to define a type class that abstracts over the parts where <code>Parser</code> and <code>Grammer</code> differ. So we have to identify all functions that are primitive in one of the two worlds, and turn them into type class methods. This includes <code>char</code> and <code>orElse</code>. It includes <code>many</code>, too: Although <code>manyP</code> is not primitive, <code>manyG</code> is. It also includes <code>nonTerminal</code>, which does not exist in the world of parsers (yet), but we need it in grammars.</p>
<p>The <code>primitiveG</code> function is tricky. We use it in grammars when the code that we might use while parsing is not expressible as a grammar. So the solution is to let it take two arguments: A <code>String</code>, when used as a descriptive non-terminal in a grammar, and a <code>Parser a</code>, used in the parsing code.</p>
<p>Finally, the type classes that we except, <code>Applicative</code> (and thus <code>Functor</code>), are added as constraints on our type class:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Descr</span> f <span class="kw">where</span>
<span class="ot">    char ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> f ()
<span class="ot">    many ::</span> f a <span class="ot">-&gt;</span> f [a]
<span class="ot">    orElse ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a
<span class="ot">    primitive ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> f a
<span class="ot">    nonTerminal ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</code></pre></div>
<p>The instances are easily written:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Descr</span> <span class="dt">Parser</span> <span class="kw">where</span>
    char <span class="fu">=</span> charP
    many <span class="fu">=</span> manyP
    orElse <span class="fu">=</span> orElseP
    <span class="kw">primitive</span> _ p <span class="fu">=</span> p
    nonTerminal _ p <span class="fu">=</span> p

<span class="kw">instance</span> <span class="dt">Descr</span> <span class="dt">Grammar</span> <span class="kw">where</span>
    char <span class="fu">=</span> charG
    many <span class="fu">=</span> manyG
    orElse <span class="fu">=</span> orElseG
    <span class="kw">primitive</span> s _ <span class="fu">=</span> primitiveG s
    nonTerminal s g <span class="fu">=</span> nonTerminalG s g</code></pre></div>
<p>And we can now take the derived definitions, of which so far we had two copies, and define them once and for all:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">many1 ::</span> <span class="dt">Descr</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f [a]
many1 p <span class="fu">=</span> pure (<span class="fu">:</span>) <span class="fu">&lt;*&gt;</span> p <span class="fu">&lt;*&gt;</span> many p

<span class="ot">anyChar ::</span> <span class="dt">Descr</span> f <span class="ot">=&gt;</span> f <span class="dt">Char</span>
anyChar <span class="fu">=</span> <span class="kw">primitive</span> <span class="st">&quot;char&quot;</span> anyCharP

<span class="ot">dottedWords ::</span> <span class="dt">Descr</span> f <span class="ot">=&gt;</span> f [<span class="dt">String</span>]
dottedWords <span class="fu">=</span> many1 (many anyChar <span class="fu">&lt;*</span> char <span class="ch">'.'</span>)

<span class="ot">sepBy ::</span> <span class="dt">Descr</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f () <span class="ot">-&gt;</span> f [a]
sepBy p1 p2 <span class="fu">=</span> ((<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> p1 <span class="fu">&lt;*&gt;</span> (many (p2 <span class="fu">*&gt;</span> p1))) <span class="ot">`orElse`</span> pure []

<span class="ot">newline ::</span> <span class="dt">Descr</span> f <span class="ot">=&gt;</span> f ()
newline <span class="fu">=</span> <span class="kw">primitive</span> <span class="st">&quot;newline&quot;</span> (charP <span class="ch">'\n'</span>)</code></pre></div>
<p>And thus we now have our CSV parser/grammar generator:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseCSV ::</span> <span class="dt">Descr</span> f <span class="ot">=&gt;</span> f [[<span class="dt">String</span>]]
parseCSV <span class="fu">=</span> many parseLine
  <span class="kw">where</span>
    parseLine <span class="fu">=</span> nonTerminal <span class="st">&quot;line&quot;</span> <span class="fu">$</span>
        parseCell <span class="ot">`sepBy`</span> char <span class="ch">','</span> <span class="fu">&lt;*</span> newline
    parseCell <span class="fu">=</span> nonTerminal <span class="st">&quot;cell&quot;</span> <span class="fu">$</span>
        char <span class="ch">'&quot;'</span> <span class="fu">*&gt;</span> many (<span class="kw">primitive</span> <span class="st">&quot;not-quote&quot;</span> (anyCharButP <span class="ch">'&quot;'</span>)) <span class="fu">&lt;*</span> char <span class="ch">'&quot;'</span></code></pre></div>
<p>We can now use this definition both to parse and to generate grammars:</p>
<pre><code>*Main&gt; putStr $ ppGrammar2 &quot;csv&quot; (parseCSV)
cell = '&quot;', {not-quote}, '&quot;';
line = (cell, {',', cell} | ''), newline;
csv = {line};
*Main&gt; parse parseCSV &quot;\&quot;ab\&quot;,\&quot;cd\&quot;\n\&quot;\&quot;,\&quot;de\&quot;\n\n&quot;
Just [[&quot;ab&quot;,&quot;cd&quot;],[&quot;&quot;,&quot;de&quot;],[]]</code></pre>
<h2 id="the-ini-file-parser">The INI file parser</h2>
<p>As a final exercise, let us transform the INI file parser into a combined thing. Here is the parser, as it could have been written for last week’s homework (if one had used applicative style):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseINIP ::</span> <span class="dt">Parser</span> <span class="dt">INIFile</span>
parseINIP <span class="fu">=</span> many1P parseSection
  <span class="kw">where</span>
    parseSection <span class="fu">=</span>
        pure (,) <span class="fu">&lt;*</span>  charP <span class="ch">'['</span>
                 <span class="fu">&lt;*&gt;</span> parseIdent
                 <span class="fu">&lt;*</span>  charP <span class="ch">']'</span>
                 <span class="fu">&lt;*</span>  charP <span class="ch">'\n'</span>
                 <span class="fu">&lt;*&gt;</span> (catMaybes <span class="fu">&lt;$&gt;</span> manyP parseLine)
    parseIdent <span class="fu">=</span> many1P letterOrDigitP
    parseLine <span class="fu">=</span> parseDecl <span class="ot">`orElseP`</span> parseComment <span class="ot">`orElseP`</span> parseEmpty

    parseDecl <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">&lt;$&gt;</span> (
        pure (,) <span class="fu">&lt;*&gt;</span> parseIdent
                 <span class="fu">&lt;*</span>  manyP (charP <span class="ch">' '</span>)
                 <span class="fu">&lt;*</span>  charP <span class="ch">'='</span>
                 <span class="fu">&lt;*</span>  manyP (charP <span class="ch">' '</span>)
                 <span class="fu">&lt;*&gt;</span> many1P (anyCharButP <span class="ch">'\n'</span>)
                 <span class="fu">&lt;*</span>  charP <span class="ch">'\n'</span>)

    parseComment <span class="fu">=</span>
        <span class="dt">Nothing</span> <span class="fu">&lt;$</span> charP <span class="ch">'#'</span>
                <span class="fu">&lt;*</span> many1P (anyCharButP <span class="ch">'\n'</span>)
                <span class="fu">&lt;*</span> charP <span class="ch">'\n'</span>

    parseEmpty <span class="fu">=</span> <span class="dt">Nothing</span> <span class="fu">&lt;$</span> charP <span class="ch">'\n'</span></code></pre></div>
<p>Transforming that to generic description is quite straight-forward. We use <code>primitive</code> again to wrap <code>letterOrDigitP</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">descrINI ::</span> <span class="dt">Descr</span> f <span class="ot">=&gt;</span> f <span class="dt">INIFile</span>
descrINI <span class="fu">=</span> many1 parseSection
  <span class="kw">where</span>
    parseSection <span class="fu">=</span>
        pure (,) <span class="fu">&lt;*</span>  char <span class="ch">'['</span>
                 <span class="fu">&lt;*&gt;</span> parseIdent
                 <span class="fu">&lt;*</span>  char <span class="ch">']'</span>
                 <span class="fu">&lt;*</span>  newline
                 <span class="fu">&lt;*&gt;</span> (catMaybes <span class="fu">&lt;$&gt;</span> many parseLine)
    parseIdent <span class="fu">=</span> many1 (<span class="kw">primitive</span> <span class="st">&quot;alphanum&quot;</span> letterOrDigitP)
    parseLine <span class="fu">=</span> parseDecl <span class="ot">`orElse`</span> parseComment <span class="ot">`orElse`</span> parseEmpty

    parseDecl <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">&lt;$&gt;</span> (
        pure (,) <span class="fu">&lt;*&gt;</span> parseIdent
                 <span class="fu">&lt;*</span>  many (char <span class="ch">' '</span>)
                 <span class="fu">&lt;*</span>  char <span class="ch">'='</span>
                 <span class="fu">&lt;*</span>  many (char <span class="ch">' '</span>)
                 <span class="fu">&lt;*&gt;</span> many1 (<span class="kw">primitive</span> <span class="st">&quot;non-newline&quot;</span> (anyCharButP <span class="ch">'\n'</span>))
		 <span class="fu">&lt;*</span>  newline)

    parseComment <span class="fu">=</span>
        <span class="dt">Nothing</span> <span class="fu">&lt;$</span> char <span class="ch">'#'</span>
                <span class="fu">&lt;*</span> many1 (<span class="kw">primitive</span> <span class="st">&quot;non-newline&quot;</span> (anyCharButP <span class="ch">'\n'</span>))
		<span class="fu">&lt;*</span> newline

    parseEmpty <span class="fu">=</span> <span class="dt">Nothing</span> <span class="fu">&lt;$</span> newline</code></pre></div>
<p>This yields this not very helpful grammar:</p>
<pre><code>*Main&gt; putStr $ ppGrammar2 &quot;ini&quot; descrINI
ini = '[', alphanum, {alphanum}, ']', newline, {alphanum, {alphanum}, {' '}…</code></pre>
<p>But with a few uses of <code>nonTerminal</code>, we get something really nice:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">descrINI ::</span> <span class="dt">Descr</span> f <span class="ot">=&gt;</span> f <span class="dt">INIFile</span>
descrINI <span class="fu">=</span> many1 parseSection
  <span class="kw">where</span>
    parseSection <span class="fu">=</span> nonTerminal <span class="st">&quot;section&quot;</span> <span class="fu">$</span>
        pure (,) <span class="fu">&lt;*</span>  char <span class="ch">'['</span>
                 <span class="fu">&lt;*&gt;</span> parseIdent
                 <span class="fu">&lt;*</span>  char <span class="ch">']'</span>
                 <span class="fu">&lt;*</span>  newline
                 <span class="fu">&lt;*&gt;</span> (catMaybes <span class="fu">&lt;$&gt;</span> many parseLine)
    parseIdent <span class="fu">=</span> nonTerminal <span class="st">&quot;identifier&quot;</span> <span class="fu">$</span>
        many1 (<span class="kw">primitive</span> <span class="st">&quot;alphanum&quot;</span> letterOrDigitP)
    parseLine <span class="fu">=</span> nonTerminal <span class="st">&quot;line&quot;</span> <span class="fu">$</span>
        parseDecl <span class="ot">`orElse`</span> parseComment <span class="ot">`orElse`</span> parseEmpty

    parseDecl <span class="fu">=</span> nonTerminal <span class="st">&quot;declaration&quot;</span> <span class="fu">$</span> <span class="dt">Just</span> <span class="fu">&lt;$&gt;</span> (
        pure (,) <span class="fu">&lt;*&gt;</span> parseIdent
                 <span class="fu">&lt;*</span>  spaces
                 <span class="fu">&lt;*</span>  char <span class="ch">'='</span>
                 <span class="fu">&lt;*</span>  spaces
                 <span class="fu">&lt;*&gt;</span> remainder)

    parseComment <span class="fu">=</span> nonTerminal <span class="st">&quot;comment&quot;</span> <span class="fu">$</span>
        <span class="dt">Nothing</span> <span class="fu">&lt;$</span> char <span class="ch">'#'</span> <span class="fu">&lt;*</span> remainder

    remainder <span class="fu">=</span> nonTerminal <span class="st">&quot;line-remainder&quot;</span> <span class="fu">$</span>
        many1 (<span class="kw">primitive</span> <span class="st">&quot;non-newline&quot;</span> (anyCharButP <span class="ch">'\n'</span>)) <span class="fu">&lt;*</span> newline

    parseEmpty <span class="fu">=</span> <span class="dt">Nothing</span> <span class="fu">&lt;$</span> newline

    spaces <span class="fu">=</span> nonTerminal <span class="st">&quot;spaces&quot;</span> <span class="fu">$</span> many (char <span class="ch">' '</span>)</code></pre></div>
<pre><code>*Main&gt; putStr $ ppGrammar &quot;ini&quot; descrINI
identifier = alphanum, {alphanum};
spaces = {' '};
line-remainder = non-newline, {non-newline}, newline;
declaration = identifier, spaces, '=', spaces, line-remainder;
comment = '#', line-remainder;
line = declaration | comment | newline;
section = '[', identifier, ']', newline, {line};
ini = section, {section};</code></pre>
<h2 id="a-new-main">A new main</h2>
<p>We can adjust the <code>main</code> function of the program to parse a file, if given on the command line, or to print the grammar otherwise:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    args <span class="ot">&lt;-</span> getArgs
    <span class="kw">case</span> args <span class="kw">of</span>
        [] <span class="ot">-&gt;</span> putStr <span class="fu">$</span> ppGrammar2 <span class="st">&quot;ini&quot;</span> descrINI
        [fileName] <span class="ot">-&gt;</span> <span class="kw">do</span>
            input <span class="ot">&lt;-</span> readFile fileName
            <span class="kw">case</span> parse descrINI input <span class="kw">of</span>
                <span class="dt">Just</span> i <span class="ot">-&gt;</span> print i
                <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
                    hPutStrLn stderr <span class="st">&quot;Failed to parse INI file.&quot;</span>
                    exitFailure
        _ <span class="ot">-&gt;</span> hPutStrLn stderr <span class="st">&quot;Too many arguments&quot;</span> <span class="fu">&gt;&gt;</span> exitFailure</code></pre></div>
<h1 id="conclusion">Conclusion</h1>
<p>We have again seen an example of excellent support for abstraction: Being able to define so very different things such as a parser and a grammar description with the same code is great. Type classes helped us here.</p>
<p>Note that it was crucial that our combined parser/grammars are only able to use the methods of <code>Applicative</code>, and not <code>Monad</code>. <code>Applicative</code> is less powerful, so by giving less power to the user of our <code>Descr</code> interface, there is more power on the other side.</p>
<p>The reason why <code>Applicative</code> is ok, but <code>Monad</code> is not, is that in <code>Applicative</code>, the <em>results do not affect the shape of the computation</em>, whereas in <code>Monad</code>, the whole point of the bind operator <code>(&gt;&gt;=)</code> is that <em>the result of the computation is used to decide the next computation</em>. And while this is perfectly fine for a parser, it just makes no sense for a grammar generator, where there simply are no values around!</p>
<p>We have also seen that a phantom type, namely the parameter of <code>Grammar</code>, can be useful, as it lets the type system make sure we do not write nonsene. For example, the type of <code>orElseG</code> ensures that both grammars that are combined here indeed describe something of the same type.</p>
    </div>

    <div id="footer"><center>
      <font size="-2">Powered
      by <a href="http://community.haskell.org/~ndm/shake/">shake</a>,
      <a href="http://jaspervdj.be/hakyll/index.html">hakyll</a>,
      <a href="http://johnmacfarlane.net/pandoc/">pandoc</a>,
      <a href="http://projects.haskell.org/diagrams">diagrams</a>,
      and <a href="http://www.andres-loeh.de/lhs2tex/">lhs2TeX</a>.
      </center>
    </div>
  </div>
</body>


<!-- Mirrored from cis.upenn.edu/~cis194/fall16/lectures/09-more-applicative.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 20 Dec 2016 17:05:54 GMT -->
</html>
