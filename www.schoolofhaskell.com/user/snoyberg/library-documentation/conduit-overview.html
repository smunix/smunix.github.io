<!DOCTYPE html>
<html>
<!-- Mirrored from www.schoolofhaskell.com/user/snoyberg/library-documentation/conduit-overview by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 26 Dec 2016 20:38:42 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head><title>Conduit Overview - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="http://fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>#hident3 .like-count{margin-right:0.5em}#hident3 .likes{font-family:merriweather;float:right;margin-bottom:1em;border:1px solid #eee;font-size:1.1em;padding:0.25em;border-radius:0.25em;display:inline-block;text-align:center;color:#468847;background-color:#dff0d8;border-color:#d6e9c6}#hident3 .likes:hover{text-decoration:none;cursor:pointer}#hident3 .likes-liked i{opacity:0.25}#hident3 .likes-liked .like-count{font-weight:bold }#hident3 .like-not-logged-in *{cursor:default}.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"Â·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="http://www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='http://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="https://www.schoolofhaskell.com/"><img src="https://www.schoolofhaskell.com/static/img/ide-logo.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
<ul class="nav pull-right"><li><a href="https://www.schoolofhaskell.com/auth/login">Login</a>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/user/snoyberg">Michael Snoyman</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/snoyberg/library-documentation">Library Documentation</a>
<span class="divider">/</span>
</li>
<li><a href="conduit-overview.html">Conduit Overview</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><p class="alert">Interactive code snippets not yet available for SoH 2.0, see our <a href=https://www.fpcomplete.com/blog/2016/01/soh-status>Status of
 of School of Haskell 2.0 blog post</a></p>
</div>
</div>
<div class="row"><div class="span12"><h1 itemprop="name">Conduit Overview</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date"> 8 Aug 2016</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/snoyberg">Michael Snoyman</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/1/480cc0cef7ae8862f6422e4266864c58b7892f4f">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><div id="hident3"></div>

<span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="data-conduit-process.html">Previous content: Data.Conduit.Process</a>
</li>
<li><a href="resourcet.html">Next content: ResourceT Overview</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/snoyberg/library-documentation">Go up to: Library Documentation</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/snoyberg">See all content by Michael Snoyman</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#updated-location">Updated location</a></li><li><a href="#synopsis">Synopsis</a></li><li><a href="#features-of-conduit">Features of conduit</a></li><li><a href="#basics">Basics</a><ul><li><a href="#unified-data-type">Unified data type</a></li></ul></li><li><a href="#primitives">Primitives</a><ul><li><a href="#exercises">Exercises</a></li></ul></li><li><a href="#monadic-chaining">Monadic chaining</a></li><li><a href="#lifting-operations">Lifting operations</a></li><li><a href="#generalizing">Generalizing</a></li><li><a href="#termination">Termination</a></li><li><a href="#exception-safety">Exception Safety</a></li><li><a href="#connect-and-resume">Connect and resume</a></li><li><a href="#further-reading">Further reading</a></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="ghc-7.8-stable-14.09">
<article><h2 id="updated-location"><a href="#updated-location">Updated location</a></h2><p>Note that the most up to date version of this content is available at <a href="https://github.com/snoyberg/conduit#readme">the conduit repo homepage</a>. You should probably read it there.</p><hr /><p><code>conduit</code> is a solution to the streaming data problem, allowing for production, transformation, and consumption of streams of data in constant memory. It can be used for processing files, dealing with network interfaces, or parsing structured data in an event-driven manner.</p><p>In addition to this tutorial, there is <a href="https://docs.google.com/presentation/d/1RBefOCZ7AKOo4f1yiF4mtKPAT3l5vY9ky2SR02O4Vvg/edit?usp=sharing">a set of slides on conduit</a> which covers a number of topics.</p><p>You may wish to first check <a href="https://github.com/snoyberg/conduit#readme">the conduit homepage</a>, which may have more up-to-date tutorial content than here.</p><h2 id="synopsis"><a href="#synopsis">Synopsis</a></h2><pre><code class="haskell active">import Data.Conduit
import qualified Data.Conduit.List as CL
import qualified Data.Conduit.Binary as CB

main = do
    -- show Pure operations: summing numbers.
    result &lt;- CL.sourceList [1..10] $$ CL.fold (+) 0
    print result
    -- /show
    
    -- show Exception safe file access: copy a file.
    writeFile &quot;input.txt&quot; &quot;This is a test.&quot;
    runResourceT $ CB.sourceFile &quot;input.txt&quot; $$ CB.sinkFile &quot;output.txt&quot;
    readFile &quot;output.txt&quot; &gt;&gt;= putStrLn
    -- /show
    
    -- show Perform transformations.
    result &lt;- CL.sourceList [1..10] $$ CL.map (+ 1) =$ CL.consume
    print result
    -- /show</code></pre><h2 id="features-of-conduit"><a href="#features-of-conduit">Features of conduit</a></h2><ul><li><code>conduit</code> allows you to deal with large- and possibly infinite- streams of data in constant memory. Chunks of data are dealt with one piece at a time instead of needing to read in the entire body at once.</li><li><code>conduit</code> also allows for deterministic resource usage. When using scarce resources like file descriptors, <code>conduit</code> is designed to immediately recycle resources when they are no longer needed. Contrast this with lazy I/O, which provides for constant memory usage, but at the expense of deterministic resource usage.</li><li>Resource usage must also be exception safe: a file handle must be recycled even in the presence of exceptions. Most of this functionality is provided by the associated <code>resourcet</code> package, described below.</li><li>It should be easy to compose together pre-built components to build up more complex structures. Our goal is to retain the composability of pure code while dealing with the imperative world.</li></ul><h2 id="basics"><a href="#basics">Basics</a></h2><p>The main module for the <code>conduit</code> package is <a class="hoogle" href="https://www.stackage.org/lts/hoogle?q=Data.Conduit&amp;results=1" title="Hoogle search for: Data.Conduit"><code>Data.Conduit</code></a>, which provides the core data types and primitive operations. Another commonly used modules is <a class="hoogle" href="https://www.stackage.org/lts/hoogle?q=Data.Conduit.List&amp;results=1" title="Hoogle search for: Data.Conduit.List"><code>Data.Conduit.List</code></a>, which provides a number of helper functions for common cases, based on standard Haskell concepts like <code>map</code> and <code>fold</code>.</p><p>There are three main concepts in conduit. A <code>Source</code> will produce a stream of data values and send them <i>downstream</i>. A <code>Sink</code> will consume a stream of data values from <i>upstream</i> and produce a return value. In the first example in the synopsis, <code>sourceList</code> generated a stream of <code>Integer</code>s which the <code>fold</code> consumed, producing a return value of 55. The third concept is the <code>Conduit</code>, which consumes a stream of values from upstream and produces a new stream to send downstream. In the synopsis, the call to <code>map</code> consumed one stream of <code>Integer</code>s, added 1 to each value, and sent the new results downstream.</p><p>In order to combine these different components, we have <i>connecting</i> and <i>fusing</i>. The connect operator is <code>$$</code>, and it will combine a <code>Source</code> and <code>Sink</code>, feeding the values produced by the former into the latter, and producing a final result. Fusion, on the other hand, will take two components and generate a new component. For example, <code>=$</code> can fuse a <code>Conduit</code> and <code>Sink</code> together into a new <code>Sink</code>, which will consume the same values as the original <code>Conduit</code> and produce the same result as the original <code>Sink</code>. The other two fusion operators are <code>$=</code>, which combines a <code>Source</code> and <code>Conduit</code> into a new <code>Source</code>, and <code>=$=</code>, which combines two <code>Conduit</code>s into a new <code>Conduit</code>.</p><pre><code class="active haskell">-- show Demonstration of connect and fuse operators
import Data.Conduit
import qualified Data.Conduit.List as CL

source :: Source IO Int -- produces a stream of Ints
source = CL.sourceList [1..4]

sink :: Sink String IO () -- consumes a stream of Strings, no result
sink = CL.mapM_ putStrLn

conduit :: Conduit Int IO String -- converts Ints into Strings
conduit = CL.map show

main = do
    source $$ conduit =$ sink
    -- alternatively, with the same meaning
    source $= conduit $$ sink</code></pre><p><b>Exercise</b>: Write a <code>Conduit</code> which will multiply all incoming numbers by 2, and then include it in the above code snippet. Note that there are multiple ways of using the connect and fusion operators to get the desired result, give a few of them a shot.</p><div class="hidden" title="SHOW SOLUTION"><pre><code class="active haskell">import Data.Conduit
import qualified Data.Conduit.List as CL

source :: Source IO Int -- produces a stream of Ints
source = CL.sourceList [1..4]

sink :: Sink String IO () -- consumes a stream of Strings, no result
sink = CL.mapM_ putStrLn

conduit :: Conduit Int IO String -- converts Ints into Strings
conduit = CL.map show

-- show
newConduit :: Conduit Int IO Int
newConduit = CL.map (* 2)

main = do
    -- each of the following does the same thing
    source $$ newConduit =$ conduit =$ sink
    source $= newConduit $= conduit $$ sink
    source $= newConduit $$ conduit =$ sink
    source $$ (newConduit =$= conduit) =$ sink
    source $= (newConduit =$= conduit) $$ sink</code></pre></div><h3 id="unified-data-type"><a href="#unified-data-type">Unified data type</a></h3><p>Under the surface, all three core data types are just wrappers around the same type, <code>ConduitM</code>. By wrapping around this single unified type, we're able to reuse a lot of code and more easily compose components in conduit.</p><p><code>ConduitM</code> takes four type parameters: input received from upstream, output send downstream, the underlying monad, and the return value. Our specialized types are defined as:</p><pre><code class="haskell">type Source m a = ConduitM () a m () -- no meaningful input or return value
type Conduit a m b = ConduitM a b m () -- no meaningful return value
type Sink a m b = ConduitM a Void m b -- no meaningful output value</code></pre><p><code>ConduitM</code> is a monad transformer. As such, you can lift operations from the underlying monad (see &quot;Lifting Operations&quot; below), and can easily compose together multiple components. This makes it simple to build up complex mechanisms from simpler components.</p><p>You will very rarely need to interface directly with the <code>ConduitM</code> datatype, though it will occasionally appear in error messages.</p><h2 id="primitives"><a href="#primitives">Primitives</a></h2><p>There are three core primitives in the <code>conduit</code> library.</p><ol><li><code>await</code> will take a single value from upstream, if available.</li><li><code>yield</code> will send a single value downstream.</li><li><code>leftover</code> will put a single value back in the upstream queue, ready to be read by the next call to <code>await</code>.</li></ol><pre><code class="haskell active">-- show Using primitives
import Data.Conduit
import Control.Monad.IO.Class

source :: Source IO Int
source = do
    yield 1
    yield 2
    yield 3
    yield 4
    
conduit :: Conduit Int IO String
conduit = do
    -- Get all of the adjacent pairs from the stream
    mi1 &lt;- await
    mi2 &lt;- await
    case (mi1, mi2) of
        (Just i1, Just i2) -&gt; do
            yield $ show (i1, i2)
            leftover i2
            conduit
        _ -&gt; return ()
            
sink :: Sink String IO ()
sink = do
    mstr &lt;- await
    case mstr of
        Nothing -&gt; return ()
        Just str -&gt; do
            liftIO $ putStrLn str
            sink
            
main = source $$ conduit =$ sink</code></pre><h3 id="exercises"><a href="#exercises">Exercises</a></h3><ol><li><p>Implement <code>sourceList</code> in terms of <code>yield</code>.</p><pre><code class="haskell active">import Data.Conduit
import qualified Data.Conduit.List as CL

-- show
sourceList :: Monad m =&gt; [a] -&gt; Source m a
sourceList = ???
-- /show

main = sourceList [1, 2, 3] $$ CL.mapM_ print</code></pre><div class="hidden" title="SHOW SOLUTION"><pre><code class="haskell active">import Data.Conduit
import qualified Data.Conduit.List as CL

-- show
sourceList :: Monad m =&gt; [a] -&gt; Source m a
sourceList = mapM_ yield
-- /show

main = sourceList [1, 2, 3] $$ CL.mapM_ print</code></pre></div></li><li><p>There's a helper function in the library called <a class="hoogle" href="https://www.stackage.org/lts/hoogle?q=Data.Conduit.awaitForever&amp;results=1" title="Hoogle search for: Data.Conduit.awaitForever"><code>awaitForever</code></a>. Rewrite <code>sink</code> above using <code>awaitForever</code>.</p><pre><code class="haskell active">import Data.Conduit
import Control.Monad.IO.Class

source :: Source IO Int
source = do
    yield 1
    yield 2
    yield 3
    yield 4
    
conduit :: Conduit Int IO String
conduit = do
    -- Get all of the adjacent pairs from the stream
    mi1 &lt;- await
    mi2 &lt;- await
    case (mi1, mi2) of
        (Just i1, Just i2) -&gt; do
            yield $ show (i1, i2)
            leftover i2
            conduit
        _ -&gt; return ()


-- show
sink :: Sink String IO ()
sink = ???
-- /show
        
main = source $$ conduit =$ sink</code></pre><div class="hidden" title="SHOW SOLUTION"><pre><code class="haskell active">import Data.Conduit
import Control.Monad.IO.Class

source :: Source IO Int
source = do
    yield 1
    yield 2
    yield 3
    yield 4
    
conduit :: Conduit Int IO String
conduit = do
    -- Get all of the adjacent pairs from the stream
    mi1 &lt;- await
    mi2 &lt;- await
    case (mi1, mi2) of
        (Just i1, Just i2) -&gt; do
            yield $ show (i1, i2)
            leftover i2
            conduit
        _ -&gt; return ()


-- show
sink :: Sink String IO ()
sink = awaitForever $ liftIO . putStrLn
-- /show
        
main = source $$ conduit =$ sink</code></pre></div></li><li><p>Implement your own version of <code>awaitForever</code>.</p><pre><code class="active haskell">import Data.Conduit
import qualified Data.Conduit.List as CL
import Control.Monad.Trans.Class (lift)

-- show
myAwaitForever :: Monad m =&gt; (a -&gt; Conduit a m b) -&gt; Conduit a m b
myAwaitForever f = ???
-- /show

main = CL.sourceList [1..10] $$ myAwaitForever (lift . print)</code></pre><div class="hidden" title="SHOW SOLUTION"><pre><code class="active haskell">import Data.Conduit
import qualified Data.Conduit.List as CL
import Control.Monad.Trans.Class (lift)

-- show
myAwaitForever :: Monad m =&gt; (a -&gt; Conduit a m b) -&gt; Conduit a m b
myAwaitForever f = 
    await &gt;&gt;= maybe (return ()) (\x -&gt; f x &gt;&gt; myAwaitForever f)
-- /show

main = CL.sourceList [1..10] $$ myAwaitForever (lift . print)</code></pre></div></li></ol><h2 id="monadic-chaining"><a href="#monadic-chaining">Monadic chaining</a></h2><p>The above examples demonstrated how we can combine primitives together using standard monadic binding. This doesn't just apply to the primitives: you can combine larger components together as well. Consider the &quot;triple&quot; <code>Conduit</code> which will output any values it receives three times:</p><pre><code class="haskell active">import Data.Conduit
import qualified Data.Conduit.List as CL

triple :: Monad m =&gt; Conduit a m a
-- show Triple conduit
triple = do
    ma &lt;- await
    case ma of
        Nothing -&gt; return ()
        Just a -&gt; do
            CL.sourceList [a, a, a]
            triple
-- /show

main = CL.sourceList [1..4] $$ triple =$ CL.mapM_ print</code></pre><p>Mini exercise: rewrite the above using <code>awaitForever</code>, which should be much shorter.</p><p>As you can see, it's entirely possible to combine a higher-level function like <code>sourceList</code> into a larger function. One question you might have is: how can we use a <code>Source</code> inside the body of a <code>Conduit</code>? We'll discuss that with <code>Producer</code>s and <code>Consumer</code>s in the generalizing section below.</p><p><b>Exercise</b>: Write a <code>Conduit</code> that consumes a stream of <code>Int</code>s. It takes the first <code>Int</code> from the stream, and then multiplies all subsequent <code>Int</code>s by that number and sends them back downstream. You should use the <a class="hoogle" href="https://www.stackage.org/lts/hoogle?q=Data.Conduit.List.map&amp;results=1" title="Hoogle search for: Data.Conduit.List.map"><code>Data.Conduit.List.map</code></a> function for this.</p><div class="hidden" title="SHOW SOLUTION"><pre><code class="haskell active">import Data.Conduit
import qualified Data.Conduit.List as CL

-- show Multiplier
multiplier = do
    ma &lt;- await
    case ma of
        Nothing -&gt; return ()
        Just a -&gt; CL.map (* a)
-- /show

main = CL.sourceList [5..10] $$ multiplier =$ CL.mapM_ print</code></pre></div><h2 id="lifting-operations"><a href="#lifting-operations">Lifting operations</a></h2><p>As monad transformers, our components can perform any operations supported by their underlying monads. We've already seen this implicitly with usage of <code>CL.mapM_ print</code>. However, we can also use <code>lift</code> or <code>liftIO</code> explicitly. And we're also not limited to the <code>IO</code> monad. Let's consider an example with the <code>State</code> monad.</p><pre><code class="active haskell">import Control.Monad.State
import Data.Conduit
import qualified Data.Conduit.List as CL

source :: Source (State Int) Int
source = do
    x &lt;- lift get
    if x &lt;= 0
        then return ()
        else do
            yield x
            lift $ modify (\x -&gt; x - 2)
            source
            
conduit :: Conduit Int (State Int) (Int, Int)
conduit = awaitForever $ \i -&gt; do
    lift $ modify (+ 1)
    x &lt;- lift get
    yield (i, x)

main :: IO ()
main = do
    let result :: State Int [(Int, Int)]
        result = source $$ conduit =$ CL.consume
    print $ runState result 5</code></pre><h2 id="generalizing"><a href="#generalizing">Generalizing</a></h2><p>In the triple conduit example above, why were we able to use a <code>Source</code> inside a <code>Conduit</code>? That shouldn't typecheck, should it? After all, a <code>Source</code> has its input type constrained to <code>()</code>, while a <code>Conduit</code> can have any input type. In our example above, the input was <code>Int</code>, so it certainly should not have worked.</p><p>The answer is that we have two final type synonyms to introduce. <code>Producer</code> is a generalized <code>Source</code>. Instead of stating that it consumes an input stream of <code>()</code> values, it can consume <i>any</i> input values, thus allowing it to work for both <code>Source</code> and <code>Conduit</code>. Similarly, we have <code>Consumer</code> which can output any values, and thus works as either a <code>Conduit</code> or a <code>Sink</code>.</p><p>In the interest of generality, most library functions will be written in terms of <code>Producer</code> or <code>Consumer</code>. As a user, you can simply use <code>Source</code> and <code>Sink</code> in most of your code, unless you need to use a function as <code>Conduit</code> as well.</p><p>And for the cases where you have a <code>Source</code> and wish to convert it to a <code>Conduit</code> after the fact (e.g., it comes from another person's library), you can use <a class="hoogle" href="https://www.stackage.org/lts/hoogle?q=toProducer&amp;results=1" title="Hoogle search for: toProducer"><code>toProducer</code></a>, or <a class="hoogle" href="https://www.stackage.org/lts/hoogle?q=toConsumer&amp;results=1" title="Hoogle search for: toConsumer"><code>toConsumer</code></a> for <code>Sink</code>s.</p><h2 id="termination"><a href="#termination">Termination</a></h2><p>Let's talk about the lifetime of a sequence of components (we'll call it a pipeline). A pipeline is always driven from <i>downstream</i>. This means, for example, that if we connect a <code>Source</code> and a <code>Sink</code>, we start our execution with the <code>Sink</code>.</p><p>The Sink will continue processing- however that specific Sink processes- until it needs more input. Then it calls <code>await</code>, and processing is paused until new input is available. For the Source, it will be woken up when the downstream component asks for input, and will yield control downstream when it yields a value. As soon as the <code>Sink</code> completes, the entire pipeline terminates.</p><p>The following example demonstrates how the components of our pipeline interact with each other. Try modifying the parameter to <code>sink</code> from 2 to 4 to see how that affects the output.</p><pre><code class="haskell active">import Data.Conduit
import Control.Monad.IO.Class

-- show Termination

source = do
    liftIO $ putStrLn &quot;source: yielding 1&quot;
    yield 1
    liftIO $ putStrLn &quot;source: yielding 2&quot;
    yield 2
    liftIO $ putStrLn &quot;source: yielding 3&quot;
    yield 3
    
conduit = do
    liftIO $ putStrLn &quot;conduit calling await&quot;
    mx &lt;- await
    case mx of
        Nothing -&gt; liftIO $ putStrLn &quot;Nothing left, exiting&quot;
        Just x -&gt; do
            liftIO $ putStrLn $ &quot;conduit yielding &quot; ++ show x
            yield x
            conduit
            
sink 0 = liftIO $ putStrLn &quot;sink is finished, terminating&quot;
sink i = do
    liftIO $ putStrLn $ &quot;sink: still waiting for &quot; ++ show i
    mx &lt;- await
    case mx of
        Nothing -&gt; liftIO $ putStrLn &quot;sink: Nothing from upstream, exiting&quot;
        Just x -&gt; do
            liftIO $ putStrLn $ &quot;sink received: &quot; ++ show x
            sink (i - 1)
            
main = source $$ conduit =$ sink 2
-- /show</code></pre><p>Based on what we've said until now, there's a big limitation. <code>Source</code>s and <code>Conduit</code>s have no way of cleaning up after themselves, since they are terminated immediately when anything downstream from them terminates. To address this, <code>conduit</code> supports the concept of terminators. Each time a <code>Source</code> or <code>Conduit</code> <code>yield</code>s a value downstream, it may additionally include a clean-up function. Each time the <code>Source</code> <code>yield</code>s, it overwrites the previously yielded clean-up function. Let's see a simple example:</p><pre><code class="haskell active">import Data.Conduit
import qualified Data.Conduit.List as CL

source =
    loop 1
  where
    loop i = do
        yieldOr i $ putStrLn $ &quot;Terminated when yielding: &quot; ++ show i
        loop $ i + 1
        
main = source $$ CL.isolate 7 =$ CL.mapM_ print</code></pre><p>While in our examples till now this isn't incredibly important, when we start dealing with scarce resources like file descriptors, we need the ability to close the descriptor as soon as we're done with it.</p><p>Manually inserting <code>yieldOr</code>s throughout your codebase can be very tedious. Instead, it's usually easier to use the <code>addCleanup</code> function, which will ensure that a certain function is called on termination. Your cleanup function is provided a <code>Bool</code> parameter. If <code>True</code>, it means that the component ran to its normal completion. If <code>False</code>, it means that downstream terminated first.</p><p>Let's demonstrate some simple file I/O. Note that the code below deals with characters one at a time, and is thus incredibly inefficient. It is highly recommended to use <a class="hoogle" href="https://www.stackage.org/lts/hoogle?q=Data.Conduit.Binary" title="Hoogle search for: Data.Conduit.Binary"><code>Data.Conduit.Binary</code></a> for real-world use cases.</p><pre><code class="haskell active">{-# START_FILE test.txt #-}
This is a test.
{-# START_FILE main.hs #-}
import System.IO
import Data.Conduit
import Control.Monad.IO.Class
import qualified Data.Conduit.List as CL

source = do
    handle &lt;- liftIO $ openFile &quot;test.txt&quot; ReadMode
    addCleanup (const $ putStrLn &quot;Closing handle&quot; &gt;&gt; hClose handle) $ loop handle
  where
    loop handle = do
        eof &lt;- liftIO $ hIsEOF handle
        if eof
            then return ()
            else do
                c &lt;- liftIO $ hGetChar handle
                yield c
                loop handle
                
main = source $$ CL.isolate 5 =$ CL.mapM_ print</code></pre><h2 id="exception-safety"><a href="#exception-safety">Exception Safety</a></h2><p>There's still a major flaw in our <code>addCleanup</code> approach: it's not exception safe! If an exception is thrown by either our component or any other component in the pipeline, our <code>Handle</code> will not be closed correctly.</p><p>In order to guarantee that an action takes place even in the presence of exceptions, we need to introduce one final function: <code>bracketP</code>. It works very similarly to the standard <code>bracket</code> function: you provide it an allocate function which creates some scarce resource, a cleanup function which frees that resource, and an inside function which will perform some action with that resource.</p><p>Let's rewrite our inefficient file reader above to use <code>bracketP</code>.</p><pre><code class="haskell active">{-# START_FILE test.txt #-}
This is a test.
{-# START_FILE main.hs #-}
import System.IO
import Data.Conduit
import Control.Monad.IO.Class
import qualified Data.Conduit.List as CL

source =
-- show Better with bracketP
    bracketP
        (openFile &quot;test.txt&quot; ReadMode)
        (\handle -&gt; putStrLn &quot;Closing handle&quot; &gt;&gt; hClose handle)
        loop
-- /show
  where
    loop handle = do
        eof &lt;- liftIO $ hIsEOF handle
        if eof
            then return ()
            else do
                c &lt;- liftIO $ hGetChar handle
                yield c
                loop handle

-- show An exception-throwing sink.
exceptionalSink = do
    c &lt;- await
    liftIO $ print c
    error &quot;This throws an exception&quot;
-- /show

-- show We also need to call runResourceT
main = runResourceT $ source $$ exceptionalSink
-- /show</code></pre><p>Notice our call to <code>runResourceT</code>. At the point where execution leaves that function, all resources allocated inside that block will be freed. For more information on <code>ResourceT</code>, please see <a class="hoogle" href="https://www.stackage.org/lts/hoogle?q=Control.Monad.Trans.Resource&amp;results=1" title="Hoogle search for: Control.Monad.Trans.Resource"><code>Control.Monad.Trans.Resource</code></a>.</p><h2 id="connect-and-resume"><a href="#connect-and-resume">Connect and resume</a></h2><p><code>conduit</code> introduces a form of inversion of control. You no longer control the flow of execution of your program. Instead, you declaratively state when individual components need input and provide output, and then <code>conduit</code> ensures that everything is passed around correctly. For many use cases, this is sufficient. However, there are some cases where you may want to have more control over the flow of execution. Connect and resume provides you such an escape route.</p><p>Connect and resume introduces the concept of a <b>resumable source</b>. This is a <code>Source</code> which has been partially run, but can be continued by reconnecting to another <code>Sink</code>. To create a <code>ResumableSource</code>, you use the <code>$$+</code> connect-and-resume operator. To reconnect a <code>ResumableSource</code> to a new <code>Sink</code> and get an updated <code>ResumableSource</code>, use the <code>$$++</code> operator. And finally, you use the <code>$$+-</code> to connect a <code>ResumableSource</code> to its final <code>Sink</code>.</p><pre><code class="haskell active">import Data.Conduit
import qualified Data.Conduit.List as CL

main = do
    (rsrc1, result1) &lt;- CL.sourceList [1..10] $$+ CL.take 3
    (rsrc2, result2) &lt;- rsrc1 $$++ CL.take 3
    result3 &lt;- rsrc2 $$+- CL.consume
    print (result1, result2, result3)</code></pre><p>The important thing to note about this <code>ResumableSource</code> is that it might have some cleanup function associated with it, so you <i>must</i> ultimately call <code>$$+-</code> or else risk delaying cleanup of those resources.</p><p>Connect and resume usually only comes up in more complicated control flow operations, so it's likely that you won't run into it in your normal usage of <code>conduit</code>. One library which does utilize this is http-conduit, where a <code>ResumableSource</code> is returned from the <a class="hoogle" href="https://www.stackage.org/lts/hoogle?q=Network.HTTP.Conduit.http&amp;results=1" title="Hoogle search for: Network.HTTP.Conduit.http"><code>http</code></a> function to represent the body of an HTTP response.</p><h2 id="further-reading"><a href="#further-reading">Further reading</a></h2><ul><li><a class="hoogle" href="https://www.stackage.org/lts/hoogle?q=Data.Conduit&amp;results=1" title="Hoogle search for: Data.Conduit"><code>Data.Conduit</code></a> Main module defining data types and core operations.</li><li><a class="hoogle" href="https://www.stackage.org/lts/hoogle?q=Data.Conduit.List&amp;results=1" title="Hoogle search for: Data.Conduit.List"><code>Data.Conduit.List</code></a> A collection of common helper utilities.</li><li><a class="hoogle" href="https://www.stackage.org/lts/hoogle?q=Data.Conduit.Network&amp;results=1" title="Hoogle search for: Data.Conduit.Network"><code>Data.Conduit.Network</code></a> Create network servers and clients.</li></ul></article>

<div id="disqus_thread"><script>var disqus_shortname = "snoyberg-soh"; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })();</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com/">comments powered by <span class="logo-disqus">Disqus</span></a></a>
</div>

</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
<li><a href="https://www.schoolofhaskell.com/auth/login">Log In</a>
</li>
<li><a href="https://www.schoolofhaskell.com/auth/page/email/register">Sign Up</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="https://www.schoolofhaskell.com/static/bootstrap/css/bootstrap-responsive.css" />
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/cKRLBd-P.js"></script><script>window.fpco = window.fpco || {};
window.fpco.keyMap = "";

        function hident2() {
            if (navigator.id) {
                navigator.id.watch({
                    onlogin: function (assertion) {
                        if (assertion) {
                            document.location = "https://www.schoolofhaskell.com/auth/page/browserid/" + assertion;
                        }
                    },
                    onlogout: function () {}
                });
                navigator.id.request({
                    returnTo: "/auth/login" + "?autologin=true"
                });
            }
            else {
                alert("Loading, please try again");
            }
        }
    
        (function(){
            var bid = document.createElement("script");
            bid.async = true;
            bid.src = "https://login.persona.org/include.js";
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(bid, s);
        })();
    $(function(){
    var url = "https://www.schoolofhaskell.com/like-content/237";
    var $self = $("#hident3");
    $.getJSON(url, function(state){
        var $a, $likeCount;

        $a = $('<a class="likes" href="/auth/login"></a>');
        $likeCount = $('<span class="like-count"></span>');
        $thumbs = $("<i class='icon-thumbs-up' title='Unlike this :-('>");
        $a.append($likeCount);
        $a.append($thumbs);
        $self.append($a);

        updateView();

        $a.click(function(){
            if(state.myLike == 'not-logged-in') {
                return true;
            } else {
                var $a = $(this);
                $.post(url, state.myLike !== 'no-like' ? {unlike:true} : {}, function(data){
                    state.myLike = state.myLike == 'no-like'? 'like' : 'no-like';
                    state.likes = data.likes;
                    updateView();
                });
                return false;
            }
        });

        function updateView(){
            var liked = state.myLike !== 'not-logged-in' && state.myLike !== 'no-like';
            if(liked) $a.addClass('likes-liked');
            else $a.removeClass('likes-liked');

            $likeCount.text(state.likes);

            if(state.myLike !== 'not-logged-in') {
                if (liked) $thumbs.attr('title','Unlike this');
                else $thumbs.attr('title','Like this!');

                if (liked) $a.addClass('likes-liked');
                else $a.removeClass('likes-liked');
            } else {
                $a.addClass('like-not-logged-in');
                $thumbs.attr('title','Please login to vote!');
            }
        }
    });
});
$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/user/snoyberg/library-documentation/conduit-overview';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body>
<!-- Mirrored from www.schoolofhaskell.com/user/snoyberg/library-documentation/conduit-overview by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 26 Dec 2016 20:38:42 GMT -->
</html>