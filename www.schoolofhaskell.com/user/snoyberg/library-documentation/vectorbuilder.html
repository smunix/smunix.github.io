<!DOCTYPE html>
<html>
<!-- Mirrored from www.schoolofhaskell.com/user/snoyberg/library-documentation/vectorbuilder by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 31 Dec 2016 04:40:09 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head><title>vectorBuilder - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="http://fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>#hident3 .like-count{margin-right:0.5em}#hident3 .likes{font-family:merriweather;float:right;margin-bottom:1em;border:1px solid #eee;font-size:1.1em;padding:0.25em;border-radius:0.25em;display:inline-block;text-align:center;color:#468847;background-color:#dff0d8;border-color:#d6e9c6}#hident3 .likes:hover{text-decoration:none;cursor:pointer}#hident3 .likes-liked i{opacity:0.25}#hident3 .likes-liked .like-count{font-weight:bold }#hident3 .like-not-logged-in *{cursor:default}.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"Â·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="http://www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='http://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="https://www.schoolofhaskell.com/"><img src="https://www.schoolofhaskell.com/static/img/ide-logo.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
<ul class="nav pull-right"><li><a href="https://www.schoolofhaskell.com/auth/login">Login</a>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/user/snoyberg">Michael Snoyman</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/snoyberg/library-documentation">Library Documentation</a>
<span class="divider">/</span>
</li>
<li><a href="vectorbuilder.html">vectorBuilder</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><p class="alert">Interactive code snippets not yet available for SoH 2.0, see our <a href=https://www.fpcomplete.com/blog/2016/01/soh-status>Status of
 of School of Haskell 2.0 blog post</a></p>
</div>
</div>
<div class="row"><div class="span12"><h1 itemprop="name">vectorBuilder</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date">30 Jul 2014</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/snoyberg">Michael Snoyman</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/1/09477567d05a2c01260838a183de10d04bc81807">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><div id="hident3"></div>

<span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="data-conduit-process.html">Next content: Data.Conduit.Process</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/snoyberg/library-documentation">Go up to: Library Documentation</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/snoyberg">See all content by Michael Snoyman</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#motivating-use-case">Motivating use case</a></li><li><a href="#buffer-copying">Buffer copying</a></li><li><a href="#avoiding-transformers">Avoiding transformers</a></li><li><a href="#bytestring-and-vector">ByteString and Vector</a></li><li><a href="#comparison-with-blaze-builder">Comparison with blaze-builder</a></li><li><a href="#complete-code">Complete code</a></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="ghc-7.8-stable-14.09">
<article><p>Often times when working with Haskell in a high performance context, the overhead introduced by a linked list representation can be too high. Having an extra constructor around each value, a constructor for each cons cell, and the indirection introduced by having to follow pointers, can completely kill performance. The most common examples of this are the high speedup you can often achieve by replacing <code>String</code> with <code>Text</code> (or something <code>ByteString</code>), or by using <code>Vector</code>s- especially unboxed or storable <code>Vector</code>s.</p><p>conduit has a similar representation of a stream as a list, including the constructor overheads just mentioned. It's not surprising, therefore, that in a situation that a list would be a poor representation, conduits will often suffer similar performance problems. Like lists, some of this overhead is mitigated by shortcut fusion (a.k.a., rewrite rules). But this isn't always the case.</p><p>conduit-combinators provides a helper function which allows us to take back performance, by working with a packed representation instead of creating a bunch of cons cells. It does this by using the vector package's generic mutable interface under the surface, while at a user-facing level providing a simple yield-like function, avoiding the need to muck around with mutable buffers.</p><p>This article will cover how to use this function, some implementation details, and comparisons to other approaches.</p><p><b>NOTE</b>: At the time of writing, the version of conduit-combinators provided on School of Haskell does not contain the <code>vectorBuilder</code> function, and therefore the active code below will not run.</p><h2 id="motivating-use-case"><a href="#motivating-use-case">Motivating use case</a></h2><p>Let's start with a simple goal: we have chunks of bytes coming in, and we want to (1) duplicate each successive byte so that, e.g. [1, 2, 3] becomes [1, 1, 2, 2, 3, 3] and (2) rechunk the values into vectors of size 512. The original data could be chunked in any way, so we can rely on any specific incoming chunk size (in this case, a known 256 chunk size would be convenient).</p><p>Likely the easiest approach is to convert our stream of chunked values (e.g., <code>ByteString</code> or <code>Vector Word8</code>) into a stream of elements (e.g., <code>Word8</code>), duplicate the individual values, then chunk those back up. Such a solution would look like:</p><pre><code class="haskell">rechunk1 = concatC
       =$= concatMapC (\x -&gt; [x, x])
       =$= conduitVector 512</code></pre><p>This uses the <code>concatC</code> combinator to &quot;flatten out&quot; the input stream, <code>concatMapC</code> to duplicate each individual <code>Word8</code>, and then <code>conduitVector</code> to create a stream of 512-sized <code>Vector</code>s. In my simple benchmark, this function took 13.06ms.</p><p>But as we can probably guess, this falls into the problem zone described in our introduction. So instead of dealing with things on the individual byte level, let's try to use some higher-level functions operating on <code>Vector</code>s of values instead. Our new approach will be to first <code>mapC</code> over the stream and use vector's <code>concatMap</code> to double each value, and then use <code>takeCE</code> and <code>foldC</code> to extract successive chunks of size 4096. In code:</p><pre><code class="haskell">rechunk2 =
    mapC (concatMap $ replicate 2) =$= loop
  where
    loop = do
        x &lt;- takeCE 512 =$= foldC
        unless (null x) $ yield x &gt;&gt; loop</code></pre><p>In the same benchmark, this performed at 8.83ms, a 32% speedup. While respectable, we can do better.</p><h2 id="buffer-copying"><a href="#buffer-copying">Buffer copying</a></h2><p>Our first approach is optimal in one way: it avoids needless buffer copying. Each <code>Word8</code> is copied precisely once into an output <code>Vector</code> by <code>conduitVector</code>. Unfortunately, this advantage is killed by the overhead of boxing the <code>Word8</code>s and allocating constructors for conduit. Our second approach avoids the boxing and constructors by always operating on <code>Vector</code>s, but we end up copying buffers multiple times: from the original <code>Vector</code> to the doubled <code>Vector</code>, and then when folding together multiple <code>Vector</code>s into a single <code>Vector</code> of size 512.</p><p>What we want to do is to be able to <code>yield</code> a <code>Word8</code> and have it fill up an output buffer, and once that buffer is filled, <code>yield</code> that buffer downstream and start working on a new one. We could do that by directly dealing with mutable <code>Vector</code>s, but that's error-prone and tedious. Instead, let's introduce our new combinator function: <code>vectorBuilder</code> (or its unqualified name, <code>vectorBuilderC</code>).</p><p>The idea is simple. <code>vectorBuilder</code> will allocate an output buffer for you. It provides you with a special <code>yield</code>-like function that fills up this buffer, and when it's full, yields the entire buffer downstream for you.</p><p>To use it, we're going to use one other combinator function: <code>mapM_CE</code>, which performs an action for every value in a chunked input stream (in our case, for each <code>Word8</code> in our input <code>Vector Word8</code>s). Altogether, this looks like:</p><pre><code class="haskell">rechunk3 = vectorBuilderC 512 $ \yield' -&gt;
    mapM_CE (\x -&gt; yield' x &gt;&gt; yield' x)</code></pre><p>We call <code>yield'</code> twice to double our bytes. <code>vectorBuilder</code> ensures that each output buffer is of size 512. <code>mapM_CE</code> efficiently traverses the incoming <code>Vector</code>s without creating intermediate data structures.</p><p>This version benchmarks at 401.12us. This is approximately 95% faster than our previous attempt!</p><h2 id="avoiding-transformers"><a href="#avoiding-transformers">Avoiding transformers</a></h2><p>There's something tricky about the <code>yield'</code> function above. Notice how it's not being used in the <code>Conduit</code> monad transformer, but is instead living the base monad (e.g., <code>IO</code>). This is not accidental. Not only does this allow us to use existing monadic combinators like <code>mapM_CE</code>, it also allows for <i>far</i> more efficient code. To demonstrate, let's look at two different ways of doing the same thing:</p><pre><code class="haskell">bgroup &quot;transformers&quot; $
    let src = return () in
    [ bench &quot;single&quot; $ nfIO $ do
        ref &lt;- newIORef 0
        let incr = modifyIORef ref succ
        src $$ liftIO (replicateM_ 1000 incr)
    , bench &quot;multi&quot; $ nfIO $ do
        ref &lt;- newIORef 0
        let incr = liftIO $ modifyIORef ref succ
        src $$ replicateM_ 1000 incr
    ]</code></pre><p>Both of these benchmarks use no conduit features. They both create an <code>IORef</code>, then increment it 1000 times. The difference is that the first calls <code>liftIO</code> once, while the second calls <code>liftIO</code> 1000 times. Let's see the difference in benchmark results:</p><pre><code>benchmarking transformers/single
mean: 4.292891 us, lb 4.285319 us, ub 4.303626 us, ci 0.950
std dev: 45.83832 ns, lb 35.04324 ns, ub 59.43617 ns, ci 0.950

benchmarking transformers/multi
mean: 93.10228 us, lb 92.95708 us, ub 93.30159 us, ci 0.950
std dev: 869.6636 ns, lb 673.8342 ns, ub 1.090044 us, ci 0.950</code></pre><p>Avoiding extra <code>liftIO</code> calls has a profound performance impact. The reason for this is somewhat similar to what we've been discussing up until now about extra cons cells. In our case, it's extra <code>PipeM</code> constructors used by conduit's <code>MonadIO</code> instance. I don't want to dwell on those details too much right now, as that's a whole separate topic of analysis, involving looking at GHC core output. But let's take it as a given right now.</p><p>The question is: how does <code>vectorBuilder</code> allow you to live in the base monad, but still <code>yield</code> values downstream, which requires access to the <code>Conduit</code> transformer? There's a trick here using mutable variables. The implementation essentially works like this:</p><ul><li>Allocate a new, empty mutable vector.</li><li>Allocate a mutable variable holding an empty list.</li><li>Start running the user-supplied <code>Conduit</code> function, providing it with a specialized <code>yield</code> function.</li><li>The specialized <code>yield</code> function- which lives in the base monad- will write values into the mutable vector. Once that mutable vector is filled, the vector is frozen and added to the end of the mutable variable's list, and a new mutable vector is allocated.</li><li>The next time the user's function <code>await</code>s for values from upstream, we jump into action. Since we're already forced to be in the <code>Conduit</code> transformer at that point, this is our chance to <code>yield</code>. We grab all of the frozen vectors from the mutable variable and <code>yield</code> them downstream. Once that's done, we <code>await</code> for new data from upstream, and provide it to the user's function.</li><li>When the user's function is finished, we freeze the last bit of data from the mutable vector and yield that downstream too.</li></ul><p>The upsides of this approach are ease-of-use and performance. There <i>is</i> one downside you should be aware of: if you generate a large amount of output without <code>await</code>ing for more data from upstream, you can begin to accumulate more memory. You can force the collection of frozen <code>Vector</code>s to be flushed using the following helper function:</p><pre><code class="haskell">forceFlush :: Monad m =&gt; ConduitM i o m ()
forceFlush = await &gt;&gt;= maybe (return ()) leftover</code></pre><p>This simply <code>await</code>s for a value, allowing <code>vectorBuilder</code> to clear its cache, and then gives the new value back as a leftover.</p><p>Overall, your goal should be to have a decent trade-off between memory and time efficiency. To demonstrate, try playing around with the functions f1, f2, and f3 in the following code snippet:</p><pre><code class="haskell active">{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE FlexibleContexts #-}
import ClassyPrelude.Conduit

forceFlush :: Monad m =&gt; ConduitM i o m ()
forceFlush = await &gt;&gt;= maybe (return ()) leftover

-- Memory inefficient, time efficient
f1 :: (Int -&gt; IO ()) -&gt; Sink () IO ()
f1 f = liftIO $ forM_ [1..1000000] f

-- Memory efficient, time inefficient
f2 :: (Int -&gt; Sink () IO ()) -&gt; Sink () IO ()
f2 f = forM_ [1..1000000] $ \i -&gt; do
    f i
    forceFlush

-- Good trade-off
f3 f = forM_ (chunksOf 10000 [1..1000000]) $ \is -&gt; do
    liftIO $ mapM_ f is
    forceFlush
  where
    chunksOf _ [] = []
    chunksOf i x =
        y : chunksOf i z
      where
        (y, z) = splitAt i x

main = vectorBuilderC 4096 f3
    $$ (sinkNull :: Sink (Vector Int) IO ())</code></pre><h2 id="bytestring-and-vector"><a href="#bytestring-and-vector">ByteString and Vector</a></h2><p>It may be surprising to have seen an entire article on packed representations of bytes, and not yet seen <code>ByteString</code>. As a matter of fact, the <a href="http://www.reddit.com/r/haskell/comments/29nvsx/how_to_get_good_performance_when_processing/">original use case</a> I started working on this for had nothing to do with the vector package. However, I decided to focus on <code>vector</code> for two reasons:</p><ol><li>Unlike bytestring, it provides a well developed mutable interface. Not only that, but the mutable interface is optimized for storable, unboxed, and generic vectors, plus existing helper packages like <a href="http://hackage.haskell.org/package/hybrid-vectors">hybrid-vectors</a>. In other words, this is a far more general-purpose solution.</li><li>It's trivial and highly efficient to convert a <code>ByteString</code> to and from a storable <code>Vector</code>.</li></ol><p>To demonstrate that second point, let's try to read a file, duplicate all of its bytes as we did above, and write it back to a separate file. We'll use the <code>toByteVector</code> and <code>fromByteVector</code> functions, which I recently added to mono-traversable for just this purpose:</p><pre><code class="haskell active">{-# LANGUAGE NoImplicitPrelude #-}
import           ClassyPrelude.Conduit
import           System.IO             (IOMode (ReadMode, WriteMode),
                                        withBinaryFile)

double :: (Word8 -&gt; IO ()) -&gt; Sink (SVector Word8) IO ()
double yield' = mapM_CE $ \w -&gt;
    yield' w &gt;&gt; yield' w

main :: IO ()
main = withBinaryFile &quot;input.txt&quot; ReadMode $ \inH -&gt;
       withBinaryFile &quot;output.txt&quot; WriteMode $ \outH -&gt;
       sourceHandle inH
    $$ mapC toByteVector
    =$ vectorBuilderC 4096 double
    =$ mapC fromByteVector
    =$ sinkHandle outH</code></pre><h2 id="comparison-with-blaze-builder"><a href="#comparison-with-blaze-builder">Comparison with blaze-builder</a></h2><p>There's a strong overlap between what <code>vectorBuilder</code> does, and how blaze-builder (and more recently, bytestring's <code>Builder</code> type) are intended to be used. I unfortunately can't give any conclusive comparisons between these two techniques right now. What I <i>can</i> say is that there are cases where using a <code>Builder</code> has proven to be inefficient, and <code>vectorBuilder</code> provides a large performance improvement. I can also say that <code>vectorBuilder</code> addresses many more use cases that <code>Builder</code>. For example, at FP Complete we're planning to use this in financial analyses for creating time series data.</p><p>On the other hand, blaze-builder and bytestring's <code>Builder</code> have both had far more real-world tuning than <code>vectorBuilder</code>. They also have support for things such as copying existing <code>ByteString</code>s into the output stream, whereas <code>vectorBuilder</code> always works by copying a single element at a time.</p><p>So for now, if you have a use case and you're uncertain whether to use <code>vectorBuilder</code> to blaze-builder, I recommend either trying both approaches, or discussing it on one of the Haskell mailing lists to get more feedback.</p><h2 id="complete-code"><a href="#complete-code">Complete code</a></h2><p>The code for most of the blog post above is below. Sorry that it's a bit messy:</p><pre><code class="haskell active">{-# LANGUAGE FlexibleContexts          #-}
{-# LANGUAGE NoImplicitPrelude         #-}
{-# LANGUAGE NoMonomorphismRestriction #-}
import           ClassyPrelude.Conduit
import           Control.Monad.Primitive (PrimMonad)
import           Control.Monad.ST        (runST)
import           Criterion.Main          (bench, bgroup, defaultMain, nfIO,
                                          whnfIO)
import qualified Data.Vector.Generic     as VG
import qualified System.Random.MWC       as MWC
import           Test.Hspec              (hspec, shouldBe)
import           Test.Hspec.QuickCheck   (prop)

rechunk1 :: ( Monad m
            , VG.Vector vector (Element input)
            , PrimMonad base
            , MonadBase base m
            , MonoFoldable input
            )
         =&gt; Conduit input m (vector (Element input))
rechunk1 = concatC =$= concatMapC (\x -&gt; [x, x]) =$= conduitVector 512
{-# INLINE rechunk1 #-}

rechunk2 :: (Monad m, IsSequence a) =&gt; Conduit a m a
rechunk2 =
    mapC (concatMap $ replicate 2) =$= loop
  where
    loop = do
        x &lt;- takeCE 512 =$= foldC
        unless (null x) $ yield x &gt;&gt; loop
{-# INLINE rechunk2 #-}

rechunk3 :: ( MonadBase base m
            , PrimMonad base
            , MonoFoldable input
            , VG.Vector vector (Element input)
            )
         =&gt; Conduit input m (vector (Element input))
rechunk3 = vectorBuilderC 512 $ \yield' -&gt;
    mapM_CE (\x -&gt; yield' x &gt;&gt; yield' x)
{-# INLINE rechunk3 #-}

main :: IO ()
main = do
    hspec $ prop &quot;rechunking&quot; $ \ws -&gt; do
        let src = yield (pack ws :: UVector Word8)
            doubled = concatMap (\w -&gt; [w, w]) ws
            res1 = runST $ src $$ rechunk1 =$ sinkList
            res2 = runST $ src $$ rechunk2 =$ sinkList
            res3 = runST $ src $$ rechunk3 =$ sinkList
        res1 `shouldBe` (res2 :: [UVector Word8])
        (res3 :: [UVector Word8]) `shouldBe` (res2 :: [UVector Word8])
        (unpack $ (mconcat res2 :: UVector Word8)) `shouldBe` (doubled :: [Word8])
        case reverse res1 :: [UVector Word8] of
            [] -&gt; return ()
            x:xs -&gt; do
                (length x &lt;= 512) `shouldBe` True
                all ((== 512) . length) xs `shouldBe` True

    gen &lt;- MWC.createSystemRandom
    bytes &lt;- replicateM 20 $
        MWC.uniformR (12, 1024) gen &gt;&gt;= MWC.uniformVector gen

    defaultMain
        [ bgroup &quot;copy bytes&quot;
            [ bench &quot;rechunk1&quot; $ whnfIO
                $ yieldMany (bytes :: [UVector Word8])
               $$ (rechunk1 :: Conduit (UVector Word8) IO (UVector Word8))
               =$ sinkNull
            , bench &quot;rechunk2&quot; $ whnfIO
                $ yieldMany (bytes :: [UVector Word8])
               $$ (rechunk2 :: Conduit (UVector Word8) IO (UVector Word8))
               =$ sinkNull
            , bench &quot;rechunk3&quot; $ whnfIO
                $ yieldMany (bytes :: [UVector Word8])
               $$ (rechunk3 :: Conduit (UVector Word8) IO (UVector Word8))
               =$ sinkNull
            ]
        , bgroup &quot;transformers&quot; $
            let src = return () in
            [ bench &quot;single&quot; $ nfIO $ do
                ref &lt;- newIORef (0 :: Int)
                let incr = modifyIORef ref succ
                src $$ liftIO (replicateM_ 1000 incr)
            , bench &quot;multi&quot; $ nfIO $ do
                ref &lt;- newIORef (0 :: Int)
                let incr = liftIO $ modifyIORef ref succ
                src $$ replicateM_ 1000 incr
            ]
        ]</code></pre></article>

<div id="disqus_thread"><script>var disqus_shortname = "snoyberg-soh"; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })();</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com/">comments powered by <span class="logo-disqus">Disqus</span></a></a>
</div>

</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
<li><a href="https://www.schoolofhaskell.com/auth/login">Log In</a>
</li>
<li><a href="https://www.schoolofhaskell.com/auth/page/email/register">Sign Up</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="https://www.schoolofhaskell.com/static/bootstrap/css/bootstrap-responsive.css" />
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/cKRLBd-P.js"></script><script>window.fpco = window.fpco || {};
window.fpco.keyMap = "";

        function hident2() {
            if (navigator.id) {
                navigator.id.watch({
                    onlogin: function (assertion) {
                        if (assertion) {
                            document.location = "https://www.schoolofhaskell.com/auth/page/browserid/" + assertion;
                        }
                    },
                    onlogout: function () {}
                });
                navigator.id.request({
                    returnTo: "/auth/login" + "?autologin=true"
                });
            }
            else {
                alert("Loading, please try again");
            }
        }
    
        (function(){
            var bid = document.createElement("script");
            bid.async = true;
            bid.src = "https://login.persona.org/include.js";
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(bid, s);
        })();
    $(function(){
    var url = "https://www.schoolofhaskell.com/like-content/32333";
    var $self = $("#hident3");
    $.getJSON(url, function(state){
        var $a, $likeCount;

        $a = $('<a class="likes" href="/auth/login"></a>');
        $likeCount = $('<span class="like-count"></span>');
        $thumbs = $("<i class='icon-thumbs-up' title='Unlike this :-('>");
        $a.append($likeCount);
        $a.append($thumbs);
        $self.append($a);

        updateView();

        $a.click(function(){
            if(state.myLike == 'not-logged-in') {
                return true;
            } else {
                var $a = $(this);
                $.post(url, state.myLike !== 'no-like' ? {unlike:true} : {}, function(data){
                    state.myLike = state.myLike == 'no-like'? 'like' : 'no-like';
                    state.likes = data.likes;
                    updateView();
                });
                return false;
            }
        });

        function updateView(){
            var liked = state.myLike !== 'not-logged-in' && state.myLike !== 'no-like';
            if(liked) $a.addClass('likes-liked');
            else $a.removeClass('likes-liked');

            $likeCount.text(state.likes);

            if(state.myLike !== 'not-logged-in') {
                if (liked) $thumbs.attr('title','Unlike this');
                else $thumbs.attr('title','Like this!');

                if (liked) $a.addClass('likes-liked');
                else $a.removeClass('likes-liked');
            } else {
                $a.addClass('like-not-logged-in');
                $thumbs.attr('title','Please login to vote!');
            }
        }
    });
});
$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/user/snoyberg/library-documentation/vectorbuilder';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body>
<!-- Mirrored from www.schoolofhaskell.com/user/snoyberg/library-documentation/vectorbuilder by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 31 Dec 2016 04:40:09 GMT -->
</html>