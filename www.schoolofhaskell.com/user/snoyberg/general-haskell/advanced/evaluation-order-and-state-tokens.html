<!DOCTYPE html>
<html>
<!-- Mirrored from www.schoolofhaskell.com/user/snoyberg/general-haskell/advanced/evaluation-order-and-state-tokens by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 31 Dec 2016 04:40:10 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head><title>Evaluation order and state tokens - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="http://fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>#hident3 .like-count{margin-right:0.5em}#hident3 .likes{font-family:merriweather;float:right;margin-bottom:1em;border:1px solid #eee;font-size:1.1em;padding:0.25em;border-radius:0.25em;display:inline-block;text-align:center;color:#468847;background-color:#dff0d8;border-color:#d6e9c6}#hident3 .likes:hover{text-decoration:none;cursor:pointer}#hident3 .likes-liked i{opacity:0.25}#hident3 .likes-liked .like-count{font-weight:bold }#hident3 .like-not-logged-in *{cursor:default}.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"Â·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="http://www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='http://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="https://www.schoolofhaskell.com/"><img src="https://www.schoolofhaskell.com/static/img/ide-logo.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
<ul class="nav pull-right"><li><a href="https://www.schoolofhaskell.com/auth/login">Login</a>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/user/snoyberg">Michael Snoyman</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/snoyberg/general-haskell">General Haskell</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/snoyberg/general-haskell/advanced">Advanced</a>
<span class="divider">/</span>
</li>
<li><a href="evaluation-order-and-state-tokens.html">Evaluation order and state tokens</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><p class="alert">Interactive code snippets not yet available for SoH 2.0, see our <a href=https://www.fpcomplete.com/blog/2016/01/soh-status>Status of
 of School of Haskell 2.0 blog post</a></p>
</div>
</div>
<div class="row"><div class="span12"><h1 itemprop="name">Evaluation order and state tokens</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date"> 9 Sep 2014</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/snoyberg">Michael Snoyman</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/1/5e868fed77a315b9bee801724a4e228c0f7a7cfc">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><div id="hident3"></div>

<span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="https://www.schoolofhaskell.com/user/snoyberg/general-haskell/advanced">Go up to: Advanced</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/snoyberg">See all content by Michael Snoyman</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#evaluation-order-basics">Evaluation order basics</a></li><li><a href="#state-tokens">State tokens</a></li><li><a href="#unsafeperformio--unsafedupableperformio--inlineperformio--aka-he-who-shall-not-be-named-">unsafePerformIO, unsafeDupablePerformIO, inlinePerformIO (aka he-who-shall-not-be-named)</a></li><li><a href="#guidelines-on-using-each-function">Guidelines on using each function</a></li><li><a href="#interaction-with-stm">Interaction with STM</a></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="ghc-7.8-stable-14.09">
<article><p>Note: The new canonical location for this document is <a href="http://www.haskell.org/haskellwiki/Evaluation_order_and_state_tokens">on the GHC wiki</a>. This page may still be referenced, but is not guaranteed to be kept up-to-date.</p><p>Let's start off with a little quiz. What will be the output of running the following program? (Don't cheat by pressing play...)</p><pre><code class="haskell active">import System.IO.Unsafe

foo = unsafePerformIO $ putStrLn &quot;foo&quot;
bar = unsafePerformIO $ do
    putStrLn &quot;bar&quot;
    return &quot;baz&quot;
main = putStrLn $ foo `seq` bar</code></pre><p>The answer is: it's undefined. If you want to understand why, keep reading.</p><h2 id="evaluation-order-basics"><a href="#evaluation-order-basics">Evaluation order basics</a></h2><p><b>NOTE</b>: School of Haskell evaluates active code snippets like GHCi, which means that no optimizations are turned on. As a result, you will likely <i>never</i> see the &quot;surprising&quot; behavior described in this document manifesting when you run code here. Furthermore, you won't reliably see such behavior even if you compile with <code>-O2</code>; that's what I mean by &quot;undefined behavior&quot;.</p><p>Let's get back to something simpler. What's the output of this program?</p><pre><code class="haskell active">helper i = print i &gt;&gt; return i

main = do
    one &lt;- helper 1
    two &lt;- helper 2
    print $ one + two</code></pre><p>I think most people would agree: it will print 1, then 2, then 3. Now let's tweak this a little bit:</p><pre><code class="haskell active">import System.IO.Unsafe

helper i = unsafePerformIO $ print i &gt;&gt; return i

main = do
    let one = helper 1
        two = helper 2
    print $ one + two</code></pre><p>In this case, it's pretty easy to see that 3 will have to be printed after both 1 and 2, but it's unclear whether 1 or 2 will be printed first. The reason for this is evaluation order: in order to evaluate <code>one + two</code>, we'll need to evaluate both <code>one</code> and <code>two</code>. But there is nothing telling GHC which of those thunks should be evaluated first, and therefore GHC is at full liberty to choose whichever thunk to evaluate first. Now let's make it a bit more complicated:</p><pre><code class="haskell active">import System.IO.Unsafe

helper i = unsafePerformIO $ print i &gt;&gt; return i

main = do
    let one = helper 1
        two = helper 2
    print $ one `seq` one + two</code></pre><p>Now we've forced evaluation of <code>one</code> before evaluating the <code>one + two</code> expression, so presumably we should always print 1, then 2, then 3. But in fact, that's not true. To quote the docs for <code>seq</code>:</p><blockquote><p>A note on evaluation order: the expression <code>seq a b</code> does <i>not</i> guarantee that <code>a</code> will be evaluated before <code>b</code>. The only guarantee given by <code>seq</code> is that the both <code>a</code> and <code>b</code> will be evaluated before <code>seq</code> returns a value. In particular, this means that <code>b</code> may be evaluated before <code>a</code>.</p></blockquote><p>(Note: this version of the docs has not yet been publicly released as of writing this document.)</p><p>In other words, <code>seq</code> ensures that both <code>one</code> and <code>one + two</code> will be evaluated before the result of the <code>seq</code> expression is returned, but we <i>still</i> don't know which one will be evaluated first. If we want to be certain about that ordering, we need to instead use <code>pseq</code>. To quote its docs:</p><blockquote><p>Semantically identical to <code>seq</code>, but with a subtle operational difference: <code>seq</code> is strict in both its arguments, so the compiler may, for example, rearrange <code>a `seq` b</code> into <code>b `seq` a `seq` b</code>.</p></blockquote><p>To see this in action:</p><pre><code class="haskell active">import System.IO.Unsafe
import Control.Parallel

helper i = unsafePerformIO $ print i &gt;&gt; return i

main = do
    let one = helper 1
        two = helper 2
    print $ one `pseq` one + two</code></pre><p>Notice that comment about being strict in its arguments. You might think (as I did) that we can get the same guaranteed ordering of evaluation by having a function which is only strict in one of its arguments:</p><pre><code class="haskell active">{-# LANGUAGE BangPatterns #-}
import System.IO.Unsafe

helper i = unsafePerformIO $ print i &gt;&gt; return i

add !x y = x + y

main = do
    let one = helper 1
        two = helper 2
    print $ add one two</code></pre><p>However, that's not the case: GHC is free to inline the definition of <code>add</code>. And if we have <code>+</code> on a typical numeric type (like <code>Int</code>), which is strict in both arguments, we'll be right back where we started with both arguments being strictly evaluated. The only way to guarantee ordering of evaluation in this case is with <code>pseq</code>.</p><p>Alright, one more higher-level twist. What do you think about this?</p><pre><code class="haskell active">import System.IO.Unsafe

helper i = print i &gt;&gt; return i

main = do
    one &lt;- helper 1
    let two = unsafePerformIO $ helper 2
    print $ one + two</code></pre><p>This looks like it <i>should</i> be straightforward:</p><ol><li>Run <code>helper 1</code>.</li><li>Create a thunk to run <code>helper 2</code>.</li><li>Evaluate <code>one + two</code>, forcing the <code>helper 2</code> thunk to be evaluated in the process.</li><li>Print the result of <code>one + two</code>, a.k.a. 3.</li></ol><p>However, this isn't guaranteed! GHC is allowed to rearrange evaluation of thunks however it wishes. So a perfectly valid sequence of events for GHC with this code is:</p><ol><li>Create and evaluate the <code>helper 2</code> thunk.</li><li>Run <code>helper 1</code>.</li><li>Print the result of <code>one + two</code>.</li></ol><p>And this would result in the output of 2, then 1, then 3. You might think you can work around this with the following:</p><pre><code class="haskell active">import System.IO.Unsafe

helper i = print i &gt;&gt; return i

main = do
    one &lt;- helper 1
    two &lt;- return $ unsafePerformIO $ helper 2
    print $ one + two</code></pre><p>However, this makes absolutely no difference! The <code>helper 2</code> thunk can still be reordered to before the <code>helper 1</code> call. The following, however, <i>does</i> ensure that the evaluation of <code>two</code> always occurs after <code>helper 1</code>:</p><pre><code class="haskell active">import System.IO.Unsafe

helper i = print i &gt;&gt; return i

main = do
    one &lt;- helper 1
    two &lt;- unsafeInterleaveIO $ helper 2
    print $ one + two</code></pre><p>The reason is that <code>unsafeInterleaveIO</code> provides an extra guarantee relative to <code>unsafePerformIO</code>. Namely, with the code:</p><pre><code class="haskell">do
    before
    unsafeInterleaveIO side
    after</code></pre><p>We are guaranteed that effects in <code>side</code> will <i>always</i> happen after effects in <code>before</code>. However, effects in <code>side</code> may still occur interleaved with effects in <code>after</code>.</p><p>To understand how <code>unsafeInterleaveIO</code> provides these guarantees as opposed to <code>return . unsafePerformIO</code>, we need to drop down a layer of abstraction.</p><h2 id="state-tokens"><a href="#state-tokens">State tokens</a></h2><p>(Note: due to usage of unboxed tuples below- a feature unsupported by GHCi- running active code below will not work.)</p><p>When we have the code <code>print 1 &gt;&gt; print 2</code>, we know that 1 will be printed before 2. That's a feature of the IO monad: guaranteed ordering of effects. However, the second <code>print</code> call does not depend on the result of the first <code>print</code> call, so how do we know that GHC won't rearrange the <code>print</code> calls? The real answer is that our assumption was wrong: the result of <code>print 1</code> <i>is</i> in fact used by <code>print 2</code>. To see how, we need to look at the definition of <code>IO</code>:</p><pre><code class="haskell">newtype IO a = IO (State# RealWorld -&gt; (# State# RealWorld, a #))

instance  Monad IO  where
    (&gt;&gt;=)     = bindIO

bindIO :: IO a -&gt; (a -&gt; IO b) -&gt; IO b
bindIO (IO m) k = IO $ \ s -&gt; case m s of (# new_s, a #) -&gt; unIO (k a) new_s</code></pre><p>Unwrapping the <code>newtype</code> and replacing the slightly unwieldy <code>State# RealWorld</code> with <code>S#</code>, we can see that the type of <code>print 1</code> is:</p><pre><code class="haskell">print 1 :: S# -&gt; (# S#, () #)</code></pre><p>So in fact, our <code>print 1</code> call produces <i>two</i> results: a new state token, and a unit value. If we inline the definition of <code>&gt;&gt;</code>, our <code>print 1 &gt;&gt; print 2</code> turns into:</p><pre><code class="haskell">\s0 -&gt;
    case print 1 s0 of
        (# s1, _ignored #) -&gt; print 2 s1</code></pre><p>In fact, our call to <code>print 2</code> <i>does</i> rely on the result of <code>print 1</code>, in particular, the newly generated state token. This is the exact mechanism by which we ensure ordering of actions in both the <code>IO</code> and <code>ST</code> monads.</p><p>When you have a <code>main :: IO ()</code> function, GHC will generate a brand new state token at the start of the program, pass it in to the main function, and then throw away the state token generated at the end. By having these state tokens threaded through your program, we have a strict ordering of every single <code>IO</code> action in our program.</p><p>NB: In reality, GHC doesn't actually have any state tokens at runtime, they're a purely compile-time construct. So there's no actual &quot;generating&quot; and &quot;throwing away.&quot;</p><p>And this is where the magic of <code>unsafePerformIO</code> comes into play. It does the same thing as GHC does with <code>main</code>, but with a subprogram instead. This in theory looks something like the following (though in practice is more complicated, we'll get to that later):</p><pre><code class="haskell">unsafePerformIO (IO f) =
    case f fakeStateToken of
        (# _ignoredStateToken, result #) -&gt; result</code></pre><p>With normal, safe <code>IO</code> code, running of the action is forced by evaluating the state token passed to the next <code>IO</code> action. But when we use <code>unsafePerformIO</code>, the state token is completely ignored. Therefore, we're only left with the <code>result</code> value, and evaluating that forces the action to be run.</p><p>NB: The real name for <code>fakeStateToken</code> is <code>realWorld#</code>, we'll use that from now on.</p><p>As a reminder, we had this somewhat surprising code above:</p><pre><code class="haskell active">import System.IO.Unsafe

helper i = print i &gt;&gt; return i

main = do
    one &lt;- helper 1
    let two = unsafePerformIO $ helper 2
    print $ one + two</code></pre><p>I said that it was possible for 2 to be printed before 1. Understanding state tokens better, let's see why. A liberal translation of this code would be:</p><pre><code class="haskell">main s0 =
    case helper 1 s0 of
        (# s1, one #) -&gt;
            case helper 2 realWorld# of
                (# _ignored, two #) -&gt;
                    print (one + two) s1</code></pre><p>But using normal Haskell reasoning, it's perfectly sane for me to rewrite that and change the ordering of the case expressions, since the results of the first expression are never used by the second or vice versa:</p><pre><code class="haskell">main s0 =
    case helper 2 realWorld# of
        (# _ignored, two #) -&gt;
            case helper 1 s0 of
                (# s1, one #) -&gt;
                    print (one + two) s1</code></pre><p>I also above said that <code>unsafeInterleaveIO</code> would fix this ordering issue. To understand why <i>that's</i> the case, let's look at a simplified implementation of that function:</p><pre><code class="haskell">unsafeInterleaveIO (IO f) = IO $ \s0 -&gt;
    case f s0 of
        (# _ignored, result #) -&gt;
            (# s0, result #)</code></pre><p>Like <code>unsafePerformIO</code>, <code>unsafeInterleaveIO</code> throws away its resulting state token, so that the only way to force evaluation of the thunk is by using its result, not its state token. <i>However</i>, <code>unsafeInterleaveIO</code> does <i>not</i> conjure a new state token out of thin air. Instead, it takes the state token from the current <code>IO</code> context. This means that, when you create a thunk with <code>unsafeInterleaveIO</code>, you are guaranteed that it will only be evaluated after all previous <code>IO</code> actions are run. To do a similar rewrite of our <code>unsafeIntereleaveIO</code> example from above:</p><pre><code class="haskell">main s0 =
    case helper 1 s0 of
        (# s1, one #) -&gt;
            case helper 2 s1 of
                (# _ignored, two #) -&gt;
                    print (one + two) s1</code></pre><p>As you can see, it would no longer be legal to swap around the case expressions, since <code>helper 2 s1</code> depends on the result of <code>helper 1 s0</code>.</p><p>One final note about <code>unsafeInterleaveIO</code>: while it <i>does</i> force evaluation to occur after previous <code>IO</code> actions, it says nothing about actions that come later. To drive that home, the ordering in the following example is undefined:</p><pre><code class="haskell active">import System.IO.Unsafe

helper i = print i &gt;&gt; return i

main = do
    one &lt;- unsafeInterleaveIO $ helper 1
    two &lt;- unsafeInterleaveIO $ helper 2
    print $ one + two</code></pre><p>I encourage you to do a similar rewriting to case expressions as I did above to prove to yourself that either 1 or 2 may be printed first.</p><h2 id="unsafeperformio--unsafedupableperformio--inlineperformio--aka-he-who-shall-not-be-named-"><a href="#unsafeperformio--unsafedupableperformio--inlineperformio--aka-he-who-shall-not-be-named-">unsafePerformIO, unsafeDupablePerformIO, inlinePerformIO (aka he-who-shall-not-be-named)</a></h2><p>To sum up: we now understand the difference between <code>unsafePerformIO</code> and <code>unsafeInterleaveIO</code>, the difference between <code>seq</code> and <code>pseq</code>, how state tokens force evaluation order, and the difference between running <code>IO</code> actions safely and evaluating unsafe thunks. There's one question left: why are there three different functions with the type signatures <code>IO a -&gt; a</code>, namely: <code>unsafePerformIO</code>, <code>unsafeDupablePerformIO</code>, and <code>inlinePerformIO</code> (provided by <code>Data.ByteString.Internal</code>, also known as <a href="http://hackage.haskell.org/package/primitive-0.5.3.0/docs/Control-Monad-Primitive.html#v:unsafeInlineIO"><code>unsafeInlineIO</code></a>, also known as <a href="http://www.reddit.com/r/haskell/comments/2cbgpz/flee_traveller_flee_or_you_will_be_corrupted_and/"><code>accursedUnutterablePerformIO</code></a>).</p><p>What we were looking at previously is actually the implementation of <code>inlinePerformIO</code>, or to provide the <a href="https://github.com/haskell/bytestring/blob/a562ab285eb8e9ffd51de104f88389ac125aa833/Data/ByteString/Internal.hs#L624">actual code from bytestring</a>:</p><pre><code class="haskell">{-# INLINE accursedUnutterablePerformIO #-}
accursedUnutterablePerformIO :: IO a -&gt; a
accursedUnutterablePerformIO (IO m) = case m realWorld# of (# _, r #) -&gt; r</code></pre><p>This looks straightforward, so why wouldn't we want to just use this in all cases? Let's consider a usage of this:</p><pre><code class="haskell active">import Data.ByteString.Internal (inlinePerformIO)
import qualified Data.Vector as V
import qualified Data.Vector.Mutable as VM

vectorA = inlinePerformIO $ do
    mv &lt;- VM.new 1
    VM.write mv 0 'A'
    V.unsafeFreeze mv

vectorB = inlinePerformIO $ do
    mv &lt;- VM.new 1
    VM.write mv 0 'B'
    V.unsafeFreeze mv

main = do
    print vectorA
    print vectorB</code></pre><p>When evaluating the <code>vectorA</code> thunk, we want to:</p><ol><li>Create a new mutable vector.</li><li>Write 'A' into the first element of the vector.</li><li>Freeze the vector.</li></ol><p>We then do the same thing with <code>vectorB</code>, writing 'B' instead. The goal should be getting two separate, immutable vectors, one containing &quot;A&quot;, the other &quot;B&quot;.</p><p>However, this may not be the case! In particular, both <code>vectorA</code> and <code>vectorB</code> start off with a call to <code>VM.new 1</code>. If we expand this using our <code>inlinePerformIO</code> implementation, this looks something like:</p><pre><code class="haskell">vectorA =
    case VM.new 1 realWorld# of
        (# s1, mv #) -&gt;
            case VM.write mv 0 'A' s1 of
                (# s2, () #) -&gt;
                    case V.unsafeFreeze mv s2 of
                        (# _, v #) -&gt; v

vectorB =
    case VM.new 1 realWorld# of
        (# s1, mv #) -&gt;
            case VM.write mv 0 'B' s1 of
                (# s2, () #) -&gt;
                    case V.unsafeFreeze mv s2 of
                        (# _, v #) -&gt; v</code></pre><p>But notice how both <code>vectorA</code> and <code>vectorB</code> start in exactly the same way. It's valid to rewrite this code to use sharing:</p><pre><code class="haskell">(# s1, mv #) = VM.new 1 realWorld#

vectorA =
    case VM.write mv 0 'A' s1 of
        (# s2, () #) -&gt;
            case V.unsafeFreeze mv s2 of
                (# _, v #) -&gt; v

vectorB =
    case VM.write mv 0 'B' s1 of
        (# s2, () #) -&gt;
            case V.unsafeFreeze mv s2 of
                (# _, v #) -&gt; v</code></pre><p>Do you see the problem with this? <b>Both vectors will point to the same block of memory!</b> This means that we'll first write 'A' into the vector, then overwrite that with 'B', and end up with &quot;two vectors&quot; both containing the same values. That's clearly not what we wanted!</p><p>The answer to this is to avoid the possibility of sharing. And to do that, we use <a href="http://hackage.haskell.org/package/ghc-prim-0.3.1.0/docs/GHC-Magic.html#v:lazy">magic, aka lazy</a>, and pragmas. To wit, the implementation of <code>unsafeDupablePerformIO</code> is:</p><pre><code class="haskell">{-# NOINLINE unsafeDupablePerformIO #-}
unsafeDupablePerformIO  :: IO a -&gt; a
unsafeDupablePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -&gt; r)</code></pre><p>This has two changes from <code>inlinePerformIO</code>:</p><ul><li>The <code>NOINLINE</code> pragma ensures that the expression is never inlined, which stops any sharing.</li><li><code>lazy</code> prevents premature evaluation of the action. (<i>NB: I'm actually not completely certain of what <code>lazy</code> is ensuring here.</i>)</li></ul><p>We can now safely allocate memory inside <code>unsafeDupablePerformIO</code>, and now that allocated memory won't be shared among other calls. But we pay a small performance cost by avoiding the inlining.</p><p>So what's the downside of this function? Pretty simple, actually: if you have two threads which evaluate a thunk at the same time, they may both start performing the action. And when the first thread completes the action, it may terminate the execution of the other thread. In other words, with:</p><pre><code class="haskell active">import System.IO.Unsafe
import Control.Concurrent

thunk :: ()
thunk = unsafeDupablePerformIO $ do
    putStrLn &quot;starting thunk&quot;
    threadDelay 1000000
    putStrLn &quot;finished thunk&quot;

main :: IO ()
main = do
    forkIO $ print thunk
    threadDelay 500000
    print thunk
    threadDelay 1000000</code></pre><p>&quot;starting thunk&quot; may be printed multiple times, and &quot;finished thunk&quot; may be printed less times than &quot;starting thunk&quot;. This can't even be worked around by using something like <code>bracket</code>, since in this situation, the second thread doesn't receive an exception, it simply stops executing. The two upshots of this are:</p><ul><li>If you need to ensure that an action is only run once, this is problematic.</li><li>If you need to guarantee some kind of resource cleanup, this is problematic.</li></ul><p>Which leads us to our final function: <code>unsafePerformIO</code>. It has an implementation of:</p><pre><code class="haskell">unsafePerformIO :: IO a -&gt; a
unsafePerformIO m = unsafeDupablePerformIO (noDuplicate &gt;&gt; m)</code></pre><p>This uses some GHC internal magic to ensure that the action is only run by a single thread, fixing our two problems above. As you might guess, this <i>also</i> introduces a small performance cost, which is the motivation to avoidng it in favor of <code>unsafeDupablePerformIO</code> or <code>inlinePerformIO</code>.</p><h2 id="guidelines-on-using-each-function"><a href="#guidelines-on-using-each-function">Guidelines on using each function</a></h2><p>Note that the guidelines below are cummulative: the requirements for using <code>unsafeInterleaveIO</code>, for example, apply to the other three functions as well.</p><ul><li>Whenever possible, avoid using unsafe functions.</li><li>If you're certain that it's safe to perform the action only on evaluation, use <code>unsafeInterleaveIO</code>. You need to ensure that you don't mind which order the effects are performed in, relative to both the main I/O monad and other calls to <code>unsafePerformIO</code>.</li><li>If you aren't in the <code>IO</code> monad at all, or it's acceptable if the action is performed before other <code>IO</code> actions, use <code>unsafePerformIO</code>.</li><li>If you need extra speed, and it's acceptable for the action to be performed multiple times, and it's acceptable if this action is canceled halfway through its execution, use <code>unsafeDupablePerformIO</code>. Another way of saying this is that the action should be idempotent, and require no cleanup.</li><li>If you need even extra speed, you're performing no actions that would be problematic if shared (e.g., memory allocation), and you're OK with the fact that your code is very likely broken, use <code>inlinePerformIO</code>. Seriously, be very, very, very careful.<ul><li>Another guideline is to never perform writes inside <code>inlinePerformIO</code>. However, I believe that this is not actually strictly necessary, but instead a result of <a href="https://ghc.haskell.org/trac/ghc/ticket/9390">a long-standing GHC bug</a>, which should be fixed since GHC 7.8.4. Incidentally, that issue was the impetus for the writing of this document.</li></ul></li></ul><h2 id="interaction-with-stm"><a href="#interaction-with-stm">Interaction with STM</a></h2><p>A related issue to point out is how <code>unsafePerformIO</code> interact with <code>STM</code>. Since <code>STM</code> transactions can be retried multiple times, an <code>unsafePerformIO</code> action may be run multiple times as well. In that sense, you should treat such calls similarly to how you would normally treat <code>unsafeDupablePerformIO</code>.</p><p>However, there's a long-standing runtime system bug where aborted STM transactions do not result in any exceptions being thrown, which leads to a similar behavior of missing cleanup actions as we have with <code>inlinePerformIO</code>. For more information, see:</p><ul><li><a href="http://www.haskell.org/pipermail/haskell-cafe/2014-February/112555.html">http://www.haskell.org/pipermail/haskell-cafe/2014-February/112555.html</a></li><li><a href="https://ghc.haskell.org/trac/ghc/ticket/2401">https://ghc.haskell.org/trac/ghc/ticket/2401</a></li></ul></article>

<div id="disqus_thread"><script>var disqus_shortname = "snoyberg-soh"; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })();</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com/">comments powered by <span class="logo-disqus">Disqus</span></a></a>
</div>

</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
<li><a href="https://www.schoolofhaskell.com/auth/login">Log In</a>
</li>
<li><a href="https://www.schoolofhaskell.com/auth/page/email/register">Sign Up</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="https://www.schoolofhaskell.com/static/bootstrap/css/bootstrap-responsive.css" />
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/cKRLBd-P.js"></script><script>window.fpco = window.fpco || {};
window.fpco.keyMap = "";

        function hident2() {
            if (navigator.id) {
                navigator.id.watch({
                    onlogin: function (assertion) {
                        if (assertion) {
                            document.location = "https://www.schoolofhaskell.com/auth/page/browserid/" + assertion;
                        }
                    },
                    onlogout: function () {}
                });
                navigator.id.request({
                    returnTo: "/auth/login" + "?autologin=true"
                });
            }
            else {
                alert("Loading, please try again");
            }
        }
    
        (function(){
            var bid = document.createElement("script");
            bid.async = true;
            bid.src = "https://login.persona.org/include.js";
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(bid, s);
        })();
    $(function(){
    var url = "https://www.schoolofhaskell.com/like-content/33183";
    var $self = $("#hident3");
    $.getJSON(url, function(state){
        var $a, $likeCount;

        $a = $('<a class="likes" href="/auth/login"></a>');
        $likeCount = $('<span class="like-count"></span>');
        $thumbs = $("<i class='icon-thumbs-up' title='Unlike this :-('>");
        $a.append($likeCount);
        $a.append($thumbs);
        $self.append($a);

        updateView();

        $a.click(function(){
            if(state.myLike == 'not-logged-in') {
                return true;
            } else {
                var $a = $(this);
                $.post(url, state.myLike !== 'no-like' ? {unlike:true} : {}, function(data){
                    state.myLike = state.myLike == 'no-like'? 'like' : 'no-like';
                    state.likes = data.likes;
                    updateView();
                });
                return false;
            }
        });

        function updateView(){
            var liked = state.myLike !== 'not-logged-in' && state.myLike !== 'no-like';
            if(liked) $a.addClass('likes-liked');
            else $a.removeClass('likes-liked');

            $likeCount.text(state.likes);

            if(state.myLike !== 'not-logged-in') {
                if (liked) $thumbs.attr('title','Unlike this');
                else $thumbs.attr('title','Like this!');

                if (liked) $a.addClass('likes-liked');
                else $a.removeClass('likes-liked');
            } else {
                $a.addClass('like-not-logged-in');
                $thumbs.attr('title','Please login to vote!');
            }
        }
    });
});
$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/user/snoyberg/general-haskell/advanced/evaluation-order-and-state-tokens';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body>
<!-- Mirrored from www.schoolofhaskell.com/user/snoyberg/general-haskell/advanced/evaluation-order-and-state-tokens by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 31 Dec 2016 04:40:10 GMT -->
</html>