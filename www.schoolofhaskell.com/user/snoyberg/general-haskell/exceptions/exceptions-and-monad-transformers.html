<!DOCTYPE html>
<html>
<!-- Mirrored from www.schoolofhaskell.com/user/snoyberg/general-haskell/exceptions/exceptions-and-monad-transformers by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 26 Dec 2016 20:53:54 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head><title>Exceptions and monad transformers - School of Haskell | School of Haskell</title><meta http-equiv="x-ua-compatible" content="IE=9"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="Rfxk2TdeMMXEXHgJ2_OO8Rt3hPbQSDao0OXQV_n6z_s" /><link href="http://fonts.googleapis.com/css?family=Merriweather" rel="stylesheet" type="text/css"><link href="https://www.schoolofhaskell.com/recent-content/feed" type="application/rss+xml" rel="alternate" title="Recently published content">
<link rel="stylesheet" href="https://www.schoolofhaskell.com/static/combined/UlwEHVcM.css"><style>#hident3 .like-count{margin-right:0.5em}#hident3 .likes{font-family:merriweather;float:right;margin-bottom:1em;border:1px solid #eee;font-size:1.1em;padding:0.25em;border-radius:0.25em;display:inline-block;text-align:center;color:#468847;background-color:#dff0d8;border-color:#d6e9c6}#hident3 .likes:hover{text-decoration:none;cursor:pointer}#hident3 .likes-liked i{opacity:0.25}#hident3 .likes-liked .like-count{font-weight:bold }#hident3 .like-not-logged-in *{cursor:default}.social{margin-right:1em}h1{font-family:Merriweather !important}article{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}h1,h2,h3,h4,h4,h5{font-family:Merriweather !important}.editor p{font-family:Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif}.article-footer{border-top:1px solid #ddd;padding-top:1em;margin-top:1em}body{font-size:16px !important}.navbar .navbar-inner{background:#3c3f41}.navbar .brand{font-size:14px}.navbar .brand img{width:6em}.navbar .icon-wrench{margin:0 -0.5em 0 -0.5em;padding:0 1em 0 1em;height:20px}.navbar-inverse .nav .active a{background:#333638}.navbar-inverse .nav > li > a{color:#a7a7a7
}.navbar-inverse .btn-navbar{background:#333638}.navbar-inverse .nav > li a:hover,.navbar-inverse .btn{background:#333537 !important}@media (max-width: 979px) {.icon-wrench{padding-left:1em !important}}.breadcrumb{border-top-left-radius:0;border-top-right-radius:0}h1{margin-top:20px}.breadcrumb-container + .main-content h1{margin-top:0}.footer{padding:30px 0;margin-top:70px;border-top:1px solid #e5e5e5;background-color:#f5f5f5}.footer ul.footer-menu{list-style-type:none}.footer ul.footer-menu li{display:inline-block}.footer ul.footer-menu li + li{margin-left:0.5em}.footer ul.footer-menu li + li:before{margin-right:0.5em;content:"Â·";color:#999}.footer ul.menu li{display:inline-block}.footer ul.menu li + li{margin-left:0.5em}.footer .copyright{margin-left:25px}.main-content{min-height:100%}.gravatar{width:80px;height:80px;border-radius:2px;background:#eee}.empty-gravatar{width:0}.container{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}.container h1,.container h2,.container h4,.container h4,.container h5{font-family:"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif}article{font-family:Merriweather !important}article h1{font-family:Merriweather !important}article li{font-family:Merriweather !important;line-height:1.6em}article li + li{margin-top:0.5em}article div.code{background:#f9f9f9;border:1px solid #d1d1d1;position:relative;border-radius:0.2em;margin:0.25em 0 0.75em 0;min-height:2.5em}article code{color:#005580;font-size:14px;white-space:pre}article a.hoogle > code{color:#0088cc;font-size:14px;white-space:pre;border:0}article .expand-code{display:none}article pre{overflow:auto;word-wrap:normal}article code.active{display:block;max-height:430px}article h1{font-size:31.5px}article h3{font-size:17.5px}article h4{font-size:14px}article h5,article h6{font-size:11.9px}article p{line-height:1.7em}article h1 code,article h2 code,article h3 code,article h4 code,article h5 code,article h6 code{font-size:inherit !important}article h1 a,article h2 a,article h3 a,article h4 a,article h5 a,article h6 a{color:#444}article h1 a:before,article h2 a:before,article h3 a:before,article h4 a:before,article h5 a:before,article h6 a:before{margin-left:-1.5em;padding-right:0.5em;font-family:fontawesome;content:"\f0c1";font-size:20px;color:#fff}article h1 a:hover,article h2 a:hover,article h3 a:hover,article h4 a:hover,article h5 a:hover,article h6 a:hover{text-decoration:none;color:#0088cc}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#888}article h2{font-size:24.5px}article .popover{font-family:actor}article .popover h3.popover-title{font-family:actor !important;font-size:1em}article .popover .popover-content{width:15em;font-size:1em}article .controlsRun{display:block;padding:0.5em;text-align:right;background:#f2f2f2}article .controlsRun a.clone{margin-right:1em;font-family:actor;text-decoration:none}article .controlsRun a.clone span{padding-left:0.5em}article .controlsRun a.run,article .controlsRun a.reset,article .controlsRun a.show-code{font-size:16px}article .controlsRun a.run span,article .controlsRun a.reset span,article .controlsRun a.show-code span{display:none}article .controlsRun a.reset{margin-left:0.5em;color:#a2becc}article .controlsRun a.reset{display:none}article .controlsRun a.show-code{margin-right:0.75em}article .controlsRun a.run:hover,article .controlsRun a.show-code:hover{text-decoration:none}article .controlsRun a.show-code.active{color:#DC0D0D}article .controlsRun a[disabled]{color:#a2becc;cursor:default}article .collapse-area .collapse-header{background:#0088cc;color:#fff;padding:0.3em;cursor:pointer}article .collapse-area .hidden-toggle:before{content:"\f0d7";font-family:fontawesome;margin-right:0.5em;margin-left:0.25em}article .collapse-area .collapsed-files{overflow:auto;height:auto}article .collapse-area.collapse-disabled{display:none}article .collapse-area.collapse-area-off .collapsed-files{height:0px;overflow:hidden}article .collapse-area.collapse-area-off .hidden-toggle:before{content:"\f0da"}article .snippet-stdio .stdout{margin:0.5em;padding-right:2em;position:relative;word-wrap:break-word}article .snippet-stdio .stdin{-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none;padding:0;margin:0}article .hoogle-results{margin:0.25em}article .hoogle-results .hoogle-inner{background:#fff;padding:0.5em;border-radius:3px;border:1px solid #ddd}article .hoogle-results .hoogle-inner .close-link{position:relative;float:right;margin-top:-0.5em;margin-right:-0.5em}article .snippet-output-errors{margin:1em 0.5em 0.5em 0.5em;position:relative}article .snippet-output-errors ul{list-style-type:none;margin:0;position:relative}article .snippet-output-errors pre{border:0;border-radius:0;padding:0.25em;margin:0;background:inherit;color:inherit}article .snippet-output-errors .close-link{color:inherit;background:inherit}article .snippet-editors{z-index:0;padding:0.25em}article .close-link{padding:0.5em;background:#eaeaea;border-bottom-left-radius:0.2em;border-top-right-radius:0.2em;position:absolute;top:0;right:0}article .close-link:hover{text-decoration:none}article .snippet-title{padding:0.5em 0 0 0.5em}article .snippet-title .snippet-icon{font-family:FontAwesome;display:inline-block;margin-right:0.5em}article .fullModuleCode + div .snippet-title{margin-top:0.5em;border-top:1px solid #ccc;padding-top:0.5em}article .CodeMirror{height:auto;min-height:1em;line-height:1.5em;background:transparent;font-size:14px !important}article .CodeMirror .highlighted{background:rgba(250, 210, 0, 0.45) !important}article .CodeMirror-widget{margin-left:2em;line-height:1.8}article .CodeMirror.collapsed{height:10em !important}article .editor .expander{text-align:center;display:block;padding:0.5em;text-decoration:none;border-bottom-left-radius:2px;border-bottom-right-radius:2px}article .editor .expander .ellipsis{background:white;border:1px solid #ccc;padding:0 0.5em;height:1em;line-height:0.5em;display:inline-block;color:#555;cursor:pointer}article .editor .expander .ellipsis:hover{background:#ddd;color:#333}article .web-runner{margin:0.5em;padding:0.5em;border:1px solid #ccc;border-radius:3px;background:#f5f5f5}article .web-runner iframe{border:0;margin-top:0.5em;margin-bottom:0;background:white}article .web-runner .controls i{cursor:pointer;color:#0088cc}article .web-runner .controls i:hover{color:#222}article .web-runner .controls i + i{margin-left:0.5em}article .web-runner .controls .icon-remove{float:right}article .hidden{display:block;visibility:visible}article .controlsShowHide{margin-bottom:0.5em}.tutorial-body{float:left !important}.tutorial-nav{float:right !important}@media (max-width: 979px) {.related-content{float:right}.author-name{display:block;margin-left:20px !important;padding-left:5px;margin-top:5px}article h1 a:hover:before,article h2 a:hover:before,article h3 a:hover:before,article h4 a:hover:before,article h5 a:hover:before,article h6 a:hover:before{color:#fff}.tutorial-nav{float:none !important;width:auto !important}.tutorial-body{float:none !important;width:auto !important}}@media (min-width: 980px) and (max-width: 1199px) {.navbar-search{display:none}.tutorial-nav{width:200px}.tutorial-body{width:720px}}#accountPage h1{margin:20px 0 0 0}#accountPage h2{font-size:20px}.group-contents .span8{float:left}.group-contents .span4{float:right}.container > .alert-block{margin-top:1em}.alert{color:#aa874a
}.social{margin-bottom:.8em;display:block}.social a{text-decoration:none}.social i{font-size:1.1em;color:#fff;padding:0.25em;border-radius:0.25em;width:1em;display:inline-block;text-align:center}.social i.icon-twitter{background:#0088cc}.social i.icon-facebook{background:#3b5998
  }.social i.icon-google-plus{background:#dd4b39
  }.well pre{background:#fcfcfc}.well h2{margin-top:0}code{color:#005580;font-size:14px;white-space:pre}</style><!--[if lt IE 8]><link rel="stylesheet" href="https://www.schoolofhaskell.com/static/design/css/ie7.css?etag=TSMl9x1V"><![endif]--><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--></head><body class="not-logged-in" itemscope itemtype="http://schema.org/Product"><noscript><iframe src="http://www.googletagmanager.com/ns.html?id=GTM-H62P" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='http://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-H62P');</script><div class="navbar navbar-inverse navbar-static-top"><div class="navbar-inner"><div class="container"><a class="btn btn-navbar" type="button" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="https://www.schoolofhaskell.com/"><img src="https://www.schoolofhaskell.com/static/img/ide-logo.png" title="School of Haskell">
</a>
<div class="nav-collapse collapse"><ul class="nav"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
</ul>
<form class="navbar-search pull-left" action="https://www.schoolofhaskell.com/search"><input class="search-query" type="text" placeholder="Search" name="search">
</form>
<ul class="nav pull-right"><li><a href="https://www.schoolofhaskell.com/auth/login">Login</a>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="container breadcrumb-container"><div class="row"><div class="span12"><ul class="breadcrumb"><li><a href="https://www.schoolofhaskell.com/user/snoyberg">Michael Snoyman</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/snoyberg/general-haskell">General Haskell</a>
<span class="divider">/</span>
</li>
<li><a href="https://www.schoolofhaskell.com/user/snoyberg/general-haskell/exceptions">Exceptions</a>
<span class="divider">/</span>
</li>
<li><a href="exceptions-and-monad-transformers.html">Exceptions and monad transformers</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container main-content"><div class="row"><div class="span12"><p class="alert">Interactive code snippets not yet available for SoH 2.0, see our <a href=https://www.fpcomplete.com/blog/2016/01/soh-status>Status of
 of School of Haskell 2.0 blog post</a></p>
</div>
</div>
<div class="row"><div class="span12"><h1 itemprop="name">Exceptions and monad transformers</h1>
</div>
</div>
<div class="row"><div class="span7 meta"><p><span class="date">22 Aug 2013</span>
<span class="author"><a href="https://www.schoolofhaskell.com/user/snoyberg">Michael Snoyman</a>
</span>
<span class="view-edit-link pull-right"><a class="view-source-link" href="https://www.schoolofhaskell.com/tutorial-raw/1/be7ad2eb9c43ecd292d75315a142396adc6e6452">View Markdown source</a>
</span>
</p>
<p class="tags"></p>
</div>
</div>
<div class="row"><div class="span7 meta"><div id="hident3"></div>

<span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
<div class="row" itemprop="desc"><div class="span4 tutorial-nav"><div class="related-content"><ul class="nav nav-tabs nav-stacked"><li><script>reddit_target='fpcomplete'</script>
<script src="https://redditstatic.s3.amazonaws.com/button/button1.js"></script>
</li>
<li><a href="catching-all-exceptions.html">Next content: Catching all exceptions</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/snoyberg/general-haskell/exceptions">Go up to: Exceptions</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user/snoyberg">See all content by Michael Snoyman</a>
</li>
</ul>

</div>
<div class="aside"><h3>Sections</h3>
<ul><li><a href="#the-simple-case--the-readert-transformer">The simple case: the ReaderT transformer</a></li><li><a href="#first-complication--mutable-state">First complication: mutable state</a></li><li><a href="#second-complication--alternative-exit-paths">Second complication: alternative exit paths</a></li><li><a href="#monad-control">monad-control</a></li><li><a href="#more-intuitive-mutable-state">More intuitive mutable state</a></li></ul></div>
</div>
<div class="span8 tutorial-body" data-environment="ghc-7.8-stable-14.09">
<article><p>John Wiegley and I are currently working- together with some members of the community- on various exception handling related code. As part of this work, we're also going to be publishing a number of tutorials on this topic. Eventually, we'll collect all of this information together into a more cohesive whole, but for now we wanted to get the content out there to the community as we produce it.</p><hr /><p>Love them or hate them, runtime exceptions are a reality of writing Haskell code. Consider the following fake code:</p><pre><code class="haskell">myFunc = do
    resource &lt;- acquireScarceResource
    useResource resource
    releaseResource resource</code></pre><p>In a world without exceptions, this seems completely reasonable. However, what happens if the call to <code>useResource</code> throws a runtime exception? In such a case, <code>releaseResource</code> would never be called, and our scarce resource would never be released. In concurrent code dealing with mutexes, such a bug could lead to a deadlock.</p><p>The solution to this problem is well known: use the <a class="hoogle" href="https://www.stackage.org/lts/hoogle?q=bracket&amp;results=1" title="Hoogle search for: bracket"><code>bracket</code></a> function. Then our above example reduces to <code>myFunc = bracket acquireScarceResource releaseResource useResource</code>. We're now safe from any exception thrown by <code>useResource</code>, and even from asynchronous exceptions (a topic I'll try to avoid in this post).</p><p>But let's analyze the type signature of <code>bracket</code>:</p><pre><code>bracket :: IO a -&gt; (a -&gt; IO b) -&gt; (a -&gt; IO c) -&gt; IO c</code></pre><p>How do we use such a function in monad transformer stack, where the functions we pass in won't live in the <code>IO</code> monad itself?</p><p>Note that for the rest of this tutorial, I'm going to talk about the <a class="hoogle" href="https://www.stackage.org/lts/hoogle?q=finally&amp;results=1" title="Hoogle search for: finally"><code>finally</code></a> function instead of <code>bracket</code>, which is really just a simplified version of the latter. The reasoning used will apply to not only <code>bracket</code>, but also to many other functions in <a class="hoogle" href="https://www.stackage.org/lts/hoogle?q=Control.Exception&amp;results=1" title="Hoogle search for: Control.Exception"><code>Control.Exception</code></a>. Its signature is <code>IO a -&gt; IO b -&gt; IO a</code>, and its purpose is to ensure that the second function is called regardless of what exceptions are thrown by the first (or any asynchronous exceptions... sorry for bringing those up again).</p><h2 id="the-simple-case--the-readert-transformer"><a href="#the-simple-case--the-readert-transformer">The simple case: the ReaderT transformer</a></h2><p>Let's forget about any kind of grand solution. Instead, let's take one of the simplest monad transformers that exists, <code>ReaderT</code>, and see how we can write a <code>finally</code> that works with it. Since a <code>ReaderT</code> simply passes in some environment to all actions, this turns out to be really easy:</p><pre><code class="haskell active">import Control.Monad.Reader
import Control.Exception (finally, try, ErrorCall)

finallyReaderT :: ReaderT r IO a -&gt; ReaderT r IO b -&gt; ReaderT r IO a
finallyReaderT a sequel = do
    r &lt;- ask
    liftIO $ runReaderT a r `finally` runReaderT sequel r

main :: IO ()
main = do
    res &lt;- try $ runReaderT
        (step1 `finallyReaderT` step2)
        &quot;This is the environment&quot;
    print (res :: Either ErrorCall ())
  where
    step1 = do
        r &lt;- ask
        liftIO $ putStrLn $ &quot;In step1, r == &quot; ++ show r
        error &quot;Erroring out, bye!&quot;
    step2 = do
        r &lt;- ask
        liftIO $ putStrLn $ &quot;In step2, r == &quot; ++ show r</code></pre><p>That turns out to be pretty simple. And by reusing the existing <code>finally</code> function, we can feel comfortable knowing that our implementation is correct (or at least as correct as <code>finally</code> itself).</p><h2 id="first-complication--mutable-state"><a href="#first-complication--mutable-state">First complication: mutable state</a></h2><p>But <code>ReaderT</code> is a really simple case to support, since it's just a read-only environment. Let's up the ante a bit, and try using <code>StateT</code> instead. We'll now need to deal with threading the mutable state variable through. Before jumping into the code, let's consider abstractly how would could achieve this threading. We have two possible cases: an exception is thrown before calling the cleanup function, or an exception is not thrown. If no exception is thrown, then we can extract the state value from the result of the first function call, pass that to the cleanup function, and then return the final state value as the new mutable state.</p><p>But if an exception is thrown, there won't be a chance to extract the updated state value from the first function. In that case, we'll only have the initial state value available to pass through to the cleanup function. (The new result state is irrelevant, since the exception is going to be rethrown anyway.) As described until now, let's see what this kind of <code>finally</code> implementation may look like.</p><pre><code class="haskell active">import Prelude hiding (catch)
import Control.Monad.State
import Control.Exception

finallyStateT :: StateT s IO a -&gt; StateT s IO b -&gt; StateT s IO a
finallyStateT a sequel = do
    s1 &lt;- get
    (result, s2) &lt;- liftIO $ runStateT a s1 `catch` \e -&gt; do
        _ignored &lt;- runStateT sequel s1
        throwIO (e :: SomeException)
    (_ignored, s3) &lt;- liftIO $ runStateT sequel s2
    put s3
    return result

main :: IO ()
main = do
    res &lt;- try $ runStateT
        (step1 `finallyStateT` step2)
        1
    print (res :: Either ErrorCall ((), Int))
  where
    step1 = do
        s &lt;- get
        liftIO $ putStrLn $ &quot;In step1, s == &quot; ++ show s
        put $ s + 1
        error &quot;Erroring out, bye!&quot; -- Try commenting me out
    step2 = do
        s &lt;- get
        liftIO $ putStrLn $ &quot;In step2, s == &quot; ++ show s
        put $ s + 1</code></pre><p>This seems to work, but there are a two problems:</p><ul><li>We were not able to reuse the standard <code>finally</code> function to implement this, since it wouldn't allow us to manually thread state. Practically, that means our implementation is susceptible to asynchronous exceptions (argh... those came up again).</li><li>The behavior is pretty inconsistent. In one case, we use the original mutable state value and ignore the updated state from the cleanup function. In the other, we use the updated state value from the first function and keep the updated mutable state.</li></ul><p>So let's instead try out a different approach. Regardless of whether an exception is thrown or not, we'll call the cleanup function using the original mutable state, and always ignore the state produced by the cleanup function.</p><pre><code class="haskell active">import Control.Monad.State
import Control.Exception

finallyStateT :: StateT s IO a -&gt; StateT s IO b -&gt; StateT s IO a
finallyStateT a sequel = do
    s1 &lt;- get
    (result, s2) &lt;- liftIO $ runStateT a s1 `finally`
                             runStateT sequel s1
    put s2
    return result

main :: IO ()
main = do
    res &lt;- try $ runStateT
        (step1 `finallyStateT` step2)
        1
    print (res :: Either ErrorCall ((), Int))
  where
    step1 = do
        s &lt;- get
        liftIO $ putStrLn $ &quot;In step1, s == &quot; ++ show s
        put $ s + 1
        error &quot;Erroring out, bye!&quot; -- Try commenting me out
    step2 = do
        s &lt;- get
        liftIO $ putStrLn $ &quot;In step2, s == &quot; ++ show s
        put $ s + 1</code></pre><p>This solves my two complaints from before, but unfortunately introduces a new one: the behavior is not really intuitive in the non-exception case. Nonetheless, in my opinion, this is the right way to implement things due to the consistency. We'll cover a method to get back the more intuitive semantics towards the end of this post.</p><h2 id="second-complication--alternative-exit-paths"><a href="#second-complication--alternative-exit-paths">Second complication: alternative exit paths</a></h2><p>The previous section essentially provided two approaches to writing a transformer-based <code>finally</code>: base it off of primitives like <code>catch</code>, or reuse <code>finally</code>. It turns out that both of these approaches have quite a bit of prior art. In the first case, there are the <code>MonadCatchIO-mtl</code> and <code>MonadCatchIO-transformers</code> packages, as well as the more recent <code>exceptions</code> package. These all define a typeclass for the primitive operations of <code>catch</code>ing and masking asynchronous exceptions (we just can't escape those, can we?).</p><p>Let's extract the <code>catch</code> logic from our first <code>StateT</code> example above to demonstrate the technique:</p><pre><code class="haskell active">import Prelude hiding (catch)
import Control.Monad.State
import Control.Exception

-- show
catchStateT :: Exception e
            =&gt; StateT s IO a
            -&gt; (e -&gt; StateT s IO a)
            -&gt; StateT s IO a
catchStateT a onE = do
    s1 &lt;- get
    (result, s2) &lt;- liftIO $ runStateT a s1 `catch` \e -&gt;
        runStateT (onE e) s1
    put s2
    return result

finallyStateT :: StateT s IO a -&gt; StateT s IO b -&gt; StateT s IO a
finallyStateT a sequel = do
    result &lt;- a `catchStateT` \e -&gt; do
        _ignored &lt;- sequel
        liftIO $ throwIO (e :: SomeException)
    _ignored &lt;- sequel
    return result
-- /show

main :: IO ()
main = do
    res &lt;- try $ runStateT
        (step1 `finallyStateT` step2)
        1
    print (res :: Either ErrorCall ((), Int))
  where
    step1 = do
        s &lt;- get
        liftIO $ putStrLn $ &quot;In step1, s == &quot; ++ show s
        put $ s + 1
        error &quot;Erroring out, bye!&quot; -- Try commenting me out
    step2 = do
        s &lt;- get
        liftIO $ putStrLn $ &quot;In step2, s == &quot; ++ show s
        put $ s + 1</code></pre><p>That's certainly a bit prettier than what we had before (though it's still not async-exception safe). And what's really nice is that this definition of <code>finallyStateT</code> doesn't actually have anything <code>StateT</code>-specific about it. So presuming we had a <code>catch</code> function for some other transformer, we could reuse the same definition. Let's try this out for <code>ErrorT</code>.</p><pre><code class="haskell active">import Prelude hiding (catch)
import Control.Monad.Error
import Control.Exception

catchErrorT :: (Exception e, Error s)
            =&gt; ErrorT s IO a
            -&gt; (e -&gt; ErrorT s IO a)
            -&gt; ErrorT s IO a
catchErrorT a onE = do
    eresult &lt;- liftIO $ runErrorT a `catch` \e -&gt;
        runErrorT (onE e)
    either throwError return eresult

finallyErrorT :: Error s =&gt; ErrorT s IO a -&gt; ErrorT s IO b -&gt; ErrorT s IO a
finallyErrorT a sequel = do
    result &lt;- a `catchErrorT` \e -&gt; do
        _ignored &lt;- sequel
        liftIO $ throwIO (e :: SomeException)
    _ignored &lt;- sequel
    return result

main :: IO ()
main = do
    res &lt;- try $ runErrorT
        (step1 `finallyErrorT` step2)
    print (res :: Either ErrorCall (Either String ()))
  where
    step1 = do
        liftIO $ putStrLn $ &quot;In step1&quot;
        throwError &quot;This should be interesting&quot;
    step2 = liftIO $ putStrLn $ &quot;In step2&quot;</code></pre><p>Go ahead and run that code snippet. Do you notice something not there to be noticed? That's right, the cleanup function is never called! Here we have a function called <code>finally</code> which, despite its name, doesn't actually call the cleanup function when it finally exits. What gives?</p><p>The issue is that, with an <code>ErrorT s IO</code> stack, there are <b>three</b> ways to exit the function: normally, with a runtime exception, or with a <code>throwError</code> result. In <code>finallyErrorT</code>, the call to <code>catchErrorT</code> accounts for the runtime exception case, and the following call to <code>sequel</code> accounts for the normal exit case. But there's no way to account for the <code>throwError</code> case without adding <code>ErrorT</code>-specific logic to <code>finally</code> (we'll do that in a moment).</p><p>You can try this example out with <code>MonadCatchIO-mtl</code> or <code>MonadCatchIO-transformers</code> and reproduce this buggy behavior. This affects both the <code>ErrorT</code> and <code>ContT</code> transformers. In the <code>exceptions</code> package, this also applies to the <code>CatchT</code> type. (John Wiegley discussed this issue with Edward, who described this as a documentation bug, since <code>CatchT</code> should not be used on top of <code>IO</code>.)</p><p>Doing this correctly is certainly possible, as you can see with the following example:</p><pre><code class="haskell active">import Control.Monad.Error
import Control.Exception

-- show
finallyErrorT :: Error s =&gt; ErrorT s IO a -&gt; ErrorT s IO b -&gt; ErrorT s IO a
finallyErrorT a sequel = do
    eresult &lt;- liftIO $ runErrorT a `finally` runErrorT sequel
    either throwError return eresult
-- /show

main :: IO ()
main = do
    res &lt;- try $ runErrorT
        (step1 `finallyErrorT` step2)
    print (res :: Either ErrorCall (Either String ()))
  where
    step1 = do
        liftIO $ putStrLn $ &quot;In step1&quot;
        throwError &quot;This should be interesting&quot;
    step2 = liftIO $ putStrLn $ &quot;In step2&quot;</code></pre><p>But this seems to imply that we would need to write a separate implementation of <code>finally</code> for each and every transformer, which would be tedious and error-prone. There must be a better way.</p><h2 id="monad-control"><a href="#monad-control">monad-control</a></h2><p>If you look at our various implementations so far, they all follow a similar pattern: embedding the state of the monad inside the value, running the underlying monadic action, and then rebuilding the monadic state from the result. This procedure can be done with many different transformers (basically, all common transformers except <code>ContT</code>). To capture this concept, we have the <code>MonadTransControl</code> and <code>MonadBaseControl</code> typeclasses in the <a href="https://www.fpcomplete.com/haddocks/monad-control"><code>monad-control</code></a> package.</p><p><code>monad-control</code> is frankly pretty complicated, and I'm not going to delve into all of its details here. Instead, I'll point you to the <a href="https://www.fpcomplete.com/haddocks/lifted-base"><code>lifted-base</code></a> package, which uses <code>monad-control</code> to create transformer-friendly versions of many common functions in <code>base</code>. As you'd expect based on this tutorial, exception handling functions are present, but also concurrency, timeouts, and mutable variables (which will become important in just a moment).</p><p><code>monad-control</code> is- as far as I know- the third attempt at a library to cover these concepts. Previous solutions were <code>monad-peel</code> and my own <a href="http://hackage.haskell.org/packages/archive/neither/0.1.0/doc/html/Control-Monad-Invert.html">MonadInvertIO</a>, part of earlier versions of <code>neither</code>. While in my opinion these other two approaches are easier to understand, <code>monad-control</code> is highly optimized, and therefore gets my recommendation as the go-to library for handling monad transformer stacks.</p><h2 id="more-intuitive-mutable-state"><a href="#more-intuitive-mutable-state">More intuitive mutable state</a></h2><p>We're left with one annoyance with the <code>monad-control</code>-based solution: we lose any mutations performed to our mutable state either before an exception is thrown, or in our cleanup functions. Is there some way to keep the elegance of <code>monad-control</code> but get back the more intuitive behavior? The answer is yes, but you may not like it.</p><p>When dealing with either <code>StateT</code> or <code>WriterT</code> transformers, the behavior which I would consider most intuitive would be that any mutations are immediately captured. Unfortunately, this can't be achieved at all using the standard <code>StateT</code> and <code>WriterT</code> implementations, since the monadic state is thrown away as soon as an exception is thrown.</p><p>In this case, my solution is to use a mutable variable- such as an <code>IORef</code>- and keep a reference to it in a <code>ReaderT</code>. As an example, this technique is used by the <a class="hoogle" href="https://www.stackage.org/lts/hoogle?q=HandlerT&amp;results=1" title="Hoogle search for: HandlerT"><code>HandlerT</code></a> transformer used in Yesod.</p><p>To demonstrate the concept, here's an implementation of the RWST monad transformer which uses <code>IORef</code>s for holding mutable state. For completeness, I'll include appropriate instances for <code>monad-control</code> and demonstrate usage of <code>lifted-base</code>.</p><pre><code class="haskell active">{-# OPTIONS_GHC -Wall -Werror #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE UndecidableInstances #-}
import Control.Monad.RWS.Class
import Control.Monad.Reader
import Control.Monad.Base
import Control.Applicative (Applicative)
import Data.IORef.Lifted
import Data.Monoid (Monoid, (&lt;&gt;), mempty)
import Control.Exception.Lifted
import Control.Monad.Trans.Control

data Env r w s = Env
    { envReader :: !r
    , envWriter :: !(IORef w)
    , envState  :: !(IORef s)
    }

newtype RWST r w s m a = RWST (ReaderT (Env r w s) m a)
    deriving (Functor, Applicative, Monad, MonadIO, MonadTrans)

instance Monad m =&gt; MonadReader r (RWST r w s m) where
    ask = RWST $ liftM envReader ask
    local f (RWST g) =
        RWST $ local f' g
      where
        f' env = env { envReader = f $ envReader env }

instance (MonadBase IO m, Monoid w) =&gt; MonadWriter w (RWST r w s m) where
    tell w = RWST $ ask &gt;&gt;= flip modifyIORef (&lt;&gt; w) . envWriter
    listen (RWST (ReaderT f)) = RWST $ ReaderT $ \env -&gt; do
        iwriter &lt;- newIORef mempty
        result &lt;- f env { envWriter = iwriter }
        w &lt;- readIORef iwriter
        return (result, w)
    pass (RWST (ReaderT f)) = RWST $ ReaderT $ \env -&gt; do
        (result, g) &lt;- f env
        modifyIORef (envWriter env) g
        return result

instance MonadBase IO m =&gt; MonadState s (RWST r w s m) where
    get = RWST $ ask &gt;&gt;= readIORef . envState
    put s = RWST $ ask &gt;&gt;= flip writeIORef s . envState

instance (MonadBase IO m, Monoid w) =&gt; MonadRWS r w s (RWST r w s m)

runRWST :: (MonadBase IO m, Monoid w) =&gt; RWST r w s m a -&gt; r -&gt; s -&gt; m (a, s, w)
runRWST (RWST (ReaderT f)) r s = do
    iwriter &lt;- newIORef mempty
    istate &lt;- newIORef s
    a &lt;- f $ Env r iwriter istate
    w &lt;- readIORef iwriter
    s' &lt;- readIORef istate
    return (a, s', w)

instance MonadBase b m =&gt; MonadBase b (RWST r w s m) where
    liftBase = lift . liftBase

instance MonadTransControl (RWST r w s) where
    newtype StT (RWST r w s) a = StRWS {unStRWS :: a}
    liftWith f = RWST $ ReaderT $ \r -&gt; f $ \(RWST t) -&gt; liftM StRWS $ runReaderT t r
    restoreT = RWST . ReaderT . const . liftM unStRWS

instance MonadBaseControl b m =&gt; MonadBaseControl b (RWST r w s m) where
    newtype StM (RWST r w s m) a = ST { unST :: ComposeSt (RWST r w s) m a }
    liftBaseWith = defaultLiftBaseWith ST
    restoreM     = defaultRestoreM unST

main :: IO ()
main = do
    res &lt;- try $ runRWST
        (step1 `finally` step2)
        &quot;This is the environment&quot;
        0
    print (res :: Either ErrorCall ((), Int, [Bool]))
  where
    step1 = do
        liftIO $ putStrLn $ &quot;In step1&quot;
        modify (+ 1)
        error &quot;User exception&quot;
    step2 = do
        s &lt;- get
        liftIO $ putStrLn $ &quot;In step2: &quot; ++ show s</code></pre></article>

<div id="disqus_thread"><script>var disqus_shortname = "snoyberg-soh"; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })();</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com/">comments powered by <span class="logo-disqus">Disqus</span></a></a>
</div>

</div>
</div>
<div class="row article-footer"><div class="span7 meta"><span class="sociallinksunicode social">
<a href="https://twitter.com/home?status=$url$" target="_blank"><i class="icon-twitter"></i></a>&nbsp;
<a href="http://www.facebook.com/sharer/sharer.php?u=$url$" target="_blank"><i class="icon-facebook"></i></a>&nbsp;
<a href="https://plus.google.com/share?url=$url$" target="_blank"><i class="icon-google-plus"></i></a></span>
</div>
</div>
</div>
<div class="footer"><div class="container"><div class="row"><div class="span12"><ul class="menu"><li><a href="https://www.schoolofhaskell.com/">School</a>
</li>
<li><a href="https://www.schoolofhaskell.com/user">Users</a>
</li>
<li><a href="https://www.schoolofhaskell.com/auth/login">Log In</a>
</li>
<li><a href="https://www.schoolofhaskell.com/auth/page/email/register">Sign Up</a>
</li>
</ul>
</div>
</div>
<div class="row"><div class="span12"></div>
</div>
</div>
</div>
<link rel="stylesheet" type="text/css" href="https://www.schoolofhaskell.com/static/bootstrap/css/bootstrap-responsive.css" />
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script><script src="https://www.schoolofhaskell.com/static/combined/cKRLBd-P.js"></script><script>window.fpco = window.fpco || {};
window.fpco.keyMap = "";

        function hident2() {
            if (navigator.id) {
                navigator.id.watch({
                    onlogin: function (assertion) {
                        if (assertion) {
                            document.location = "https://www.schoolofhaskell.com/auth/page/browserid/" + assertion;
                        }
                    },
                    onlogout: function () {}
                });
                navigator.id.request({
                    returnTo: "/auth/login" + "?autologin=true"
                });
            }
            else {
                alert("Loading, please try again");
            }
        }
    
        (function(){
            var bid = document.createElement("script");
            bid.async = true;
            bid.src = "https://login.persona.org/include.js";
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(bid, s);
        })();
    $(function(){
    var url = "https://www.schoolofhaskell.com/like-content/3379";
    var $self = $("#hident3");
    $.getJSON(url, function(state){
        var $a, $likeCount;

        $a = $('<a class="likes" href="/auth/login"></a>');
        $likeCount = $('<span class="like-count"></span>');
        $thumbs = $("<i class='icon-thumbs-up' title='Unlike this :-('>");
        $a.append($likeCount);
        $a.append($thumbs);
        $self.append($a);

        updateView();

        $a.click(function(){
            if(state.myLike == 'not-logged-in') {
                return true;
            } else {
                var $a = $(this);
                $.post(url, state.myLike !== 'no-like' ? {unlike:true} : {}, function(data){
                    state.myLike = state.myLike == 'no-like'? 'like' : 'no-like';
                    state.likes = data.likes;
                    updateView();
                });
                return false;
            }
        });

        function updateView(){
            var liked = state.myLike !== 'not-logged-in' && state.myLike !== 'no-like';
            if(liked) $a.addClass('likes-liked');
            else $a.removeClass('likes-liked');

            $likeCount.text(state.likes);

            if(state.myLike !== 'not-logged-in') {
                if (liked) $thumbs.attr('title','Unlike this');
                else $thumbs.attr('title','Like this!');

                if (liked) $a.addClass('likes-liked');
                else $a.removeClass('likes-liked');
            } else {
                $a.addClass('like-not-logged-in');
                $thumbs.attr('title','Please login to vote!');
            }
        }
    });
});
$(function(){
  $("a.logout").click(function(){
    var form = $("<form method='post'/>");
    form.attr("action", $(this).attr("href"));
    $("body").append(form);
    form.submit();
    return false;
  });
});

$(function(){
    $('.sociallinksunicode a').each(function(){
        $(this).attr('href',$(this).attr('href').replace('$url$',document.location));
    });
});

$(function(){
  // If we need to select a user/select a password then show the
  // details confirmation form, otherwise enable the getting started
  // section.
  if($('.alert-block a').text().match(/(selected a username|change your password)/)) {
    $("#confirm-details").show();
    $("#confirm-details #inputUsername").focus();
  } else {
    $("#get-started").removeClass('disabled').addClass('enabled');
  }

  // For lack of a plain HTML validation story this will do.
  $('.welcome-page').each(function(){
    $('form').submit(check);
  });
  function check(){
    setTimeout(check,500);
    var error = false;
    $('.error').removeClass('error');
    $('#enter-details input').each(function(){
      if($(this).val() == '') {
        $(this).parent().parent().addClass('error');
        error = true;
      }
    });
    if(error) return false;
    if($('[name=password]').val() == $('[name=confirm]').val()) {
      $('#confirm').removeClass('error');
      return true;
    } else {
      $('#confirm').addClass('error');
      return false;
    }
  }
});

$(function(){
  // When scrolling over a snippet editor, activate the "clone in IDE" popovers
  $('article').each(function(){
    var n = 100;
    var wait = 10000;
    function check(){
      if($('.clone').length == 0) {
        setTimeout(check,n);
        return;
      }
      var activated = $.cookie('clone-popover');
      if (activated) return;
      var activate = false;
      $('.controlsRun:onScreen').each(function(){
        $.cookie('clone-popover', 'true', { expires: 30, path: '/' });
        activate = true;
        return false;
      });
      if(activate) {
          $('.clone').each(function(){
              // The bootstrap API is rather unreasonable to say the
              // least.
              next = $(this).parent();
              var title = next.attr('title');
              next.attr('data-content',$(this).attr('data-content'));
              next.attr('title',$(this).attr('title'));
              next.popover('show',{
                  title: $(this).attr('title')
              });
              next.attr('title',title);
          });
          setTimeout(function(){
              $('.clone').each(function(){
                  $(this).parent().popover('hide');
              });
          },wait);
      } else {
        setTimeout(check,n);
      }
    }
    setTimeout(check,n);
  });
});

// onScreen jQuery plugin v0.2.1
// (c) 2011-2013 Ben Pickles
//
// http://benpickles.github.com/onScreen
//
// Released under MIT license.
(function(a){a.expr[":"].onScreen=function(b){var c=a(window),d=c.scrollTop(),e=c.height(),f=d+e,g=a(b),h=g.offset().top,i=g.height(),j=h+i;return h>=d&&h<f||j>d&&j<=f||i>e&&h<=d&&j>=f}})(jQuery);

/*!
 * jQuery Cookie Plugin v1.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function($, document) {

  var pluses = /\+/g;
  function raw(s) {
    return s;
  }
  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  $.cookie = function(key, value, options) {

    // key and at least value given, set cookie...
    if (arguments.length > 1 && (!/Object/.test(Object.prototype.toString.call(value)) || value == null)) {
      options = $.extend({}, $.cookie.defaults, options);

      if (value == null) {
	options.expires = -1;
      }

      if (typeof options.expires === 'number') {
	var days = options.expires, t = options.expires = new Date();
	t.setDate(t.getDate() + days);
      }

      value = String(value);

      return (document.cookie = [
	encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
	options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
	options.path    ? '; path=' + options.path : '',
	options.domain  ? '; domain=' + options.domain : '',
	options.secure  ? '; secure' : ''
      ].join(''));
    }

    // key and possibly options given, get cookie...
    options = value || $.cookie.defaults || {};
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, parts; (parts = cookies[i] && cookies[i].split('=')); i++) {
      if (decode(parts.shift()) === key) {
	return decode(parts.join('='));
      }
    }
    return null;
  };
  $.cookie.defaults = {};})(jQuery, document);
</script><!--[if lt IE 10]><script src="https://www.schoolofhaskell.com/static/design/js/ie.js?etag=ayV2DuJ0"></script><![endif]--><script>if(!window.location.href.match(/localhost/)){var track = '/tutorial/user/snoyberg/general-haskell/exceptions/exceptions-and-monad-transformers';
window._gaq = [['_setAccount','UA-36928035-1'],track != ''? ['_trackPageview',track] : ['_trackPageview']
,['_trackPageLoadTime']];window._gaq.push(['_setCustomVar',1,'Section','School of Haskell',3]);
window._gaq.push(['_setCustomVar',2,'User Type','Visitor',1]);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);

})();}</script>
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.  chromium.org/developers/how-tos/chrome-frame-getting-started --><!--[if lt IE 7 ]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script><![endif]--></body>
<!-- Mirrored from www.schoolofhaskell.com/user/snoyberg/general-haskell/exceptions/exceptions-and-monad-transformers by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 26 Dec 2016 20:53:54 GMT -->
</html>