<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  
  

  


  
Providence Salumu
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <title>
      PatternSynonyms – GHC
    </title>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <!--[if IE]><script type="text/javascript">
      if (/^#__msie303:/.test(window.location.hash))
        window.location.replace(window.location.hash.replace(/^#__msie303:/, '#'));
    </script><![endif]-->
        <link rel="search" href="https://ghc.haskell.org/trac/ghc/search" />
        <link rel="help" href="TracGuide.html" />
        <link rel="alternate" href="https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms?format=txt" type="text/x-trac-wiki" title="Plain Text" />
        <link rel="start" href="https://ghc.haskell.org/trac/ghc/wiki" />
        <link rel="stylesheet" href="https://ghc.haskell.org/trac-1.0.7-htdocs/css/trac.css" type="text/css" /><link rel="stylesheet" href="https://ghc.haskell.org/trac-1.0.7-htdocs/css/wiki.css" type="text/css" /><link rel="stylesheet" href="https://ghc.haskell.org/trac/ghc/chrome/wikiextras/css/phrases.css" type="text/css" /><link rel="stylesheet" href="https://ghc.haskell.org/trac/ghc/chrome/wikiextras/css/boxes.css" type="text/css" /><link rel="stylesheet" href="https://ghc.haskell.org/trac/ghc/wikiextras/dynamicboxes.css" type="text/css" />
        <link rel="shortcut icon" href="https://ghc.haskell.org/trac/ghc/chrome/common/trac.ico" type="image/x-icon" />
        <link rel="icon" href="https://ghc.haskell.org/trac/ghc/chrome/common/trac.ico" type="image/x-icon" />
    <style id="trac-noscript" type="text/css">.trac-noscript { display: none !important }</style>
      <link type="application/opensearchdescription+xml" rel="search" href="https://ghc.haskell.org/trac/ghc/search/opensearch" title="Search GHC" />
      <script type="text/javascript" charset="utf-8" src="https://ghc.haskell.org/trac-1.0.7-htdocs/js/jquery.js"></script>
      <script type="text/javascript" charset="utf-8" src="https://ghc.haskell.org/trac-1.0.7-htdocs/js/babel.js"></script>
      <script type="text/javascript" charset="utf-8" src="https://ghc.haskell.org/trac-1.0.7-htdocs/js/trac.js"></script>
      <script type="text/javascript" charset="utf-8" src="https://ghc.haskell.org/trac-1.0.7-htdocs/js/search.js"></script>
      <script type="text/javascript" charset="utf-8" src="https://ghc.haskell.org/trac-1.0.7-htdocs/js/folding.js"></script>
    <script type="text/javascript">
      jQuery("#trac-noscript").remove();
      jQuery(document).ready(function($) {
        $(".trac-autofocus").focus();
        $(".trac-target-new").attr("target", "_blank");
        setTimeout(function() { $(".trac-scroll").scrollToTop() }, 1);
        $(".trac-disable-on-submit").disableOnSubmit();
      });
    </script>
    <script type="text/javascript">
      jQuery(document).ready(function($) {
        $("#content").find("h1,h2,h3,h4,h5,h6").addAnchor(_("Link to this section"));
        $("#content").find(".wikianchor").each(function() {
          $(this).addAnchor(babel.format(_("Link to #%(id)s"), {id: $(this).attr('id')}));
        });
        $(".foldable").enableFolding(true, true);
      });
    </script>
  </head>
  <body>
    <div id="banner">
      <div id="header">
        <a id="logo" href="http://www.haskell.org/ghc/"><img src="https://ghc.haskell.org/trac/ghc/chrome/site/ghc_logo.png" alt="Trac" height="73" width="584" /></a>
      </div>
      <form id="search" action="https://ghc.haskell.org/trac/ghc/search" method="get">
        <div>
          <label for="proj-search">Search:</label>
          <input type="text" id="proj-search" name="q" size="18" value="" />
          <input type="submit" value="Search" />
        </div>
      </form>
      <div id="metanav" class="nav">
    <ul>
      <li class="first"><a href="https://ghc.haskell.org/trac/ghc/login">Login</a></li><li><a href="TracGuide.html">Help/Guide</a></li><li><a href="https://ghc.haskell.org/trac/ghc/about">About Trac</a></li><li><a href="https://ghc.haskell.org/trac/ghc/prefs">Preferences</a></li><li class="last"><a href="https://ghc.haskell.org/trac/ghc/register">Register</a></li>
    </ul>
  </div>
    </div>
    <div id="mainnav" class="nav">
    <ul>
      <li class="first active"><a href="https://ghc.haskell.org/trac/ghc/wiki">Wiki</a></li><li><a href="https://ghc.haskell.org/trac/ghc/timeline">Timeline</a></li><li><a href="https://ghc.haskell.org/trac/ghc/roadmap">Roadmap</a></li><li><a href="https://ghc.haskell.org/trac/ghc/browser">Browse Source</a></li><li><a href="https://ghc.haskell.org/trac/ghc/report">View Tickets</a></li><li><a href="https://ghc.haskell.org/trac/ghc/search">Search</a></li><li class="last"><a href="https://ghc.haskell.org/trac/ghc/blog">Blog</a></li>
    </ul>
  </div>
    <div id="main">
      <div id="pagepath" class="noprint">
  <a class="pathentry first" title="View WikiStart" href="https://ghc.haskell.org/trac/ghc/wiki">wiki:</a><a class="pathentry" href="PatternSynonyms.html" title="View PatternSynonyms">PatternSynonyms</a>
</div>
      <div id="ctxtnav" class="nav">
        <h2>Context Navigation</h2>
        <ul>
          <li class="first"><a href="WikiStart.html">Start Page</a></li><li><a href="TitleIndex.html">Index</a></li><li class="last"><a href="https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms?action=history">History</a></li>
        </ul>
        <hr />
      </div>
    <div id="ghc-wrap" style="padding: 0; margin 0; width: 100%; border: 0; min-height: 45em;">
      <div id="ghc-sidebar" style="border: 1px solid #bbb; margin-top: 0px; width: 136px; border-radius: 0.5em; position: absolute; background-color: #D6F3D6; box-shadow: 1px 1px 10px #aaa;">
  <ul style="list-style: none; padding: 9px; font-size: 85%; margin: 0;">
    <li><a href="http://ghc.haskell.org/trac/ghc">GHC Trac Home</a></li>
    <li><a href="http://www.haskell.org/ghc/">GHC Home</a></li>
    <li> </li>
    <li><b>Joining In</b></li>
    <li><a href="ReportABug.html">Report a bug</a></li>
    <li><a href="Newcomers.html">Newcomers info</a></li>
    <li><a href="MailingListsAndIRC.html">Mailing Lists &amp; IRC</a></li>
    <li><a href="TeamGHC.html">The GHC Team</a></li>
    <li> </li>
    <li><b>Documentation</b></li>
    <li><a href="Status.html">GHC Status Info</a></li>
    <li><a href="Building.html">Building Guide</a></li>
    <li><a href="WorkingConventions.html">Working conventions</a></li>
    <li><a href="Commentary.html">Commentary</a></li>
    <li><a href="Debugging.html">Debugging</a></li>
    <li><a href="Infrastructure.html">Infrastructure</a></li>
    <li> </li>
    <li><b>View Tickets</b></li>
    <li><a href="https://ghc.haskell.org/trac/ghc/query?status=infoneeded&amp;status=new&amp;status=patch&amp;order=priority&amp;owner=$USER">My Tickets</a></li>
    <li><a href="https://ghc.haskell.org/trac/ghc/query?status=infoneeded&amp;status=new&amp;status=patch&amp;order=priority&amp;reporter=$USER">Tickets I Created</a></li>
    <li><a href="https://ghc.haskell.org/trac/ghc/query?status=new&amp;status=assigned&amp;status=reopened&amp;group=milestone&amp;order=priority">By Milestone</a></li>
    <li><a href="https://ghc.haskell.org/trac/ghc/query?status=new&amp;status=assigned&amp;status=reopened&amp;group=os&amp;order=priority">By OS</a></li>
    <li><a href="https://ghc.haskell.org/trac/ghc/query?status=new&amp;status=assigned&amp;status=reopened&amp;group=architecture&amp;order=priority">By Architecture</a></li>
    <li><a href="https://ghc.haskell.org/trac/ghc/query?status=patch&amp;ol=id&amp;col=summary&amp;col=owner&amp;col=type&amp;col=priority&amp;col=milestone&amp;col=component&amp;order=priority&amp;differential=">Patches for review</a></li>
    <li> </li>
    <li><b>Create Ticket</b></li>
    <li><a href="https://ghc.haskell.org/trac/ghc/newticket?type=bug">New Bug</a></li>
    <li><a href="https://ghc.haskell.org/trac/ghc/newticket?type=task">New Task</a></li>
    <li><a href="https://ghc.haskell.org/trac/ghc/newticket?type=feature+request">New Feature Req</a></li>
    <li> </li>
    <li><b>Wiki</b></li>
    <li><a href="TitleIndex.html">Title Index</a></li>
    <li><a href="RecentChanges.html">Recent Changes</a></li>
    <li><a href="TracWikiMisc.html">Wiki Notes</a></li>
  </ul>
</div>
      <div id="ghc-content" style="margin-left: 150px;">
        <div id="content" class="wiki">
      <div class="wikipage searchable">
        
          <div id="wikipage" class="trac-content"><h1 id="PatternSynonyms">Pattern Synonyms</h1>
<p>
Most language entities in Haskell can be named so that they can be abbreviated instead of written out in full.
This proposal provides the same power for patterns.  See the <a class="wiki" href="https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms/Implementation">implementation</a> page for implementation details.
</p>
<p>
Tickets should include <tt>PatternSynonyms</tt> in their Keywords to appear in these summary lists.
</p>
<p>
Open Tickets:
</p><div><dl class="wiki compact"><dt><a class="new" href="https://ghc.haskell.org/trac/ghc/ticket/8581" title="Pattern synonym used in an expression context could have different ...">#8581</a></dt><dd>Pattern synonym used in an expression context could have different constraints to pattern used in a pattern context</dd><dt><a class="new" href="https://ghc.haskell.org/trac/ghc/ticket/8583" title="Associated pattern synonyms">#8583</a></dt><dd>Associated pattern synonyms</dd><dt><a class="new" href="https://ghc.haskell.org/trac/ghc/ticket/8779" title="Exhaustiveness checks for pattern synonyms">#8779</a></dt><dd>Exhaustiveness checks for pattern synonyms</dd><dt><a class="new" href="https://ghc.haskell.org/trac/ghc/ticket/9671" title="Allow expressions in patterns">#9671</a></dt><dd>Allow expressions in patterns</dd><dt><a class="new" href="https://ghc.haskell.org/trac/ghc/ticket/9793" title="Some as-patterns could be accepted in pattern synonyms">#9793</a></dt><dd>Some as-patterns could be accepted in pattern synonyms</dd><dt><a class="new" href="https://ghc.haskell.org/trac/ghc/ticket/10783" title="Partial type signatures should work in pattern synonym signatures">#10783</a></dt><dd>Partial type signatures should work in pattern synonym signatures</dd><dt><a class="new" href="https://ghc.haskell.org/trac/ghc/ticket/11212" title="Should be more liberal parsing pattern synonyms with view patterns">#11212</a></dt><dd>Should be more liberal parsing pattern synonyms with view patterns</dd><dt><a class="new" href="https://ghc.haskell.org/trac/ghc/ticket/11228" title="Interaction between ORF and record pattern synonyms needs to be resolved.">#11228</a></dt><dd>Interaction between ORF and record pattern synonyms needs to be resolved.</dd><dt><a class="new" href="https://ghc.haskell.org/trac/ghc/ticket/11350" title="Allow visible type application in patterns">#11350</a></dt><dd>Allow visible type application in patterns</dd><dt><a class="new" href="https://ghc.haskell.org/trac/ghc/ticket/11368" title="Pattern synonym name is mangled when patterns are non-exhaustive">#11368</a></dt><dd>Pattern synonym name is mangled when patterns are non-exhaustive</dd><dt><a class="new" href="https://ghc.haskell.org/trac/ghc/ticket/11461" title="Allow pattern synonyms to be bundled with type classes?">#11461</a></dt><dd>Allow pattern synonyms to be bundled with type classes?</dd><dt><a class="new" href="https://ghc.haskell.org/trac/ghc/ticket/11646" title="Make pattern synonym export type mismatch a warning">#11646</a></dt><dd>Make pattern synonym export type mismatch a warning</dd><dt><a class="new" href="https://ghc.haskell.org/trac/ghc/ticket/11655" title="Ambiguous types in pattern synonym not determined by functional ...">#11655</a></dt><dd>Ambiguous types in pattern synonym not determined by functional dependencies</dd><dt><a class="new" href="https://ghc.haskell.org/trac/ghc/ticket/11955" title="Haddock documentation for pattern synonyms printed with explicit ...">#11955</a></dt><dd>Haddock documentation for pattern synonyms printed with explicit forall quantifiers</dd><dt><a class="new" href="https://ghc.haskell.org/trac/ghc/ticket/11959" title="Importing doubly exported pattern synonym and associated pattern ...">#11959</a></dt><dd>Importing doubly exported pattern synonym and associated pattern synonym panics</dd><dt><a class="new" href="https://ghc.haskell.org/trac/ghc/ticket/11993" title="RFC, allow local bindings in pattern synonyms">#11993</a></dt><dd>RFC, allow local bindings in pattern synonyms</dd><dt><a class="new" href="https://ghc.haskell.org/trac/ghc/ticket/12006" title="Can't infer constraint of pattern synonyms">#12006</a></dt><dd>Can't infer constraint of pattern synonyms</dd><dt><a class="new" href="https://ghc.haskell.org/trac/ghc/ticket/12025" title="Order of constraints forced (in pattern synonyms, type classes in comments)">#12025</a></dt><dd>Order of constraints forced (in pattern synonyms, type classes in comments)</dd><dt><a class="new" href="https://ghc.haskell.org/trac/ghc/ticket/12178" title="Allow inline pragmas on pattern synonyms">#12178</a></dt><dd>Allow inline pragmas on pattern synonyms</dd><dt><a class="new" href="https://ghc.haskell.org/trac/ghc/ticket/12179" title="Incorrect parsing of a pattern synonym type">#12179</a></dt><dd>Incorrect parsing of a pattern synonym type</dd><dt><a class="new" href="https://ghc.haskell.org/trac/ghc/ticket/12187" title="Clarify the scoping of existentials for pattern synonym signatures">#12187</a></dt><dd>Clarify the scoping of existentials for pattern synonym signatures</dd><dt><a class="new" href="https://ghc.haskell.org/trac/ghc/ticket/12203" title="Allow constructors on LHS of (implicit) bidirectional pattern synonym">#12203</a></dt><dd>Allow constructors on LHS of (implicit) bidirectional pattern synonym</dd><dt><a class="new" href="https://ghc.haskell.org/trac/ghc/ticket/12429" title="Pattern synonym parse error should recommend enabling extension">#12429</a></dt><dd>Pattern synonym parse error should recommend enabling extension</dd><dt><a class="new" href="https://ghc.haskell.org/trac/ghc/ticket/12448" title="Allow partial application of bidirectional pattern synonyms">#12448</a></dt><dd>Allow partial application of bidirectional pattern synonyms</dd><dt><a class="new" href="https://ghc.haskell.org/trac/ghc/ticket/12975" title="Suggested type signature for a pattern synonym causes program to fail ...">#12975</a></dt><dd>Suggested type signature for a pattern synonym causes program to fail to type check</dd><dt><a class="patch" href="https://ghc.haskell.org/trac/ghc/ticket/13018" title="TH-spliced pattern synonym declaration fails to typecheck">#13018</a></dt><dd>TH-spliced pattern synonym declaration fails to typecheck</dd><dt><a class="new" href="https://ghc.haskell.org/trac/ghc/ticket/13042" title="Allow type annotations / visible type application in pattern synonyms">#13042</a></dt><dd>Allow type annotations / visible type application in pattern synonyms</dd></dl></div><p>
</p>
<p>
There is a list of closed tickets at the bottom of the page.
</p>
<h2 id="Motivatingexample">Motivating example</h2>
<p>
Here is a simple representation of types
</p>
<pre class="wiki">    data Type = App String [Type]
</pre><p>
Using this representations the arrow type looks like <tt>App "-&gt;" [t1, t2]</tt>.
Here are functions that collect all argument types of nested arrows and recognize the <tt>Int</tt> type:
</p>
<pre class="wiki">   collectArgs :: Type -&gt; [Type]
   collectArgs (App "-&gt;" [t1, t2]) = t1 : collectArgs t2
   collectArgs _ = []

   isInt (App "Int" []) = True
   isInt _ = False
</pre><p>
Matching on <tt>App</tt> directly is both hard to read and error prone to write.
</p>
<p>
The proposal is to introduce a way to give patterns names:
</p>
<pre class="wiki">   pattern Arrow t1 t2 = App "-&gt;" [t1, t2]
   pattern Int = App "Int" []
</pre><p>
And now we can write
</p>
<pre class="wiki">   collectArgs :: Type -&gt; [Type]
   collectArgs (Arrow t1 t2) = t1 : collectArgs t2
   collectArgs _ = []

   isInt Int = True
   isInt _ = False
</pre><p>
Here is a second example from <a class="ext-link" href="http://www.reddit.com/r/haskell/comments/1kmods/patternsynonyms_ghc_trac/"><span class="icon">​</span>pigworker on Reddit</a>.
Your basic sums-of-products functors can be built from this kit.
</p>
<pre class="wiki">newtype K a        x  = K a
newtype I          x  = I x
newtype (:+:) f g  x  = Sum (Either (f x) (g x))
newtype (:*:) f g  x  = Prod (f x, g x)
</pre><p>
and then you can make recursive datatypes via
</p>
<pre class="wiki">newtype Fix f = In (f (Fix f))
</pre><p>
e.g.,
</p>
<pre class="wiki">type Tree = Fix (K () :+: (I :*: I))
</pre><p>
and you can get useful generic operations cheaply because the functors in the kit are all <tt>Traversable</tt>, admit a partial zip operation, etc.
</p>
<p>
You can define friendly constructors for use in expressions
</p>
<pre class="wiki">leaf :: Tree
leaf = In (Sum (Left (K ())))
node :: Tree -&gt; Tree -&gt; Tree
node l r = In (Sum (Right (Prod (I l, I r))))
</pre><p>
but any <tt>Tree</tt>-specific pattern matching code you write will be wide and obscure. Turning these definitions into pattern synonyms means you can have both readable type-specific programs and handy generics without marshalling your data between views.
</p>
<h2 id="Uni-directionalpattern-onlysynonyms">Uni-directional (pattern-only) synonyms</h2>
<p>
The simplest form of pattern synonyms is the one from the examples above.  The grammar rule is:
</p>
<p>
<tt>pattern</tt> <em>conid</em> <em>varid<sub>1</sub></em> ... <em>varid<sub>n</sub></em> <tt>&lt;-</tt> <em>pat</em>
</p>
<p>
<tt>pattern</tt> <em>varid<sub>1</sub></em> <em>consym</em> <em>varid<sub>2</sub></em> <tt>&lt;-</tt> <em>pat</em>
</p>
<ul><li>Each of the variables on the left hand side must occur exactly once on the right hand side 
</li><li>Pattern synonyms are not allowed to be recursive.  Cf. type synonyms.
</li></ul><table class="wiki">
<tr><td><p>
There have been several proposals for the syntax of defining pattern-only synonyms:
</p>
<ul><li><tt>pattern</tt> <em>conid</em> <em>varid<sub>1</sub></em> ... <em>varid<sub>n</sub></em> <tt>~</tt> <em>pat</em>
</li><li><tt>pattern</tt> <em>conid</em> <em>varid<sub>1</sub></em> ... <em>varid<sub>n</sub></em> <tt>:=</tt> <em>pat</em>
</li><li><tt>pattern</tt> <em>conid</em> <em>varid<sub>1</sub></em> ... <em>varid<sub>n</sub></em> <tt>-&gt;</tt> <em>pat</em>
</li><li><tt>pattern</tt> <em>conid</em> <em>varid<sub>1</sub></em> ... <em>varid<sub>n</sub></em> <tt>&lt;-</tt> <em>pat</em>
</li></ul></td></tr></table>
<p>
Pattern synonyms can be exported and imported by prefixing the <em>conid</em> with the keyword <tt>pattern</tt>:
</p>
<pre class="wiki">   module Foo (pattern Arrow) where ...
</pre><p>
This is required because pattern synonyms are in the namespace of constructors, so it's perfectly valid to have
</p>
<pre class="wiki">   data P = C
   pattern P = 42
</pre><p>
You may also give a type signature for a pattern, but as with most other type signatures in Haskell it is optional:
</p>
<p>
<tt>pattern</tt> <em>conid</em> <tt>::</tt> <em>type</em>
</p>
<p>
E.g.
</p>
<pre class="wiki">   pattern Arrow :: Type -&gt; Type -&gt; Type
   pattern Arrow t1 t2 &lt;- App "-&gt;" [t1, t2]
</pre><p>
Together with <a class="wiki" href="https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns">ViewPatterns</a> we can now create patterns that look like regular patterns to match on existing (perhaps abstract) types in new ways:
</p>
<pre class="wiki">import qualified Data.Sequence as Seq

pattern Empty &lt;- (Seq.viewl -&gt; Seq.EmptyL)
pattern x :&lt; xs &lt;- (Seq.viewl -&gt; x Seq.:&lt; xs)
pattern xs :&gt; x &lt;- (Seq.viewr -&gt; xs Seq.:&gt; x)
</pre><h2 id="Simply-bidirectionalpatternsynonyms">Simply-bidirectional pattern synonyms</h2>
<p>
In cases where <em>pat</em> is in the intersection of the grammars for patterns and expressions (i.e. is valid both as an expression and a pattern), the pattern synonym can be made bidirectional, and can be used in expression contexts as well. Bidirectional pattern synonyms have the following syntax:
</p>
<p>
<tt>pattern</tt> <em>conid</em> <em>varid<sub>1</sub></em> ... <em>varid<sub>n</sub></em> <tt>=</tt> <em>pat</em>
</p>
<p>
<tt>pattern</tt> <em>varid<sub>1</sub></em> <em>consym</em> <em>varid<sub>2</sub></em> <tt>=</tt> <em>pat</em>
</p>
<p>
For example, the following two pattern synonym definitions are rejected, because they are not bidirectional (but they would be valid as pattern-only synonyms)
</p>
<pre class="wiki">   pattern ThirdElem x = _:_:x:_
   pattern Snd y = (x, y)
</pre><p>
since the right-hand side is not a closed expression of {<em>x</em>} and {<em>y</em>} respectively.
</p>
<p>
In contrast, the pattern synonyms for <em>Arrow</em> and <em>Int</em> above are bidirectional, so you can e.g. write:
</p>
<pre class="wiki">   arrows :: [Type] -&gt; Type -&gt; Type
   arrows = flip $ foldr Arrow
</pre><h2 id="Explicitly-bidirectionalpatternsynonyms">Explicitly-bidirectional pattern synonyms</h2>
<p>
What if you want to use <tt>Succ</tt> in an expression:
</p>
<pre class="wiki">    pattern Succ n &lt;- n1 | let n = n1 -1, n &gt;= 0
</pre><p>
It's clearly impossible since its expansion is a pattern that has no meaning as an expression.
Nevertheless, if we want to make what looks like a constructor for a type we will often want to use it in both patterns and expressions.
This is the rationale for the most complicated synonyms, the bidirectional ones.  They provide two expansions, one for patterns and one for expressions.
</p>
<p>
<tt>pattern</tt> <em>conid</em> <em>varid<sub>1</sub></em> ... <em>varid<sub>n</sub></em> <tt>&lt;-</tt> <em>pat</em> <tt>where</tt> <em>cfunlhs</em> <em>rhs</em>
</p>
<p>
where <em>cfunlhs</em> is like <em>funlhs</em>, except that the functions symbol is a <em>conid</em> instead of a <em>varid</em>.
</p>
<p>
Example:
</p>
<pre class="wiki">   pattern Succ n &lt;- n1 | let n = n1-1, n &gt;= 0 where
      Succ n = n + 1
</pre><p>
<strong><span class="wikiextras phrase todo">TODO</span></strong>: Rewrite this example to not use <a class="wiki" href="https://ghc.haskell.org/trac/ghc/wiki/ViewPatternsAlternative">ViewPatternsAlternative</a>
</p>
<p>
The first part as is before and describes the expansion of the synonym in patterns. The second part describes the expansion in expressions.
</p>
<pre class="wiki">   fac 0 = 0
   fac (Succ n) = Succ n * fac n 
</pre><h2 id="Associatedpatternsynonyms">Associated pattern synonyms</h2>
<p>
Just like data types and type synonyms can be part of a class declaration, it would be possible to have pattern synonyms as well.
</p>
<p>
Example:
</p>
<pre class="wiki">   class ListLike l where
      pattern Nil :: l a
      pattern Cons :: a -&gt; l a -&gt; a
      isNil :: l a -&gt; Bool
      isNil Nil = True
      isNil (Cons _ _) = False
      append :: l a -&gt; l a -&gt; l a

   instance ListLike [] where
      pattern Nil = []
      pattern Cons x xs = x:xs
      append = (++)

   headOf :: (ListLike l) =&gt; l a -&gt; Maybe a
   headOf Nil = Nothing
   headOf (Cons x _) = Just x
</pre><p>
One could go one step further and leave out the <tt>pattern</tt> keyword to obtain <em>associated constructors</em>, which are required to be bidirectional. The capitalized identifier would indicate that a pattern synonym is being defined. For complicated cases one could resort to the <tt>where</tt> syntax (shown above).
</p>
<p>
<strong><span class="wikiextras phrase todo">TODO</span></strong>: Syntax for associated pattern synonym declarations to discern between pattern-only and bidirectional pattern synonyms
</p>
<h2 id="Staticsemantics">Static semantics</h2>
<p>
A unidirectional pattern synonym declaration has the form
</p>
<pre class="wiki">pattern P var1 var2 ... varN &lt;- pat
</pre><p>
The formal pattern synonym arguments <tt>var1</tt>, <tt>var2</tt>, ..., <tt>varN</tt> are brought
into scope by the pattern pat on the right-hand side. The declaration
brings the name <tt>P</tt> as a pattern synonym into the module-level scope.
</p>
<p>
The pattern synonym <tt>P</tt> is assigned a <em>pattern type</em> of the form
</p>
<pre class="wiki">pattern P :: CProv =&gt; CReq =&gt; t1 -&gt; t2 -&gt; ... -&gt; tN -&gt; t 
</pre><p>
where <tt>t1</tt>, ..., <tt>tN</tt> are the types of the parameters <tt>var1</tt>, ..., <tt>varN</tt>, <tt>t</tt> is the simple type (with no context) of the thing getting matched, and <tt>CReq</tt> and <tt>CProv</tt> are type contexts.
</p>
<p>
<tt>CReq</tt> can be omitted if it is empty. If <tt>CProv</tt> is empty, but <tt>CReq</tt> is not, <tt>()</tt> is used. The following example shows cases:
</p>
<pre class="wiki">data Showable where
    MkShowable :: (Show a) =&gt; a -&gt; Showable

-- Required context is empty
pattern Sh :: (Show a) =&gt; a -&gt; Showable
pattern Sh x &lt;- MkShowable x

-- Provided context is empty, but required context is not
pattern One :: () =&gt; (Num a, Eq a) =&gt; a
pattern One &lt;- 1
</pre><p>
A pattern synonym can be used in a pattern if the
instatiated (monomorphic) type satisfies the constraints of
<tt>CReq</tt>. In this case, it extends the context available in the
right-hand side of the match with <tt>CProv</tt>, just like how an
existentially-typed data constructor can extend the context.
</p>
<p>
As with function and variable types, the pattern type signature can be inferred, or it can be explicitly written out on the program. 
</p>
<p>
Here's a more complex example. Let's look at the following definition:
</p>
<pre class="wiki">{-# LANGUAGE PatternSynonyms, GADTs, ViewPatterns #-}
module ShouldCompile where

data T a where
	MkT :: (Eq b) =&gt; a -&gt; b -&gt; T a

f :: (Show a) =&gt; a -&gt; Bool

pattern P x &lt;- MkT (f -&gt; True) x
</pre><p>
Here, the inferred type of <tt>P</tt> is
</p>
<pre class="wiki">pattern P :: (Eq b) =&gt; (Show a) =&gt; b -&gt; T a
</pre><p>
A bidirectional pattern synonym declaration has the form
</p>
<pre class="wiki">pattern P var1 var2 ... varN = pat
</pre><p>
where both of the following are well-typed declarations:
</p>
<pre class="wiki">pattern P1 var1 var2 ... varN &lt;- pat

P2 = \var1 var2 ... varN -&gt; pat
</pre><p>
In this case, the <em>pattern type</em> of <tt>P</tt> is simply the pattern type
of <tt>P1</tt>, and its <em>expression type</em> is the type of <tt>P2</tt>. The name <tt>P</tt>
is brought into the module-level scope both as a pattern synonym and
as an expression.
</p>
<h2 id="Dynamicsemantics">Dynamic semantics</h2>
<p>
A pattern synonym occurance in a pattern is evaluated by first
matching against the pattern synonym itself, and then on the argument
patterns. For example, given the following definitions:
</p>
<pre class="wiki">pattern P x y &lt;- [x, y]

f (P True True) = True
f _             = False

g [True, True] = True
g _            = False
</pre><p>
the behaviour of <tt>f</tt> is the same as
</p>
<pre class="wiki">f [x, y] | True &lt;- x, True &lt;- y = True
f _                             = False
</pre><p>
Because of this, the eagerness of <tt>f</tt> and <tt>g</tt> differ:
</p>
<pre class="wiki">*Main&gt; f (False:undefined)
*** Exception: Prelude.undefined
*Main&gt; g (False:undefined)
False
</pre><p>
This is because we generate the matching function at the definition site. 
</p>
<h2 id="Typedpatternsynonyms">Typed pattern synonyms</h2>
<p>
So far patterns only had <em>syntactic</em> meaning. In comparison <a class="ext-link" href="http://code.google.com/p/omega"><span class="icon">​</span>Ωmega</a> has <em>typed</em> pattern synonyms, so they become first class values. For bidirectional pattern synonyms this seems to be the case
</p>
<pre class="wiki">data Nat = Z | S Nat deriving Show
pattern Ess p = S p
</pre><p>
And it works:
</p>
<pre class="wiki">*Main&gt; map S [Z, Z, S Z]
[S Z,S Z,S (S Z)]
*Main&gt; map Ess [Z, Z, S Z]
[S Z,S Z,S (S Z)]
</pre><h2 id="Branchingpattern-onlysynonyms">Branching pattern-only synonyms</h2>
<p>
<em>N.B. this is a speculative suggestion!
</em></p>
<p>
Sometimes you want to match against several summands of an ADT simultaneously. E.g. in a data type of potentially unbounded natural numbers:
</p>
<pre class="wiki">data Nat = Zero | Succ Nat
type UNat = Maybe Nat -- Nothing meaning unbounded
</pre><p>
Conceptually <tt>Nothing</tt> means <em>infinite</em>, so it makes sense to interpret it as a <em>successor</em> of something. We wish it to have a predecessor just like <tt>Just (Succ Zero)</tt>!
</p>
<p>
I suggest <em>branching pattern synonyms</em> for this purpose:
</p>
<pre class="wiki">pattern S pred &lt;- pred@Nothing | pred@(Just a &lt;- Just (Succ a))
pattern Z = Just Zero
</pre><p>
Here <tt>pred@(Just a &lt;- Just (Succ a))</tt> means that the pattern invocation <tt>S pred</tt> matches against <tt>Just (Succ a)</tt> and - if successful - binds <tt>Just a</tt> to <tt>pred</tt>.
</p>
<p>
This means we can syntactically address unbound naturals just like bounded ones:
</p>
<pre class="wiki">greetTimes :: UNat -&gt; String -&gt; IO ()
greetTimes Z _ = return ()
greetTimes (S rest) message = putStrLn message &gt;&gt; greetTimes rest message
</pre><p>
As a nice collateral win this proposal handles <tt>pattern Name name &lt;- Person name workplace | Dog name vet</tt> too.
</p>
<h2 id="RecordPatternSynonyms">Record Pattern Synonyms</h2>
<p>
See <a class="wiki" href="https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms/RecordPatternSynonyms">PatternSynonyms/RecordPatternSynonyms</a>
</p>
<h2 id="Associatingsynonymswithtypes">Associating synonyms with types</h2>
<p>
See <a class="wiki" href="https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms/AssociatingSynonyms">PatternSynonyms/AssociatingSynonyms</a>
</p>
<h2 id="ClosedTickets">Closed Tickets</h2>
<p>
Closed Tickets:
</p><div><dl class="wiki compact"><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/5144" title="Pattern synonyms">#5144</a></dt><dd>Pattern synonyms</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/8582" title="Record syntax for pattern synonyms">#8582</a></dt><dd>Record syntax for pattern synonyms</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/8584" title="Pattern synonym type signatures">#8584</a></dt><dd>Pattern synonym type signatures</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/8749" title="Pattern synonyms crash GHCi">#8749</a></dt><dd>Pattern synonyms crash GHCi</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/8761" title="Make pattern synonyms work with Template Haskell">#8761</a></dt><dd>Make pattern synonyms work with Template Haskell</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/8841" title="PatternSynonyms error gives wrong source locations">#8841</a></dt><dd>PatternSynonyms error gives wrong source locations</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/8968" title="Pattern synonyms and GADTs">#8968</a></dt><dd>Pattern synonyms and GADTs</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/9161" title="Pattern synonyms interact badly with data kinds">#9161</a></dt><dd>Pattern synonyms interact badly with data kinds</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/9226" title="Internal error when using equality constraint in pattern synonyms">#9226</a></dt><dd>Internal error when using equality constraint in pattern synonyms</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/9417" title="Pattern synonyms across modules broken in Haddock">#9417</a></dt><dd>Pattern synonyms across modules broken in Haddock</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/9514" title="Haddock panics when exporting a module with pattern synonyms">#9514</a></dt><dd>Haddock panics when exporting a module with pattern synonyms</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/9705" title="Panic on a pattern synonym in a class">#9705</a></dt><dd>Panic on a pattern synonym in a class</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/9732" title="Pattern synonyms and unboxed values">#9732</a></dt><dd>Pattern synonyms and unboxed values</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/9783" title="Pattern synonym matcher is unnecessarily strict on unboxed continuations">#9783</a></dt><dd>Pattern synonym matcher is unnecessarily strict on unboxed continuations</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/9803" title="Poor error message for unbound variable in pattern synonym">#9803</a></dt><dd>Poor error message for unbound variable in pattern synonym</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/9867" title="PatternSynonyms + ScopedTypeVariables triggers an internal error">#9867</a></dt><dd>PatternSynonyms + ScopedTypeVariables triggers an internal error</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/9889" title="Pattern synonym does not work in top-level pattern bind">#9889</a></dt><dd>Pattern synonym does not work in top-level pattern bind</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/9891" title="Fixity declarations for pattern synonyms not persisted">#9891</a></dt><dd>Fixity declarations for pattern synonyms not persisted</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/9900" title="Support pattern synonyms in GHCi">#9900</a></dt><dd>Support pattern synonyms in GHCi</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/9911" title="Pattern synonyms with no signatures should yield warnings">#9911</a></dt><dd>Pattern synonyms with no signatures should yield warnings</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/9953" title="Pattern synonyms don't work with GADTs">#9953</a></dt><dd>Pattern synonyms don't work with GADTs</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/9954" title="Required constraints are not inferred for pattern synonyms involving GADTs">#9954</a></dt><dd>Required constraints are not inferred for pattern synonyms involving GADTs</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/9967" title="Pattern synonym type signature documentation out of date">#9967</a></dt><dd>Pattern synonym type signature documentation out of date</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/9975" title="RecordWildcards and PatternSynonyms cause impossible bug">#9975</a></dt><dd>RecordWildcards and PatternSynonyms cause impossible bug</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/10339" title="PatternSynonyms confuse exhaustiveness check">#10339</a></dt><dd>PatternSynonyms confuse exhaustiveness check</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/10404" title="GHC panic when creating a monomorphised pattern synonym for GADT">#10404</a></dt><dd>GHC panic when creating a monomorphised pattern synonym for GADT</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/10426" title="matchGroupArity panic with PatternSynonyms">#10426</a></dt><dd>matchGroupArity panic with PatternSynonyms</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/10653" title="PatternSynonyms should be imported/exported as part of the wildcard ...">#10653</a></dt><dd>PatternSynonyms should be imported/exported as part of the wildcard notation</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/10747" title="Infix pattern synonyms fail to parse (regression)">#10747</a></dt><dd>Infix pattern synonyms fail to parse (regression)</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/10873" title="Bad error message for incorrect pattern synonym signature">#10873</a></dt><dd>Bad error message for incorrect pattern synonym signature</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/10897" title="Incorrect ASSERT for buildPatSyn">#10897</a></dt><dd>Incorrect ASSERT for buildPatSyn</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/10997" title="Pattern synonym causes Iface error.">#10997</a></dt><dd>Pattern synonym causes Iface error.</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/11039" title="Panic with incorrect pattern synonym signature">#11039</a></dt><dd>Panic with incorrect pattern synonym signature</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/11213" title="Incorrect reported pattern synonym signature">#11213</a></dt><dd>Incorrect reported pattern synonym signature</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/11224" title="Program doesn't preserve semantics after pattern synonym inlining.">#11224</a></dt><dd>Program doesn't preserve semantics after pattern synonym inlining.</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/11225" title="Unable to provide type signature for pattern synonym">#11225</a></dt><dd>Unable to provide type signature for pattern synonym</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/11227" title="Interaction between ORF and record pattern synonyms needs to be resolved.">#11227</a></dt><dd>Interaction between ORF and record pattern synonyms needs to be resolved.</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/11233" title="Improve optimisation of pattern synonym matching">#11233</a></dt><dd>Improve optimisation of pattern synonym matching</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/11283" title="PatternSynonms and DisambiguateRecordFields causes panic">#11283</a></dt><dd>PatternSynonms and DisambiguateRecordFields causes panic</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/11336" title="GHC craches on this combination of ViewPatterns and PatternSynonyms">#11336</a></dt><dd>GHC craches on this combination of ViewPatterns and PatternSynonyms</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/11351" title="Scoped type variables in pattern synonyms">#11351</a></dt><dd>Scoped type variables in pattern synonyms</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/11367" title="[Regression] Only one clause allowed in (explicitly bidirectional) ...">#11367</a></dt><dd>[Regression] Only one clause allowed in (explicitly bidirectional) pattern synonyms</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/11524" title="Something is amiss with quantification in pattern synonym type signatures">#11524</a></dt><dd>Something is amiss with quantification in pattern synonym type signatures</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/11633" title="Record field order in a bidirectional pattern synonym match is order ...">#11633</a></dt><dd>Record field order in a bidirectional pattern synonym match is order dependent</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/11667" title="Incorrect pattern synonym types in error messages">#11667</a></dt><dd>Incorrect pattern synonym types in error messages</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/11727" title="Allow one type signature for multiple pattern synonyms">#11727</a></dt><dd>Allow one type signature for multiple pattern synonyms</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/11728" title="Core lint errors">#11728</a></dt><dd>Core lint errors</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/11977" title="ghc doesn't agree with its own inferred pattern type">#11977</a></dt><dd>ghc doesn't agree with its own inferred pattern type</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/11985" title="Core lint error on record syntax update/pattern synonym">#11985</a></dt><dd>Core lint error on record syntax update/pattern synonym</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/11986" title="Record fields not defined with pattern synonym in ghci">#11986</a></dt><dd>Record fields not defined with pattern synonym in ghci</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/11987" title="Allow record wildcards with pattern synonyms which are defined in GHCi">#11987</a></dt><dd>Allow record wildcards with pattern synonyms which are defined in GHCi</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/12007" title="Panic when loading file with nested pattern synonyms into ghci">#12007</a></dt><dd>Panic when loading file with nested pattern synonyms into ghci</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/12017" title="GHC panics on pattern synonym ‘kindPrimRep’">#12017</a></dt><dd>GHC panics on pattern synonym ‘kindPrimRep’</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/12024" title="GHC leaks GHC.Prim.~# into type">#12024</a></dt><dd>GHC leaks GHC.Prim.~# into type</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/12061" title="Allow duplicate record fields in pattern synonyms">#12061</a></dt><dd>Allow duplicate record fields in pattern synonyms</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/12094" title="Unlifted types and pattern synonym signatures">#12094</a></dt><dd>Unlifted types and pattern synonym signatures</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/12101" title="Regression: Pattern synonyms make GHCi 8.0.1 crash">#12101</a></dt><dd>Regression: Pattern synonyms make GHCi 8.0.1 crash</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/12108" title="Function type synonym fails in pattern synonym">#12108</a></dt><dd>Function type synonym fails in pattern synonym</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/12109" title="Matching on pattern synonym succeeds compiled with ghc, fails with ghci">#12109</a></dt><dd>Matching on pattern synonym succeeds compiled with ghc, fails with ghci</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/12153" title="Bug in pattern synonyms with template haskell">#12153</a></dt><dd>Bug in pattern synonyms with template haskell</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/12165" title="Multiple pattern type signatures accepted">#12165</a></dt><dd>Multiple pattern type signatures accepted</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/12166" title="Pattern synonym existential variable confusion">#12166</a></dt><dd>Pattern synonym existential variable confusion</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/12366" title="Use TypeOperators for pattern synonyms?">#12366</a></dt><dd>Use TypeOperators for pattern synonyms?</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/12426" title="Allow smart constructors their own types">#12426</a></dt><dd>Allow smart constructors their own types</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/12456" title="Panics when making a quotation as pattern synonym">#12456</a></dt><dd>Panics when making a quotation as pattern synonym</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/12489" title="undefined in view pattern inside pattern synonym causes GHC to panic">#12489</a></dt><dd>undefined in view pattern inside pattern synonym causes GHC to panic</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/12548" title="Exported pattern synonyms does not mark top-level bindings in RHS as used">#12548</a></dt><dd>Exported pattern synonyms does not mark top-level bindings in RHS as used</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/12615" title="Record pattern synonyms cause spurious name shadowing warnings">#12615</a></dt><dd>Record pattern synonyms cause spurious name shadowing warnings</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/12697" title="Improve output of pattern synonym info">#12697</a></dt><dd>Improve output of pattern synonym info</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/12698" title="GHC panic on pattern synonym">#12698</a></dt><dd>GHC panic on pattern synonym</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/12746" title="Assertion failed with  BuildFlavour = devel2 (one more)">#12746</a></dt><dd>Assertion failed with  BuildFlavour = devel2 (one more)</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/12767" title="Pattern synonyms for Cont, Writer, Reader, State, ...">#12767</a></dt><dd>Pattern synonyms for Cont, Writer, Reader, State, ...</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/12872" title="Pattern synonyms allow multiple type signatures but only use the first">#12872</a></dt><dd>Pattern synonyms allow multiple type signatures but only use the first</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/13022" title="Pattern Synonyms using other synonyms causes ghc panic">#13022</a></dt><dd>Pattern Synonyms using other synonyms causes ghc panic</dd><dt><a class="closed" href="https://ghc.haskell.org/trac/ghc/ticket/13071" title="GHCi 8.0.1 panic with PatternSynonyms">#13071</a></dt><dd>GHCi 8.0.1 panic with PatternSynonyms</dd></dl></div><p>
</p>
</div>
          
          <div class="trac-modifiedby">
            <span><a href="https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms?action=diff&amp;version=76" title="Version 76 by mpickering">Last modified</a> <a class="timeline" href="https://ghc.haskell.org/trac/ghc/timeline?from=2016-06-12T10%3A34%3A36Z&amp;precision=second" title="See timeline at Jun 12, 2016 10:34:36 AM">7 months ago</a></span>
            <span class="trac-print">Last modified on Jun 12, 2016 10:34:36 AM</span>
          </div>
        
        
      </div>
        </div>
      </div>
    </div>
    <div id="altlinks">
      <h3>Download in other formats:</h3>
      <ul>
        <li class="last first">
          <a rel="nofollow" href="https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms?format=txt">Plain Text</a>
        </li>
      </ul>
    </div>
    </div>
    <div id="footer" lang="en" xml:lang="en"><hr />
      <a id="tracpowered" href="http://trac.edgewall.org/"><img src="https://ghc.haskell.org/trac-1.0.7-htdocs/trac_logo_mini.png" height="30" width="107" alt="Trac Powered" /></a>
      <p class="left">Powered by <a href="https://ghc.haskell.org/trac/ghc/about"><strong>Trac 1.0.9</strong></a><br />
        By <a href="http://www.edgewall.org/">Edgewall Software</a>.</p>
      <p class="right">Visit the Trac open source project at<br /><a href="http://trac.edgewall.org/">http://trac.edgewall.org/</a></p>
    </div>
  </body>

Providence Salumu
</html>