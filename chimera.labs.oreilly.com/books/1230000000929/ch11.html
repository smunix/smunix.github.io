<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<!-- Mirrored from chimera.labs.oreilly.com/books/1230000000929/ch11.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 23 Dec 2016 08:33:23 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head><script type="text/javascript">var NREUMQ=NREUMQ||[];NREUMQ.push(["mark","firstbyte",new Date().getTime()]);</script>
	<title>Parallel and Concurrent Programming in Haskell</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link href="http://dwn0odqttrkhc.cloudfront.net/assets/book-f1caceafd9c9f3a6ff72d40c54d173ab.css" media="screen" rel="stylesheet" type="text/css" />
	<link href="http://dwn0odqttrkhc.cloudfront.net/assets/default-24583441b4f47382b8932338cd56ed23.css" media="screen" rel="stylesheet" type="text/css" />
	<script src="http://dwn0odqttrkhc.cloudfront.net/assets/application-47d6ffb0c77b868d29a43eb65e940505.js" type="text/javascript"></script>
	<script src="http://dwn0odqttrkhc.cloudfront.net/assets/book-756862b9ed04d945ca53de5b8f106a83.js" type="text/javascript"></script>
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	<link href="http://dwn0odqttrkhc.cloudfront.net/assets/janrain-53eb5abed55992e21943b9d3373923e8.css" media="all" rel="stylesheet" type="text/css" />
	<meta content="authenticity_token" name="csrf-param" />
<meta content="WQ02oEFDbvBG99rmf8rwvGssMqcy27cCD64yZVVTcMY=" name="csrf-token" />
	<script type="text/javascript" charset="utf-8">
  	
		app.data = new classes.Data({"controller":{"controller":"books","action":"html"},"capturable":{"capture_server":"https://oreilly.janraincapture.com","client_id":"6n5q2k9vesqgn93k3mhevka6c3c3rsre","app_url":"https://login.oreilly.com","app_id":"xsnca5wmqe9vxv97ygh5vfejkd","load_js":"d16s8pqtk4uodx.cloudfront.net/login.oreilly.com/load.js"},"user":{"id":null,"account":"LoggedOutAccount","email":"","name":null,"gravatar_url":"http://www.gravatar.com/avatar/d41d8cd98f00b204e9800998ecf8427e?s=40&d=identicon"},"book":{"isbn":"1230000000929","chapter":"ch11.html","toc_url":"/books/1230000000929/toc_html","metadata_url":"http://d4bb7yl96lyl1.cloudfront.net/1230000000929/metadata/metadata_9b2ac4d71a3220a7d463d8d4c80f9113048bb194.json"},"abilities":{"can_destroy_all_comments":false,"can_create_comments":false},"advertisement":{"body":"<style>      \r\n.ad-profile-image {\r\n  padding: 0;\r\n  margin: 0;\r\n  max-height: 30px;\r\n }\r\n\r\n.top-banner {\r\n  position: absolute;\r\n  right: 0;\r\n  top: 34px;\r\n  z-index: 99999;\r\n}\r\n\r\np.banner-text {\r\n  margin: 0;\r\n  text-align: center;\r\n  padding-right: 10px;\r\n  width: 450px;\r\n}\r\n\r\n@media screen and (max-width: 600px) {\r\n   p.banner-text {\r\n     width: 100%;\r\n     text-align: center;\r\n  }\r\n}\r\n\r\nspan.ebook-advantage {\r\n  font-size: smaller;\r\n  display: block;\r\n}\r\n\r\ndiv.banner-container {\r\n  margin: 0 auto;\r\n}\r\n\r\ndiv.banner-container ul {\r\n  margin: 0 auto;\r\n}\r\n\r\ndiv.topad { padding-bottom: 5px; }\r\n\r\ndiv.banner-container ul li {\r\n  display: inline-block;\r\n  vertical-align: middle;\r\n}\r\n\r\ndiv.banner-container li p {\r\n  padding-top: 0;\r\n  margin-top: 0;\r\n}\r\n\r\ndiv.banner-container li.sponsor {\r\n  border-right: 1px solid rgb(125, 154, 180);\r\n  margin-right: 5px;\r\n  padding-right: 10px;\r\n}\r\n\r\ndiv.banner-container .webbutton {\r\n  background-color: #3994b6;\r\n  display: inline-block;\r\n  padding: 10px;\r\n  -webkit-border-radius: 5px;\r\n  -moz-border-radius: 5px;\r\n  border-radius: 5px;\r\n  color: #FFF;\r\n  text-align: center;\r\n  text-decoration: none;\r\n  font-size: 12px;\r\n  font-weight: bold;\r\n}\r\n\r\n</style>\r\n   \r\n<div style=\"color: rgb(125, 154, 180);\">\r\n\r\n<div class=\"banner-container\">\r\n\r\n<ul>\r\n\r\n<li class=\"sponsor\">\r\n<!--CONFERENCE SPONSOR IMAGE-->\r\n<a href=\"http://www.oscon.com/oscon2013\">\r\n<!--<img src=\"http://orm-other.s3.amazonaws.com/fluent_logo.png\" class=\"ad-profile-image\"/>-->\r\n<img src=\"http://orm-other.s3.amazonaws.com/oscon_logo.png\" class=\"ad-profile-image\"/>\r\n<!--<img src=\"http://orm-other.s3.amazonaws.com/strata_logo.png\" class=\"ad-profile-image\"/>\r\n<img src=\"http://orm-other.s3.amazonaws.com/StrataRx_logo.png\" class=\"ad-profile-image\"/>\r\n<img src=\"http://orm-other.s3.amazonaws.com/velocity_logo.png\" class=\"ad-profile-image\"/>-->\r\n</a>\r\n</li>\r\n\r\n<li>\r\n<!--AD TEXT, 2 LINES, REPLACE LINK URL AS WELL-->\r\n<p class=\"banner-text\">Enjoy this online version of <em>Parallel and Concurrent Programming in Haskell</em>. Purchase and download the DRM-free ebook on <a href=\"http://shop.oreilly.com/product/0636920026365.do\">oreilly.com</a>.<span class=\"ebook-advantage\">Learn more about the O’Reilly <a href=\"http://shop.oreilly.com/category/ebooks.do\">Ebook Advantage</a>.</span></p>\r\n</li>\r\n\r\n<li>\r\n<!--BUY BUTTON-->\r\n<a class=\"webbutton\" href=\"http://shop.oreilly.com/product/0636920026365.do\">Buy the Ebook</a>\r\n</li> \r\n\r\n</ul>\r\n\r\n</div>\r\n\r\n<!--CORNER BANNER (IF NEEDED)-->\r\n<!--<a href=\"http://shop.oreilly.com/product/0636920026365.do\" class=\"top-banner\"><img src=\"http://orm-other.s3.amazonaws.com/banner.png\" /></a>-->\r\n\r\n</div>"}});

		/* Janrain setup */
  	var janrainModal = new JanrainView();
  	$("head").append(janrainModal.render().el);

  	/* segment.io setup */
  	var analytics=analytics||[];analytics.load=function(e){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src=("https:"===document.location.protocol?"https://":"http://")+"d2dq2ahtl5zl1z.cloudfront.net/analytics.js/v1/"+e+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(t,n);var r=function(e){return function(){analytics.push([e].concat(Array.prototype.slice.call(arguments,0)))}},i=["identify","track","trackLink","trackForm","trackClick","trackSubmit","pageview","ab","alias","ready"];for(var s=0;s<i.length;s++)analytics[i[s]]=r(i[s])};
  	
  	analytics.load("hg9h6b9pae");

  	$(function() {
			app.bookapp = new BookApp();
		});
	
	</script>
</head>
<body>
	<div id="menu">
	
		<ul id="menu-left">
			<li id="home-link"><a href="http://chimera.labs.oreilly.com/"><i class="icon-house"></i></a></li>
			<li><a href="http://chimera.labs.oreilly.com/books/1230000000929">Parallel and Concurrent Programming in Haskell</a></li>
			<div class="clear"></div>
		</ul>
	
		<ul id="menu-right">
			<li id="comments-link"><a>&nbsp;</a></li>
			<li>
				<a href="#" class="dropdown-toggle" data-toggle="dropdown">Chapters</a>
				<div id="toc-popup" class="dropdown-menu"></div>
			</li>
				<li><a href="#" class="capture_modal_open" id="capture_signin_link">Log In / Sign Up</a></li>
			<li id="search-li">
				<form accept-charset="UTF-8" action="http://chimera.labs.oreilly.com/searches" id="search-form" method="get"><div style="margin:0;padding:0;display:inline"><input name="utf8" type="hidden" value="&#x2713;" /></div>
	<input name='search[q]' type="text" placeholder="Search book..." id="book-search" />

	<input id="search_bookId" name="search[bookId]" type="hidden" value="1230000000929" />
	
	<div style='display:none'>
		sorted by: 
		<select name='search[sort]' >
			<option value='relevance'>Relevance</option>
			<option value='authors'>Author(s)</option>
			<option value='title'>Title</option>
		</select>
		returning
		<select name='search[limit]' >
			<option value='5'>5</option>
			<option value='10'>10</option>
			<option value='20'>20</option>
			<option selected="selected" value='50'>50</option>
			<option value='100'>100</option>
		</select>
		values at a time.
	</div>
</form>
			</li>
			<div class="clear"></div>
		</ul>
		<div class="clear"></div>
	
</div>
	<header><div class="navheader">
<table style="width: 100%; ">
<tr><td style="text-align: center; " colspan="3">Chapter 11. Higher-Level Concurrency Abstractions</td></tr>
<tr>
<td style="width: 20%; text-align: left; ">
<a accesskey="p" href="ch10.html">Prev</a> </td>
<td style="width: 60%; text-align: center; ">Part II. Concurrent Haskell</td>
<td style="width: 20%; text-align: right; "> <a accesskey="n" href="ch12.html">Next</a>
</td>
</tr>
</table>
<hr>
</div></header><section class="chapter" data-original-filename="ch11_conc-higher.asciidoc" id="sec_conc-higher"><div class="titlepage"><div><div><h2 class="title">Chapter 11. Higher-Level Concurrency Abstractions</h2></div></div></div>
<p id="concurrencythe_"><a id="ix_ch11_conc-higher-txt0" class="indexterm"></a>The preceding sections covered the basic interfaces for writing
concurrent code in Haskell.  These are enough for simple tasks, but
for larger and more complex programs we need to raise the level of
abstraction.</p>
<p id="conc-higher_00000000">The previous chapters developed the <code class="literal">Async</code> interface for
performing operations asynchronously and waiting for the results.  In
this chapter, we will be revisiting that interface and expanding it
with some more sophisticated functionality.  In particular, we will
provide a way to create an <code class="literal">Async</code> that is automatically cancelled if
its parent dies and then use this to build more compositional
functionality.</p>
<p id="conc-higher_00000001">What we are aiming for is the ability to <a id="id468489" class="indexterm"></a><a id="id468494" class="indexterm"></a><a id="id468502" class="indexterm"></a><a id="id468510" class="indexterm"></a>build <span class="emphasis"><em>trees of threads</em></span>,
such that when a thread dies for whatever reason, two things happen:
any children it has are automatically terminated, and its parent is
informed.  Thus the tree is always collapsed from the bottom up, and
no threads are ever left running accidentally.  Furthermore, all
threads are given a chance to clean up when they die, by handling
exceptions.</p>
<div class="sect1" data-original-filename="ch11_conc-higher.asciidoc" id="sec_conc-withasync">
<div class="titlepage"><div><div><h2 class="title">Avoiding Thread Leakage</h2></div></div></div>
<p id="conc-higher_00000002"><a id="ix_ch11_conc-higher-txt1" class="indexterm"></a><a id="ix_ch11_conc-higher-txt2" class="indexterm"></a>Let’s review the last version of <a id="id468570" class="indexterm"></a>the <code class="literal">Async</code> API that we encountered
from <a class="xref" href="ch10.html#sec_stm-async" title="Async Revisited">“Async Revisited”</a>:</p>
<pre class="programlisting" data-language="haskell" id="data_async_asyn"><code class="kr">data</code> <code class="kt">Async</code>

<code class="nf">async</code>        <code class="ow">::</code> <code class="kt">IO</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">Async</code> <code class="n">a</code><code class="p">)</code>
<code class="nf">cancel</code>       <code class="ow">::</code> <code class="kt">Async</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code>

<code class="nf">waitCatchSTM</code> <code class="ow">::</code> <code class="kt">Async</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="p">(</code><code class="kt">Either</code> <code class="kt">SomeException</code> <code class="n">a</code><code class="p">)</code>
<code class="nf">waitCatch</code>    <code class="ow">::</code> <code class="kt">Async</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">Either</code> <code class="kt">SomeException</code> <code class="n">a</code><code class="p">)</code>

<code class="nf">waitSTM</code>      <code class="ow">::</code> <code class="kt">Async</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="n">a</code>
<code class="nf">wait</code>         <code class="ow">::</code> <code class="kt">Async</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">a</code>

<code class="nf">waitEither</code>   <code class="ow">::</code> <code class="kt">Async</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Async</code> <code class="n">b</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">Either</code> <code class="n">a</code> <code class="n">b</code><code class="p">)</code></pre>
<p id="conc-higher_00000008">Now we’ll define a way to create <a id="id468965" class="indexterm"></a><a id="id468973" class="indexterm"></a><a id="id468979" class="indexterm"></a>an <code class="literal">Async</code> that is automatically
cancelled if the current thread dies.  A good motivation for this
arises from the example we had in <a class="xref" href="ch08.html#sec_conc-mvar-errors" title="Error Handling with Async">“Error Handling with Async”</a>,
<span class="emphasis"><em>geturls4.hs</em></span>, which contains the following code:</p>
<pre class="programlisting" data-language="haskell" id="main__do_a__id2"><code class="nf">main</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">a1</code> <code class="ow">&lt;-</code> <code class="n">async</code> <code class="p">(</code><code class="n">getURL</code> <code class="s">"http://www.wikipedia.org/wiki/Shovel"</code><code class="p">)</code>
  <code class="n">a2</code> <code class="ow">&lt;-</code> <code class="n">async</code> <code class="p">(</code><code class="n">getURL</code> <code class="s">"http://www.wikipedia.org/wiki/Spade"</code><code class="p">)</code>
  <code class="n">r1</code> <code class="ow">&lt;-</code> <code class="n">wait</code> <code class="n">a1</code>
  <code class="n">r2</code> <code class="ow">&lt;-</code> <code class="n">wait</code> <code class="n">a2</code>
  <code class="n">print</code> <code class="p">(</code><code class="kt">B</code><code class="o">.</code><code class="n">length</code> <code class="n">r1</code><code class="p">,</code> <code class="kt">B</code><code class="o">.</code><code class="n">length</code> <code class="n">r2</code><code class="p">)</code></pre>
<p id="conc-higher_00000010">Consider what happens when the first <code class="literal">Async</code>, <code class="literal">a1</code>, fails with an
exception.  The first <code class="literal">wait</code> operation throws the same exception,
which gets propagated up to the top of <code class="literal">main</code>, resulting in program
termination.  But this is untidy: we left <code class="literal">a2</code> running, and if this
had been deep in a program, we would be not only leaking a thread, but
also leaving some I/O running in the background.</p>
<p id="conc-higher_00000011">What we would like to do is create an <code class="literal">Async</code> and install an <a id="id469253" class="indexterm"></a><a id="id469262" class="indexterm"></a>exception
handler that cancels the <code class="literal">Async</code> should an exception be raised.  This
is a typical resource acquire/release pattern, and Haskell has a good
abstraction for that: the <code class="literal">bracket</code> function.  Here is the general pattern:</p>
<pre class="programlisting" data-language="haskell" id="bracket_async_">  <code class="n">bracket</code> <code class="p">(</code><code class="n">async</code> <em class="replaceable"><code><code class="nf">io</code></code></em><code class="p">)</code> <code class="n">cancel</code> <em class="replaceable"><code><code class="nf">operation</code></code></em></pre>
<p id="conc-higher_00000014">Here, <em class="replaceable"><code>io</code></em> is the IO action to perform
asynchronously and <em class="replaceable"><code>operation</code></em> is the
code to execute while <em class="replaceable"><code>io</code></em> is running.
Typically, <em class="replaceable"><code>operation</code></em> will include a
<code class="literal">wait</code> to get the result of the <code class="literal">Async</code>.  For example, we could
rewrite <span class="emphasis"><em>geturls4.hs</em></span> in this way:</p>
<pre class="programlisting" data-language="haskell" id="main__do_brack"><code class="nf">main</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">bracket</code> <code class="p">(</code><code class="n">async</code> <code class="p">(</code><code class="n">getURL</code> <code class="s">"http://www.wikipedia.org/wiki/Shovel"</code><code class="p">))</code>
          <code class="n">cancel</code> <code class="o">$</code> <code class="nf">\</code><code class="n">a1</code> <code class="ow">-&gt;</code> <code class="kr">do</code>
  <code class="n">bracket</code> <code class="p">(</code><code class="n">async</code> <code class="p">(</code><code class="n">getURL</code> <code class="s">"http://www.wikipedia.org/wiki/Shovel"</code><code class="p">))</code>
          <code class="n">cancel</code> <code class="o">$</code> <code class="nf">\</code><code class="n">a2</code> <code class="ow">-&gt;</code> <code class="kr">do</code>
  <code class="n">r1</code> <code class="ow">&lt;-</code> <code class="n">wait</code> <code class="n">a1</code>
  <code class="n">r2</code> <code class="ow">&lt;-</code> <code class="n">wait</code> <code class="n">a2</code>
  <code class="n">print</code> <code class="p">(</code><code class="kt">B</code><code class="o">.</code><code class="n">length</code> <code class="n">r1</code><code class="p">,</code> <code class="kt">B</code><code class="o">.</code><code class="n">length</code> <code class="n">r2</code><code class="p">)</code></pre>
<p id="conc-higher_00000016">But this is a bit of a mouthful.  Let’s package up the <code class="literal">bracket</code>
pattern into a function <a id="id469637" class="indexterm"></a>instead:</p>
<pre class="programlisting" data-language="haskell" id="withasync__io_id1"><code class="nf">withAsync</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="p">(</code><code class="kt">Async</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">b</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">b</code>
<code class="nf">withAsync</code> <code class="n">io</code> <code class="n">operation</code> <code class="ow">=</code> <code class="n">bracket</code> <code class="p">(</code><code class="n">async</code> <code class="n">io</code><code class="p">)</code> <code class="n">cancel</code> <code class="n">operation</code></pre>
<p id="conc-higher_00000018">Now our <code class="literal">main</code> function becomes:</p>
<p id="conc-higher_00000019" class="caption"><span class="emphasis"><em>geturls7.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="main__withasyn"><code class="nf">main</code> <code class="ow">=</code>
  <code class="n">withAsync</code> <code class="p">(</code><code class="n">getURL</code> <code class="s">"http://www.wikipedia.org/wiki/Shovel"</code><code class="p">)</code> <code class="o">$</code> <code class="nf">\</code><code class="n">a1</code> <code class="ow">-&gt;</code>
  <code class="n">withAsync</code> <code class="p">(</code><code class="n">getURL</code> <code class="s">"http://www.wikipedia.org/wiki/Spade"</code><code class="p">)</code>  <code class="o">$</code> <code class="nf">\</code><code class="n">a2</code> <code class="ow">-&gt;</code> <code class="kr">do</code>
  <code class="n">r1</code> <code class="ow">&lt;-</code> <code class="n">wait</code> <code class="n">a1</code>
  <code class="n">r2</code> <code class="ow">&lt;-</code> <code class="n">wait</code> <code class="n">a2</code>
  <code class="n">print</code> <code class="p">(</code><code class="kt">B</code><code class="o">.</code><code class="n">length</code> <code class="n">r1</code><code class="p">,</code> <code class="kt">B</code><code class="o">.</code><code class="n">length</code> <code class="n">r2</code><code class="p">)</code></pre>
<p id="conc-higher_00000020">This is an improvement over <span class="emphasis"><em>geturls6.hs</em></span>. Now the second <code class="literal">Async</code> is
cleaned up if the first one fails.<a id="id470050" class="indexterm"></a><a id="id470060" class="indexterm"></a></p>
</div>
<div class="sect1" data-original-filename="ch11_conc-higher.asciidoc" id="sec_conc-symmetric">
<div class="titlepage"><div><div><h2 class="title">Symmetric Concurrency Combinators</h2></div></div></div>
<p id="conc-higher_00000021"><a id="ix_ch11_conc-higher-txt3" class="indexterm"></a><a id="ix_ch11_conc-higher-txt4" class="indexterm"></a>Take another look at the example at the end of the previous section.
The behavior in the event of failure is lopsided: if <code class="literal">a1</code> fails, then the alarm is raised immediately, but if <code class="literal">a2</code> fails, then the program waits for a result from <code class="literal">a1</code> before it notices the failure of <code class="literal">a2</code>.
Ideally, we should be able to write this symmetrically so that we
notice the failure of either <code class="literal">a1</code> or <code class="literal">a2</code>, whichever one happens
first.  This is somewhat like <a id="id470150" class="indexterm"></a>the <code class="literal">waitEither</code> operation that we
defined earlier:</p>
<pre class="programlisting" data-language="haskell" id="waiteither__a_id4"><code class="nf">waitEither</code> <code class="ow">::</code> <code class="kt">Async</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Async</code> <code class="n">b</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">Either</code> <code class="n">a</code> <code class="n">b</code><code class="p">)</code></pre>
<p id="conc-higher_00000023">But here we want to wait for <span class="emphasis"><em>both</em></span> results and terminate
early if either <code class="literal">Async</code> raises an exception.  By analogy with
<code class="literal">waitEither</code>, let’s call it <code class="literal">waitBoth</code>:</p>
<pre class="programlisting" data-language="haskell" id="waitboth__asy_id1"><code class="nf">waitBoth</code> <code class="ow">::</code> <code class="kt">Async</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Async</code> <code class="n">b</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="n">a</code><code class="p">,</code><code class="n">b</code><code class="p">)</code></pre>
<p id="conc-higher_00000025">Indeed, we can program <code class="literal">waitBoth</code> rather succinctly, thanks to <a id="id470365" class="indexterm"></a><a id="id470371" class="indexterm"></a>STM’s
<code class="literal">orElse</code> combinator:</p>
<pre class="programlisting" data-language="haskell" id="waitboth__asy_id2"><code class="nf">waitBoth</code> <code class="ow">::</code> <code class="kt">Async</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Async</code> <code class="n">b</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="n">a</code><code class="p">,</code><code class="n">b</code><code class="p">)</code>
<code class="nf">waitBoth</code> <code class="n">a1</code> <code class="n">a2</code> <code class="ow">=</code>
  <code class="n">atomically</code> <code class="o">$</code> <code class="kr">do</code>
    <code class="n">r1</code> <code class="ow">&lt;-</code> <code class="n">waitSTM</code> <code class="n">a1</code> <code class="p">`</code><code class="n">orElse</code><code class="p">`</code> <code class="p">(</code><code class="kr">do</code> <code class="n">waitSTM</code> <code class="n">a2</code><code class="p">;</code> <code class="n">retry</code><code class="p">)</code> <code class="c1">-- </code><span id="waitBoth-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
    <code class="n">r2</code> <code class="ow">&lt;-</code> <code class="n">waitSTM</code> <code class="n">a2</code>
    <code class="n">return</code> <code class="p">(</code><code class="n">r1</code><code class="p">,</code><code class="n">r2</code><code class="p">)</code>
</pre>
<p id="conc-higher_00000027">It is worth considering the different cases to convince yourself that
line <a class="xref" href="ch11.html#waitBoth-1"><span><img src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1" border="0"></span></a> has the right behavior:</p>
<div class="itemizedlist" id="if_a_threw_an__id1"><ul class="itemizedlist">
<li class="listitem">
If <code class="literal">a1</code> threw an exception, then the exception is re-thrown here
  (remember that if an <code class="literal">Async</code> results in an exception, it is
  re-thrown by <code class="literal">waitSTM</code>).
</li>
<li class="listitem">
If <code class="literal">a1</code> returned a result, then we proceed to the next line and wait for
  <code class="literal">a2</code>'s result.
</li>
<li class="listitem">
<p id="if_waitstm_a_r_id1" class="simpara">
If <code class="literal">waitSTM a1</code> retries, then we enter the right side of <code class="literal">orElse</code>:
</p>
<div class="itemizedlist" id="if_a_threw_an__id3"><ul class="itemizedlist">
<li class="listitem">
If <code class="literal">a2</code> threw an exception, then the exception is re-thrown here.
</li>
<li class="listitem">
If <code class="literal">a2</code> returned a result, then we ignore it and call <code class="literal">retry</code>, so the
    whole transaction retries.  This case might seem
    counterintuitive, but the purpose of calling <code class="literal">waitSTM a2</code> here
    was to check whether <code class="literal">a2</code> had thrown an exception. We aren’t
    interested in its result yet because we know that <code class="literal">a1</code> has still
    not completed.
</li>
<li class="listitem">
If <code class="literal">waitSTM a2</code> retries, then the whole transaction retries.
</li>
</ul></div>
</li>
</ul></div>
<p id="conc-higher_00000028">Now, <a id="id470798" class="indexterm"></a><a id="id470806" class="indexterm"></a>using <code class="literal">withAsync</code> and <code class="literal">waitBoth</code>, we can build a nice symmetric
function that runs two <code class="literal">IO</code> actions concurrently but aborts if either
one fails with an exception:</p>
<pre class="programlisting" data-language="haskell" id="concurrently_"><code class="nf">concurrently</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">b</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="n">a</code><code class="p">,</code><code class="n">b</code><code class="p">)</code>
<code class="nf">concurrently</code> <code class="n">ioa</code> <code class="n">iob</code> <code class="ow">=</code>
  <code class="n">withAsync</code> <code class="n">ioa</code> <code class="o">$</code> <code class="nf">\</code><code class="n">a</code> <code class="ow">-&gt;</code>
  <code class="n">withAsync</code> <code class="n">iob</code> <code class="o">$</code> <code class="nf">\</code><code class="n">b</code> <code class="ow">-&gt;</code>
    <code class="n">waitBoth</code> <code class="n">a</code> <code class="n">b</code></pre>
<p id="conc-higher_00000030">Finally, we can rewrite <span class="emphasis"><em>geturls7.hs</em></span> to use <code class="literal">concurrently</code>:</p>
<p id="conc-higher_00000031" class="caption"><span class="emphasis"><em>geturls8.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="main__do_rr"><code class="nf">main</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="p">(</code><code class="n">r1</code><code class="p">,</code><code class="n">r2</code><code class="p">)</code> <code class="ow">&lt;-</code> <code class="n">concurrently</code>
               <code class="p">(</code><code class="n">getURL</code> <code class="s">"http://www.wikipedia.org/wiki/Shovel"</code><code class="p">)</code>
               <code class="p">(</code><code class="n">getURL</code> <code class="s">"http://www.wikipedia.org/wiki/Spade"</code><code class="p">)</code>
  <code class="n">print</code> <code class="p">(</code><code class="kt">B</code><code class="o">.</code><code class="n">length</code> <code class="n">r1</code><code class="p">,</code> <code class="kt">B</code><code class="o">.</code><code class="n">length</code> <code class="n">r2</code><code class="p">)</code></pre>
<p id="conc-higher_00000032">What if we wanted to download a list of URLs at the same time?  <a id="id471204" class="indexterm"></a><a id="id471210" class="indexterm"></a>The
<code class="literal">concurrently</code> function takes only two arguments, but we can fold it
over a list, provided that we use a small wrapper to rebuild the list of
results:</p>
<p id="conc-higher_00000033" class="caption"><span class="emphasis"><em>geturls9.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="main__do_xs_"><code class="nf">main</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">xs</code> <code class="ow">&lt;-</code> <code class="n">foldr</code> <code class="n">conc</code> <code class="p">(</code><code class="n">return</code> <code class="kt">[]</code><code class="p">)</code> <code class="p">(</code><code class="n">map</code> <code class="n">getURL</code> <code class="n">sites</code><code class="p">)</code>
  <code class="n">print</code> <code class="p">(</code><code class="n">map</code> <code class="kt">B</code><code class="o">.</code><code class="n">length</code> <code class="n">xs</code><code class="p">)</code>
 <code class="kr">where</code>
  <code class="n">conc</code> <code class="n">ioa</code> <code class="n">ioas</code> <code class="ow">=</code> <code class="kr">do</code>
    <code class="p">(</code><code class="n">a</code><code class="p">,</code><code class="n">as</code><code class="p">)</code> <code class="ow">&lt;-</code> <code class="n">concurrently</code> <code class="n">ioa</code> <code class="n">ioas</code>
    <code class="n">return</code> <code class="p">(</code><code class="n">a</code><code class="kt">:</code><code class="n">as</code><code class="p">)</code></pre>
<p id="conc-higher_00000034">The <code class="literal">concurrently</code> function has a companion; if we swap <code class="literal">waitBoth</code> <a id="id471487" class="indexterm"></a>for
<code class="literal">waitEither</code>, we get a different but equally useful function:</p>
<pre class="programlisting" data-language="haskell" id="race__io_a_"><code class="nf">race</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">b</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">Either</code> <code class="n">a</code> <code class="n">b</code><code class="p">)</code>
<code class="nf">race</code> <code class="n">ioa</code> <code class="n">iob</code> <code class="ow">=</code>
  <code class="n">withAsync</code> <code class="n">ioa</code> <code class="o">$</code> <code class="nf">\</code><code class="n">a</code> <code class="ow">-&gt;</code>
  <code class="n">withAsync</code> <code class="n">iob</code> <code class="o">$</code> <code class="nf">\</code><code class="n">b</code> <code class="ow">-&gt;</code>
    <code class="n">waitEither</code> <code class="n">a</code> <code class="n">b</code></pre>
<p id="conc-higher_00000036"><a id="id471688" class="indexterm"></a>The <code class="literal">race</code> function runs two <code class="literal">IO</code> actions concurrently, but as
soon as one of them returns a result or throws an exception, the other
is immediately cancelled.  Hence the name <code class="literal">race</code>: the two <code class="literal">IO</code> actions are
racing to produce a result.  As we shall see later, <code class="literal">race</code> is quite
useful when we need to fork two threads while letting either one terminate
the other by just returning.</p>
<p id="conc-higher_00000037">These two functions<a id="id471735" class="indexterm"></a>, <code class="literal">race</code> and <code class="literal">concurrently</code>, are the essence of
constructing trees of threads.  Each builds a structure like <a class="xref" href="ch11.html#conc-higher_00000038" title="Figure 11-1. Threads created by concurrently">Figure 11-1</a>.</p>
<div class="figure" id="conc-higher_00000038">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_1101.png" alt="Threads created by concurrently"></div></div>
<div class="figure-title">Figure 11-1. Threads created by concurrently</div>
</div>
<p id="conc-higher_00000039">By using multiple <code class="literal">race</code> and <code class="literal">concurrently</code> calls, we can build up
larger trees of threads.  If we use these functions consistently,
we can be sure that the tree of threads constructed will always be
collapsed from the bottom <a id="id471796" class="indexterm"></a><a id="id471805" class="indexterm"></a><a id="id471810" class="indexterm"></a>up:</p>
<div class="itemizedlist" id="conc-higher_00000040"><ul class="itemizedlist">
<li class="listitem">
If a parent throws an exception or receives an asynchronous
  exception, then the children are automatically cancelled.  This happens
  recursively. If the children have children themselves, then they will
  also be cancelled, and so on.
</li>
<li class="listitem">
If one child receives an exception, then its sibling is also
  cancelled.
</li>
<li class="listitem">
The parent chooses whether to wait for a result from both children
  or just one, by using <code class="literal">race</code> or <code class="literal">concurrently</code>, respectively.
</li>
</ul></div>
<p id="conc-higher_00000043">What is particularly nice about this way of building thread trees is
that there is no explicit representation of the tree as a data
structure, which would involve a lot of bookkeeping and would likely
be prone to errors.  The thread tree is completely implicit in the
structure of the calls to <code class="literal">withAsync</code> and hence <code class="literal">concurrently</code> and
<code class="literal">race</code>.</p>
<div class="sect2" id="sec_conc-race-timeout">
<div class="titlepage"><div><div><h3 class="title">Timeouts Using race</h3></div></div></div>
<p id="conc-higher_00000044"><a id="ix_ch11_conc-higher-txt5" class="indexterm"></a><a id="ix_ch11_conc-higher-txt6" class="indexterm"></a><a id="ix_ch11_conc-higher-txt7" class="indexterm"></a><a id="ix_ch11_conc-higher-txt8" class="indexterm"></a>A simple demonstration of the power of <code class="literal">race</code> is an implementation of the <code class="literal">timeout</code> function from <a class="xref" href="ch09.html#sec_timeout" title="Timeouts">“Timeouts”</a>.</p>
<p id="conc-higher_00000045" class="caption"><span class="emphasis"><em>timeout2.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="timeout__int__id2"><code class="nf">timeout</code> <code class="ow">::</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">Maybe</code> <code class="n">a</code><code class="p">)</code>
<code class="nf">timeout</code> <code class="n">n</code> <code class="n">m</code>
    <code class="o">|</code> <code class="n">n</code> <code class="o">&lt;</code>  <code class="mi">0</code>    <code class="ow">=</code> <code class="n">fmap</code> <code class="kt">Just</code> <code class="n">m</code>
    <code class="o">|</code> <code class="n">n</code> <code class="o">==</code> <code class="mi">0</code>    <code class="ow">=</code> <code class="n">return</code> <code class="kt">Nothing</code>
    <code class="o">|</code> <code class="n">otherwise</code> <code class="ow">=</code> <code class="kr">do</code>
        <code class="n">r</code> <code class="ow">&lt;-</code> <code class="n">race</code> <code class="p">(</code><code class="n">threadDelay</code> <code class="n">n</code><code class="p">)</code> <code class="n">m</code>
        <code class="kr">case</code> <code class="n">r</code> <code class="kr">of</code>
          <code class="kt">Left</code> <code class="kr">_</code>  <code class="ow">-&gt;</code> <code class="n">return</code> <code class="kt">Nothing</code>
          <code class="kt">Right</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">return</code> <code class="p">(</code><code class="kt">Just</code> <code class="n">a</code><code class="p">)</code></pre>
<p id="conc-higher_00000046">Most of the code here is administrative: checking for negative and
zero timeout values and converting the <code class="literal">Either () a</code> result of <code class="literal">race</code>
into a <code class="literal">Maybe a</code>.  The core of the implementation is simply <code class="literal">race
(threadDelay n) m</code>.</p>
<p id="conc-higher_00000047">Pedantically speaking, this implementation of <code class="literal">timeout</code> does have a
few differences from the one in <a class="xref" href="ch09.html#sec_timeout" title="Timeouts">“Timeouts”</a>.  First, it doesn’t
have precisely the same semantics in the case where another thread
sends the current thread an exception using <code class="literal">throwTo</code>. With the
original <code class="literal">timeout</code>, the <a id="id472366" class="indexterm"></a>exception would be delivered to the computation
<code class="literal">m</code>, whereas here the exception is delivered to <code class="literal">race</code>, which then
terminates <code class="literal">m</code> with <code class="literal">killThread</code>, and so the exception seen by <code class="literal">m</code>
will be <code class="literal">ThreadKilled</code>, not the original one that was thrown.</p>
<p id="conc-higher_00000048">Secondly, the exception thrown to <code class="literal">m</code> in the case of a timeout is
<code class="literal">ThreadKilled</code>, not a special <code class="literal">Timeout</code> exception.  This might be
important if the thread wanted to act on the <code class="literal">Timeout</code> exception.</p>
<p id="conc-higher_00000049">Finally, <code class="literal">race</code> creates an extra thread, which makes this
implementation of <code class="literal">timeout</code> a little less efficient than the one in
<a class="xref" href="ch09.html#sec_timeout" title="Timeouts">“Timeouts”</a>.  You won’t notice the difference unless <code class="literal">timeout</code> is
in a critical path in your application, though.<a id="id472474" class="indexterm"></a><a id="id472484" class="indexterm"></a><a id="id472494" class="indexterm"></a><a id="id472504" class="indexterm"></a><a id="id472514" class="indexterm"></a><a id="id472524" class="indexterm"></a></p>
</div>
</div>
<div class="sect1" data-original-filename="ch11_conc-higher.asciidoc" id="sec_conc-async-functor">
<div class="titlepage"><div><div><h2 class="title">Adding a Functor Instance</h2></div></div></div>
<p id="conc-higher_00000050"><a id="ix_ch11_conc-higher-txt9" class="indexterm"></a><a id="ix_ch11_conc-higher-txt10" class="indexterm"></a>When an <code class="literal">Async</code> is created, it has a fixed result type corresponding to the type of the value returned by the <code class="literal">IO</code> action.  But this might
be inconvenient: suppose we need to wait for several different
<code class="literal">Async</code>s that have different result types.  We would like to emulate
<a id="id472595" class="indexterm"></a>the <code class="literal">waitAny</code> function defined in <a class="xref" href="ch10.html#sec_stm-async" title="Async Revisited">“Async Revisited”</a>:</p>
<pre class="programlisting" data-language="haskell" id="waitany__asy_id3"><code class="nf">waitAny</code> <code class="ow">::</code> <code class="p">[</code><code class="kt">Async</code> <code class="n">a</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">a</code>
<code class="nf">waitAny</code> <code class="n">asyncs</code> <code class="ow">=</code>
  <code class="n">atomically</code> <code class="o">$</code> <code class="n">foldr</code> <code class="n">orElse</code> <code class="n">retry</code> <code class="o">$</code> <code class="n">map</code> <code class="n">waitSTM</code> <code class="n">asyncs</code></pre>
<p id="conc-higher_00000052">But if our <code class="literal">Async</code>s don’t all have the same result type, then we
can’t put them in a list.  We could force them all to have
the same type when they are created, but that might be difficult,
especially if we use an <code class="literal">Async</code> created by a library function that is
not under our control.</p>
<p id="conc-higher_00000053">A better solution to the problem is to make <code class="literal">Async</code> an instance of
<code class="literal">Functor</code>:</p>
<pre class="programlisting" data-language="haskell" id="class_functor_f"><code class="kr">class</code> <code class="kt">Functor</code> <code class="n">f</code> <code class="kr">where</code>
    <code class="n">fmap</code> <code class="ow">::</code> <code class="p">(</code><code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">b</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="n">f</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">f</code> <code class="n">b</code></pre>
<p id="conc-higher_00000055"><a id="id472878" class="indexterm"></a>The <code class="literal">fmap</code> operation lets us map the result of an
<code class="literal">Async</code> into any type we need.</p>
<p id="conc-higher_00000056">But how can we implement <code class="literal">fmap</code> for <code class="literal">Async</code>?  The type of the result
that the <code class="literal">Async</code> will place in the <code class="literal">TMVar</code> is fixed when we create the
<code class="literal">Async</code>; the definition of <code class="literal">Async</code> is the following:</p>
<pre class="programlisting" data-language="haskell" id="data_async_a___id5"><code class="kr">data</code> <code class="kt">Async</code> <code class="n">a</code> <code class="ow">=</code> <code class="kt">Async</code> <code class="kt">ThreadId</code> <code class="p">(</code><code class="kt">TMVar</code> <code class="p">(</code><code class="kt">Either</code> <code class="kt">SomeException</code> <code class="n">a</code><code class="p">))</code></pre>
<p id="conc-higher_00000058">Instead of storing <a id="id473025" class="indexterm"></a>the <code class="literal">TMVar</code> in the <code class="literal">Async</code>, we need to store
something more compositional that we can compose with the function
argument to <code class="literal">fmap</code> to change the result type.  One solution is to replace
the <code class="literal">TMVar</code> with an <code class="literal">STM</code> computation that returns the same type:</p>
<pre class="programlisting" data-language="haskell" id="data_async_a___id6"><code class="kr">data</code> <code class="kt">Async</code> <code class="n">a</code> <code class="ow">=</code> <code class="kt">Async</code> <code class="kt">ThreadId</code> <code class="p">(</code><code class="kt">STM</code> <code class="p">(</code><code class="kt">Either</code> <code class="kt">SomeException</code> <code class="n">a</code><code class="p">))</code></pre>
<p id="conc-higher_00000060">The change is very minor. We only need to move the <code class="literal">readTMVar</code> call
from <code class="literal">waitCatchSTM</code> to <code class="literal">async</code>:</p>
<pre class="programlisting" data-language="haskell" id="async__io_a__id6"><code class="nf">async</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">Async</code> <code class="n">a</code><code class="p">)</code>
<code class="nf">async</code> <code class="n">action</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">var</code> <code class="ow">&lt;-</code> <code class="n">newEmptyTMVarIO</code>
  <code class="n">t</code> <code class="ow">&lt;-</code> <code class="n">forkFinally</code> <code class="n">action</code> <code class="p">(</code><code class="n">atomically</code> <code class="o">.</code> <code class="n">putTMVar</code> <code class="n">var</code><code class="p">)</code>
  <code class="n">return</code> <code class="p">(</code><code class="kt">Async</code> <code class="n">t</code> <code class="p">(</code><code class="n">readTMVar</code> <code class="n">var</code><code class="p">))</code></pre>
<pre class="programlisting" data-language="haskell" id="waitcatchstm__id2"><code class="nf">waitCatchSTM</code> <code class="ow">::</code> <code class="kt">Async</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="p">(</code><code class="kt">Either</code> <code class="kt">SomeException</code> <code class="n">a</code><code class="p">)</code>
<code class="nf">waitCatchSTM</code> <code class="p">(</code><code class="kt">Async</code> <code class="kr">_</code> <code class="n">stm</code><code class="p">)</code> <code class="ow">=</code> <code class="n">stm</code></pre>
<p id="conc-higher_00000063">And now we can define <code class="literal">fmap</code> by building a new <code class="literal">STM</code> computation that is
composed from the old one by applying the function argument of <code class="literal">fmap</code>
to the result: <a id="id473497" class="indexterm"></a><a id="id473507" class="indexterm"></a></p>
<pre class="programlisting" data-language="haskell" id="instance_functo"><code class="kr">instance</code> <code class="kt">Functor</code> <code class="kt">Async</code> <code class="kr">where</code>
  <code class="n">fmap</code> <code class="n">f</code> <code class="p">(</code><code class="kt">Async</code> <code class="n">t</code> <code class="n">stm</code><code class="p">)</code> <code class="ow">=</code> <code class="kt">Async</code> <code class="n">t</code> <code class="n">stm'</code>
    <code class="kr">where</code> <code class="n">stm'</code> <code class="ow">=</code> <code class="kr">do</code>
            <code class="n">r</code> <code class="ow">&lt;-</code> <code class="n">stm</code>
            <code class="kr">case</code> <code class="n">r</code> <code class="kr">of</code>
              <code class="kt">Left</code> <code class="n">e</code>  <code class="ow">-&gt;</code> <code class="n">return</code> <code class="p">(</code><code class="kt">Left</code> <code class="n">e</code><code class="p">)</code>
              <code class="kt">Right</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">return</code> <code class="p">(</code><code class="kt">Right</code> <code class="p">(</code><code class="n">f</code> <code class="n">a</code><code class="p">))</code></pre>
</div>
<div class="sect1" data-original-filename="ch11_conc-higher.asciidoc" id="_summary_the_async_api">
<div class="titlepage"><div><div><h2 class="title">Summary: The Async API</h2></div></div></div>
<p id="we_visited_the_">We visited the <code class="literal">Async</code> API several times during the course of the
previous few chapters, each time evolving it to add a new feature or
to fix some undesirable behavior.  The addition of the <code class="literal">Functor</code> instance
in the previous section represents the last addition I’ll be making to
<code class="literal">Async</code> in this book, so it seems like a good point to take a step
back and summarize what has been achieved:</p>
<div class="itemizedlist" id="we_started_with_id1"><ul class="itemizedlist">
<li class="listitem">
We started with a simple API to execute an <code class="literal">IO</code> action
  asynchronously (<code class="literal">async</code>) and wait for its result (<code class="literal">wait</code>).
</li>
<li class="listitem">
We modified the implementation to catch exceptions in the
  asynchronous code and propagate them to the <code class="literal">wait</code> call.  This
  avoids a common error in concurrent programming: forgetting to
  handle errors in a child thread.
</li>
<li class="listitem">
We reimplemented the <code class="literal">Async</code> API using STM, which made it possible
  to have efficient implementations of combinators that symmetrically
  wait for multiple <code class="literal">Async</code>s to complete (<code class="literal">waitEither</code>, <code class="literal">waitBoth</code>).
</li>
<li class="listitem">
We added <code class="literal">withAsync</code>, which avoids the accidental leakage of threads
  when an exception occurs in the parent thread, thus avoiding another
  common pitfall in concurrent programming.
</li>
<li class="listitem">
Finally, we combined <code class="literal">withAsync</code> with <code class="literal">waitEither</code> and <code class="literal">waitBoth</code> to
  make the high-level symmetric combinators <code class="literal">race</code> and <code class="literal">concurrently</code>.
  These two operations can be used to build trees of threads that are
  always collapsed from the bottom up and to propagate errors correctly.
</li>
</ul></div>
<p id="the_complete_li">The complete library is available in the <code class="literal">async</code> package on Hackage.<a id="id473931" class="indexterm"></a></p>
</div></section><footer><div class="navfooter">
<hr>
<table style="width: 100%; ">
<tr>
<td style="width: 40%; text-align: left; ">
<a accesskey="p" href="ch10.html">Prev</a> </td>
<td style="width: 20%; text-align: center; "><a accesskey="u" href="pt02.html">Up</a></td>
<td style="width: 40%; text-align: right; "> <a accesskey="n" href="ch12.html">Next</a>
</td>
</tr>
<tr>
<td style="width: 40%; text-align: left; vertical-align: top; ">Chapter 10. Software Transactional Memory </td>
<td style="width: 20%; text-align: center; "><a accesskey="h" href="index.html">Home</a></td>
<td style="width: 40%; text-align: right; vertical-align: top; "> Chapter 12. Concurrent Network Servers</td>
</tr>
</table>
</div></footer>


	<div class="extra-footer">
		<p>© 2013, O’Reilly Media, Inc.</p>
		<ul>
			<li><a href="http://oreilly.com/terms/">Terms of Service</a></li>
			<li><a href="http://oreilly.com/oreilly/privacy.csp">Privacy Policy</a></li>
			<li>Interested in <a href="mailto:scordesse@oreilly.com">sponsoring content?</a></li>
		</ul>
	</div>
<script type="text/javascript">if (!NREUMQ.f) { NREUMQ.f=function() {
NREUMQ.push(["load",new Date().getTime()]);
var e=document.createElement("script");
e.type="text/javascript";
e.src=(("http:"===document.location.protocol)?"http:":"https:") + "//" +
  "js-agent.newrelic.com/nr-100.js";
document.body.appendChild(e);
if(NREUMQ.a)NREUMQ.a();
};
NREUMQ.a=window.onload;window.onload=NREUMQ.f;
};
NREUMQ.push(["nrfj","bam.nr-data.net","3e361aebcf","2194180","IApbRUBZXg1WEEoHDAwORh5aQl8N",7,18,new Date().getTime(),"","","","",""]);</script></body>

<!-- Mirrored from chimera.labs.oreilly.com/books/1230000000929/ch11.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 23 Dec 2016 08:33:23 GMT -->
</html>