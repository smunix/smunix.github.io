<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<!-- Mirrored from chimera.labs.oreilly.com/books/1230000000929/ch03.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 24 Dec 2016 02:18:08 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head><script type="text/javascript">var NREUMQ=NREUMQ||[];NREUMQ.push(["mark","firstbyte",new Date().getTime()]);</script>
	<title>Parallel and Concurrent Programming in Haskell</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link href="http://dwn0odqttrkhc.cloudfront.net/assets/book-f1caceafd9c9f3a6ff72d40c54d173ab.css" media="screen" rel="stylesheet" type="text/css" />
	<link href="http://dwn0odqttrkhc.cloudfront.net/assets/default-24583441b4f47382b8932338cd56ed23.css" media="screen" rel="stylesheet" type="text/css" />
	<script src="http://dwn0odqttrkhc.cloudfront.net/assets/application-47d6ffb0c77b868d29a43eb65e940505.js" type="text/javascript"></script>
	<script src="http://dwn0odqttrkhc.cloudfront.net/assets/book-756862b9ed04d945ca53de5b8f106a83.js" type="text/javascript"></script>
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	<link href="http://dwn0odqttrkhc.cloudfront.net/assets/janrain-53eb5abed55992e21943b9d3373923e8.css" media="all" rel="stylesheet" type="text/css" />
	<meta content="authenticity_token" name="csrf-param" />
<meta content="WQ02oEFDbvBG99rmf8rwvGssMqcy27cCD64yZVVTcMY=" name="csrf-token" />
	<script type="text/javascript" charset="utf-8">
  	
		app.data = new classes.Data({"controller":{"controller":"books","action":"html"},"capturable":{"capture_server":"https://oreilly.janraincapture.com","client_id":"6n5q2k9vesqgn93k3mhevka6c3c3rsre","app_url":"https://login.oreilly.com","app_id":"xsnca5wmqe9vxv97ygh5vfejkd","load_js":"d16s8pqtk4uodx.cloudfront.net/login.oreilly.com/load.js"},"user":{"id":null,"account":"LoggedOutAccount","email":"","name":null,"gravatar_url":"http://www.gravatar.com/avatar/d41d8cd98f00b204e9800998ecf8427e?s=40&d=identicon"},"book":{"isbn":"1230000000929","chapter":"ch03.html","toc_url":"/books/1230000000929/toc_html","metadata_url":"http://d4bb7yl96lyl1.cloudfront.net/1230000000929/metadata/metadata_9b2ac4d71a3220a7d463d8d4c80f9113048bb194.json"},"abilities":{"can_destroy_all_comments":false,"can_create_comments":false},"advertisement":{"body":"<style>      \r\n.ad-profile-image {\r\n  padding: 0;\r\n  margin: 0;\r\n  max-height: 30px;\r\n }\r\n\r\n.top-banner {\r\n  position: absolute;\r\n  right: 0;\r\n  top: 34px;\r\n  z-index: 99999;\r\n}\r\n\r\np.banner-text {\r\n  margin: 0;\r\n  text-align: center;\r\n  padding-right: 10px;\r\n  width: 450px;\r\n}\r\n\r\n@media screen and (max-width: 600px) {\r\n   p.banner-text {\r\n     width: 100%;\r\n     text-align: center;\r\n  }\r\n}\r\n\r\nspan.ebook-advantage {\r\n  font-size: smaller;\r\n  display: block;\r\n}\r\n\r\ndiv.banner-container {\r\n  margin: 0 auto;\r\n}\r\n\r\ndiv.banner-container ul {\r\n  margin: 0 auto;\r\n}\r\n\r\ndiv.topad { padding-bottom: 5px; }\r\n\r\ndiv.banner-container ul li {\r\n  display: inline-block;\r\n  vertical-align: middle;\r\n}\r\n\r\ndiv.banner-container li p {\r\n  padding-top: 0;\r\n  margin-top: 0;\r\n}\r\n\r\ndiv.banner-container li.sponsor {\r\n  border-right: 1px solid rgb(125, 154, 180);\r\n  margin-right: 5px;\r\n  padding-right: 10px;\r\n}\r\n\r\ndiv.banner-container .webbutton {\r\n  background-color: #3994b6;\r\n  display: inline-block;\r\n  padding: 10px;\r\n  -webkit-border-radius: 5px;\r\n  -moz-border-radius: 5px;\r\n  border-radius: 5px;\r\n  color: #FFF;\r\n  text-align: center;\r\n  text-decoration: none;\r\n  font-size: 12px;\r\n  font-weight: bold;\r\n}\r\n\r\n</style>\r\n   \r\n<div style=\"color: rgb(125, 154, 180);\">\r\n\r\n<div class=\"banner-container\">\r\n\r\n<ul>\r\n\r\n<li class=\"sponsor\">\r\n<!--CONFERENCE SPONSOR IMAGE-->\r\n<a href=\"http://www.oscon.com/oscon2013\">\r\n<!--<img src=\"http://orm-other.s3.amazonaws.com/fluent_logo.png\" class=\"ad-profile-image\"/>-->\r\n<img src=\"http://orm-other.s3.amazonaws.com/oscon_logo.png\" class=\"ad-profile-image\"/>\r\n<!--<img src=\"http://orm-other.s3.amazonaws.com/strata_logo.png\" class=\"ad-profile-image\"/>\r\n<img src=\"http://orm-other.s3.amazonaws.com/StrataRx_logo.png\" class=\"ad-profile-image\"/>\r\n<img src=\"http://orm-other.s3.amazonaws.com/velocity_logo.png\" class=\"ad-profile-image\"/>-->\r\n</a>\r\n</li>\r\n\r\n<li>\r\n<!--AD TEXT, 2 LINES, REPLACE LINK URL AS WELL-->\r\n<p class=\"banner-text\">Enjoy this online version of <em>Parallel and Concurrent Programming in Haskell</em>. Purchase and download the DRM-free ebook on <a href=\"http://shop.oreilly.com/product/0636920026365.do\">oreilly.com</a>.<span class=\"ebook-advantage\">Learn more about the O’Reilly <a href=\"http://shop.oreilly.com/category/ebooks.do\">Ebook Advantage</a>.</span></p>\r\n</li>\r\n\r\n<li>\r\n<!--BUY BUTTON-->\r\n<a class=\"webbutton\" href=\"http://shop.oreilly.com/product/0636920026365.do\">Buy the Ebook</a>\r\n</li> \r\n\r\n</ul>\r\n\r\n</div>\r\n\r\n<!--CORNER BANNER (IF NEEDED)-->\r\n<!--<a href=\"http://shop.oreilly.com/product/0636920026365.do\" class=\"top-banner\"><img src=\"http://orm-other.s3.amazonaws.com/banner.png\" /></a>-->\r\n\r\n</div>"}});

		/* Janrain setup */
  	var janrainModal = new JanrainView();
  	$("head").append(janrainModal.render().el);

  	/* segment.io setup */
  	var analytics=analytics||[];analytics.load=function(e){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src=("https:"===document.location.protocol?"https://":"http://")+"d2dq2ahtl5zl1z.cloudfront.net/analytics.js/v1/"+e+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(t,n);var r=function(e){return function(){analytics.push([e].concat(Array.prototype.slice.call(arguments,0)))}},i=["identify","track","trackLink","trackForm","trackClick","trackSubmit","pageview","ab","alias","ready"];for(var s=0;s<i.length;s++)analytics[i[s]]=r(i[s])};
  	
  	analytics.load("hg9h6b9pae");

  	$(function() {
			app.bookapp = new BookApp();
		});
	
	</script>
</head>
<body>
	<div id="menu">
	
		<ul id="menu-left">
			<li id="home-link"><a href="http://chimera.labs.oreilly.com/"><i class="icon-house"></i></a></li>
			<li><a href="http://chimera.labs.oreilly.com/books/1230000000929">Parallel and Concurrent Programming in Haskell</a></li>
			<div class="clear"></div>
		</ul>
	
		<ul id="menu-right">
			<li id="comments-link"><a>&nbsp;</a></li>
			<li>
				<a href="#" class="dropdown-toggle" data-toggle="dropdown">Chapters</a>
				<div id="toc-popup" class="dropdown-menu"></div>
			</li>
				<li><a href="#" class="capture_modal_open" id="capture_signin_link">Log In / Sign Up</a></li>
			<li id="search-li">
				<form accept-charset="UTF-8" action="http://chimera.labs.oreilly.com/searches" id="search-form" method="get"><div style="margin:0;padding:0;display:inline"><input name="utf8" type="hidden" value="&#x2713;" /></div>
	<input name='search[q]' type="text" placeholder="Search book..." id="book-search" />

	<input id="search_bookId" name="search[bookId]" type="hidden" value="1230000000929" />
	
	<div style='display:none'>
		sorted by: 
		<select name='search[sort]' >
			<option value='relevance'>Relevance</option>
			<option value='authors'>Author(s)</option>
			<option value='title'>Title</option>
		</select>
		returning
		<select name='search[limit]' >
			<option value='5'>5</option>
			<option value='10'>10</option>
			<option value='20'>20</option>
			<option selected="selected" value='50'>50</option>
			<option value='100'>100</option>
		</select>
		values at a time.
	</div>
</form>
			</li>
			<div class="clear"></div>
		</ul>
		<div class="clear"></div>
	
</div>
	<header><div class="navheader">
<table style="width: 100%; ">
<tr><td style="text-align: center; " colspan="3">Chapter 3. Evaluation Strategies</td></tr>
<tr>
<td style="width: 20%; text-align: left; ">
<a accesskey="p" href="ch02.html">Prev</a> </td>
<td style="width: 60%; text-align: center; ">Part I. Parallel Haskell</td>
<td style="width: 20%; text-align: right; "> <a accesskey="n" href="ch04.html">Next</a>
</td>
</tr>
</table>
<hr>
</div></header><section class="chapter" data-original-filename="ch03_par-strat.asciidoc" id="sec_par-strategies"><div class="titlepage"><div><div><h2 class="title">Chapter 3. Evaluation Strategies</h2></div></div></div>
<p id="strategyevaluat"><a id="ix_ch03_par-strat-txt0" class="indexterm"></a>Evaluation Strategies, or simply Strategies, are a means for modularizing
parallel code by separating the algorithm from the parallelism.
Sometimes they require you to
rewrite your algorithm, but once you do so, you will be able to
parallelize it in different ways just by substituting a new Strategy.</p>
<p id="par-strat_00000000">Concretely, a <code class="literal">Strategy</code> is a function in <a id="id377120" class="indexterm"></a>the <code class="literal">Eval</code> monad that takes a
value of type <code class="literal">a</code> and returns the same value:</p>
<pre class="programlisting" data-language="haskell" id="type_strategy_a"><code class="kr">type</code> <code class="kt">Strategy</code> <code class="n">a</code> <code class="ow">=</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Eval</code> <code class="n">a</code></pre>
<p id="par-strat_00000002">The idea is that a Strategy takes a data structure as input, traverses
the structure creating parallelism <a id="id377192" class="indexterm"></a><a id="id377199" class="indexterm"></a>with <code class="literal">rpar</code> and <code class="literal">rseq</code>, and then
returns the original value.</p>
<p id="heres_a_simple_id1">Here’s a simple example: Let’s create a Strategy for pairs that
evaluates the two components of the pair in parallel.  We want a
function <code class="literal">parPair</code> with the following type:</p>
<pre class="programlisting" data-language="haskell" id="parpair__stra_id1"><code class="nf">parPair</code> <code class="ow">::</code> <code class="kt">Strategy</code> <code class="p">(</code><code class="n">a</code><code class="p">,</code><code class="n">b</code><code class="p">)</code></pre>
<p id="from_the_defini">From the definition of the <code class="literal">Strategy</code> type previously shown, we know that this
type is the same as <code class="literal">(a,b) -&gt; Eval (a,b)</code>.  So <code class="literal">parPair</code> is a function
that takes a pair, does some computation in the <code class="literal">Eval</code> monad, and
returns the pair again.  Here is its definition:</p>
<p id="straths_code_id1" class="caption"><span class="emphasis"><em>strat.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="parpair__stra_id2"><code class="nf">parPair</code> <code class="ow">::</code> <code class="kt">Strategy</code> <code class="p">(</code><code class="n">a</code><code class="p">,</code><code class="n">b</code><code class="p">)</code>
<code class="nf">parPair</code> <code class="p">(</code><code class="n">a</code><code class="p">,</code><code class="n">b</code><code class="p">)</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">a'</code> <code class="ow">&lt;-</code> <code class="n">rpar</code> <code class="n">a</code>
  <code class="n">b'</code> <code class="ow">&lt;-</code> <code class="n">rpar</code> <code class="n">b</code>
  <code class="n">return</code> <code class="p">(</code><code class="n">a'</code><code class="p">,</code><code class="n">b'</code><code class="p">)</code></pre>
<p id="this_is_similar">This is similar to the <span class="emphasis"><em>rpar/rpar</em></span> pattern that we saw in
<a class="xref" href="ch02.html#sec_par-rpar-rseq" title="The Eval Monad, rpar, and rseq">“The Eval Monad, rpar, and rseq”</a>.  The difference is that we’ve packaged it up
as a Strategy: It takes a data structure (in this case a pair),
creates some parallelism using <code class="literal">rpar</code>, and then returns the same data structure.</p>
<p id="well_see_this_">We’ll see this in action in a moment, but first we need to know how to
use a Strategy.  Using a Strategy consists of applying it to its
input and running <a id="id377489" class="indexterm"></a>the <code class="literal">Eval</code> computation to get the output.  We could
write that directly with <code class="literal">runEval</code>; for example, to evaluate the pair
<code class="literal">(fib 35, fib 36)</code> in parallel, we could write:</p>
<pre class="programlisting" data-language="haskell" id="runeval_parpai">  <code class="n">runEval</code> <code class="p">(</code><code class="n">parPair</code> <code class="p">(</code><code class="n">fib</code> <code class="mi">35</code><code class="p">,</code> <code class="n">fib</code> <code class="mi">36</code><code class="p">))</code></pre>
<p id="this_works_just">This works just fine, but it turns out to be much nicer to package up
the application of a Strategy into a function named <code class="literal">using</code>:</p>
<pre class="screen" id="using__a__s"><code class="nf">using</code> <code class="ow">::</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Strategy</code> <code class="\n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code>
<code class="n">x</code> <code class="p">`</code><code class="nf">using</code><code class="p">`</code> <code class="n">s</code> <code class="ow">=</code> <code class="n">runEval</code> <code class="p">(</code><code class="n">s</code> <code class="n">x</code><code class="p">)</code></pre>
<p id="par-strat_00000011">The <code class="literal">using</code> function<a id="id377684" class="indexterm"></a> takes a value of type <code class="literal">a</code> and a Strategy for <code class="literal">a</code>,
and applies the Strategy to the value.  We normally write <code class="literal">using</code>
infix, as its definition suggests.  Here is the <code class="literal">parPair</code> example
above rewritten with <code class="literal">using</code>:</p>
<pre class="programlisting" data-language="haskell" id="fib__fib__id1">   <code class="p">(</code><code class="n">fib</code> <code class="mi">35</code><code class="p">,</code> <code class="n">fib</code> <code class="mi">36</code><code class="p">)</code> <code class="p">`</code><code class="n">using</code><code class="p">`</code> <code class="n">parPair</code></pre>
<p id="why_write_it_th">Why write it this way? Well, a Strategy returns the same value that it
was passed, so we know that aside from its performance, the above code
is equivalent to just:</p>
<pre class="programlisting" data-language="haskell" id="fib__fib__id2">   <code class="p">(</code><code class="n">fib</code> <code class="mi">35</code><code class="p">,</code> <code class="n">fib</code> <code class="mi">36</code><code class="p">)</code></pre>
<p id="so_weve_clearl">So we’ve clearly separated the code that describes what the program
<span class="emphasis"><em>does</em></span> (the pair) from the code that adds the parallelism (<code class="literal">`using`
parPair</code>).  Indeed, everywhere we see <code class="literal">x `using` s</code> in our program,
we can delete the <code class="literal">`using` s</code> part and the program should produce the
same result.<a href="#ftn.id377851" class="footnote"><sup class="footnote" id="id377851">[6]</sup></a>  Conversely, someone who is interested in
parallelizing the program can focus on modifying the Strategy without
worrying about breaking the program.</p>
<p id="the_example_pro">The example program <span class="emphasis"><em>strat.hs</em></span> contains the <code class="literal">parPair</code> example just shown;
try running it yourself with one and two processors to see it compute
the two calls to <code class="literal">fib</code> in parallel.</p>
<div class="sect1" data-original-filename="ch03_par-strat.asciidoc" id="sec_strat_parameterized">
<div class="titlepage"><div><div><h2 class="title">Parameterized Strategies</h2></div></div></div>
<p id="parameterized_s"><a id="ix_ch03_par-strat-txt1" class="indexterm"></a><a id="ix_ch03_par-strat-txt2" class="indexterm"></a>The <code class="literal">parPair</code> Strategy<a id="id377918" class="indexterm"></a> embodies a fixed policy: It always evaluates
the components of the pair in parallel, and always to weak head normal
form. If we wanted to do something different with a pair—fully
evaluate the components to normal form, for example—we would have to
write a completely new Strategy.  A better way to factor things is to
write a <span class="emphasis"><em>parameterized</em></span> Strategy, which takes as arguments the
Strategies to apply to the components of the data structure.  Here is
a parameterized Strategy for pairs:</p>
<p id="straths_code_id2" class="caption"><span class="emphasis"><em>strat.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="evalpair__str"><code class="nf">evalPair</code> <code class="ow">::</code> <code class="kt">Strategy</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Strategy</code> <code class="n">b</code> <code class="ow">-&gt;</code> <code class="kt">Strategy</code> <code class="p">(</code><code class="n">a</code><code class="p">,</code><code class="n">b</code><code class="p">)</code>
<code class="nf">evalPair</code> <code class="n">sa</code> <code class="n">sb</code> <code class="p">(</code><code class="n">a</code><code class="p">,</code><code class="n">b</code><code class="p">)</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">a'</code> <code class="ow">&lt;-</code> <code class="n">sa</code> <code class="n">a</code>
  <code class="n">b'</code> <code class="ow">&lt;-</code> <code class="n">sb</code> <code class="n">b</code>
  <code class="n">return</code> <code class="p">(</code><code class="n">a'</code><code class="p">,</code><code class="n">b'</code><code class="p">)</code></pre>
<p id="this_strategy_n">This Strategy no longer has parallelism built in, so I’ve called <a id="id378146" class="indexterm"></a><a id="id378151" class="indexterm"></a>it
<code class="literal">evalPair</code> instead of <code class="literal">parPair</code>.<a href="#ftn.id378170" class="footnote"><sup class="footnote" id="id378170">[7]</sup></a>  It takes
two <code class="literal">Strategy</code> arguments, <code class="literal">sa</code> and <code class="literal">sb</code>, applies them to the
respective components of the pair, and then returns the pair.</p>
<p id="compared_with_p">Compared with <code class="literal">parPair</code>, we are passing in the functions to apply to <code class="literal">a</code>
and <code class="literal">b</code> instead of making fixed calls to <code class="literal">rpar</code>.  So to define
<code class="literal">parPair</code> in terms of <code class="literal">evalPair</code>, we can just pass <code class="literal">rpar</code> as the
arguments:</p>
<pre class="programlisting" data-language="haskell" id="parpair__stra_id3"><code class="nf">parPair</code> <code class="ow">::</code> <code class="kt">Strategy</code> <code class="p">(</code><code class="n">a</code><code class="p">,</code><code class="n">b</code><code class="p">)</code>
<code class="nf">parPair</code> <code class="ow">=</code> <code class="n">evalPair</code> <code class="n">rpar</code> <code class="n">rpar</code></pre>
<p id="this_means_wer">This means we’re <a id="ix_ch03_par-strat-txt3" class="indexterm"></a>using <code class="literal">rpar</code> itself as a <code class="literal">Strategy</code>:</p>
<pre class="programlisting" data-language="haskell" id="rpar__strateg"><code class="nf">rpar</code> <code class="ow">::</code> <code class="kt">Strategy</code> <code class="n">a</code></pre>
<p id="the_type_of_rpa">The type of <code class="literal">rpar</code> is <code class="literal">a -&gt; Eval a</code>, which is equivalent to <code class="literal">Strategy
a</code>; <code class="literal">rpar</code> is therefore a Strategy for any type, with the effect of
starting the evaluation of its argument while the enclosing <code class="literal">Eval</code>
computation proceeds in parallel.  (The <code class="literal">rseq</code> operation is also a
<code class="literal">Strategy</code>.)</p>
<p id="but_parpair_is_">But <code class="literal">parPair</code> is still restrictive, in that the components of the pair
are always evaluated to weak head normal form.  What if we wanted to
fully evaluate the components using <code class="literal">force</code>, for example?  We can make
a <code class="literal">Strategy</code> that fully evaluates its argument:</p>
<pre class="programlisting" data-language="haskell" id="rdeepseq__nfd"><code class="nf">rdeepseq</code> <code class="ow">::</code> <code class="kt">NFData</code> <code class="n">a</code> <code class="ow">=&gt;</code> <code class="kt">Strategy</code> <code class="n">a</code>
<code class="nf">rdeepseq</code> <code class="n">x</code> <code class="ow">=</code> <code class="n">rseq</code> <code class="p">(</code><code class="n">force</code> <code class="n">x</code><code class="p">)</code></pre>
<p id="but_how_do_we_r">But how do we <a id="ix_ch03_par-strat-txt4" class="indexterm"></a>combine <code class="literal">rpar</code> with <code class="literal">rdeepseq</code> to give us a single
Strategy that fully evaluates its argument in parallel?  We need one
further combinator, which is provided by <code class="literal">Control.Parallel.Strategies</code>:</p>
<pre class="programlisting" data-language="haskell" id="rparwith__str"><code class="nf">rparWith</code> <code class="ow">::</code> <code class="kt">Strategy</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Strategy</code> <code class="n">a</code></pre>
<p id="par-strat_00000032">Think <a id="id378638" class="indexterm"></a>of <code class="literal">rparWith s</code> as wrapping the Strategy <code class="literal">s</code> in an <code class="literal">rpar</code>.</p>
<p id="now_we_can_prov">Now we can provide a parameterized version of <code class="literal">parPair</code> that
takes the Strategies to apply to the components:</p>
<pre class="programlisting" data-language="haskell" id="parpair__stra_id4"><code class="nf">parPair</code> <code class="ow">::</code> <code class="kt">Strategy</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Strategy</code> <code class="n">b</code> <code class="ow">-&gt;</code> <code class="kt">Strategy</code> <code class="p">(</code><code class="n">a</code><code class="p">,</code><code class="n">b</code><code class="p">)</code>
<code class="nf">parPair</code> <code class="n">sa</code> <code class="n">sb</code> <code class="ow">=</code> <code class="n">evalPair</code> <code class="p">(</code><code class="n">rparWith</code> <code class="n">sa</code><code class="p">)</code> <code class="p">(</code><code class="n">rparWith</code> <code class="n">sb</code><code class="p">)</code></pre>
<p id="and_we_can_parp">And we can <a id="id378816" class="indexterm"></a>use <code class="literal">parPair</code> to write a <code class="literal">Strategy</code> that fully evaluates
both components of a pair in parallel:</p>
<pre class="programlisting" data-language="haskell" id="parpair_rdeepse">  <code class="n">parPair</code> <code class="n">rdeepseq</code> <code class="n">rdeepseq</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">NFData</code> <code class="n">a</code><code class="p">,</code> <code class="kt">NFData</code> <code class="n">b</code><code class="p">)</code> <code class="ow">=&gt;</code> <code class="kt">Strategy</code> <code class="p">(</code><code class="n">a</code><code class="p">,</code><code class="n">b</code><code class="p">)</code></pre>
<p id="to_break_down_w">To break down what happens when this <code class="literal">Strategy</code> is applied to a pair:
<code class="literal">parPair</code> calls <code class="literal">evalPair</code>, and <code class="literal">evalPair</code> calls <code class="literal">rparWith rdeepseq</code>
on each component of the pair.  So the effect is that each component
will be fully evaluated to normal form in parallel.</p>
<p id="when_using_thes">When using these parameterized Strategies, we sometimes need a way
to say, "Don’t evaluate this component at all."  The <code class="literal">Strategy</code> that
does no evaluation is <a id="id378971" class="indexterm"></a>called <code class="literal">r0</code>:</p>
<pre class="programlisting" data-language="haskell" id="r__strategy_"><code class="nf">r0</code> <code class="ow">::</code> <code class="kt">Strategy</code> <code class="n">a</code>
<code class="nf">r0</code> <code class="n">x</code> <code class="ow">=</code> <code class="n">return</code> <code class="n">x</code></pre>
<p id="for_example_we">For example, we can write a <code class="literal">Strategy</code> over a pair of pairs that
evaluates the first component (only) of both pairs in parallel.</p>
<pre class="programlisting" data-language="haskell" id="evalpair_evalp">  <code class="n">evalPair</code> <code class="p">(</code><code class="n">evalPair</code> <code class="n">rpar</code> <code class="n">r0</code><code class="p">)</code> <code class="p">(</code><code class="n">evalPair</code> <code class="n">rpar</code> <code class="n">r0</code><code class="p">)</code> <code class="ow">::</code> <code class="kt">Strategy</code> <code class="p">((</code><code class="n">a</code><code class="p">,</code><code class="n">b</code><code class="p">),(</code><code class="n">c</code><code class="p">,</code><code class="n">d</code><code class="p">))</code></pre>
<p id="the_first_rpar_">The first <code class="literal">rpar</code> applies to <code class="literal">a</code> and the first <code class="literal">r0</code> to <code class="literal">b</code>, while the
second <code class="literal">rpar</code> applies to <code class="literal">c</code> and <a id="id379190" class="indexterm"></a>the <a id="id379198" class="indexterm"></a>second <code class="literal">r0</code> to <code class="literal">d</code>.<a id="id379216" class="indexterm"></a><a id="id379223" class="indexterm"></a></p>
</div>
<div class="sect1" data-original-filename="ch03_par-strat.asciidoc" id="sec_parlist">
<div class="titlepage"><div><div><h2 class="title">A Strategy for Evaluating a List in Parallel</h2></div></div></div>
<p id="par-strat_00000021"><a id="ix_ch03_par-strat-txt5" class="indexterm"></a><a id="ix_ch03_par-strat-txt6" class="indexterm"></a>In <a class="xref" href="ch02.html" title="Chapter 2. Basic Parallelism: The Eval Monad">Chapter 2</a>, we defined a <a id="id379269" class="indexterm"></a>function <code class="literal">parMap</code> that would map a
function over a list in parallel.  We can think of <code class="literal">parMap</code> as a
composition of two parts:</p>
<div class="itemizedlist" id="par-strat_00000022"><ul class="itemizedlist">
<li class="listitem">
The algorithm: <code class="literal">map</code>
</li>
<li class="listitem">
The parallelism: evaluating the elements of a list in parallel
</li>
</ul></div>
<p id="par-strat_00000023">And indeed, with Strategies, we can express it exactly this
way:</p>
<pre class="programlisting" data-language="haskell" id="parmap__a__id2"><code class="nf">parMap</code> <code class="ow">::</code> <code class="p">(</code><code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">b</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="n">a</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="n">b</code><code class="p">]</code>
<code class="nf">parMap</code> <code class="n">f</code> <code class="n">xs</code> <code class="ow">=</code> <code class="n">map</code> <code class="n">f</code> <code class="n">xs</code> <code class="p">`</code><code class="n">using</code><code class="p">`</code> <code class="n">parList</code> <code class="n">rseq</code></pre>
<p id="par-strat_00000025">The <code class="literal">parList</code> <a id="ix_ch03_par-strat-txt7" class="indexterm"></a><a id="ix_ch03_par-strat-txt8" class="indexterm"></a>function is a Strategy on lists that evaluates the list
elements in parallel.  To define <code class="literal">parList</code>, we can take the same approach
that we took with pairs earlier and first define a parameterized
Strategy on lists, called <code class="literal">evalList</code>:</p>
<p id="par-strat_00000026" class="caption"><span class="emphasis"><em>parlist.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="evallist__str_id1"><code class="nf">evalList</code> <code class="ow">::</code> <code class="kt">Strategy</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Strategy</code> <code class="p">[</code><code class="n">a</code><code class="p">]</code>
<code class="nf">evalList</code> <code class="n">strat</code> <code class="kt">[]</code>     <code class="ow">=</code> <code class="n">return</code> <code class="kt">[]</code>
<code class="nf">evalList</code> <code class="n">strat</code> <code class="p">(</code><code class="n">x</code><code class="kt">:</code><code class="n">xs</code><code class="p">)</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">x'</code>  <code class="ow">&lt;-</code> <code class="n">strat</code> <code class="n">x</code>
  <code class="n">xs'</code> <code class="ow">&lt;-</code> <code class="n">evalList</code> <code class="n">strat</code> <code class="n">xs</code>
  <code class="n">return</code> <code class="p">(</code><code class="n">x'</code><code class="kt">:</code><code class="n">xs'</code><code class="p">)</code></pre>
<p id="note_that_evall">Note that <code class="literal">evalList</code> walks the list recursively, applying the Strategy
parameter <code class="literal">strat</code> to each of the elements and building the result
list.  Now we can define <code class="literal">parList</code> in terms of <code class="literal">evalList</code>, using
<code class="literal">rparWith</code>:</p>
<pre class="programlisting" data-language="haskell" id="parlist__stra_id1"><code class="nf">parList</code> <code class="ow">::</code> <code class="kt">Strategy</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Strategy</code> <code class="p">[</code><code class="n">a</code><code class="p">]</code>
<code class="nf">parList</code> <code class="n">strat</code> <code class="ow">=</code> <code class="n">evalList</code> <code class="p">(</code><code class="n">rparWith</code> <code class="n">strat</code><code class="p">)</code></pre>
<p id="par-strat_00000027">In fact, both <code class="literal">evalList</code> and <code class="literal">parList</code> are already provided by <code class="literal">Control.Parallel</code><code class="literal">.Strategies</code> so you don’t have to define them yourself,
but it’s useful to see that their implementations are not mysterious.</p>
<p id="par-strat_00000029">As with <code class="literal">parPair</code>, <a id="id379877" class="indexterm"></a>the <code class="literal">parList</code> function is a parameterized Strategy. That is, it takes as an argument a Strategy on values of type <code class="literal">a</code> and
returns a Strategy for lists of <code class="literal">a</code>.  So <code class="literal">parList</code> describes a
family of Strategies on lists that evaluate the list elements in
parallel<a id="id379908" class="indexterm"></a><a id="id379915" class="indexterm"></a>.</p>
<p id="par-strat_00000035">The <code class="literal">parList</code> <a id="id379933" class="indexterm"></a>Strategy covers a wide range of uses for parallelism in typical Haskell programs; in many cases, a single <code class="literal">parList</code> is all
that is needed to expose plenty of <span class="keep-together">parallelism</span>.</p>
<p id="par-strat_00000036">Returning to our Sudoku solver from <a class="xref" href="ch02.html" title="Chapter 2. Basic Parallelism: The Eval Monad">Chapter 2</a> for a moment:
instead of our own hand-written <code class="literal">parMap</code>, we could have used
<code class="literal">parList</code>:</p>
<p id="sudokuhs" class="caption"><span class="emphasis"><em>sudoku5.hs</em></span></p>
<pre class="programlisting" data-language="haskell" id="let_solutions_">  <code class="kr">let</code> <code class="n">solutions</code> <code class="ow">=</code> <code class="n">map</code> <code class="n">solve</code> <code class="n">puzzles</code> <code class="p">`</code><code class="n">using</code><code class="p">`</code> <code class="n">parList</code> <code class="n">rseq</code></pre>
<p id="par-strat_00000038">Using <code class="literal">rseq</code> as the Strategy for the list elements is enough here: The
result of <code class="literal">solve</code> is a <code class="literal">Maybe</code>, so evaluating it to
weak head normal form forces the solver to determine whether the puzzle has a solution.</p>
<p id="par-strat_00000039">This version has essentially the same performance as the version that used <code class="literal">parMap</code> in <a class="xref" href="ch02.html" title="Chapter 2. Basic Parallelism: The Eval Monad">Chapter 2</a>.<a id="id380079" class="indexterm"></a><a id="id380086" class="indexterm"></a></p>
</div>
<div class="sect1" data-original-filename="ch03_par-strat.asciidoc" id="sec_using-parlist">
<div class="titlepage"><div><div><h2 class="title">Example: The K-Means Problem</h2></div></div></div>
<p id="par-strat_00000040"><a id="ix_ch03_par-strat-txt9" class="indexterm"></a><a id="ix_ch03_par-strat-txt10" class="indexterm"></a>Let’s look at a slightly more involved example.  In the <span class="emphasis"><em>K-Means</em></span>
problem, the goal is to partition a set of data points into <a id="ix_ch03_par-strat-txt11" class="indexterm"></a>clusters. <a class="xref" href="ch03.html#fig_kmeans-example" title="Figure 3-1. The K-Means problem">Figure 3-1</a> shows an example data set, and the circles
indicate the locations of the clusters that the algorithm should
derive.  From the locations of the clusters,
partitioning the points is achieved by simply finding the closest
cluster to each point.</p>
<div class="figure" id="fig_kmeans-example">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0301.png" alt="The K-Means problem"></div></div>
<div class="figure-title">Figure 3-1. The K-Means problem</div>
</div>
<p id="par-strat_00000042">Finding an optimal solution to the problem is too expensive to be practical. However, there are
several heuristic techniques that are fast, and even though they don’t guarantee an optimal solution, in practice, they give good results. The most well-known heuristic technique for K-Means is <a id="id380171" class="indexterm"></a>Lloyd’s algorithm, which finds a solution by iteratively improving an initial
guess.  The algorithm takes as a parameter the number of clusters to
find and makes an initial guess at the center of each cluster.  Then
it proceeds as follows:</p>
<div class="orderedlist" id="par-strat_00000043"><ol class="orderedlist" type="1">
<li class="listitem">
Assign each point to the cluster to which it is closest. This yields
a new set of clusters.
</li>
<li class="listitem">
Find <a id="id380202" class="indexterm"></a>the <span class="emphasis"><em>centroid</em></span> of each cluster (the average of all the points in
the cluster).
</li>
<li class="listitem">
Repeat steps 1 and 2 until the cluster locations stabilize. We cut off processing after an arbitrarily chosen number of iterations, because sometimes the algorithm does not converge.
</li>
</ol></div>
<p id="par-strat_00000046">The initial guess can be constructed by randomly assigning each point
in the data set to a cluster and then finding the centroids of those
clusters.</p>
<p id="par-strat_00000047">The algorithm works in any number of dimensions, but we will use two for
ease of visualization.</p>
<p id="par-strat_00000048">A complete Haskell implementation can be found in the directory
<span class="emphasis"><em>kmeans</em></span> in the sample code.</p>
<p id="par-strat_00000049">A data point is represented by the <a id="id380244" class="indexterm"></a>type <code class="literal">Point</code>, which is just a pair
of <code class="literal">Double</code>s representing the <code class="literal">x</code> and <code class="literal">y</code> coordinates
respectively:<a href="#ftn.id380271" class="footnote"><sup class="footnote" id="id380271">[8]</sup></a></p>
<pre class="programlisting" data-language="haskell" id="data_point__po"><code class="kr">data</code> <code class="kt">Point</code> <code class="ow">=</code> <code class="kt">Point</code> <code class="o">!</code><code class="kt">Double</code> <code class="o">!</code><code class="kt">Double</code></pre>
<p id="par-strat_00000051">There are a couple of basic operations on <code class="literal">Point</code>:</p>
<p id="par-strat_00000052" class="caption"><span class="emphasis"><em>kmeans/KMeansCore.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="zeropoint__po"><code class="nf">zeroPoint</code> <code class="ow">::</code> <code class="kt">Point</code>
<code class="nf">zeroPoint</code> <code class="ow">=</code> <code class="kt">Point</code> <code class="mi">0</code> <code class="mi">0</code>

<code class="nf">sqDistance</code> <code class="ow">::</code> <code class="kt">Point</code> <code class="ow">-&gt;</code> <code class="kt">Point</code> <code class="ow">-&gt;</code> <code class="kt">Double</code>
<code class="nf">sqDistance</code> <code class="p">(</code><code class="kt">Point</code> <code class="n">x1</code> <code class="n">y1</code><code class="p">)</code> <code class="p">(</code><code class="kt">Point</code> <code class="n">x2</code> <code class="n">y2</code><code class="p">)</code> <code class="ow">=</code> <code class="p">((</code><code class="n">x1</code><code class="o">-</code><code class="n">x2</code><code class="p">)</code><code class="o">^</code><code class="mi">2</code><code class="p">)</code> <code class="o">+</code> <code class="p">((</code><code class="n">y1</code><code class="o">-</code><code class="n">y2</code><code class="p">)</code><code class="o">^</code><code class="mi">2</code><code class="p">)</code></pre>
<p id="par-strat_00000055">We can make a zero point <a id="id380582" class="indexterm"></a><a id="id380588" class="indexterm"></a>with <code class="literal">zeroPoint</code>, and find the square of the distance between two points
with <code class="literal">sqDistance</code>.  The actual distance between the points would be
given by the square root of this value, but since we will only be
comparing distances, we can save time by comparing squared distances
instead.</p>
<p id="par-strat_00000056">Clusters are represented by the <a id="id380615" class="indexterm"></a>type <code class="literal">Cluster</code>:</p>
<pre class="programlisting" data-language="haskell" id="data_cluster__"><code class="kr">data</code> <code class="kt">Cluster</code>
  <code class="ow">=</code> <code class="kt">Cluster</code> <code class="p">{</code> <code class="n">clId</code>    <code class="ow">::</code> <code class="kt">Int</code>
            <code class="p">,</code> <code class="n">clCent</code>  <code class="ow">::</code> <code class="kt">Point</code>
            <code class="p">}</code></pre>
<p id="par-strat_00000058">A <code class="literal">Cluster</code> contains its number (<code class="literal">clId</code>) and its centroid (<code class="literal">clCent</code>).</p>
<p id="par-strat_00000059">We will also need an intermediate type called <code class="literal">PointSum</code>:</p>
<pre class="programlisting" data-language="haskell" id="data_pointsum_"><code class="kr">data</code> <code class="kt">PointSum</code> <code class="ow">=</code> <code class="kt">PointSum</code> <code class="o">!</code><code class="kt">Int</code> <code class="o">!</code><code class="kt">Double</code> <code class="o">!</code><code class="kt">Double</code></pre>
<p id="par-strat_00000061">A <code class="literal">PointSum</code> <a id="id380813" class="indexterm"></a><a id="id380819" class="indexterm"></a>represents the sum of a set of points; it contains the
number of points in the set and the sum of their <code class="literal">x</code> and <code class="literal">y</code> coordinates respectively.  A <code class="literal">PointSum</code> is constructed
incrementally, by repeatedly adding points using <code class="literal">addToPointSum</code>:</p>
<p id="par-strat_00000062" class="caption"><span class="emphasis"><em>kmeans/kmeans.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="addtopointsum_"><code class="nf">addToPointSum</code> <code class="ow">::</code> <code class="kt">PointSum</code> <code class="ow">-&gt;</code> <code class="kt">Point</code> <code class="ow">-&gt;</code> <code class="kt">PointSum</code>
<code class="nf">addToPointSum</code> <code class="p">(</code><code class="kt">PointSum</code> <code class="n">count</code> <code class="n">xs</code> <code class="n">ys</code><code class="p">)</code> <code class="p">(</code><code class="kt">Point</code> <code class="n">x</code> <code class="n">y</code><code class="p">)</code>
  <code class="ow">=</code> <code class="kt">PointSum</code> <code class="p">(</code><code class="n">count</code><code class="o">+</code><code class="mi">1</code><code class="p">)</code> <code class="p">(</code><code class="n">xs</code> <code class="o">+</code> <code class="n">x</code><code class="p">)</code> <code class="p">(</code><code class="n">ys</code> <code class="o">+</code> <code class="n">y</code><code class="p">)</code></pre>
<p id="par-strat_00000063">A <code class="literal">PointSum</code> can be turned into <a id="id381066" class="indexterm"></a><a id="id381074" class="indexterm"></a><a id="id381082" class="indexterm"></a>a <code class="literal">Cluster</code> by computing the centroid.
The <code class="literal">x</code> coordinate of the centroid is the sum of the <code class="literal">x</code> coordinates
of the points in the cluster divided by the total number of points,
and similarly for the <code class="literal">y</code> coordinate.</p>
<pre class="programlisting" data-language="haskell" id="pointsumtoclust"><code class="nf">pointSumToCluster</code> <code class="ow">::</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="kt">PointSum</code> <code class="ow">-&gt;</code> <code class="kt">Cluster</code>
<code class="nf">pointSumToCluster</code> <code class="n">i</code> <code class="p">(</code><code class="kt">PointSum</code> <code class="n">count</code> <code class="n">xs</code> <code class="n">ys</code><code class="p">)</code> <code class="ow">=</code>
  <code class="kt">Cluster</code> <code class="p">{</code> <code class="n">clId</code>    <code class="ow">=</code> <code class="n">i</code>
          <code class="p">,</code> <code class="n">clCent</code>  <code class="ow">=</code> <code class="kt">Point</code> <code class="p">(</code><code class="n">xs</code> <code class="o">/</code> <code class="n">fromIntegral</code> <code class="n">count</code><code class="p">)</code> <code class="p">(</code><code class="n">ys</code> <code class="o">/</code> <code class="n">fromIntegral</code> <code class="n">count</code><code class="p">)</code>
          <code class="p">}</code></pre>
<p id="par-strat_00000065">The roles of the <a id="id381333" class="indexterm"></a><a id="id381341" class="indexterm"></a><a id="id381346" class="indexterm"></a><a id="id381352" class="indexterm"></a>types <code class="literal">Point</code>, <code class="literal">PointSum</code>, and <code class="literal">Cluster</code> in the
algorithm are as follows.  The input is a set of points represented as
<code class="literal">[Point]</code>, and an initial guess represented as <code class="literal">[Cluster]</code>.  The
algorithm will iteratively refine the clusters until convergence is
reached.</p>
<div class="itemizedlist" id="par-strat_00000066"><ul class="itemizedlist">
<li class="listitem">
Step 1 divides the points into new sets by finding the <code class="literal">Cluster</code> to
  which each <code class="literal">Point</code> is closest.  However, instead of collecting sets of
  <code class="literal">Point</code>s, we build up a <code class="literal">PointSum</code> for each cluster.  This is an
  optimization that avoids constructing the intermediate data
  structure and allows the algorithm to run in constant space.  We’ll
  represent the output of this step as <code class="literal">Vector PointSum</code>.
</li>
<li class="listitem">
The <code class="literal">Vector PointSum</code> is fed into step 2, which makes a <code class="literal">Cluster</code>
  from each <code class="literal">PointSum</code>, giving <code class="literal">[Cluster]</code>.
</li>
<li class="listitem">
The result of step 2 is fed back into step 1 until convergence is reached.
</li>
</ul></div>
<p id="par-strat_00000069">The <a id="id381484" class="indexterm"></a>function <code class="literal">assign</code> implements step 1 of the algorithm, assigning
points to clusters and building a vector of <code class="literal">PointSum</code>s:</p>
<pre class="programlisting" data-language="haskell" id="assign__int_"><code class="nf">assign</code> <code class="ow">::</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="kt">Cluster</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="kt">Point</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="kt">Vector</code> <code class="kt">PointSum</code>
<code class="nf">assign</code> <code class="n">nclusters</code> <code class="n">clusters</code> <code class="n">points</code> <code class="ow">=</code> <code class="kt">Vector</code><code class="o">.</code><code class="n">create</code> <code class="o">$</code> <code class="kr">do</code>
    <code class="n">vec</code> <code class="ow">&lt;-</code> <code class="kt">MVector</code><code class="o">.</code><code class="n">replicate</code> <code class="n">nclusters</code> <code class="p">(</code><code class="kt">PointSum</code> <code class="mi">0</code> <code class="mi">0</code> <code class="mi">0</code><code class="p">)</code>
    <code class="kr">let</code>
        <code class="n">addpoint</code> <code class="n">p</code> <code class="ow">=</code> <code class="kr">do</code>
          <code class="kr">let</code> <code class="n">c</code> <code class="ow">=</code> <code class="n">nearest</code> <code class="n">p</code><code class="p">;</code> <code class="n">cid</code> <code class="ow">=</code> <code class="n">clId</code> <code class="n">c</code>
          <code class="n">ps</code> <code class="ow">&lt;-</code> <code class="kt">MVector</code><code class="o">.</code><code class="n">read</code> <code class="n">vec</code> <code class="n">cid</code>
          <code class="kt">MVector</code><code class="o">.</code><code class="n">write</code> <code class="n">vec</code> <code class="n">cid</code> <code class="o">$!</code> <code class="n">addToPointSum</code> <code class="n">ps</code> <code class="n">p</code>

    <code class="n">mapM_</code> <code class="n">addpoint</code> <code class="n">points</code>
    <code class="n">return</code> <code class="n">vec</code>
 <code class="kr">where</code>
  <code class="n">nearest</code> <code class="n">p</code> <code class="ow">=</code> <code class="n">fst</code> <code class="o">$</code> <code class="n">minimumBy</code> <code class="p">(</code><code class="n">compare</code> <code class="p">`</code><code class="n">on</code><code class="p">`</code> <code class="n">snd</code><code class="p">)</code>
                        <code class="p">[</code> <code class="p">(</code><code class="n">c</code><code class="p">,</code> <code class="n">sqDistance</code> <code class="p">(</code><code class="n">clCent</code> <code class="n">c</code><code class="p">)</code> <code class="n">p</code><code class="p">)</code> <code class="o">|</code> <code class="n">c</code> <code class="ow">&lt;-</code> <code class="n">clusters</code> <code class="p">]</code></pre>
<p id="par-strat_00000072">Given a set of clusters and a set of points, the job of <code class="literal">assign</code> is to
decide, for each point, which cluster is closest.  For each cluster, we
build up a <code class="literal">PointSum</code> of the points that were found to be closest to
it.  The code has been carefully optimized, using mutable vectors from
the <code class="literal">vector</code> package; the details aren’t important here.</p>
<p id="par-strat_00000073">The <a id="id382071" class="indexterm"></a>function <code class="literal">makeNewClusters</code> implements step 2 of the algorithm:</p>
<pre class="programlisting" data-language="haskell" id="makenewclusters"><code class="nf">makeNewClusters</code> <code class="ow">::</code> <code class="kt">Vector</code> <code class="kt">PointSum</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="kt">Cluster</code><code class="p">]</code>
<code class="nf">makeNewClusters</code> <code class="n">vec</code> <code class="ow">=</code>
  <code class="p">[</code> <code class="n">pointSumToCluster</code> <code class="n">i</code> <code class="n">ps</code>
  <code class="o">|</code> <code class="p">(</code><code class="n">i</code><code class="p">,</code><code class="n">ps</code><code class="o">@</code><code class="p">(</code><code class="kt">PointSum</code> <code class="n">count</code> <code class="kr">_</code> <code class="kr">_</code><code class="p">))</code> <code class="ow">&lt;-</code> <code class="n">zip</code> <code class="p">[</code><code class="mi">0</code><code class="o">..</code><code class="p">]</code> <code class="p">(</code><code class="kt">Vector</code><code class="o">.</code><code class="n">toList</code> <code class="n">vec</code><code class="p">)</code>
  <code class="p">,</code> <code class="n">count</code> <code class="o">&gt;</code> <code class="mi">0</code>
  <code class="p">]</code></pre>
<p id="par-strat_00000075">Here we make a new <code class="literal">Cluster</code>, using <code class="literal">pointSumToCluster</code>, from each
<code class="literal">PointSum</code> produced by <code class="literal">assign</code>.  There is a slight complication in
that we have to avoid creating a cluster with no points, because it
cannot have a centroid.</p>
<p id="par-strat_00000076">Finally <code class="literal">step</code> <a id="id382356" class="indexterm"></a>combines <code class="literal">assign</code> and <code class="literal">makeNewClusters</code> to implement
one complete iteration:</p>
<pre class="programlisting" data-language="haskell" id="step__int__"><code class="nf">step</code> <code class="ow">::</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="kt">Cluster</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="kt">Point</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="kt">Cluster</code><code class="p">]</code>
<code class="nf">step</code> <code class="n">nclusters</code> <code class="n">clusters</code> <code class="n">points</code>
   <code class="ow">=</code> <code class="n">makeNewClusters</code> <code class="p">(</code><code class="n">assign</code> <code class="n">nclusters</code> <code class="n">clusters</code> <code class="n">points</code><code class="p">)</code></pre>
<p id="par-strat_00000078">To complete the algorithm, we need a loop to repeatedly apply the <code class="literal">step</code>
function until convergence. The <a id="id382541" class="indexterm"></a>function <code class="literal">kmeans_seq</code> implements this:</p>
<pre class="programlisting" data-language="haskell" id="kmeans_seq__i"><code class="nf">kmeans_seq</code> <code class="ow">::</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="kt">Point</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="kt">Cluster</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">[</code><code class="kt">Cluster</code><code class="p">]</code>
<code class="nf">kmeans_seq</code> <code class="n">nclusters</code> <code class="n">points</code> <code class="n">clusters</code> <code class="ow">=</code>
  <code class="kr">let</code>
      <code class="n">loop</code> <code class="ow">::</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="kt">Cluster</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">[</code><code class="kt">Cluster</code><code class="p">]</code>
      <code class="n">loop</code> <code class="n">n</code> <code class="n">clusters</code> <code class="o">|</code> <code class="n">n</code> <code class="o">&gt;</code> <code class="n">tooMany</code> <code class="ow">=</code> <code class="kr">do</code>                  <code class="c1">-- </code><span id="CO4-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
        <code class="n">putStrLn</code> <code class="s">"giving up."</code>
        <code class="n">return</code> <code class="n">clusters</code>
      <code class="n">loop</code> <code class="n">n</code> <code class="n">clusters</code> <code class="ow">=</code> <code class="kr">do</code>
        <code class="n">printf</code> <code class="s">"iteration %d</code><code class="se">\n</code><code class="s">"</code> <code class="n">n</code>
        <code class="n">putStr</code> <code class="p">(</code><code class="n">unlines</code> <code class="p">(</code><code class="n">map</code> <code class="n">show</code> <code class="n">clusters</code><code class="p">))</code>
        <code class="kr">let</code> <code class="n">clusters'</code> <code class="ow">=</code> <code class="n">step</code> <code class="n">nclusters</code> <code class="n">clusters</code> <code class="n">points</code>    <code class="c1">-- </code><span id="CO4-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>
        <code class="kr">if</code> <code class="n">clusters'</code> <code class="o">==</code> <code class="n">clusters</code>                          <code class="c1">-- </code><span id="CO4-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span>
           <code class="kr">then</code> <code class="n">return</code> <code class="n">clusters</code>
           <code class="kr">else</code> <code class="n">loop</code> <code class="p">(</code><code class="n">n</code><code class="o">+</code><code class="mi">1</code><code class="p">)</code> <code class="n">clusters'</code>
  <code class="kr">in</code>
  <code class="n">loop</code> <code class="mi">0</code> <code class="n">clusters</code>

<code class="nf">tooMany</code> <code class="ow">=</code> <code class="mi">80</code></pre>
<div class="calloutlist" id="par-strat_00000081"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO4-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_first_argum_id1">
The first argument to <code class="literal">loop</code> is the number of iterations completed
so far.  If this figure reaches the limit <code class="literal">tooMany</code>, then we bail
out (sometimes the algorithm does not converge).
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO4-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="after_printing_">
After printing the iteration number and the current clusters
for diagnostic purposes, we calculate the next iteration by calling
the function <code class="literal">step</code>.  The arguments to <code class="literal">step</code> are the number of
clusters, the current set of clusters, and the set of points.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO4-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="if_this_iterati">
If this iteration did not change the clusters, then the algorithm
has converged, and we return the result.  Otherwise, we do another
iteration.
</p></td>
</tr>
</table></div>
<p id="par-strat_00000084">We compile this program in the same way as before:</p>
<pre class="screen" id="par-strat_00000085">$ cd kmeans
$ ghc -O2 -threaded -rtsopts -eventlog kmeans.hs</pre>
<p id="par-strat_00000086">The sample code comes with a program to generate some input data,
<span class="emphasis"><em>GenSamples.hs</em></span>, which uses the <code class="literal">normaldistribution</code> package to
generate a realistically clustered set of values. The data set is
large, so it isn’t included with the sample code, but you can generate
it using <code class="literal">GenSamples</code>:</p>
<pre class="screen" id="par-strat_00000087">$ ghc -O2 GenSamples.hs
$ ./GenSamples 5 50000 100000 1010</pre>
<p id="par-strat_00000088">This should generate a data set of about 340,000 points with 5
clusters in the file <code class="literal">points.bin</code>.</p>
<p id="par-strat_00000089">Run the <code class="literal">kmeans</code> program using the sequential algorithm:</p>
<pre class="screen" id="par-strat_00000090">$ ./kmeans seq</pre>
<p id="par-strat_00000091">The program will display the clusters at each iteration and should
converge after 65 iterations.</p>
<p id="par-strat_00000092">Note that the program displays its own running time at the end; this is
because there is a significant amount of time spent reading in the
sample data at the beginning, and we want to be able to calculate the
parallel speedup for the portion of the runtime spent computing the
K-Means algorithm only.</p>
<div class="sect2" id="sec_par-kmeans-parallel">
<div class="titlepage"><div><div><h3 class="title">Parallelizing K-Means</h3></div></div></div>
<p id="par-strat_00000093"><a id="ix_ch03_par-strat-txt12" class="indexterm"></a>How can this algorithm be parallelized?  One place that looks
profitable to parallelize is the <code class="literal">assign</code> <a id="id383280" class="indexterm"></a>function because it is
essentially just a <code class="literal">map</code> over the points, and indeed that is where we
will concentrate our efforts.  The operations are too fine-grained
here to use a simple <code class="literal">parMap</code> or <code class="literal">parList</code> as we did before; the
overhead of the <code class="literal">parMap</code> will swamp the parallelism, so we need to
increase the size of the operations.  One way to do that is to divide
the list of points into chunks, and process the chunks in parallel.
First we need some code to split a list into chunks:</p>
<pre class="programlisting" data-language="haskell" id="split__int_"><code class="nf">split</code> <code class="ow">::</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="n">a</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="p">[[</code><code class="n">a</code><code class="p">]]</code>
<code class="nf">split</code> <code class="n">numChunks</code> <code class="n">xs</code> <code class="ow">=</code> <code class="n">chunk</code> <code class="p">(</code><code class="n">length</code> <code class="n">xs</code> <code class="p">`</code><code class="n">quot</code><code class="p">`</code> <code class="n">numChunks</code><code class="p">)</code> <code class="n">xs</code>

<code class="nf">chunk</code> <code class="ow">::</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="n">a</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="p">[[</code><code class="n">a</code><code class="p">]]</code>
<code class="nf">chunk</code> <code class="n">n</code> <code class="kt">[]</code> <code class="ow">=</code> <code class="kt">[]</code>
<code class="nf">chunk</code> <code class="n">n</code> <code class="n">xs</code> <code class="ow">=</code> <code class="n">as</code> <code class="kt">:</code> <code class="n">chunk</code> <code class="n">n</code> <code class="n">bs</code>
  <code class="kr">where</code> <code class="p">(</code><code class="n">as</code><code class="p">,</code><code class="n">bs</code><code class="p">)</code> <code class="ow">=</code> <code class="n">splitAt</code> <code class="n">n</code> <code class="n">xs</code></pre>
<p id="par-strat_00000096">So we can split the list of points into chunks and map <code class="literal">assign</code> over
the list of chunks.  But what do we do with the results?  We have a
list of <code class="literal">Vector PointSum</code>s that we need to combine into a single
<code class="literal">Vector PointSum</code>.  Fortunately, <code class="literal">PointSum</code>s can be added together:</p>
<pre class="programlisting" data-language="haskell" id="addpointsums_"><code class="nf">addPointSums</code> <code class="ow">::</code> <code class="kt">PointSum</code> <code class="ow">-&gt;</code> <code class="kt">PointSum</code> <code class="ow">-&gt;</code> <code class="kt">PointSum</code>
<code class="nf">addPointSums</code> <code class="p">(</code><code class="kt">PointSum</code> <code class="n">c1</code> <code class="n">x1</code> <code class="n">y1</code><code class="p">)</code> <code class="p">(</code><code class="kt">PointSum</code> <code class="n">c2</code> <code class="n">x2</code> <code class="n">y2</code><code class="p">)</code>
  <code class="ow">=</code> <code class="kt">PointSum</code> <code class="p">(</code><code class="n">c1</code><code class="o">+</code><code class="n">c2</code><code class="p">)</code> <code class="p">(</code><code class="n">x1</code><code class="o">+</code><code class="n">x2</code><code class="p">)</code> <code class="p">(</code><code class="n">y1</code><code class="o">+</code><code class="n">y2</code><code class="p">)</code></pre>
<p id="par-strat_00000098">And using this, we can combine vectors of <code class="literal">PointSum</code>s:</p>
<pre class="programlisting" data-language="haskell" id="combine__vect"><code class="nf">combine</code> <code class="ow">::</code> <code class="kt">Vector</code> <code class="kt">PointSum</code> <code class="ow">-&gt;</code> <code class="kt">Vector</code> <code class="kt">PointSum</code> <code class="ow">-&gt;</code> <code class="kt">Vector</code> <code class="kt">PointSum</code>
<code class="nf">combine</code> <code class="ow">=</code> <code class="kt">Vector</code><code class="o">.</code><code class="n">zipWith</code> <code class="n">addPointSums</code></pre>
<p id="par-strat_00000100">We now have all the pieces to define a parallel version <a id="id383971" class="indexterm"></a>of <code class="literal">step</code>:</p>
<pre class="programlisting" data-language="haskell" id="parsteps_strat_"><code class="nf">parSteps_strat</code> <code class="ow">::</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="kt">Cluster</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="p">[[</code><code class="kt">Point</code><code class="p">]]</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="kt">Cluster</code><code class="p">]</code>
<code class="nf">parSteps_strat</code> <code class="n">nclusters</code> <code class="n">clusters</code> <code class="n">pointss</code>
  <code class="ow">=</code> <code class="n">makeNewClusters</code> <code class="o">$</code>
      <code class="n">foldr1</code> <code class="n">combine</code> <code class="o">$</code>
          <code class="p">(</code><code class="n">map</code> <code class="p">(</code><code class="n">assign</code> <code class="n">nclusters</code> <code class="n">clusters</code><code class="p">)</code> <code class="n">pointss</code>
            <code class="p">`</code><code class="n">using</code><code class="p">`</code> <code class="n">parList</code> <code class="n">rseq</code><code class="p">)</code></pre>
<p id="the_arguments_p">The arguments <a id="id384201" class="indexterm"></a>to <code class="literal">parSteps_strat</code> are the same as for <code class="literal">step</code>, except
that the list of points is now a list of lists of points, that is, the
list of points divided into chunks by <code class="literal">split</code>.  We want to pass in the chunked data rather than call <code class="literal">split</code> inside <code class="literal">parSteps_strat</code> so
that we can do the chunking of the input data just once instead of
repeating it for each iteration.</p>
<p id="par-strat_00000102">The <code class="literal">kmeans_strat</code> <a id="id384252" class="indexterm"></a><a id="id384258" class="indexterm"></a>function below is our parallel version of
<code class="literal">kmeans_seq</code>, the only differences being that we call <code class="literal">split</code> to
divide the list of points into chunks (<a class="xref" href="ch03.html#kmeans_strat-1"><span><img src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1" border="0"></span></a>) and we call <code class="literal">parSteps_strat</code> instead of <code class="literal">steps</code> (<a class="xref" href="ch03.html#kmeans_strat-2"><span><img src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2" border="0"></span></a>):</p>
<pre class="programlisting" data-language="haskell" id="kmeans_strat_"><code class="nf">kmeans_strat</code> <code class="ow">::</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="kt">Point</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="kt">Cluster</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">[</code><code class="kt">Cluster</code><code class="p">]</code>
<code class="nf">kmeans_strat</code> <code class="n">numChunks</code> <code class="n">nclusters</code> <code class="n">points</code> <code class="n">clusters</code> <code class="ow">=</code>
  <code class="kr">let</code>
      <code class="n">chunks</code> <code class="ow">=</code> <code class="n">split</code> <code class="n">numChunks</code> <code class="n">points</code>                            <code class="c1">-- </code><span id="kmeans_strat-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>

      <code class="n">loop</code> <code class="ow">::</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="kt">Cluster</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">[</code><code class="kt">Cluster</code><code class="p">]</code>
      <code class="n">loop</code> <code class="n">n</code> <code class="n">clusters</code> <code class="o">|</code> <code class="n">n</code> <code class="o">&gt;</code> <code class="n">tooMany</code> <code class="ow">=</code> <code class="kr">do</code>
        <code class="n">printf</code> <code class="s">"giving up."</code>
        <code class="n">return</code> <code class="n">clusters</code>
      <code class="n">loop</code> <code class="n">n</code> <code class="n">clusters</code> <code class="ow">=</code> <code class="kr">do</code>
        <code class="n">printf</code> <code class="s">"iteration %d</code><code class="se">\n</code><code class="s">"</code> <code class="n">n</code>
        <code class="n">putStr</code> <code class="p">(</code><code class="n">unlines</code> <code class="p">(</code><code class="n">map</code> <code class="n">show</code> <code class="n">clusters</code><code class="p">))</code>
        <code class="kr">let</code> <code class="n">clusters'</code> <code class="ow">=</code> <code class="n">parSteps_strat</code> <code class="n">nclusters</code> <code class="n">clusters</code> <code class="n">chunks</code> <code class="c1">-- </code><span id="kmeans_strat-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>
        <code class="kr">if</code> <code class="n">clusters'</code> <code class="o">==</code> <code class="n">clusters</code>
           <code class="kr">then</code> <code class="n">return</code> <code class="n">clusters</code>
           <code class="kr">else</code> <code class="n">loop</code> <code class="p">(</code><code class="n">n</code><code class="o">+</code><code class="mi">1</code><code class="p">)</code> <code class="n">clusters'</code>
  <code class="kr">in</code>
  <code class="n">loop</code> <code class="mi">0</code> <code class="n">clusters</code>
</pre>
<p id="par-strat_00000105">Note that the number of chunks doesn’t have to be related to
the number of processors; as we saw earlier, it is better to produce
plenty of sparks and let the runtime schedule them automatically,
because this should enable the program to scale over a wide range of
processors.<a id="id384860" class="indexterm"></a></p>
</div>
<div class="sect2" id="sec_par-kmeans-perf">
<div class="titlepage"><div><div><h3 class="title">Performance and Analysis</h3></div></div></div>
<p id="par-strat_00000106"><a id="ix_ch03_par-strat-txt14" class="indexterm"></a>Next we’re going on an exploration of the performance of this parallel
program. Along the way, we’ll learn several lessons about the kinds
of things that can go wrong when parallelizing Haskell code, how to
look out for them using ThreadScope, and how to fix them.</p>
<p id="par-strat_00000107">We’ll start by taking some measurements of the <a id="ix_ch03_par-strat-txt15" class="indexterm"></a>speedup for various
numbers of cores.  When running the program in parallel, we get to
choose the number of chunks to divide the input into, and for these
measurements I’ll use 64 (but we’ll revisit this in
<a class="xref" href="ch03.html#sec_par-kmeans-granularity" title="Granularity">“Granularity”</a>).  The program is run in parallel like
this:</p>
<pre class="screen" id="par-strat_00000108">$ ./kmeans strat 64 +RTS -N2</pre>
<p id="par-strat_00000109"><code class="literal">strat</code> indicates that we want to use the Strategies version of
the algorithm, and 64 is the number of chunks to divide the input data
into.  Here, I’m telling the GHC runtime to use two cores.</p>
<p id="par-strat_00000110">Here are the speedup results I get on my computer for the <code class="literal">kmeans</code> program I showed
earlier.<a href="#ftn.id384970" class="footnote"><sup class="footnote" id="id384970">[9]</sup></a> For each
measurement, I ran the program a few times and took the average
runtime.<a href="#ftn.id384975" class="footnote"><sup class="footnote" id="id384975">[10]</sup></a></p>
<div class="informaltable" id="par-strat_00000111"><table style="width: 30%; border-collapse: collapse;">
<colgroup>
<col class="col_1">
<col class="col_2">
<col class="col_3">
</colgroup>
<thead><tr>
<td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> Cores </td>
<td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> Time (s) </td>
<td style="border-bottom: 0.5pt solid ; "> Speedup</td>
</tr></thead>
<tbody>
<tr>
<td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p id="simpara_id1">1</p></td>
<td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p id="simpara_id2">2.56</p></td>
<td style="border-bottom: 0.5pt solid ; "><p id="simpara_id3">1</p></td>
</tr>
<tr>
<td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p id="simpara_id4">2</p></td>
<td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p id="simpara_id5">1.42</p></td>
<td style="border-bottom: 0.5pt solid ; "><p id="simpara_id6">1.8</p></td>
</tr>
<tr>
<td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p id="simpara_id7">3</p></td>
<td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p id="simpara_id8">1.06</p></td>
<td style="border-bottom: 0.5pt solid ; "><p id="simpara_id9">2.4</p></td>
</tr>
<tr>
<td style="border-right: 0.5pt solid ; "><p id="simpara_id10">4</p></td>
<td style="border-right: 0.5pt solid ; "><p id="simpara_id11">0.97</p></td>
<td><p id="simpara_id12">2.6</p></td>
</tr>
</tbody>
</table></div>
<p id="par-strat_00000112">We can see that speedup is quite good for two to three cores but starts to
drop off at four cores.  Still, a 2.6 speedup on 4 cores is reasonably
respectable.</p>
<p id="par-strat_00000113">The ThreadScope profile gives us some clues about why the speedup
might be less than we hope.  The overall view of the four-core run can be
seen in <a class="xref" href="ch03.html#fig_kmeans1" title="Figure 3-2. kmeans on four cores">Figure 3-2</a>.</p>
<div class="figure" id="fig_kmeans1">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0302.png" alt="kmeans on four cores"></div></div>
<div class="figure-title">Figure 3-2. kmeans on four cores</div>
</div>
<p id="par-strat_00000114">We can clearly see the sequential section at the start, where the
program reads in the input data.  But that isn’t a problem; remember that
the program emits its own timing results, which begin at the parallel
part of the run.  The parallel section itself looks quite good; all
cores seem to be running for the duration.  Let’s zoom in on the
beginning of the parallel section, as shown in <a class="xref" href="ch03.html#fig_kmeans2" title="Figure 3-3. kmeans on four cores, start of parallel execution">Figure 3-3</a>.</p>
<div class="figure" id="fig_kmeans2">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0303.png" alt="kmeans on four cores, start of parallel execution"></div></div>
<div class="figure-title">Figure 3-3. kmeans on four cores, start of parallel execution</div>
</div>
<p id="par-strat_00000115">There’s a segment between 0.78s and 0.8s where, although parallel
execution has started, there is heavy GC activity.  This is similar to
what we saw in <a class="xref" href="ch02.html#sec_par-eval-sudoku2" title="Example: Parallelizing a Sudoku Solver">“Example: Parallelizing a Sudoku Solver”</a>, where the work of splitting
the input data into lines was overlapped with the parallel execution.
In the case of <code class="literal">kmeans</code>, the act of splitting the data set into chunks
is causing the extra work.</p>
<p id="par-strat_00000116">The sequential version of the algorithm doesn’t need to split the data into
chunks, so <a id="id385214" class="indexterm"></a>chunking is a source of extra overhead in the parallel
version.  This is one reason that we aren’t achieving full speedup.
If you’re feeling adventurous, you might want to see whether you can
avoid this chunking overhead by using <code class="literal">Vector</code> instead of a list to
represent the data set, because <code class="literal">Vector</code>s can be sliced in <span class="emphasis"><em>O</em></span>(1)
time.</p>
<p id="par-strat_00000117">Let’s look at the rest of the parallel section in more detail (see <a class="xref" href="ch03.html#fig_kmeans3" title="Figure 3-4. kmeans on four cores, parallel execution">Figure 3-4</a>).</p>
<div class="figure" id="fig_kmeans3">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0304.png" alt="kmeans on four cores, parallel execution"></div></div>
<div class="figure-title">Figure 3-4. kmeans on four cores, parallel execution</div>
</div>
<p id="par-strat_00000118">The parallel execution, which at first looked quite uniform, actually
consists of a series of humps when we zoom in.  Remember that the
algorithm performs a series of iterations over the data set—these
humps in the profile correspond to the iterations.  Each iteration is a separate
parallel segment, and between the iterations lies some sequential
execution.  We expect a small amount of sequential execution
corresponding to <code class="literal">makeNewClusters</code>, <code class="literal">combine</code>, and the comparison
between the new and old clusters in the outer loop.</p>
<p id="par-strat_00000119">Let’s see whether the reality matches our expectations by zooming in
on one of the gaps to see more clearly what happens between
iterations (<a class="xref" href="ch03.html#fig_kmeans4" title="Figure 3-5. kmeans on four cores, gap between iterations">Figure 3-5</a>).</p>
<div class="figure" id="fig_kmeans4">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0305.png" alt="kmeans on four cores, gap between iterations"></div></div>
<div class="figure-title">Figure 3-5. kmeans on four cores, gap between iterations</div>
</div>
<p id="par-strat_00000120">There’s quite a lot going on here.  We can see the parallel execution
of the previous iteration tailing off, as a couple of cores run longer
than the others.  Following this, there is some sequential execution
on HEC 3 before the next iteration starts up in parallel.</p>
<p id="par-strat_00000121">Looking more closely at the sequential bit on HEC 3, we can see some
gaps where nothing appears to be happening at all.  In the <a id="id385347" class="indexterm"></a>ThreadScope
GUI, we can show the detailed events emitted by the RTS (look for the
"Raw Events" tab in the lower pane), and if we look at the events for
this section, we see:</p>
<pre class="screen" id="par-strat_00000122">0.851404792s HEC 3: stopping thread 4 (making a foreign call)
0.851405771s HEC 3: running thread 4
0.851406373s HEC 3: stopping thread 4 (making a foreign call)
0.851419669s HEC 3: running thread 4
0.851451713s HEC 3: stopping thread 4 (making a foreign call)
0.851452171s HEC 3: running thread 4
...</pre>
<p id="par-strat_00000123">The program is popping out to make several foreign calls during this
period.  ThreadScope doesn’t tell us any more than this, but it’s
enough of a clue: A <a id="id385378" class="indexterm"></a><a id="id385386" class="indexterm"></a>foreign call usually indicates some kind of I/O,
which should remind us to look back at what happens between iterations in the
<code class="literal">kmeans_seq</code> function:</p>
<pre class="programlisting" data-language="haskell" id="loop_n_clusters">      <code class="n">loop</code> <code class="n">n</code> <code class="n">clusters</code> <code class="ow">=</code> <code class="kr">do</code>
        <code class="n">printf</code> <code class="s">"iteration %d</code><code class="se">\n</code><code class="s">"</code> <code class="n">n</code>
        <code class="n">putStr</code> <code class="p">(</code><code class="n">unlines</code> <code class="p">(</code><code class="n">map</code> <code class="n">show</code> <code class="n">clusters</code><code class="p">))</code>
        <code class="o">...</code></pre>
<p id="par-strat_00000125">We’re printing some output. Furthermore, we’re doing this in the
sequential part of the program, and Amdahl’s law is making us pay for
it in parallel speedup.</p>
<p id="par-strat_00000126">Commenting out these two lines (in both <code class="literal">kmeans_seq</code> and
<code class="literal">kmeans_strat</code>, to be fair) improves the parallel speedup from 2.6 to
<span class="strong"><strong>3.4</strong></span> on my quad-core machine.  It’s amazing how easy it is to make a
small mistake like this in parallel programming, but fortunately
ThreadScope helps us identify the problem, or at least gives us clues
about where we <a id="id385543" class="indexterm"></a>should <a id="id385554" class="indexterm"></a>look.<a id="id385565" class="indexterm"></a></p>
</div>
<div class="sect2" id="sec_par-kmeans-visualising-sparks">
<div class="titlepage"><div><div><h3 class="title">Visualizing Spark Activity</h3></div></div></div>
<p id="par-strat_00000127"><a id="ix_ch03_par-strat-txt16" class="indexterm"></a><a id="ix_ch03_par-strat-txt17" class="indexterm"></a>We can also use <a id="ix_ch03_par-strat-txt18" class="indexterm"></a>ThreadScope to visualize the creation and use of sparks
during the run of the program.  <a class="xref" href="ch03.html#fig_kmeans5" title="Figure 3-6. kmeans on four cores, spark pool sizes">Figure 3-6</a> shows the profile for
<code class="literal">kmeans</code> running on four cores, showing the spark pool size over time for
each HEC (these graphs are enabled in the ThreadScope GUI from the
"Traces" tab in the left pane).</p>
<div class="figure" id="fig_kmeans5">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0306.png" alt="kmeans on four cores, spark pool sizes"></div></div>
<div class="figure-title">Figure 3-6. kmeans on four cores, spark pool sizes</div>
</div>
<p id="par-strat_00000128">The figure clearly shows that as each iteration starts, 64 sparks are
created on one HEC and then are gradually consumed.  What is perhaps
surprising is that the sparks aren’t always generated on the same HEC;
this is the GHC runtime moving work behind the scenes as it tries to
keep the load balanced across the cores.</p>
<p id="par-strat_00000129">There are more spark-related graphs available in ThreadScope, showing
the rates of spark creation and conversion (running sparks).  All of
these can be valuable in understanding the performance characteristics
of your parallel <a id="id385680" class="indexterm"></a>program.<a id="id385691" class="indexterm"></a><a id="id385700" class="indexterm"></a></p>
</div>
<div class="sect2" id="sec_par-kmeans-granularity">
<div class="titlepage"><div><div><h3 class="title">Granularity</h3></div></div></div>
<p id="par-strat_00000130"><a id="ix_ch03_par-strat-txt19" class="indexterm"></a><a id="ix_ch03_par-strat-txt20" class="indexterm"></a>Looking back at <a class="xref" href="ch03.html#fig_kmeans4" title="Figure 3-5. kmeans on four cores, gap between iterations">Figure 3-5</a>, I remarked earlier that the parallel
section didn’t finish evenly, with two cores running a bit
longer than the others.  Ideally, we would have all the cores running
until the end to maximize our speedup.</p>
<p id="par-strat_00000131">As we saw in <a class="xref" href="ch02.html#sec_par-eval-sudoku2" title="Example: Parallelizing a Sudoku Solver">“Example: Parallelizing a Sudoku Solver”</a>, having too few work items in
our parallel program can impact the <a id="ix_ch03_par-strat-txt21" class="indexterm"></a><a id="ix_ch03_par-strat-txt22" class="indexterm"></a>speedup, because the work items
can vary in cost.  To get a more even run, we want to create
fine-grained work items and more of them.</p>
<p id="par-strat_00000132">To see the effect of this, I ran <code class="literal">kmeans</code> with various numbers of
chunks from 4 up to 512, and measured the runtime on 4 cores.  The
results are shown in <a class="xref" href="ch03.html#fig_kmeans-granularity" title="Figure 3-7. The effect of the number of chunks in kmeans">Figure 3-7</a>.</p>
<div class="figure" id="fig_kmeans-granularity">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0307.png" alt="The effect of the number of chunkingnumber of chunks and runtimechunks in kmeans"></div></div>
<div class="figure-title">Figure 3-7. The effect of the number of <a id="ix_ch03_par-strat-txt23" class="indexterm"></a>chunks in kmeans</div>
</div>
<p id="par-strat_00000133">We can see not only that having too few chunks is not good for the
reasons given above, but also having too many can have a severe
impact.  In this case, the sweet spot is somewhere around 50-100.</p>
<p id="par-strat_00000134">Why does having too many chunks increase the runtime?
There are two reasons:</p>
<div class="itemizedlist" id="par-strat_00000135"><ul class="itemizedlist">
<li class="listitem">
There is some overhead per chunk in creating the spark and
  arranging to run it on another processor.  As the chunks get
  smaller, this overhead becomes more significant.
</li>
<li class="listitem">
The amount of sequential work that the program has to do is greater.
  Combining the results from 512 chunks takes longer than 64, and
  because this is in the sequential part, it significantly impacts the
  <a id="id385890" class="indexterm"></a>parallel <a id="id385900" class="indexterm"></a><a id="id385909" class="indexterm"></a>performance.<a id="id385920" class="indexterm"></a><a id="id385929" class="indexterm"></a><a id="id385939" class="indexterm"></a><a id="id385948" class="indexterm"></a>
</li>
</ul></div>
</div>
</div>
<div class="sect1" data-original-filename="ch03_par-strat.asciidoc" id="sec_par-strat-speculative">
<div class="titlepage"><div><div><h2 class="title">GC’d Sparks and Speculative Parallelism</h2></div></div></div>
<p id="par-strat_00000137"><a id="ix_ch03_par-strat-txt25" class="indexterm"></a><a id="ix_ch03_par-strat-txt26" class="indexterm"></a><a id="ix_ch03_par-strat-txt27" class="indexterm"></a>Recall the definition of <code class="literal">parList</code>:</p>
<pre class="programlisting" data-language="haskell" id="parlist__stra_id2"><code class="nf">parList</code> <code class="ow">::</code> <code class="kt">Strategy</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Strategy</code> <code class="p">[</code><code class="n">a</code><code class="p">]</code>
<code class="nf">parList</code> <code class="n">strat</code> <code class="ow">=</code> <code class="n">evalList</code> <code class="p">(</code><code class="n">rparWith</code> <code class="n">strat</code><code class="p">)</code></pre>
<p id="and_the_underly">And the underlying parameterized <code class="literal">Strategy</code> on lists, <code class="literal">evalList</code>:</p>
<pre class="programlisting" data-language="haskell" id="evallist__str_id2"><code class="nf">evalList</code> <code class="ow">::</code> <code class="kt">Strategy</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Strategy</code> <code class="p">[</code><code class="n">a</code><code class="p">]</code>
<code class="nf">evalList</code> <code class="n">strat</code> <code class="kt">[]</code>     <code class="ow">=</code> <code class="n">return</code> <code class="kt">[]</code>
<code class="nf">evalList</code> <code class="n">strat</code> <code class="p">(</code><code class="n">x</code><code class="kt">:</code><code class="n">xs</code><code class="p">)</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">x'</code>  <code class="ow">&lt;-</code> <code class="n">strat</code> <code class="n">x</code>
  <code class="n">xs'</code> <code class="ow">&lt;-</code> <code class="n">evalList</code> <code class="n">strat</code> <code class="n">xs</code>
  <code class="n">return</code> <code class="p">(</code><code class="n">x'</code><code class="kt">:</code><code class="n">xs'</code><code class="p">)</code></pre>
<p id="par-strat_00000139">As <code class="literal">evalList</code> traverses the list applying the strategy <code class="literal">strat</code> to the
list elements, it remembers each value returned by <code class="literal">strat</code> (bound to
<code class="literal">x'</code>), and constructs a new list from these values. Why?  Well, one
answer is that a Strategy must return a data structure equal to the
one it was passed.</p>
<p id="but_do_we_reall">But do we really need to build a new list? After all, this means that
<code class="literal">evalList</code> is not <span class="emphasis"><em>tail-recursive</em></span>; the recursive call to
<code class="literal">evalList</code> is not the last operation in the <code class="literal">do</code> on its right-hand
side, so <code class="literal">evalList</code> requires stack space linear in the length of
the input list.</p>
<p id="par-strat_00000140">Couldn’t we just write a <a id="ix_ch03_par-strat-txt28" class="indexterm"></a>tail-recursive version of <code class="literal">parList</code> instead?
Perhaps like this:</p>
<pre class="programlisting" data-language="haskell" id="parlist__stra_id3"><code class="nf">parList</code> <code class="ow">::</code> <code class="kt">Strategy</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Strategy</code> <code class="p">[</code><code class="n">a</code><code class="p">]</code>
<code class="nf">parList</code> <code class="n">strat</code> <code class="n">xs</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">go</code> <code class="n">xs</code>
  <code class="n">return</code> <code class="n">xs</code>
 <code class="kr">where</code>
  <code class="n">go</code> <code class="kt">[]</code>     <code class="ow">=</code> <code class="n">return</code> <code class="nb">()</code>
  <code class="n">go</code> <code class="p">(</code><code class="n">x</code><code class="kt">:</code><code class="n">xs</code><code class="p">)</code> <code class="ow">=</code> <code class="kr">do</code> <code class="n">rparWith</code> <code class="n">strat</code> <code class="n">x</code>
                 <code class="n">go</code> <code class="n">xs</code></pre>
<p id="par-strat_00000142">After all, this is type-correct and seems to call <code class="literal">rparWith</code> on each
list element as required.</p>
<p id="par-strat_00000143">Unfortunately, this version of <code class="literal">parList</code> has a serious problem: All the
parallelism it creates will be discarded by the garbage
collector.  The omission of the result list turns out to be
crucial. Let’s take a look at the data structures that our original,
correct implementations of <code class="literal">parList</code> and <code class="literal">evalList</code> created<a id="id386685" class="indexterm"></a>
(<a class="xref" href="ch03.html#fig_parlist-heap" title="Figure 3-8. parList heap structures">Figure 3-8</a>).</p>
<div class="figure" id="fig_parlist-heap">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0308.png" alt="parList heap structures"></div></div>
<div class="figure-title">Figure 3-8. parList heap structures</div>
</div>
<p id="par-strat_00000147">At the top of the diagram is the input list <code class="literal">xs</code>: a linked list
of cells, each of which points to a list element (<code class="literal">x1</code>, <code class="literal">x2</code>, and so
forth).  At the bottom of the diagram is <a id="id386742" class="indexterm"></a>the <span class="emphasis"><em>spark pool</em></span>, the runtime
system data structure that stores references to sparks in the heap.
The other structures in the diagram are built by <code class="literal">parList</code> (the
correct version, not the one I most recently showed). Each <code class="literal">strat</code> box represents the
strategy <code class="literal">strat</code> applied to an element of the original list, and
<code class="literal">xs'</code> is the linked list of cells in the output list.  The spark pool
contains pointers to each of the <code class="literal">strat</code> boxes; these are the pointers
created by each call to <code class="literal">rparWith</code>.</p>
<p id="par-strat_00000148">The GHC runtime regularly checks the spark pool for any entries that
are not required by the program and removes them.  It would be bad to
retain entries that aren’t needed, because that could cause the
program to hold on to memory unnecessarily, leading to a space leak.
We don’t want parallelism to have a negative impact on performance.</p>
<p id="par-strat_00000149">How does the runtime know whether an entry is needed?  The same way it
knows whether any item in memory is needed: There must be a pointer to
it from something else that is needed.  This is the reason that <code class="literal">parList</code>
creates a new list <code class="literal">xs'</code>.  Suppose we did not build the new
list <code class="literal">xs'</code>, as in the tail-recursive version of <code class="literal">parList</code> above.
Then the only reference to each <code class="literal">strat</code> box in the heap would be from
the spark pool, and hence the runtime would automatically sweep all
those references from the spark pool, discarding the parallelism.
So we build a new list <code class="literal">xs'</code> to hold references to the <code class="literal">strat</code> calls
that we need to retain.</p>
<p id="par-strat_00000151">The automatic discarding of unreferenced sparks has another benefit besides avoiding space leaks; suppose that under some circumstances the program does not need the entire list.  If the program simply forgets the unused remainder of the list, the runtime system will clean up the unreferenced sparks from the spark pool and will not waste any further parallel processing resources on evaluating those sparks.  The extra parallelism in this case is <a id="id323363" class="indexterm"></a>termed <span class="emphasis"><em>speculative</em></span>, because it is not necessarily required, and the runtime will automatically discard speculative tasks that it can prove will never be required—a useful property!</p>
<p id="par-strat_00000152">Although the runtime system’s discarding of unreferenced sparks is
certainly useful in some cases, it can be tricky to work with because
there is no language-level support for catching mistakes.  Fortunately,
the runtime system will tell us if it garbage-collects unreferenced
sparks.  For example, if you use the tail-recursive <code class="literal">parList</code> with the
Sudoku solver from <a class="xref" href="ch02.html" title="Chapter 2. Basic Parallelism: The Eval Monad">Chapter 2</a>, the <code class="literal">+RTS -s</code> stats will show
something like this:</p>
<pre class="screen" id="par-strat_00000144">  SPARKS: 1000 (2 converted, 0 overflowed, 0 dud, 998 GC'd, 0 fizzled)</pre>
<p id="garbagecollect">Garbage-collected<a id="id323421" class="indexterm"></a> sparks are reported as "GC’d."  ThreadScope will
also indicate GC’d sparks in its spark graphs.</p>
<p id="par-strat_00000153">If you see that a large number of sparks are GC’d, it’s a good
indication that sparks are being removed from the spark pool before
they can be used for parallelism.  Unless you are using speculation, a
non-zero figure for GC’d sparks is probably a bad sign.</p>
<p id="par-strat_00000154">All the combinators in the <code class="literal">Control.Parallel.Strategies</code> libraries
retain references to sparks correctly.  These are the rules of thumb for not
shooting yourself in the foot:</p>
<div class="itemizedlist" id="par-strat_00000155"><ul class="itemizedlist">
<li class="listitem">
Use <code class="literal">using</code> <a id="id387039" class="indexterm"></a>to apply Strategies instead of <code class="literal">runEval</code>; it encourages the right pattern, in which the program uses the results of applying the Strategy.
</li>
<li class="listitem">
<p id="when_writing_yo" class="simpara">
When writing your own <code class="literal">Eval</code> monad code, this is wrong:
</p>
<pre class="programlisting" data-language="haskell" id="do__rpar_f_">  <code class="kr">do</code>
    <code class="o">...</code>
    <code class="n">rpar</code> <code class="p">(</code><code class="n">f</code> <code class="n">x</code><code class="p">)</code>
    <code class="o">...</code></pre>
<p id="equivalently_r" class="simpara">Equivalently, <a id="id387125" class="indexterm"></a>using <code class="literal">rparWith</code> without binding the result is wrong.
However, this is OK:</p>
<pre class="programlisting" data-language="haskell" id="do__y__rpa">  <code class="kr">do</code>
    <code class="o">...</code>
    <code class="n">y</code> <code class="ow">&lt;-</code> <code class="n">rpar</code> <code class="p">(</code><code class="n">f</code> <code class="n">x</code><code class="p">)</code>
    <code class="o">...</code> <code class="n">y</code> <code class="o">...</code></pre>
<p id="and_this_might_" class="simpara">And this might be OK, as long as <code class="literal">y</code> is required by the program somewhere: <a id="id387221" class="indexterm"></a><a id="id387230" class="indexterm"></a><a id="id387240" class="indexterm"></a></p>
<pre class="programlisting" data-language="haskell" id="do__rpar_y_">  <code class="kr">do</code>
    <code class="o">...</code>
    <code class="n">rpar</code> <code class="n">y</code>
    <code class="o">...</code></pre>
</li>
</ul></div>
</div>
<div class="sect1" data-original-filename="ch03_par-strat.asciidoc" id="sec_parBuffer">
<div class="titlepage"><div><div><h2 class="title">Parallelizing Lazy Streams with parBuffer</h2></div></div></div>
<p id="par-strat_00000157"><a id="ix_ch03_par-strat-txt29" class="indexterm"></a><a id="ix_ch03_par-strat-txt30" class="indexterm"></a><a id="ix_ch03_par-strat-txt31" class="indexterm"></a>A common pattern in Haskell programming is to use a lazy list as a
stream so that the program can consume input while simultaneously
producing output and consequently run in constant space.  Such
programs present something of a challenge for parallelism; if we
aren’t careful, parallelizing the computation will destroy the lazy
streaming property and the program will require space linear in the
size of the input.</p>
<p id="par-strat_00000158">To demonstrate this, we will use the sample program <span class="emphasis"><em>rsa.hs</em></span>,
an implementation of RSA encryption and decryption.  The program
takes two command line arguments: the first specifies which action to
take, <code class="literal">encrypt</code> or <code class="literal">decrypt</code>, and the second is either the filename of
the file to read, or the character <code class="literal">-</code> to read from <code class="literal">stdin</code>.  The
output is always produced on <code class="literal">stdout</code>.</p>
<p id="par-strat_00000159">The following example uses the program to encrypt the message <code class="literal">"Hello World!"</code>:</p>
<pre class="screen" id="par-strat_00000160">$ echo 'Hello World!' | ./rsa encrypt -
11656463941851871045300458781178110195032310900426966299882646602337646308966290
04616367852931838847898165226788260038683620100405280790394258940505884384435202
74975036125752600761230510342589852431747</pre>
<p id="par-strat_00000161">And we can test that the program successfully decrypts the output,
producing the original text, by piping the output back into <code class="literal">rsa
decrypt</code>:</p>
<pre class="screen" id="par-strat_00000162">$ echo "Hello World!" | ./rsa encrypt - | ./rsa decrypt -
Hello World!</pre>
<p id="par-strat_00000163">The <code class="literal">rsa</code> program is a stream transformer, consuming input and
producing output lazily.  We can see this by looking at the RTS stats:</p>
<pre class="screen" id="par-strat_00000164">$ ./rsa encrypt /usr/share/dict/words &gt;/dev/null +RTS -s
   8,040,128,392 bytes allocated in the heap
      66,756,936 bytes copied during GC
         186,992 bytes maximum residency (71 sample(s))
          36,584 bytes maximum slop
               2 MB total memory in use (0 MB lost due to fragmentation)</pre>
<p id="par-strat_00000165">The <span class="emphasis"><em>/usr/share/dict/words</em></span> file is about 1 MB in size, but the program has a
maximum residency (live memory) of 186,992 bytes.</p>
<p id="par-strat_00000166">Let’s try to parallelize the program.  The program uses the lazy
<code class="literal">ByteString</code> type from <code class="literal">Data.ByteString.Lazy</code> to achieve streaming,
and the top-level <code class="literal">encrypt</code> function has this type:</p>
<pre class="programlisting" data-language="haskell" id="encrypt__inte_id1"><code class="nf">encrypt</code> <code class="ow">::</code> <code class="kt">Integer</code> <code class="ow">-&gt;</code> <code class="kt">Integer</code> <code class="ow">-&gt;</code> <code class="kt">ByteString</code> <code class="ow">-&gt;</code> <code class="kt">ByteString</code></pre>
<p id="par-strat_00000168">The two <code class="literal">Integer</code>s are the key with which to encrypt the data.  The
implementation of <code class="literal">encrypt</code> is a beautiful pipeline composition:</p>
<p id="par-strat_00000169" class="caption"><span class="emphasis"><em>rsa.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="encrypt_n_e__b_id1"><code class="nf">encrypt</code> <code class="n">n</code> <code class="n">e</code> <code class="ow">=</code> <code class="kt">B</code><code class="o">.</code><code class="n">unlines</code>                                <code class="c1">-- </code><span id="CO5-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
            <code class="o">.</code> <code class="n">map</code> <code class="p">(</code><code class="kt">B</code><code class="o">.</code><code class="n">pack</code> <code class="o">.</code> <code class="n">show</code> <code class="o">.</code> <code class="n">power</code> <code class="n">e</code> <code class="n">n</code> <code class="o">.</code> <code class="n">code</code><code class="p">)</code>   <code class="c1">-- </code><span id="CO5-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>
            <code class="o">.</code> <code class="n">chunk</code> <code class="p">(</code><code class="n">size</code> <code class="n">n</code><code class="p">)</code>                           <code class="c1">-- </code><span id="CO5-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></pre>
<div class="calloutlist" id="par-strat_00000170"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO5-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="divide_the_inpu">
Divide the input into chunks.  Each chunk is encrypted
separately; this has nothing to do with parallelism.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO5-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="encrypt_each_ch">
Encrypt each chunk.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO5-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="concatenate_the">
Concatenate the result as a sequence of lines.
</p></td>
</tr>
</table></div>
<p id="par-strat_00000173">We won’t delve into the details of the RSA implementation here, but if
you’re interested, go and look at the code in <span class="emphasis"><em>rsa.hs</em></span> (it’s fairly
short).  For the purposes of parallelism, all we need to know is that
there’s a <code class="literal">map</code> on the second line, so that’s our target for
<span class="keep-together">parallelization</span>.</p>
<p id="par-strat_00000174">First, let’s try to use <a id="ix_ch03_par-strat-txt32" class="indexterm"></a>the <code class="literal">parList</code> Strategy that we have seen before:</p>
<p id="par-strat_00000175" class="caption"><span class="emphasis"><em>rsa1.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="encrypt_n_e__b_id2"><code class="nf">encrypt</code> <code class="n">n</code> <code class="n">e</code> <code class="ow">=</code> <code class="kt">B</code><code class="o">.</code><code class="n">unlines</code>
            <code class="o">.</code> <code class="n">withStrategy</code> <code class="p">(</code><code class="n">parList</code> <code class="n">rdeepseq</code><code class="p">)</code>        <code class="c1">-- </code><span id="CO6-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
            <code class="o">.</code> <code class="n">map</code> <code class="p">(</code><code class="kt">B</code><code class="o">.</code><code class="n">pack</code> <code class="o">.</code> <code class="n">show</code> <code class="o">.</code> <code class="n">power</code> <code class="n">e</code> <code class="n">n</code> <code class="o">.</code> <code class="n">code</code><code class="p">)</code>
            <code class="o">.</code> <code class="n">chunk</code> <code class="p">(</code><code class="n">size</code> <code class="n">n</code><code class="p">)</code></pre>
<div class="calloutlist" id="par-strat_00000176"><table style="border: 0; "><tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO6-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="im_withstrateg">
I’m <a id="id388078" class="indexterm"></a>using <code class="literal">withStrategy</code> here, which is just a version of <code class="literal">using</code>
with the arguments flipped; it is slightly nicer in situations like
this.  The Strategy is <code class="literal">parList</code>, with <code class="literal">rdeepseq</code> as the Strategy to
apply to the list elements (the list elements are lazy <code class="literal">ByteStrings</code>, so we
want to ensure that they are fully evaluated).
</p></td>
</tr></table></div>
<p id="par-strat_00000177">If we run this program on four cores, the stats show something
interesting:</p>
<pre class="screen" id="par-strat_00000178">   6,251,537,576 bytes allocated in the heap
      44,392,808 bytes copied during GC
       2,415,240 bytes maximum residency (33 sample(s))
         550,264 bytes maximum slop
              10 MB total memory in use (0 MB lost due to fragmentation)</pre>
<p id="par-strat_00000179">The maximum residency has increased to 2.3 MB, because the <code class="literal">parList</code>
Strategy forces the whole spine of the list, preventing the program
from streaming in constant space.  The speedup in this case was 2.2;
not terrible, but not great either.  We can do better.</p>
<p id="par-strat_00000180">The <code class="literal">Control.Parallel.Strategies</code> library provides a Strategy to solve
exactly this problem, called<a id="id388162" class="indexterm"></a> <code class="literal">parBuffer</code>:</p>
<pre class="programlisting" data-language="haskell" id="parbuffer__in"><code class="nf">parBuffer</code> <code class="ow">::</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="kt">Strategy</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Strategy</code> <code class="p">[</code><code class="n">a</code><code class="p">]</code></pre>
<p id="par-strat_00000182">The <code class="literal">parBuffer</code> function has a similar type to <code class="literal">parList</code> but takes an <code class="literal">Int</code>
argument as a buffer size.  In contrast to <code class="literal">parList</code> which eagerly
creates a spark for every list element, <code class="literal">parBuffer</code> <span class="emphasis"><em>N</em></span> creates
sparks for only the first <span class="emphasis"><em>N</em></span> elements of the list, and then creates
more sparks as the result list is consumed.  The effect is that there
will always be <span class="emphasis"><em>N</em></span> sparks available until the end of the list is
reached.</p>
<p id="par-strat_00000183">The disadvantage of <code class="literal">parBuffer</code> is that we have to choose a particular
value for the <a id="id388304" class="indexterm"></a>buffer size, and as with the chunk factor we saw
earlier, there will be a "best value" somewhere in the range.
Fortunately, performance is usually not too sensitive to this value,
and something in the range of 50-500 is often good.  So let’s see how
well this works:</p>
<p id="par-strat_00000184" class="caption"><span class="emphasis"><em>rsa2.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="encrypt_n_e__b_id3"><code class="nf">encrypt</code> <code class="n">n</code> <code class="n">e</code> <code class="ow">=</code> <code class="kt">B</code><code class="o">.</code><code class="n">unlines</code>
            <code class="o">.</code> <code class="n">withStrategy</code> <code class="p">(</code><code class="n">parBuffer</code> <code class="mi">100</code> <code class="n">rdeepseq</code><code class="p">)</code>             <code class="c1">-- </code><span id="CO7-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
            <code class="o">.</code> <code class="n">map</code> <code class="p">(</code><code class="kt">B</code><code class="o">.</code><code class="n">pack</code> <code class="o">.</code> <code class="n">show</code> <code class="o">.</code> <code class="n">power</code> <code class="n">e</code> <code class="n">n</code> <code class="o">.</code> <code class="n">code</code><code class="p">)</code>
            <code class="o">.</code> <code class="n">chunk</code> <code class="p">(</code><code class="n">size</code> <code class="n">n</code><code class="p">)</code></pre>
<div class="calloutlist" id="par-strat_00000185"><table style="border: 0; "><tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO7-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="here_i_replaced">
Here I replaced <code class="literal">parList</code> with <code class="literal">parBuffer 100</code>.
</p></td>
</tr></table></div>
<p id="par-strat_00000186">This programs achieves a speedup of 3.5 on 4 cores. Furthermore, it
runs in much less memory than the <code class="literal">parList</code> version:</p>
<pre class="screen" id="par-strat_00000187">   6,275,891,072 bytes allocated in the heap
      27,749,720 bytes copied during GC
         294,872 bytes maximum residency (58 sample(s))
          62,456 bytes maximum slop
               4 MB total memory in use (0 MB lost due to fragmentation)</pre>
<p id="par-strat_00000188">We can expect it to need more memory than the sequential version, which required only 2 MB,
because we’re performing many computations in parallel.  Indeed, a
higher residency is common in parallel programs for the simple reason
that they are doing more work, although it’s not always the case;
sometimes parallel evaluation can reduce memory overhead by
evaluating thunks that were causing space leaks.</p>
<p id="par-strat_00000189">ThreadScope’s spark pool graph shows that <code class="literal">parBuffer</code> really does keep
a constant supply of sparks, as shown in <a class="xref" href="ch03.html#fig_rsa2" title="Figure 3-9. rsa on four cores, using parBuffer">Figure 3-9</a>.</p>
<div class="figure" id="fig_rsa2">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0309.png" alt="rsa on four cores, using parBuffer"></div></div>
<div class="figure-title">Figure 3-9. rsa on four cores, using parBuffer</div>
</div>
<p id="par-strat_00000190">The spark pool on HEC 0 constantly hovers around 90-100 sparks.</p>
<p id="par-strat_00000191">In programs with a multistage pipeline, interposing more calls to
<code class="literal">withStrategy</code> in the pipeline can expose more parallelism.<a id="id388645" class="indexterm"></a><a id="id388654" class="indexterm"></a><a id="id388663" class="indexterm"></a></p>
</div>
<div class="sect1" data-original-filename="ch03_par-strat.asciidoc" id="sec_more-strategies">
<div class="titlepage"><div><div><h2 class="title">Chunking Strategies</h2></div></div></div>
<p id="par-strat_00000193">When parallelizing K-Means in <a class="xref" href="ch03.html#sec_par-kmeans-parallel" title="Parallelizing K-Means">“Parallelizing K-Means”</a>, we divided
the input data into chunks to avoid creating parallelism with
excessively fine granularity.  Chunking is a common technique, so the
<code class="literal">Control.Parallel.Strategies</code> library provides a version <a id="ix_ch03_par-strat-txt35" class="indexterm"></a>of <code class="literal">parList</code>
that has chunking built in:</p>
<pre class="programlisting" data-language="haskell" id="parlistchunk_"><code class="nf">parListChunk</code> <code class="ow">::</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="kt">Strategy</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Strategy</code> <code class="p">[</code><code class="n">a</code><code class="p">]</code></pre>
<p id="par-strat_00000195">The first argument is the number of elements in each chunk; the list
is split in the same way as the <code class="literal">chunk</code> function that we saw earlier
in the <code class="literal">kmeans</code> example.  You might find <code class="literal">parListChunk</code> useful if you
have a list with too many elements to spark every one, or when the
list elements are too cheap to warrant a spark each.</p>
<p id="par-strat_00000196">The spark pool has a fixed size, and when the pool is full, subsequent
sparks are dropped and reported as <code class="literal">overflowed</code> in the <code class="literal">+RTS -s</code> stats output.  If you see some overflowed sparks, it is probably a
good idea to create fewer sparks; replacing <code class="literal">parList</code> with
<code class="literal">parListChunk</code> is a good way to do that.</p>
<p id="par-strat_00000197">Note that chunking the list incurs some overhead, as we noticed in the
earlier <code class="literal">kmeans</code> example when we used chunking directly.  For that
reason, in <code class="literal">kmeans</code> we created the chunked list once and shared it
amongst all the iterations of the algorithm, rather than using
<code class="literal">parListChunk</code>, which would chunk the list every <a id="id388872" class="indexterm"></a>time.</p>
</div>
<div class="sect1" data-original-filename="ch03_par-strat.asciidoc" id="sec_strat_identity">
<div class="titlepage"><div><div><h2 class="title">The Identity Property</h2></div></div></div>
<p id="identity_proper"><a id="ix_ch03_par-strat-txt36" class="indexterm"></a><a id="ix_ch03_par-strat-txt37" class="indexterm"></a>I mentioned at the beginning of this chapter that if we see an
expression of this form:</p>
<pre class="programlisting" data-language="haskell" id="x_using_s">  <code class="n">x</code> <code class="p">`</code><code class="n">using</code><code class="p">`</code> <code class="n">s</code></pre>
<p id="we_can_delete_">We can delete <code class="literal">`using` s</code>, leaving an equivalent program. For this to be true, the Strategy <code class="literal">s</code> must obey the <span class="emphasis"><em>identity property</em></span>; that is, the value it returns must be equal to the value it was passed.  The operations provided by the <code class="literal">Control.Parallel</code><code class="literal">.Strategies</code> library all satisfy this property, but unfortunately it isn’t possible to enforce it for arbitrary user-defined Strategies.  Hence we cannot <span class="emphasis"><em>guarantee</em></span> that <code class="literal">x `using` s == x</code>, just as we cannot guarantee that all instances of <code class="literal">Monad</code> satisfy the monad laws, or that all instances of <code class="literal">Eq</code> are reflexive.  These properties are satisfied by convention only; this is just something to be aware of.</p>
<p id="par-strat_00000016">There is one more caveat to this property.  The
expression <code class="literal">x `using` s</code> might <a id="id389033" class="indexterm"></a>be <span class="emphasis"><em>less defined</em></span> than <code class="literal">x</code>, because it
evaluates more structure of <code class="literal">x</code> than the context does.  What does
<span class="emphasis"><em>less defined</em></span> mean?  It means that the program containing <code class="literal">x `using` s</code> might fail with an error when simply <code class="literal">x</code> would not.  A trivial
example of this is:</p>
<pre class="programlisting" data-language="haskell" id="print__snd__"><code class="nf">print</code> <code class="o">$</code> <code class="n">snd</code> <code class="p">(</code><code class="mi">1</code> <code class="p">`</code><code class="n">div</code><code class="p">`</code> <code class="mi">0</code><code class="p">,</code> <code class="s">"Hello!"</code><code class="p">)</code></pre>
<p id="par-strat_00000018">This program works and prints <code class="literal">"Hello!"</code>, but:</p>
<pre class="programlisting" data-language="haskell" id="print__snd_"><code class="nf">print</code> <code class="o">$</code> <code class="n">snd</code> <code class="p">((</code><code class="mi">1</code> <code class="p">`</code><code class="n">div</code><code class="p">`</code> <code class="mi">0</code><code class="p">,</code> <code class="s">"Hello!"</code><code class="p">)</code> <code class="p">`</code><code class="n">using</code><code class="p">`</code> <code class="n">rdeepseq</code><code class="p">)</code></pre>
<p id="par-strat_00000020">This program fails with <code class="literal">divide by zero</code>.  The original program didn’t
fail because the erroneous expression was never evaluated, but adding
the Strategy has caused the program to fully evaluate the pair, including
the division by zero.</p>
<p id="this_is_rarely_">This is rarely a problem in practice; if the Strategy evaluates more
than the program would have done anyway, the Strategy is probably
wasting effort and needs to be <span class="keep-together">modified</span>.<a id="id389269" class="indexterm"></a><a id="id389278" class="indexterm"></a><a id="id389288" class="indexterm"></a></p>
</div>
<div class="footnotes">
<br><hr style="width: 100; align: left;">
<div id="ftn.id377851" class="footnote"><p><a href="#id377851" class="simpara"><sup class="simpara">[6] </sup></a>This comes with a couple of minor caveats that we’ll describe in <a class="xref" href="ch03.html#sec_strat_identity" title="The Identity Property">“The Identity Property”</a>.</p></div>
<div id="ftn.id378170" class="footnote"><p><a href="#id378170" class="simpara"><sup class="simpara">[7] </sup></a>The <code class="literal">evalPair</code> function is
provided by <code class="literal">Control.Parallel.Strategies</code> as <code class="literal">evalTuple2</code>.</p></div>
<div id="ftn.id380271" class="footnote"><p><a href="#id380271" class="simpara"><sup class="simpara">[8] </sup></a>The actual implementation adds <code class="literal">UNPACK</code> pragmas for efficiency, which I have omitted here for clarity.</p></div>
<div id="ftn.id384970" class="footnote"><p><a href="#id384970" class="simpara"><sup class="simpara">[9] </sup></a>A quad-core Intel i7-3770</p></div>
<div id="ftn.id384975" class="footnote"><p><a href="#id384975" class="simpara"><sup class="simpara">[10] </sup></a>To do this scientifically, you would need to be much more rigorous, but the goal here is just to optimize our program, so rough measurements are fine.</p></div>
</div></section><footer><div class="navfooter">
<hr>
<table style="width: 100%; ">
<tr>
<td style="width: 40%; text-align: left; ">
<a accesskey="p" href="ch02.html">Prev</a> </td>
<td style="width: 20%; text-align: center; "><a accesskey="u" href="pt01.html">Up</a></td>
<td style="width: 40%; text-align: right; "> <a accesskey="n" href="ch04.html">Next</a>
</td>
</tr>
<tr>
<td style="width: 40%; text-align: left; vertical-align: top; ">Chapter 2. Basic Parallelism: The Eval Monad </td>
<td style="width: 20%; text-align: center; "><a accesskey="h" href="index.html">Home</a></td>
<td style="width: 40%; text-align: right; vertical-align: top; "> Chapter 4. Dataflow Parallelism: The Par Monad</td>
</tr>
</table>
</div></footer>


	<div class="extra-footer">
		<p>© 2013, O’Reilly Media, Inc.</p>
		<ul>
			<li><a href="http://oreilly.com/terms/">Terms of Service</a></li>
			<li><a href="http://oreilly.com/oreilly/privacy.csp">Privacy Policy</a></li>
			<li>Interested in <a href="mailto:scordesse@oreilly.com">sponsoring content?</a></li>
		</ul>
	</div>
<script type="text/javascript">if (!NREUMQ.f) { NREUMQ.f=function() {
NREUMQ.push(["load",new Date().getTime()]);
var e=document.createElement("script");
e.type="text/javascript";
e.src=(("http:"===document.location.protocol)?"http:":"https:") + "//" +
  "js-agent.newrelic.com/nr-100.js";
document.body.appendChild(e);
if(NREUMQ.a)NREUMQ.a();
};
NREUMQ.a=window.onload;window.onload=NREUMQ.f;
};
NREUMQ.push(["nrfj","bam.nr-data.net","3e361aebcf","2194180","IApbRUBZXg1WEEoHDAwORh5aQl8N",4,27,new Date().getTime(),"","","","",""]);</script></body>

<!-- Mirrored from chimera.labs.oreilly.com/books/1230000000929/ch03.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 24 Dec 2016 02:18:08 GMT -->
</html>