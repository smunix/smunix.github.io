<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<!-- Mirrored from chimera.labs.oreilly.com/books/1230000000929/ch02.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 22 Dec 2016 02:54:29 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head><script type="text/javascript">var NREUMQ=NREUMQ||[];NREUMQ.push(["mark","firstbyte",new Date().getTime()]);</script>
	<title>Parallel and Concurrent Programming in Haskell</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link href="http://dwn0odqttrkhc.cloudfront.net/assets/book-f1caceafd9c9f3a6ff72d40c54d173ab.css" media="screen" rel="stylesheet" type="text/css" />
	<link href="http://dwn0odqttrkhc.cloudfront.net/assets/default-24583441b4f47382b8932338cd56ed23.css" media="screen" rel="stylesheet" type="text/css" />
	<script src="http://dwn0odqttrkhc.cloudfront.net/assets/application-47d6ffb0c77b868d29a43eb65e940505.js" type="text/javascript"></script>
	<script src="http://dwn0odqttrkhc.cloudfront.net/assets/book-756862b9ed04d945ca53de5b8f106a83.js" type="text/javascript"></script>
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	<link href="http://dwn0odqttrkhc.cloudfront.net/assets/janrain-53eb5abed55992e21943b9d3373923e8.css" media="all" rel="stylesheet" type="text/css" />
	<meta content="authenticity_token" name="csrf-param" />
<meta content="WQ02oEFDbvBG99rmf8rwvGssMqcy27cCD64yZVVTcMY=" name="csrf-token" />
	<script type="text/javascript" charset="utf-8">
  	
		app.data = new classes.Data({"controller":{"controller":"books","action":"html"},"capturable":{"capture_server":"https://oreilly.janraincapture.com","client_id":"6n5q2k9vesqgn93k3mhevka6c3c3rsre","app_url":"https://login.oreilly.com","app_id":"xsnca5wmqe9vxv97ygh5vfejkd","load_js":"d16s8pqtk4uodx.cloudfront.net/login.oreilly.com/load.js"},"user":{"id":null,"account":"LoggedOutAccount","email":"","name":null,"gravatar_url":"http://www.gravatar.com/avatar/d41d8cd98f00b204e9800998ecf8427e?s=40&d=identicon"},"book":{"isbn":"1230000000929","chapter":"ch02.html","toc_url":"/books/1230000000929/toc_html","metadata_url":"http://d4bb7yl96lyl1.cloudfront.net/1230000000929/metadata/metadata_9b2ac4d71a3220a7d463d8d4c80f9113048bb194.json"},"abilities":{"can_destroy_all_comments":false,"can_create_comments":false},"advertisement":{"body":"<style>      \r\n.ad-profile-image {\r\n  padding: 0;\r\n  margin: 0;\r\n  max-height: 30px;\r\n }\r\n\r\n.top-banner {\r\n  position: absolute;\r\n  right: 0;\r\n  top: 34px;\r\n  z-index: 99999;\r\n}\r\n\r\np.banner-text {\r\n  margin: 0;\r\n  text-align: center;\r\n  padding-right: 10px;\r\n  width: 450px;\r\n}\r\n\r\n@media screen and (max-width: 600px) {\r\n   p.banner-text {\r\n     width: 100%;\r\n     text-align: center;\r\n  }\r\n}\r\n\r\nspan.ebook-advantage {\r\n  font-size: smaller;\r\n  display: block;\r\n}\r\n\r\ndiv.banner-container {\r\n  margin: 0 auto;\r\n}\r\n\r\ndiv.banner-container ul {\r\n  margin: 0 auto;\r\n}\r\n\r\ndiv.topad { padding-bottom: 5px; }\r\n\r\ndiv.banner-container ul li {\r\n  display: inline-block;\r\n  vertical-align: middle;\r\n}\r\n\r\ndiv.banner-container li p {\r\n  padding-top: 0;\r\n  margin-top: 0;\r\n}\r\n\r\ndiv.banner-container li.sponsor {\r\n  border-right: 1px solid rgb(125, 154, 180);\r\n  margin-right: 5px;\r\n  padding-right: 10px;\r\n}\r\n\r\ndiv.banner-container .webbutton {\r\n  background-color: #3994b6;\r\n  display: inline-block;\r\n  padding: 10px;\r\n  -webkit-border-radius: 5px;\r\n  -moz-border-radius: 5px;\r\n  border-radius: 5px;\r\n  color: #FFF;\r\n  text-align: center;\r\n  text-decoration: none;\r\n  font-size: 12px;\r\n  font-weight: bold;\r\n}\r\n\r\n</style>\r\n   \r\n<div style=\"color: rgb(125, 154, 180);\">\r\n\r\n<div class=\"banner-container\">\r\n\r\n<ul>\r\n\r\n<li class=\"sponsor\">\r\n<!--CONFERENCE SPONSOR IMAGE-->\r\n<a href=\"http://www.oscon.com/oscon2013\">\r\n<!--<img src=\"http://orm-other.s3.amazonaws.com/fluent_logo.png\" class=\"ad-profile-image\"/>-->\r\n<img src=\"http://orm-other.s3.amazonaws.com/oscon_logo.png\" class=\"ad-profile-image\"/>\r\n<!--<img src=\"http://orm-other.s3.amazonaws.com/strata_logo.png\" class=\"ad-profile-image\"/>\r\n<img src=\"http://orm-other.s3.amazonaws.com/StrataRx_logo.png\" class=\"ad-profile-image\"/>\r\n<img src=\"http://orm-other.s3.amazonaws.com/velocity_logo.png\" class=\"ad-profile-image\"/>-->\r\n</a>\r\n</li>\r\n\r\n<li>\r\n<!--AD TEXT, 2 LINES, REPLACE LINK URL AS WELL-->\r\n<p class=\"banner-text\">Enjoy this online version of <em>Parallel and Concurrent Programming in Haskell</em>. Purchase and download the DRM-free ebook on <a href=\"http://shop.oreilly.com/product/0636920026365.do\">oreilly.com</a>.<span class=\"ebook-advantage\">Learn more about the O’Reilly <a href=\"http://shop.oreilly.com/category/ebooks.do\">Ebook Advantage</a>.</span></p>\r\n</li>\r\n\r\n<li>\r\n<!--BUY BUTTON-->\r\n<a class=\"webbutton\" href=\"http://shop.oreilly.com/product/0636920026365.do\">Buy the Ebook</a>\r\n</li> \r\n\r\n</ul>\r\n\r\n</div>\r\n\r\n<!--CORNER BANNER (IF NEEDED)-->\r\n<!--<a href=\"http://shop.oreilly.com/product/0636920026365.do\" class=\"top-banner\"><img src=\"http://orm-other.s3.amazonaws.com/banner.png\" /></a>-->\r\n\r\n</div>"}});

		/* Janrain setup */
  	var janrainModal = new JanrainView();
  	$("head").append(janrainModal.render().el);

  	/* segment.io setup */
  	var analytics=analytics||[];analytics.load=function(e){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src=("https:"===document.location.protocol?"https://":"http://")+"d2dq2ahtl5zl1z.cloudfront.net/analytics.js/v1/"+e+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(t,n);var r=function(e){return function(){analytics.push([e].concat(Array.prototype.slice.call(arguments,0)))}},i=["identify","track","trackLink","trackForm","trackClick","trackSubmit","pageview","ab","alias","ready"];for(var s=0;s<i.length;s++)analytics[i[s]]=r(i[s])};
  	
  	analytics.load("hg9h6b9pae");

  	$(function() {
			app.bookapp = new BookApp();
		});
	
	</script>
</head>
<body>
	<div id="menu">
	
		<ul id="menu-left">
			<li id="home-link"><a href="http://chimera.labs.oreilly.com/"><i class="icon-house"></i></a></li>
			<li><a href="http://chimera.labs.oreilly.com/books/1230000000929">Parallel and Concurrent Programming in Haskell</a></li>
			<div class="clear"></div>
		</ul>
	
		<ul id="menu-right">
			<li id="comments-link"><a>&nbsp;</a></li>
			<li>
				<a href="#" class="dropdown-toggle" data-toggle="dropdown">Chapters</a>
				<div id="toc-popup" class="dropdown-menu"></div>
			</li>
				<li><a href="#" class="capture_modal_open" id="capture_signin_link">Log In / Sign Up</a></li>
			<li id="search-li">
				<form accept-charset="UTF-8" action="http://chimera.labs.oreilly.com/searches" id="search-form" method="get"><div style="margin:0;padding:0;display:inline"><input name="utf8" type="hidden" value="&#x2713;" /></div>
	<input name='search[q]' type="text" placeholder="Search book..." id="book-search" />

	<input id="search_bookId" name="search[bookId]" type="hidden" value="1230000000929" />
	
	<div style='display:none'>
		sorted by: 
		<select name='search[sort]' >
			<option value='relevance'>Relevance</option>
			<option value='authors'>Author(s)</option>
			<option value='title'>Title</option>
		</select>
		returning
		<select name='search[limit]' >
			<option value='5'>5</option>
			<option value='10'>10</option>
			<option value='20'>20</option>
			<option selected="selected" value='50'>50</option>
			<option value='100'>100</option>
		</select>
		values at a time.
	</div>
</form>
			</li>
			<div class="clear"></div>
		</ul>
		<div class="clear"></div>
	
</div>
	<header><div class="navheader">
<table style="width: 100%; ">
<tr><td style="text-align: center; " colspan="3">Chapter 2. Basic Parallelism: The Eval Monad</td></tr>
<tr>
<td style="width: 20%; text-align: left; ">
<a accesskey="p" href="pt01.html">Prev</a> </td>
<td style="width: 60%; text-align: center; ">Part I. Parallel Haskell</td>
<td style="width: 20%; text-align: right; "> <a accesskey="n" href="ch03.html">Next</a>
</td>
</tr>
</table>
<hr>
</div></header><section class="chapter" data-original-filename="ch02_par-eval.asciidoc" id="sec_par-eval"><div class="titlepage"><div><div><h2 class="title">Chapter 2. Basic Parallelism: The Eval Monad</h2></div></div></div>
<p id="parallelismthis"><a id="ix_ch02_par-eval-txt0" class="indexterm"></a>This chapter will teach you the basics of adding parallelism to your
Haskell code.  We’ll start with some essential background about lazy
evaluation in the next section before moving on to look at how to use
parallelism in <a class="xref" href="ch02.html#sec_par-rpar-rseq" title="The Eval Monad, rpar, and rseq">“The Eval Monad, rpar, and rseq”</a>.</p>
<div class="sect1" data-original-filename="ch02_par-eval.asciidoc" id="sec_par-eval-whnf">
<div class="titlepage"><div><div><h2 class="title">Lazy Evaluation and Weak Head Normal Form</h2></div></div></div>
<p id="par-eval_00000000"><a id="ix_ch02_par-eval-txt1" class="indexterm"></a><a id="ix_ch02_par-eval-txt2" class="indexterm"></a><a id="ix_ch02_par-eval-txt3" class="indexterm"></a><a id="ix_ch02_par-eval-txt4" class="indexterm"></a><a id="ix_ch02_par-eval-txt5" class="indexterm"></a><a id="ix_ch02_par-eval-txt6" class="indexterm"></a>Haskell is a <span class="emphasis"><em>lazy</em></span> language<a id="id370609" class="indexterm"></a> which means that expressions are not
evaluated until they are required.<a href="#ftn.id370618" class="footnote"><sup class="footnote" id="id370618">[1]</sup></a>
Normally, we don’t have to worry about how this happens; as
long as expressions are evaluated when they are needed and not
evaluated if they aren’t, everything is fine.  However, when adding
parallelism to our code, we’re telling the compiler something about
how the program should be run: Certain things should happen in
parallel.  To be able to use parallelism effectively, it helps to have
an intuition for how lazy evaluation works, so this section will
explore the basic concepts using GHCi as a playground.</p>
<p id="par-eval_00000001">Let’s start with something very simple:</p>
<pre class="screen" id="par-eval_00000002">Prelude&gt; let x = 1 + 2 :: Int</pre>
<p id="par-eval_00000003">This binds the variable <code class="literal">x</code> to the expression <code class="literal">1 + 2</code> (at type <code class="literal">Int</code>, to avoid any complications due to overloading).  Now, as far as
Haskell is concerned, <code class="literal">1 + 2</code> is equal to <code class="literal">3</code>: We could have written
<code class="literal">let x = 3 :: Int</code> here, and there is no way to tell the difference by
writing ordinary Haskell code.  But for the purposes of parallelism,
we really do care about the difference between <code class="literal">1 + 2</code> and <code class="literal">3</code>,
because <code class="literal">1 + 2</code> is a computation that has not taken place yet, and we
might be able to compute it in parallel with something else.  Of
course in practice, you wouldn’t want to do this with something as
trivial as <code class="literal">1 + 2</code>, but the principle of an unevaluated computation is
nevertheless important.</p>
<p id="par-eval_00000004">We say at this point that <code class="literal">x</code> is <span class="emphasis"><em>unevaluated</em></span>.  Normally in Haskell,
you wouldn’t be able to tell that <code class="literal">x</code> was <a id="id370727" class="indexterm"></a>unevaluated, but fortunately
GHCi’s debugger provides some commands that inspect the structure of
Haskell expressions in a noninvasive way, so we can use those to
demonstrate what’s going on.  The <code class="literal">:sprint</code> <a id="id370742" class="indexterm"></a>command prints the value
of an expression without causing it to be evaluated:</p>
<pre class="screen" id="par-eval_00000005">Prelude&gt; :sprint x
x = _</pre>
<p id="par-eval_00000006">The special symbol <code class="literal">_</code> indicates "unevaluated."  Another term you may
hear in this context is "<a id="id370768" class="indexterm"></a>thunk," which is the object in memory
representing the unevaluated computation <code class="literal">1 + 2</code>.  The thunk in this
case looks something like <a class="xref" href="ch02.html#image_simple_thunk" title="Figure 2-1. The thunk representing 1 + 2">Figure 2-1</a>.</p>
<div class="figure" id="image_simple_thunk">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0201.png" alt="The thunk representing 1 + 2"></div></div>
<div class="figure-title">Figure 2-1. The thunk representing 1 + 2</div>
</div>
<p id="par-eval_00000007">Here, <code class="literal">x</code> is a pointer to an object in memory representing the function
<code class="literal">+</code> applied to the integers <code class="literal">1</code> and <code class="literal">2</code>.</p>
<p id="par-eval_00000008">The thunk<a id="id370831" class="indexterm"></a> representing <code class="literal">x</code> will be evaluated whenever its value is
required.  The easiest way to cause something to be evaluated in GHCi
is to print it; that is, we can just type <code class="literal">x</code> at the prompt:</p>
<pre class="screen" id="par-eval_00000009">Prelude&gt; x
3</pre>
<p id="par-eval_00000010">Now if we inspect the value of <code class="literal">x</code> using <code class="literal">:sprint</code>, we’ll find that
it has been evaluated:</p>
<pre class="screen" id="par-eval_00000011">Prelude&gt; :sprint x
x = 3</pre>
<p id="par-eval_00000012">In <a id="id370884" class="indexterm"></a>terms of the objects in memory, the thunk representing <code class="literal">1 + 2</code> is
actually overwritten by the (boxed) integer 3.<a href="#ftn.id370897" class="footnote"><sup class="footnote" id="id370897">[2]</sup></a>  So any future demand for the value of <code class="literal">x</code> gets the answer
immediately; this is how lazy evaluation works.</p>
<p id="par-eval_00000013">That was a trivial example. Let’s try making something slightly more
complex.</p>
<pre class="screen" id="par-eval_00000014">Prelude&gt; let x = 1 + 2 :: Int
Prelude&gt; let y = x + 1
Prelude&gt; :sprint x
x = _
Prelude&gt; :sprint y
y = _</pre>
<p id="par-eval_00000015">Again, <a id="id370934" class="indexterm"></a>we have <code class="literal">x</code> bound to <code class="literal">1 + 2</code>, but now we have also bound <code class="literal">y</code> to
<code class="literal">x + 1</code>, and <code class="literal">:sprint</code> shows that both are unevaluated as expected.
In memory, we have a structure like <a class="xref" href="ch02.html#image_cascading_thunk" title="Figure 2-2. One thunk referring to another">Figure 2-2</a>.</p>
<div class="figure" id="image_cascading_thunk">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0202.png" alt="One thunk referring to another"></div></div>
<div class="figure-title">Figure 2-2. One thunk referring to another</div>
</div>
<p id="par-eval_00000016">Unfortunately there’s no way to directly inspect this structure, so
you’ll just have to trust me.</p>
<p id="par-eval_00000017">Now, in order to compute the value of <code class="literal">y</code>, the value of <code class="literal">x</code> is needed:
<code class="literal">y</code> depends on <code class="literal">x</code>.  So evaluating <code class="literal">y</code> will also
cause <code class="literal">x</code> to be evaluated.  This time we’ll use a different way
to force evaluation: Haskell’s <a id="ix_ch02_par-eval-txt7" class="indexterm"></a>built-in <code class="literal">seq</code> function.</p>
<pre class="screen" id="par-eval_00000018">Prelude&gt; seq y ()
()</pre>
<p id="par-eval_00000019">The <code class="literal">seq</code> function evaluates its first argument, here <code class="literal">y</code>, and then
returns its second argument—in this case, just <code class="literal">()</code>.  Now let’s
inspect the values of <code class="literal">x</code> and <code class="literal">y</code>:</p>
<pre class="screen" id="par-eval_00000020">Prelude&gt; :sprint x
x = 3
Prelude&gt; :sprint y
y = 4</pre>
<p id="par-eval_00000021">Both are now evaluated, as expected.  So the general principles so far
are:</p>
<div class="itemizedlist" id="par-eval_00000022"><ul class="itemizedlist">
<li class="listitem">
Defining an expression causes a <a id="id371108" class="indexterm"></a>thunk to be built representing that
expression.
</li>
<li class="listitem">
A thunk remains unevaluated until its value is required.  Once
  evaluated, the thunk is replaced by its value<a id="id371123" class="indexterm"></a>.
</li>
</ul></div>
<p id="par-eval_00000024">Let’s see what happens when a <a id="id371136" class="indexterm"></a>data structure is added:</p>
<pre class="screen" id="par-eval_00000025">Prelude&gt; let x = 1 + 2 :: Int
Prelude&gt; let z = (x,x)</pre>
<p id="par-eval_00000026">This binds <code class="literal">z</code> to the pair <code class="literal">(x,x)</code>.  The <code class="literal">:sprint</code> <a id="id371171" class="indexterm"></a>command shows
something interesting:</p>
<pre class="screen" id="par-eval_00000027">Prelude&gt; :sprint z
z = (_,_)</pre>
<p id="par-eval_00000028">The underlying structure is shown in <a class="xref" href="ch02.html#image_pair" title="Figure 2-3. A pair with both components referring to the same thunk">Figure 2-3</a>.</p>
<div class="figure" id="image_pair">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0203.png" alt="A pair with both components referring to the same thunk"></div></div>
<div class="figure-title">Figure 2-3. A pair with both components referring to the same thunk</div>
</div>
<p id="par-eval_00000029">The variable <code class="literal">z</code> itself refers to the pair <code class="literal">(x,x)</code>, but the components of the pair
both point to the unevaluated thunk for <code class="literal">x</code>.  This shows that we can
build data structures with unevaluated components.</p>
<p id="par-eval_00000030">Let’s make <code class="literal">z</code> into a thunk again:</p>
<pre class="screen" id="par-eval_00000031">Prelude&gt; import Data.Tuple
Prelude Data.Tuple&gt; let z = swap (x,x+1)</pre>
<p id="par-eval_00000032">The <code class="literal">swap</code> <a id="id371256" class="indexterm"></a>function is defined as: <code class="literal">swap (a,b) = (b,a)</code>. This  <code class="literal">z</code> is
unevaluated as before:</p>
<pre class="screen" id="par-eval_00000033">Prelude Data.Tuple&gt; :sprint z
z = _</pre>
<p id="par-eval_00000034">The point of this is so that we can see what happens when <code class="literal">z</code> is
evaluated with <code class="literal">seq</code>:</p>
<pre class="screen" id="par-eval_00000035">Prelude Data.Tuple&gt; seq z ()
()
Prelude Data.Tuple&gt; :sprint z
z = (_,_)</pre>
<p id="par-eval_00000036">Applying <code class="literal">seq</code> to <code class="literal">z</code> caused it to be evaluated to a pair, <span class="emphasis"><em>but the
components of the pair are still unevaluated</em></span>.  The <code class="literal">seq</code> function
evaluates its argument only as far as the first
constructor, and doesn’t evaluate any more of the structure.  There is
a technical term for this: We say that <code class="literal">seq</code> evaluates its first
argument to <span class="emphasis"><em>weak head normal form</em></span>.  The reason for this terminology
is somewhat historical, so don’t worry about it too much.  We often
use the acronym WHNF instead.  The term <span class="emphasis"><em>normal</em></span> <a id="id371342" class="indexterm"></a><a id="id371349" class="indexterm"></a><span class="emphasis"><em>form</em></span> on its own means "fully evaluated," and we’ll see how to evaluate something to normal
form in <a class="xref" href="ch02.html#sec_par-eval-deepseq" title="Deepseq">“Deepseq”</a>.</p>
<p id="par-eval_00000037">The concept of weak head normal form will crop up several times over
the next two chapters, so it’s worth taking the time to
understand it and get a feel for how evaluation happens in
Haskell.  Playing around with expressions and <code class="literal">:sprint</code> in GHCi is a
great way to do that.</p>
<p id="par-eval_00000038">Just to finish the example, we’ll evaluate <code class="literal">x</code>:</p>
<pre class="screen" id="par-eval_00000039">Prelude Data.Tuple&gt; seq x ()
()</pre>
<p id="par-eval_00000040">What will we see if we print the value of <code class="literal">z</code>?</p>
<pre class="screen" id="par-eval_00000041">Prelude Data.Tuple&gt; :sprint z
z = (_,3)</pre>
<p id="par-eval_00000042">Remember that <code class="literal">z</code> was defined to be <code class="literal">swap (x,x+1)</code>, which is <code class="literal">(x+1,x)</code>, and
we just evaluated <code class="literal">x</code>, so the second component of <code class="literal">z</code> is now
evaluated and has the value <code class="literal">3</code>.</p>
<p id="par-eval_00000043">Finally, we’ll take a look at an example with lists and a few of the
common list functions.  You probably know the definition <a id="id371452" class="indexterm"></a><a id="id371460" class="indexterm"></a>of <code class="literal">map</code>, but
here it is for reference:</p>
<pre class="programlisting" data-language="haskell" id="map__a__b_id1"><code class="nf">map</code> <code class="ow">::</code> <code class="p">(</code><code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">b</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="n">a</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="n">b</code><code class="p">]</code>
<code class="nf">map</code> <code class="n">f</code> <code class="kt">[]</code>     <code class="ow">=</code> <code class="kt">[]</code>
<code class="nf">map</code> <code class="n">f</code> <code class="p">(</code><code class="n">x</code><code class="kt">:</code><code class="n">xs</code><code class="p">)</code> <code class="ow">=</code> <code class="n">f</code> <code class="n">x</code> <code class="kt">:</code> <code class="n">map</code> <code class="n">f</code> <code class="n">xs</code></pre>
<p id="par-eval_00000045">The <code class="literal">map</code> function builds a lazy data structure.  This might be clearer if we
rewrite the definition of <code class="literal">map</code> to make the thunks explicit:</p>
<pre class="programlisting" data-language="haskell" id="map__a__b_id2"><code class="nf">map</code> <code class="ow">::</code> <code class="p">(</code><code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">b</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="n">a</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="n">b</code><code class="p">]</code>
<code class="nf">map</code> <code class="n">f</code> <code class="kt">[]</code>     <code class="ow">=</code> <code class="kt">[]</code>
<code class="nf">map</code> <code class="n">f</code> <code class="p">(</code><code class="n">x</code><code class="kt">:</code><code class="n">xs</code><code class="p">)</code> <code class="ow">=</code> <code class="kr">let</code>
                   <code class="n">x'</code>  <code class="ow">=</code> <code class="n">f</code> <code class="n">x</code>
                   <code class="n">xs'</code> <code class="ow">=</code> <code class="n">map</code> <code class="n">f</code> <code class="n">xs</code>
               <code class="kr">in</code>
                   <code class="n">x'</code> <code class="kt">:</code> <code class="n">xs'</code></pre>
<p id="par-eval_00000047">This behaves identically to the previous definition of <code class="literal">map</code>, but now
we can see that both the head and the tail of the list that <code class="literal">map</code>
returns are thunks: <code class="literal">f x</code> and <code class="literal">map f xs</code>, respectively.  That is, <code class="literal">map</code>
builds a structure like <a class="xref" href="ch02.html#image_map_thunk" title="Figure 2-4. Thunks created by a map">Figure 2-4</a>.</p>
<div class="figure" id="image_map_thunk">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0204.png" alt="Thunks created by a map"></div></div>
<div class="figure-title">Figure 2-4. Thunks created by a map</div>
</div>
<p id="par-eval_00000048">Let’s define a simple list structure using <code class="literal">map</code>:</p>
<pre class="screen" id="par-eval_00000049">Prelude&gt; let xs = map (+1) [1..10] :: [Int]</pre>
<p id="par-eval_00000050">Nothing is evaluated yet:</p>
<pre class="screen" id="par-eval_00000051">Prelude&gt; :sprint xs
xs = _</pre>
<p id="par-eval_00000052">Now we evaluate this list to weak head normal form:</p>
<pre class="screen" id="par-eval_00000053">Prelude&gt; seq xs ()
()
Prelude&gt; :sprint xs
xs = _ : _</pre>
<p id="par-eval_00000054">We have a list with at least one element, but that is all we know
about it so far.  Next, we’ll apply <a id="id371970" class="indexterm"></a><a id="id371975" class="indexterm"></a>the <code class="literal">length</code> function to the list:</p>
<pre class="screen" id="par-eval_00000055">Prelude&gt; length xs
10</pre>
<p id="par-eval_00000056">The <code class="literal">length</code> function is defined like this:</p>
<pre class="programlisting" data-language="haskell" id="length__a_"><code class="nf">length</code> <code class="ow">::</code> <code class="p">[</code><code class="n">a</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="kt">Int</code>
<code class="nf">length</code> <code class="kt">[]</code>     <code class="ow">=</code> <code class="mi">0</code>
<code class="nf">length</code> <code class="p">(</code><code class="kr">_</code><code class="kt">:</code><code class="n">xs</code><code class="p">)</code> <code class="ow">=</code> <code class="mi">1</code> <code class="o">+</code> <code class="n">length</code> <code class="n">xs</code></pre>
<p id="par-eval_00000058">Note that <code class="literal">length</code> ignores the head of the list, recursing on the
tail, <code class="literal">xs</code>.  So when <code class="literal">length</code> is applied to a list, it will descend
the structure of the list, evaluating the list cells but not the
elements.  We can see the effect clearly with <code class="literal">:sprint</code>:</p>
<pre class="screen" id="par-eval_00000059">Prelude&gt; :sprint xs
xs = [_,_,_,_,_,_,_,_,_,_]</pre>
<p id="par-eval_00000060">GHCi noticed that the list cells were all evaluated, so it switched to
using the bracketed notation rather than infix <code class="literal">:</code> to display the
list.</p>
<p id="even_though_we_">Even though we have now evaluated the entire spine of the list, it is
still not in normal form (but it is still in weak head normal form).
We can cause it to be fully evaluated by applying a function that demands
the values of the elements, such <a id="ix_ch02_par-eval-txt14" class="indexterm"></a>as <code class="literal">sum</code>:</p>
<pre class="screen" id="par-eval_00000061">Prelude&gt; sum xs
65
Prelude&gt; :sprint xs
xs = [2,3,4,5,6,7,8,9,10,11]</pre>
<p id="par-eval_00000062">We <a id="id372195" class="indexterm"></a>have scratched the surface of what is quite a subtle and complex
topic.  Fortunately<a id="id372204" class="indexterm"></a>, most of the time, when writing Haskell code, you
don’t need to worry about understanding when things get evaluated.
Indeed, the Haskell language definition is very careful not to specify
exactly how evaluation happens; the implementation is free to choose
its own strategy as long as the program gives the right answer.  And
as programmers, most of the time that’s all we care about, too.
However, when writing parallel code, it becomes important to
understand when things are evaluated so that we can arrange to
parallelize computations.</p>
<p id="par-eval_00000063">An alternative to using lazy evaluation for parallelism is to be more
explicit about the data flow, and this is the approach taken by the
<code class="literal">Par</code> monad in <a class="xref" href="ch04.html" title="Chapter 4. Dataflow Parallelism: The Par Monad">Chapter 4</a>.  This avoids some of the subtle
issues concerning lazy evaluation in exchange for some verbosity.
Nevertheless, it’s worthwhile to learn about both approaches because
there are situations where one is more natural or more efficient than
the other.<a id="id372237" class="indexterm"></a><a id="id372244" class="indexterm"></a><a id="id372252" class="indexterm"></a><a id="id372259" class="indexterm"></a><a id="id372266" class="indexterm"></a><a id="id372273" class="indexterm"></a></p>
</div>
<div class="sect1" data-original-filename="ch02_par-eval.asciidoc" id="sec_par-rpar-rseq">
<div class="titlepage"><div><div><h2 class="title">The Eval Monad, rpar, and rseq</h2></div></div></div>
<p id="par-eval_00000064"><a id="ix_ch02_par-eval-txt15" class="indexterm"></a><a id="ix_ch02_par-eval-txt16" class="indexterm"></a><a id="ix_ch02_par-eval-txt17" class="indexterm"></a><a id="ix_ch02_par-eval-txt18" class="indexterm"></a><a id="ix_ch02_par-eval-txt19" class="indexterm"></a><a id="ix_ch02_par-eval-txt20" class="indexterm"></a><a id="ix_ch02_par-eval-txt21" class="indexterm"></a><a id="ix_ch02_par-eval-txt22" class="indexterm"></a>Next, we introduce some basic functionality for creating
parallelism, which is provided by the module
<code class="literal">Control.Parallel.Strategies</code>:</p>
<pre class="programlisting" data-language="haskell" id="data_eval_a_ins"><code class="kr">data</code> <code class="kt">Eval</code> <code class="n">a</code>
<code class="kr">instance</code> <code class="kt">Monad</code> <code class="kt">Eval</code>

<code class="nf">runEval</code> <code class="ow">::</code> <code class="kt">Eval</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code>

<code class="nf">rpar</code> <code class="ow">::</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Eval</code> <code class="n">a</code>
<code class="nf">rseq</code> <code class="ow">::</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Eval</code> <code class="n">a</code></pre>
<p id="par-eval_00000069">Parallelism is expressed using the <code class="literal">Eval</code> monad, which comes with two
operations, <code class="literal">rpar</code> and <code class="literal">rseq</code>.  The <code class="literal">rpar</code> combinator creates
parallelism: It says, "My argument could be evaluated in parallel";
while <code class="literal">rseq</code> is used for forcing <a id="id372544" class="indexterm"></a><a id="id372551" class="indexterm"></a>sequential evaluation: It says, "Evaluate my argument and wait for the result."  In both cases,
evaluation is to weak head normal form.  It’s also worth noting that
the argument to <code class="literal">rpar</code> should be an unevaluated computation—a thunk.
If the argument is already evaluated, nothing useful happens, because
there is no work to perform in parallel.</p>
<p id="par-eval_00000070">The <code class="literal">Eval</code> monad provides a <code class="literal">runEval</code> <a id="id372583" class="indexterm"></a>operation that performs the
<code class="literal">Eval</code> computation and returns its result.  Note that <code class="literal">runEval</code> is
completely pure; there’s no need to be in the <code class="literal">IO</code> monad here.</p>
<p id="par-eval_00000071">To see the effects of <code class="literal">rpar</code> and <code class="literal">rseq</code>, suppose we have a function <code class="literal">f</code>, along with two
arguments to apply it to, <code class="literal">x</code> and <code class="literal">y</code>, and we would like to calculate
the results of <code class="literal">f x</code> and <code class="literal">f y</code> in parallel. Let’s say that <code class="literal">f x</code> takes
longer to evaluate than <code class="literal">f y</code>.  We’ll look at a few different ways to
code this and investigate the differences between them.  First,
suppose we used <code class="literal">rpar</code> with both <code class="literal">f x</code> and <code class="literal">f y</code>, and then returned a
pair of the results, as shown in <a class="xref" href="ch02.html#par-eval_00000073" title="Example 2-1. rpar/rpar">Example 2-1</a>.</p>
<div class="example" id="par-eval_00000073">
<div class="example-title">Example 2-1. rpar/rpar</div>
<div class="example-contents"><pre class="programlisting" data-language="haskell" id="runeval__do_a__id1">  <code class="n">runEval</code> <code class="o">$</code> <code class="kr">do</code>
     <code class="n">a</code> <code class="ow">&lt;-</code> <code class="n">rpar</code> <code class="p">(</code><code class="n">f</code> <code class="n">x</code><code class="p">)</code>
     <code class="n">b</code> <code class="ow">&lt;-</code> <code class="n">rpar</code> <code class="p">(</code><code class="n">f</code> <code class="n">y</code><code class="p">)</code>
     <code class="n">return</code> <code class="p">(</code><code class="n">a</code><code class="p">,</code><code class="n">b</code><code class="p">)</code></pre></div>
</div>
<p id="par-eval_00000074">Execution of this program fragment proceeds as shown in <a class="xref" href="ch02.html#fig_rpar_rpar" title="Figure 2-5. rpar/rpar timeline">Figure 2-5</a>.</p>
<div class="figure" id="fig_rpar_rpar">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0205.png" alt="rpar/rpar timeline"></div></div>
<div class="figure-title">Figure 2-5. rpar/rpar timeline</div>
</div>
<p id="par-eval_00000075">We see that <code class="literal">f x</code> and <code class="literal">f y</code> begin to evaluate in parallel, while the
<code class="literal">return</code> happens immediately: It doesn’t wait for either <code class="literal">f x</code> or <code class="literal">f
y</code> to complete.  The rest of the program will continue to execute
while <code class="literal">f x</code> and <code class="literal">f y</code> are being evaluated in parallel.</p>
<p id="par-eval_00000076">Let’s try a different variant, replacing the second <code class="literal">rpar</code> with
<code class="literal">rseq</code>:</p>
<div class="example" id="par-eval_00000077">
<div class="example-title">Example 2-2. rpar/rseq</div>
<div class="example-contents"><pre class="programlisting" data-language="haskell" id="runeval__do_a__id2">  <code class="n">runEval</code> <code class="o">$</code> <code class="kr">do</code>
     <code class="n">a</code> <code class="ow">&lt;-</code> <code class="n">rpar</code> <code class="p">(</code><code class="n">f</code> <code class="n">x</code><code class="p">)</code>
     <code class="n">b</code> <code class="ow">&lt;-</code> <code class="n">rseq</code> <code class="p">(</code><code class="n">f</code> <code class="n">y</code><code class="p">)</code>
     <code class="n">return</code> <code class="p">(</code><code class="n">a</code><code class="p">,</code><code class="n">b</code><code class="p">)</code></pre></div>
</div>
<p id="par-eval_00000078">Now the execution will look like <a class="xref" href="ch02.html#fig_rpar_rseq" title="Figure 2-6. rpar/rseq timeline">Figure 2-6</a>.</p>
<div class="figure" id="fig_rpar_rseq">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0206.png" alt="rpar/rseq timeline"></div></div>
<div class="figure-title">Figure 2-6. rpar/rseq timeline</div>
</div>
<p id="par-eval_00000079">Here <code class="literal">f x</code> and <code class="literal">f y</code> are still evaluated in parallel, but now the
final <code class="literal">return</code> doesn’t happen until <code class="literal">f y</code> has completed. This is
because we used <code class="literal">rseq</code>, which waits for the evaluation of its argument
before returning.</p>
<p id="par-eval_00000080">If we add an additional <code class="literal">rseq</code> to wait for <code class="literal">f x</code>, we’ll wait for
both <code class="literal">f x</code> and <code class="literal">f y</code> to complete:</p>
<div class="example" id="par-eval_00000081">
<div class="example-title">Example 2-3. rpar/rseq/rseq</div>
<div class="example-contents"><pre class="programlisting" data-language="haskell" id="runeval__do_a__id3">  <code class="n">runEval</code> <code class="o">$</code> <code class="kr">do</code>
     <code class="n">a</code> <code class="ow">&lt;-</code> <code class="n">rpar</code> <code class="p">(</code><code class="n">f</code> <code class="n">x</code><code class="p">)</code>
     <code class="n">b</code> <code class="ow">&lt;-</code> <code class="n">rseq</code> <code class="p">(</code><code class="n">f</code> <code class="n">y</code><code class="p">)</code>
     <code class="n">rseq</code> <code class="n">a</code>
     <code class="n">return</code> <code class="p">(</code><code class="n">a</code><code class="p">,</code><code class="n">b</code><code class="p">)</code></pre></div>
</div>
<p id="par-eval_00000082">Note that the new <code class="literal">rseq</code> is applied to <code class="literal">a</code>, namely the result of the
first <code class="literal">rpar</code>.
This results in the ordering shown in <a class="xref" href="ch02.html#fig_rpar_rseq_rseq" title="Figure 2-7. rpar/rseq/rseq timeline">Figure 2-7</a>.</p>
<div class="figure" id="fig_rpar_rseq_rseq">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0207.png" alt="rpar/rseq/rseq timeline"></div></div>
<div class="figure-title">Figure 2-7. rpar/rseq/rseq timeline</div>
</div>
<p id="par-eval_00000083">The code waits until both <code class="literal">f x</code> and <code class="literal">f y</code> have completed evaluation
before returning.</p>
<p id="par-eval_00000084">Which of these patterns should we use?</p>
<div class="itemizedlist" id="par-eval_00000085"><ul class="itemizedlist">
<li class="listitem">
<span class="emphasis"><em>rpar/rseq</em></span> is unlikely to be useful because the programmer rarely
knows in advance which of the two computations takes the longest,
so it makes little sense to wait for an arbitrary one of the two.
</li>
<li class="listitem">
The choice between <span class="emphasis"><em>rpar/rpar</em></span> or <span class="emphasis"><em>rpar/rseq/rseq</em></span> styles depends on
the circumstances. If we expect to be generating more parallelism soon
and don’t depend on the results of either operation, it makes sense to
use <span class="emphasis"><em>rpar/rpar</em></span>, which returns immediately.  On the other hand, if we
have generated all the parallelism we can, or we need the results of
one of the operations in order to continue, then <span class="emphasis"><em>rpar/rseq/rseq</em></span> is an
explicit way to do that.
</li>
</ul></div>
<p id="par-eval_00000087">There is one final variant:</p>
<div class="example" id="par-eval_00000088">
<div class="example-title">Example 2-4. rpar/rpar/rseq/rseq</div>
<div class="example-contents"><pre class="programlisting" data-language="haskell" id="runeval__do_a__id4">  <code class="n">runEval</code> <code class="o">$</code> <code class="kr">do</code>
     <code class="n">a</code> <code class="ow">&lt;-</code> <code class="n">rpar</code> <code class="p">(</code><code class="n">f</code> <code class="n">x</code><code class="p">)</code>
     <code class="n">b</code> <code class="ow">&lt;-</code> <code class="n">rpar</code> <code class="p">(</code><code class="n">f</code> <code class="n">y</code><code class="p">)</code>
     <code class="n">rseq</code> <code class="n">a</code>
     <code class="n">rseq</code> <code class="n">b</code>
     <code class="n">return</code> <code class="p">(</code><code class="n">a</code><code class="p">,</code><code class="n">b</code><code class="p">)</code></pre></div>
</div>
<p id="par-eval_00000089">This has the same behavior as <span class="emphasis"><em>rpar/rseq/rseq</em></span>, waiting for both
evaluations before returning.  Although it is the longest, this
variant has more symmetry than the others, so it might be preferable
for that reason.</p>
<p id="par-eval_00000090">To experiment with these variants yourself, try the sample program
<span class="emphasis"><em>rpar.hs</em></span>, which uses the Fibonacci function to simulate
the expensive computations to run in parallel. In order to use parallelism with GHC, we have to use the <code class="literal">-threaded</code> option. Compile the program like this:</p>
<pre class="screen" id="par-eval_00000091">$ ghc -O2 rpar.hs -threaded</pre>
<p id="par-eval_00000092">To try the <span class="emphasis"><em>rpar/rpar</em></span> variant, run it as follows. The <code class="literal">+RTS -N2</code> flag tells GHC to use two cores to run the program (ensure that you have at least
a dual-core machine):</p>
<pre class="screen" id="par-eval_00000093">$ ./rpar 1 +RTS -N2
time: 0.00s
(24157817,14930352)
time: 0.83s</pre>
<p id="par-eval_00000094">The first timestamp is printed when the <code class="literal">rpar</code>/<code class="literal">rseq</code> fragment
returns, and the second timestamp is printed when the last calculation
finishes.  As you can see, the return here happened immediately.  In <span class="emphasis"><em>rpar/rseq</em></span>, it happens
after the second (shorter) computation has completed:</p>
<pre class="screen" id="par-eval_00000095">$ ./rpar 2 +RTS -N2
time: 0.50s
(24157817,14930352)
time: 0.82s</pre>
<p id="par-eval_00000096">In <span class="emphasis"><em>rpar/rseq/rseq</em></span>, the return happens at the end:</p>
<pre class="screen" id="par-eval_00000097">$ ./rpar 3 +RTS -N2
time: 0.82s
(24157817,14930352)
time: 0.82s</pre>
</div>
<div class="sect1" data-original-filename="ch02_par-eval.asciidoc" id="sec_par-eval-sudoku2">
<div class="titlepage"><div><div><h2 class="title">Example: Parallelizing a Sudoku Solver</h2></div></div></div>
<p id="par-eval_00000100">In this section, we’ll walk through a case study, exploring how to add
parallelism to a program that performs the same computation on
multiple input data.  The computation is an implementation of a Sudoku
solver.  This solver is fairly fast as Sudoku solvers go, and can
solve all 49,000 of the known 17-clue puzzles in about 2 minutes.</p>
<p id="par-eval_00000101">The goal is to parallelize the solving of multiple puzzles.  We aren’t
interested in the details of how the solver works; for the purposes of
this discussion, the solver will be treated as a black box.  It’s just
an example of an expensive computation that we want to perform on
multiple data sets, namely the Sudoku puzzles.</p>
<p id="par-eval_00000102">We will use a module <code class="literal">Sudoku</code> that provides a function <code class="literal">solve</code> with
type:</p>
<pre class="programlisting" data-language="haskell" id="solve__string"><code class="nf">solve</code> <code class="ow">::</code> <code class="kt">String</code> <code class="ow">-&gt;</code> <code class="kt">Maybe</code> <code class="kt">Grid</code></pre>
<p id="par-eval_00000104">The <code class="literal">String</code> represents a single Sudoku problem.  It is a flattened
representation of the 9×9 board, where each square is either empty,
represented by the character <span class="emphasis"><em><code class="literal">.</code></em></span>, or contains a digit 1–9.</p>
<p id="par-eval_00000105">The function <code class="literal">solve</code> returns a value of type <code class="literal">Maybe Grid</code>, which is
either <code class="literal">Nothing</code> if a problem has no solution, or <code class="literal">Just g</code> if a solution
was found, where <code class="literal">g</code> has type <code class="literal">Grid</code>.  For the purposes of this
example, we are not interested in the solution itself, the <code class="literal">Grid</code>, but only
in whether the puzzle has a solution at all.</p>
<p id="par-eval_00000106">We start with some ordinary sequential code to solve a set of Sudoku
problems read from a file:</p>
<p id="par-eval_00000107" class="caption"><span class="emphasis"><em>sudoku1.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="import_sudoku_i"><code class="kr">import</code> <code class="nn">Sudoku</code>
<code class="kr">import</code> <code class="nn">Control.Exception</code>
<code class="kr">import</code> <code class="nn">System.Environment</code>
<code class="kr">import</code> <code class="nn">Data.Maybe</code>

<code class="nf">main</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">main</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="p">[</code><code class="n">f</code><code class="p">]</code> <code class="ow">&lt;-</code> <code class="n">getArgs</code>                           <code class="c1">-- </code><span id="CO2-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
  <code class="n">file</code> <code class="ow">&lt;-</code> <code class="n">readFile</code> <code class="n">f</code>                       <code class="c1">-- </code><span id="CO2-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>

  <code class="kr">let</code> <code class="n">puzzles</code>   <code class="ow">=</code> <code class="n">lines</code> <code class="n">file</code>               <code class="c1">-- </code><span id="CO2-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span>
      <code class="n">solutions</code> <code class="ow">=</code> <code class="n">map</code> <code class="n">solve</code> <code class="n">puzzles</code>        <code class="c1">-- </code><span id="CO2-4"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span>

  <code class="n">print</code> <code class="p">(</code><code class="n">length</code> <code class="p">(</code><code class="n">filter</code> <code class="n">isJust</code> <code class="n">solutions</code><code class="p">))</code> <code class="c1">-- </code><span id="CO2-5"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/5.png" alt="5"></span></pre>
<p id="par-eval_00000111">This short program works as follows:</p>
<div class="calloutlist" id="par-eval_00000112"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO2-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="grab_the_comman">
Grab the command-line arguments, expecting a single argument, the name of the file containing the input data.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO2-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="read_the_conten">
Read the contents of the given file.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO2-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="split_the_file_">
Split the file into lines; each line is a single puzzle.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO2-4"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="solve_all_the_p">
Solve all the puzzles by mapping the <code class="literal">solve</code> function over the
list of lines.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO2-5"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/5.png" alt="5"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="calculate_the_n">
Calculate the number of puzzles that had solutions, by first
filtering out any results that are <code class="literal">Nothing</code> and then taking the
length of the resulting list.  This length is then printed.  Even
though we’re not interested in the solutions themselves, the <code class="literal">filter isJust</code>
is necessary here: Without it, the program would never evaluate the
elements of the list, and the work of the solver would never be
performed (recall the <code class="literal">length</code> example at the end of
<a class="xref" href="ch02.html#sec_par-eval-whnf" title="Lazy Evaluation and Weak Head Normal Form">“Lazy Evaluation and Weak Head Normal Form”</a>).
</p></td>
</tr>
</table></div>
<p id="par-eval_00000116">Let’s check that the program works by running over a set of sample
problems.  First, compile the program:</p>
<pre class="screen" id="par-eval_00000117">$ ghc -O2 sudoku1.hs -rtsopts
[1 of 2] Compiling Sudoku           ( Sudoku.hs, Sudoku.o )
[2 of 2] Compiling Main             ( sudoku1.hs, sudoku1.o )
Linking sudoku1 ...</pre>
<p id="par-eval_00000118">Remember that when working on performance, it is important to compile with
full optimization (<code class="literal">-O2</code>). The goal is to make the program run faster,
after all.</p>
<p id="par-eval_00000119">Now we can run the program on 1,000 sample problems:</p>
<pre class="screen" id="par-eval_00000120">$ ./sudoku1 sudoku17.1000.txt
1000</pre>
<p id="par-eval_00000121">All 1,000 problems have solutions, so the answer is 1,000.  But what
we’re really interested in is how long the program took to run,
because we want to make it go faster.  So let’s run it again with some
extra command-line arguments:</p>
<pre class="screen" id="par-eval_00000122">$ ./sudoku1 sudoku17.1000.txt +RTS -s
1000
   2,352,273,672 bytes allocated in the heap
      38,930,720 bytes copied during GC
         237,872 bytes maximum residency (14 sample(s))
          84,336 bytes maximum slop
               2 MB total memory in use (0 MB lost due to fragmentation)

                                    Tot time (elapsed)  Avg pause  Max pause
  Gen  0      4551 colls,     0 par    0.05s    0.05s     0.0000s    0.0003s
  Gen  1        14 colls,     0 par    0.00s    0.00s     0.0001s    0.0003s

  INIT    time    0.00s  (  0.00s elapsed)
  MUT     time    1.25s  (  1.25s elapsed)
  GC      time    0.05s  (  0.05s elapsed)
  EXIT    time    0.00s  (  0.00s elapsed)
  Total   time    1.30s  (  1.31s elapsed)

  %GC     time       4.1%  (4.1% elapsed)

  Alloc rate    1,883,309,531 bytes per MUT second

  Productivity  95.9% of total user, 95.7% of total elapsed</pre>
<p id="par-eval_00000128">The <a id="id374112" class="indexterm"></a><a id="id374117" class="indexterm"></a><a id="id374122" class="indexterm"></a><a id="id374128" class="indexterm"></a>argument <code class="literal">+RTS -s</code> instructs the GHC runtime system to emit the
statistics shown. These are particularly helpful as a first
step in analyzing performance.  The output is explained in
detail in the GHC User’s Guide, but for our purposes we are interested
in one particular metric: <code class="literal">Total time</code>.  This figure is given in two
forms: the total CPU time used by the program and the
<span class="emphasis"><em>elapsed</em></span> or wall-clock time.  Since we are
running on a single processor core, these times are almost identical
(sometimes the elapsed time might be slightly longer due to other
activity on the system).</p>
<p id="par-eval_00000129">We shall now add some parallelism to make use of two processor cores.
We have a list of problems to solve, so as a first attempt we’ll
divide the list in two and solve the problems in both halves of the
list in parallel.  Here is some code to do just that:</p>
<p id="par-eval_00000130" class="caption"><span class="emphasis"><em>sudoku2.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="main__io__m_id1"><code class="nf">main</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">main</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="p">[</code><code class="n">f</code><code class="p">]</code> <code class="ow">&lt;-</code> <code class="n">getArgs</code>
  <code class="n">file</code> <code class="ow">&lt;-</code> <code class="n">readFile</code> <code class="n">f</code>

  <code class="kr">let</code> <code class="n">puzzles</code> <code class="ow">=</code> <code class="n">lines</code> <code class="n">file</code>

      <code class="p">(</code><code class="n">as</code><code class="p">,</code><code class="n">bs</code><code class="p">)</code> <code class="ow">=</code> <code class="n">splitAt</code> <code class="p">(</code><code class="n">length</code> <code class="n">puzzles</code> <code class="p">`</code><code class="n">div</code><code class="p">`</code> <code class="mi">2</code><code class="p">)</code> <code class="n">puzzles</code> <code class="c1">-- </code><span id="CO3-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>

      <code class="n">solutions</code> <code class="ow">=</code> <code class="n">runEval</code> <code class="o">$</code> <code class="kr">do</code>
                    <code class="n">as'</code> <code class="ow">&lt;-</code> <code class="n">rpar</code> <code class="p">(</code><code class="n">force</code> <code class="p">(</code><code class="n">map</code> <code class="n">solve</code> <code class="n">as</code><code class="p">))</code>   <code class="c1">-- </code><span id="CO3-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>
                    <code class="n">bs'</code> <code class="ow">&lt;-</code> <code class="n">rpar</code> <code class="p">(</code><code class="n">force</code> <code class="p">(</code><code class="n">map</code> <code class="n">solve</code> <code class="n">bs</code><code class="p">))</code>   <code class="c1">-- </code><span id="CO3-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span>
                    <code class="n">rseq</code> <code class="n">as'</code>                             <code class="c1">-- </code><span id="CO3-4"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span>
                    <code class="n">rseq</code> <code class="n">bs'</code>                             <code class="c1">-- </code><span id="CO3-5"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/5.png" alt="5"></span>
                    <code class="n">return</code> <code class="p">(</code><code class="n">as'</code> <code class="o">++</code> <code class="n">bs'</code><code class="p">)</code>                  <code class="c1">-- </code><span id="CO3-6"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/6.png" alt="6"></span>

  <code class="n">print</code> <code class="p">(</code><code class="n">length</code> <code class="p">(</code><code class="n">filter</code> <code class="n">isJust</code> <code class="n">solutions</code><code class="p">))</code></pre>
<div class="calloutlist" id="par-eval_00000135"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO3-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="divide_the_list">
Divide the list of puzzles into two equal sublists (or
almost equal, if the list had an odd number of elements).
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO3-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> <a href="#CO3-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; ">
<p id="were_using_the">
We’re using the <span class="emphasis"><em>rpar/rpar/rseq/rseq</em></span> pattern from the previous section to solve both halves of the list
in parallel.  However, things are not completely straightforward,
because <code class="literal">rpar</code> only evaluates to weak head normal form.  If we were to
use <code class="literal">rpar (map solve as)</code>, the evaluation would stop at the first
<code class="literal">(:)</code> constructor and go no further, so the <code class="literal">rpar</code> would not cause any
of the work to take place in parallel.  Instead, we need to cause the
whole list and the elements to be evaluated, and this is the purpose
of <code class="literal">force</code>:
</p>
<pre class="programlisting" data-language="haskell" id="force__nfdata_id1"><code class="nf">force</code> <code class="ow">::</code> <code class="kt">NFData</code> <code class="n">a</code> <code class="ow">=&gt;</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code></pre>
<p id="the_force_force">The <code class="literal">force</code> <a id="id374733" class="indexterm"></a>function evaluates the entire structure of its argument, reducing it to
<span class="emphasis"><em>normal form</em></span>, before returning the argument itself.  It is provided
by the <code class="literal">Control</code><code class="literal">.DeepSeq</code> module.  We’ll return to the <code class="literal">NFData</code> class
in <a class="xref" href="ch02.html#sec_par-eval-deepseq" title="Deepseq">“Deepseq”</a>, but for now it will suffice to think of it as the
class of types that can be evaluated to normal form.</p>
<p id="not_evaluating_">Not evaluating deeply enough is a common mistake when using <code class="literal">rpar</code>, so
it is a good idea to get into the habit of thinking, for each <code class="literal">rpar</code>,
"How much of this structure do I want to evaluate in the parallel
task?" (Indeed, it is such a common problem that in the <code class="literal">Par</code> <a id="id374789" class="indexterm"></a>monad
to be introduced later, the designers went so far as to make <code class="literal">force</code> the
default behavior).</p>
</td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO3-4"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span></a> <a href="#CO3-5"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/5.png" alt="5"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="using_rseq_we_">
Using <code class="literal">rseq</code>, we wait for the evaluation of both lists to complete.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO3-6"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/6.png" alt="6"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="append_the_two_">
Append the two lists to form the complete list of
solutions.
</p></td>
</tr>
</table></div>
<p id="par-eval_00000140">Let’s run the program and measure how much performance improvement we get from the
parallelism:</p>
<pre class="screen" id="par-eval_00000141">$ ghc -O2 sudoku2.hs -rtsopts -threaded
[2 of 2] Compiling Main             ( sudoku2.hs, sudoku2.o )
Linking sudoku2 ...</pre>
<p id="par-eval_00000142">Now we can run the program using two cores:</p>
<pre class="screen" id="par-eval_00000143">$ ./sudoku2 sudoku17.1000.txt +RTS -N2 -s
1000
   2,360,292,584 bytes allocated in the heap
      48,635,888 bytes copied during GC
       2,604,024 bytes maximum residency (7 sample(s))
         320,760 bytes maximum slop
               9 MB total memory in use (0 MB lost due to fragmentation)

                                    Tot time (elapsed)  Avg pause  Max pause
  Gen  0      2979 colls,  2978 par    0.11s    0.06s     0.0000s    0.0003s
  Gen  1         7 colls,     7 par    0.01s    0.01s     0.0009s    0.0014s

  Parallel GC work balance: 1.49 (6062998 / 4065140, ideal 2)

                        MUT time (elapsed)       GC time  (elapsed)
  Task  0 (worker) :    0.81s    (  0.81s)       0.06s    (  0.06s)
  Task  1 (worker) :    0.00s    (  0.88s)       0.00s    (  0.00s)
  Task  2 (bound)  :    0.52s    (  0.83s)       0.04s    (  0.04s)
  Task  3 (worker) :    0.00s    (  0.86s)       0.02s    (  0.02s)

  SPARKS: 2 (1 converted, 0 overflowed, 0 dud, 0 GC'd, 1 fizzled)

  INIT    time    0.00s  (  0.00s elapsed)
  MUT     time    1.34s  (  0.81s elapsed)
  GC      time    0.12s  (  0.06s elapsed)
  EXIT    time    0.00s  (  0.00s elapsed)
  Total   time    1.46s  (  0.88s elapsed)

  Alloc rate    1,763,903,211 bytes per MUT second

  Productivity  91.6% of total user, 152.6% of total elapsed</pre>
<p id="par-eval_00000151">Note that the <code class="literal">Total time</code> now shows a marked difference between the
CPU time (1.46s) and the elapsed time (0.88s).  Previously, the elapsed
time was 1.31s, so we can calculate the <span class="emphasis"><em>speedup</em></span> on 2 cores
as 1.31/0.88 = 1.48.  <a id="id374872" class="indexterm"></a>Speedups are always calculated as a ratio of
wall-clock times.  The CPU time is a helpful metric for telling us how
busy our cores are, but as you can see here, the CPU time when
running on multiple cores is often greater than the wall-clock
time for a single core, so it would be misleading to calculate
the speedup as the ratio of CPU time to wall-clock time (1.66 here).</p>
<p id="par-eval_00000152">Why is the speedup only 1.48, and not 2?  In general, there could be a
host of reasons for this, not all of which are under the control of
the Haskell programmer.  However, in this case the problem is partly
of our doing, and we can diagnose it using <a id="ix_ch02_par-eval-txt30" class="indexterm"></a>the <span class="emphasis"><em>ThreadScope</em></span> tool.  To
profile the program using <span class="emphasis"><em>ThreadScope</em></span>, we need to first recompile it
with the <code class="literal">-eventlog</code> flag and then run it with <code class="literal">+RTS -l</code>.  This
causes the program to emit a log file called <code class="literal">sudoku2.eventlog</code>, which
we can pass to <code class="literal">threadscope</code>:</p>
<pre class="screen" id="par-eval_00000153">$ rm sudoku2; ghc -O2 sudoku2.hs -threaded -rtsopts -eventlog
[2 of 2] Compiling Main             ( sudoku2.hs, sudoku2.o )
Linking sudoku2 ...
$ ./sudoku2 sudoku17.1000.txt +RTS -N2 -l
1000
$ threadscope sudoku2.eventlog</pre>
<p id="par-eval_00000154">The <span class="emphasis"><em>ThreadScope</em></span> profile is shown in <a class="xref" href="ch02.html#fig_sudoku2-threadscope" title="Figure 2-8. sudoku2 ThreadScope profile">Figure 2-8</a>. This
graph was generated by selecting “Export image” from <span class="emphasis"><em>ThreadScope</em></span>,
so it includes the timeline graph only, and not the rest of the
<span class="emphasis"><em>ThreadScope</em></span> GUI.</p>
<div class="figure" id="fig_sudoku2-threadscope">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0208.png" alt="sudoku2 ThreadScope profile"></div></div>
<div class="figure-title">Figure 2-8. sudoku2 ThreadScope profile</div>
</div>
<p id="par-eval_00000155">The<a id="id374976" class="indexterm"></a> <span class="emphasis"><em>x</em></span>-axis of the graph is time, and there are
three horizontal bars showing how the program executed over time.  The
topmost bar is known as the “activity” profile, and it shows how
many cores were executing Haskell code (as opposed to being idle
or garbage collecting) at a given point in time.  Underneath the
activity profile is one bar per core, showing what that
core was doing at each point in the execution.  Each bar has two
parts: The upper, thicker bar is green when that core is
executing Haskell code, and the lower, narrower bar is orange or green
when that core is performing garbage collection.</p>
<p id="par-eval_00000157">As we can see from the graph, there is a period at the end of the run
where just one processor is executing and the other one is idle
(except for participating in regular garbage collections, which is
necessary for GHC’s parallel garbage collector).  This indicates that
our two parallel tasks are uneven: One takes much longer to execute
than the other.  We are not making full use of our two cores, and this
results in less-than-perfect speedup.</p>
<p id="par-eval_00000158">Why should the workloads be uneven?  After all, we divided the list in
two, and we know the sample input has an even number of problems.  The
reason for the unevenness is that each problem does not take the same
amount of time to solve: It all depends on the searching strategy used
by the Sudoku solver.<a href="#ftn.id375022" class="footnote"><sup class="footnote" id="id375022">[3]</sup></a></p>
<p id="par-eval_00000159">This <a id="id375030" class="indexterm"></a>illustrates an important principle when parallelizing code: Try
to avoid partitioning the work into a small, fixed number of chunks.
There are two reasons for this:</p>
<div class="itemizedlist" id="par-eval_00000160"><ul class="itemizedlist">
<li class="listitem">
In practice, chunks rarely contain an equal
  amount of work, so there will be some imbalance leading to a loss of
  speedup, as in the example we just saw.
</li>
<li class="listitem">
The parallelism we can achieve is limited to the number of chunks.
  In our example, even if the workloads were even, we could never
  achieve a speedup of more than two, regardless of how many cores we
  use.
</li>
</ul></div>
<p id="par-eval_00000162">Even if we tried to solve the second problem by dividing the work into
as many segments as we have cores, we would still have the first
problem, namely that the work involved in processing each segment may
differ.</p>
<p id="par-eval_00000163">GHC doesn’t force us to use a fixed number of <code class="literal">rpar</code> calls; we can
call it as many times as we like, and the system will automatically
distribute the parallel work among the available cores.  If the work
is divided into smaller chunks, then the system will be able to keep all
the cores busy for longer.</p>
<p id="par-eval_00000164">A <a id="id375079" class="indexterm"></a>fixed division of work is often called<a id="id375085" class="indexterm"></a><a id="id375093" class="indexterm"></a> <span class="emphasis"><em>static partitioning</em></span>,
whereas distributing smaller units of work among processors at
runtime is called<a id="id375103" class="indexterm"></a><a id="id375108" class="indexterm"></a> <span class="emphasis"><em>dynamic partitioning</em></span>.  GHC already provides
the mechanism for dynamic partitioning; we just have to supply it with
enough tasks by calling <code class="literal">rpar</code> often enough so that it can do its job
and balance the work evenly.</p>
<p id="par-eval_00000165">The argument to <code class="literal">rpar</code> is called a <span class="emphasis"><em>spark</em></span>.  The runtime collects <a id="id375139" class="indexterm"></a>sparks in a pool and uses this as a source of work when there
are spare processors available, using a technique called<a id="id375149" class="indexterm"></a> <span class="emphasis"><em>work stealing</em></span>.  Sparks may be evaluated at some point in the future, or
they might not—it all depends on whether there is a spare core
available.  Sparks are very cheap to create: <code class="literal">rpar</code>
essentially just writes a pointer to the expression into an array.</p>
<p id="par-eval_00000166">So let’s try to use dynamic partitioning with the Sudoku problem.
First, we define an abstraction that will let us apply a function to a
list in <a id="ix_ch02_par-eval-txt31" class="indexterm"></a>parallel, <code class="literal">parMap</code>:</p>
<pre class="programlisting" data-language="haskell" id="parmap__a__id1"><code class="nf">parMap</code> <code class="ow">::</code> <code class="p">(</code><code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">b</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="n">a</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="kt">Eval</code> <code class="p">[</code><code class="n">b</code><code class="p">]</code>
<code class="nf">parMap</code> <code class="n">f</code> <code class="kt">[]</code> <code class="ow">=</code> <code class="n">return</code> <code class="kt">[]</code>
<code class="nf">parMap</code> <code class="n">f</code> <code class="p">(</code><code class="n">a</code><code class="kt">:</code><code class="n">as</code><code class="p">)</code> <code class="ow">=</code> <code class="kr">do</code>
   <code class="n">b</code> <code class="ow">&lt;-</code> <code class="n">rpar</code> <code class="p">(</code><code class="n">f</code> <code class="n">a</code><code class="p">)</code>
   <code class="n">bs</code> <code class="ow">&lt;-</code> <code class="n">parMap</code> <code class="n">f</code> <code class="n">as</code>
   <code class="n">return</code> <code class="p">(</code><code class="n">b</code><code class="kt">:</code><code class="n">bs</code><code class="p">)</code></pre>
<p id="par-eval_00000168">This is rather like a monadic version of <code class="literal">map</code>, except that we have
used <code class="literal">rpar</code> to lift the application of the function <code class="literal">f</code> to the element
<code class="literal">a</code> into the <code class="literal">Eval</code> monad.  Hence, <code class="literal">parMap</code> runs down the whole list,
eagerly creating sparks for the application of <code class="literal">f</code> to each element,
and finally returns the new list.  When <code class="literal">parMap</code> returns, it will have
created one spark for each element of the list.  Now, the evaluation
of all the results can happen in parallel:</p>
<p id="par-eval_00000169" class="caption"><span class="emphasis"><em>sudoku3.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="main__io__m_id2"><code class="nf">main</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">main</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="p">[</code><code class="n">f</code><code class="p">]</code> <code class="ow">&lt;-</code> <code class="n">getArgs</code>
  <code class="n">file</code> <code class="ow">&lt;-</code> <code class="n">readFile</code> <code class="n">f</code>

  <code class="kr">let</code> <code class="n">puzzles</code>   <code class="ow">=</code> <code class="n">lines</code> <code class="n">file</code>
      <code class="n">solutions</code> <code class="ow">=</code> <code class="n">runEval</code> <code class="p">(</code><code class="n">parMap</code> <code class="n">solve</code> <code class="n">puzzles</code><code class="p">)</code>

  <code class="n">print</code> <code class="p">(</code><code class="n">length</code> <code class="p">(</code><code class="n">filter</code> <code class="n">isJust</code> <code class="n">solutions</code><code class="p">))</code></pre>
<p id="par-eval_00000172">Note how this version is nearly identical to the first version,
<span class="emphasis"><em>sudoku1.hs</em></span>. The only difference is that we’ve replaced <code class="literal">map solve
puzzles</code> by <code class="literal">runEval (parMap solve puzzles)</code>.<a id="id375708" class="indexterm"></a></p>
<p id="par-eval_00000173">Running this new version yields more speedup:</p>
<pre class="screen" id="par-eval_00000174">  Total   time    1.42s  (  0.72s elapsed)</pre>
<p id="par-eval_00000175">which corresponds to a speedup of
1.31/0.72 = 1.82, approaching the ideal speedup of 2.  Furthermore,
the GHC runtime system tells us how many sparks were created:</p>
<pre class="screen" id="par-eval_00000176">  SPARKS: 1000 (1000 converted, 0 overflowed, 0 dud, 0 GC'd, 0 fizzled)</pre>
<p id="par-eval_00000177">We <a id="id375742" class="indexterm"></a><a id="id375747" class="indexterm"></a><a id="id375753" class="indexterm"></a><a id="id375758" class="indexterm"></a><a id="id375763" class="indexterm"></a>created exactly 1,000 sparks, and they were all
<span class="emphasis"><em>converted</em></span> (that is, turned into real parallelism at runtime). Here are some other things that can happen to a spark:</p>
<div class="variablelist" id="par-eval_00000178"><dl class="variablelist">
<dt><span class="term">
overflowed
</span></dt>
<dd>
The spark pool has a fixed size, and if we try to
create sparks when the pool is full, they are dropped and counted as
overflowed.
</dd>
<dt><span class="term">
dud
</span></dt>
<dd>
When <code class="literal">rpar</code> is applied to an expression that is already
evaluated, this is counted as a <span class="emphasis"><em>dud</em></span> and the <code class="literal">rpar</code> is ignored.
</dd>
<dt><span class="term">
GC’d
</span></dt>
<dd>
The sparked expression was found to be unused by the program,
so the runtime removed the spark.  We’ll discuss this in more detail
in <a class="xref" href="ch03.html#sec_par-strat-speculative" title="GC’d Sparks and Speculative Parallelism">“GC’d Sparks and Speculative Parallelism”</a>.
</dd>
<dt><span class="term">
fizzled
</span></dt>
<dd>
The expression was unevaluated at the time it was sparked
but was later evaluated independently by the program.  Fizzled sparks
are removed from the spark pool.
</dd>
</dl></div>
<p id="par-eval_00000182">The <span class="emphasis"><em>ThreadScope</em></span> profile for this version looks much better
(<a class="xref" href="ch02.html#fig_sudoku3-threadscope" title="Figure 2-9. sudoku3 ThreadScope profile">Figure 2-9</a>).  Furthermore, now that the runtime is
managing the work distribution for us, the program will automatically
scale to more processors.  On an 8-core machine, for example, I measured a speedup of
5.83 for the same program.<a href="#ftn.id375847" class="footnote"><sup class="footnote" id="id375847">[4]</sup></a></p>
<div class="figure" id="fig_sudoku3-threadscope">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0209.png" alt="sudoku3 ThreadScope profile"></div></div>
<div class="figure-title">Figure 2-9. sudoku3 ThreadScope profile</div>
</div>
<p id="par-eval_00000184">If we look closely at the two-processor profile, there appears to be a
short section near the beginning where not much work is happening.  In
fact, zooming in on this section in <span class="emphasis"><em>ThreadScope</em></span>
(<a class="xref" href="ch02.html#fig_sudoku3-zoom-threadscope" title="Figure 2-10. sudoku3: zoomed ThreadScope profile">Figure 2-10</a>) reveals that both processors are
working, but most of the activity is garbage collection, and only one
processor is performing most of the garbage collection work.  In fact,
what we are seeing here is the program reading the input file (lazily)
and dividing it into lines, driven by the demand of <code class="literal">parMap</code>, which
traverses the whole list of lines. Splitting the file into
lines creates a lot of data, and this seems to be happening on the
second core here.  However, note that even though splitting the file
into lines is sequential, the program doesn’t wait for it to complete
before the parallel work starts.  The <code class="literal">parMap</code> function creates the
first spark when it has the first element of the list, so
two processors can be working before we’ve finished splitting the file into
lines.  Lazy evaluation helps the program be more parallel, in a
sense.</p>
<div class="figure" id="fig_sudoku3-zoom-threadscope">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0210.png" alt="sudoku3: zoomed ThreadScope profile"></div></div>
<div class="figure-title">Figure 2-10. sudoku3: zoomed ThreadScope profile</div>
</div>
<p id="par-eval_00000185">We can experiment with forcing the splitting into lines to happen all
at once before we start the main computation, by adding the following (see <span class="emphasis"><em>sudoku3.hs</em></span>):</p>
<pre class="programlisting" data-language="haskell" id="evaluate_lengt">    <code class="n">evaluate</code> <code class="p">(</code><code class="n">length</code> <code class="n">puzzles</code><code class="p">)</code></pre>
<p id="par-eval_00000187">The <code class="literal">evaluate</code> function is like a <code class="literal">seq</code> in the <code class="literal">IO</code> monad: it evaluates its argument to weak head normal form and then returns it:</p>
<pre class="programlisting" data-language="haskell" id="evaluate__a_"><code class="nf">evaluate</code> <code class="ow">::</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">a</code></pre>
<p id="par-eval_00000189">Forcing the lines to be evaluated early reduces the parallelism
slightly, because we no longer get the benefit of overlapping the
line splitting with the solving. Our two-core runtime is now 0.76s.
However, we can now clearly see the boundary between the sequential
and parallel parts in <span class="emphasis"><em>ThreadScope</em></span>
(<a class="xref" href="ch02.html#fig_sudoku4-threadscope" title="Figure 2-11. sudoku4 ThreadScope profile">Figure 2-11</a>).</p>
<div class="figure" id="fig_sudoku4-threadscope">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0211.png" alt="sudoku4 ThreadScope profile"></div></div>
<div class="figure-title">Figure 2-11. sudoku4 ThreadScope profile</div>
</div>
<p id="par-eval_00000190">Looking at the profile, we can see that the program is sequential until
about 16.7ms, when it starts executing in parallel.  A program that
has a sequential portion like this can never achieve perfect speedup,
and in fact we can calculate the maximum achievable speedup for a
given number of cores using <a id="id376050" class="indexterm"></a>Amdahl’s law.  Amdahl’s law gives the maximum speedup as the ratio:</p>
<p id="___p__">1 / ((1 - <span class="emphasis"><em>P</em></span>) + <span class="emphasis"><em>P</em></span>/<span class="emphasis"><em>N</em></span>)</p>
<p id="par-eval_00000193">where <span class="emphasis"><em>P</em></span> is the portion of the runtime that can be
parallelized, and <span class="emphasis"><em>N</em></span> is the number of processors available.  In our
case, <span class="emphasis"><em>P</em></span> is (0.76 - 0.0167)/0.76 = 0.978, and the maximum speedup is 1.96.  The sequential fraction here is too small to make a significant impact on the theoretical maximum speedup with two
processors, but when we have more processors, say 64, it becomes much
more important: 1 / ((1-0.978) + 0.978/64) = 26.8.  So no matter
what we do, this tiny sequential part of our program will limit the
maximum speedup we can obtain with 64 processors to 26.8.  In fact,
even with 1,024 cores, we could achieve only around 44 speedup, and it
is impossible to achieve a speedup of 46 no matter how many cores we
have.  Amdahl’s law tells us that not only does parallel speedup
become harder to achieve the more processors we add, but in practice most
programs have a theoretical maximum amount of parallelism.</p>
</div>
<div class="sect1" data-original-filename="ch02_par-eval.asciidoc" id="sec_par-eval-deepseq">
<div class="titlepage"><div><div><h2 class="title">Deepseq</h2></div></div></div>
<p id="par-eval_00000195"><a id="ix_ch02_par-eval-txt39" class="indexterm"></a><a id="ix_ch02_par-eval-txt40" class="indexterm"></a><a id="ix_ch02_par-eval-txt41" class="indexterm"></a>We encountered <code class="literal">force</code> earlier, with this type:</p>
<pre class="programlisting" data-language="haskell" id="force__nfdata_id2"><code class="nf">force</code> <code class="ow">::</code> <code class="kt">NFData</code> <code class="n">a</code> <code class="ow">=&gt;</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code></pre>
<p id="par-eval_00000197">The <code class="literal">force</code> function fully evaluates its argument and then returns
it.  This function isn’t built-in, though: Its behavior is defined for
each data type through the <code class="literal">NFData</code> class.  The name stands for
normal-form data, where <a id="id376214" class="indexterm"></a><a id="id376221" class="indexterm"></a>normal-form is a value with no unevaluated
subexpressions, and "data" because it isn’t possible to put a function
in normal form; there’s no way to "look inside" a function and
evaluate the things it mentions.<a href="#ftn.id376234" class="footnote"><sup class="footnote" id="id376234">[5]</sup></a></p>
<p id="par-eval_00000198">The <code class="literal">NFData</code> class has only one method:</p>
<pre class="programlisting" data-language="haskell" id="class_nfdata_a_"><code class="kr">class</code> <code class="kt">NFData</code> <code class="n">a</code> <code class="kr">where</code>
  <code class="n">rnf</code> <code class="ow">::</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="nb">()</code>
  <code class="n">rnf</code> <code class="n">a</code> <code class="ow">=</code> <code class="n">a</code> <code class="p">`</code><code class="n">seq</code><code class="p">`</code> <code class="nb">()</code></pre>
<p id="par-eval_00000200">The <code class="literal">rnf</code> name stands <a id="id376355" class="indexterm"></a>for "reduce to normal-form."  It fully evaluates
its argument and then returns <code class="literal">()</code>.  The default definition uses
<code class="literal">seq</code>, which is convenient for types that have no substructure; we can
just use the default.  For example, the instance for <code class="literal">Bool</code> is defined
as simply:</p>
<pre class="programlisting" data-language="haskell" id="instance_nfdata_id1"><code class="kr">instance</code> <code class="kt">NFData</code> <code class="kt">Bool</code></pre>
<p id="par-eval_00000202">And the <code class="literal">Control.Deepseq</code> module provides instances for all the other
common types found in the libraries.</p>
<p id="you_may_need_to">You may need to create instances of <code class="literal">NFData</code> for your own types.  For example, if we had a binary tree
data type:</p>
<pre class="programlisting" data-language="haskell" id="data_tree_a__e"><code class="kr">data</code> <code class="kt">Tree</code> <code class="n">a</code> <code class="ow">=</code> <code class="kt">Empty</code> <code class="o">|</code> <code class="kt">Branch</code> <code class="p">(</code><code class="kt">Tree</code> <code class="n">a</code><code class="p">)</code> <code class="n">a</code> <code class="p">(</code><code class="kt">Tree</code> <code class="n">a</code><code class="p">)</code></pre>
<p id="par-eval_00000204">then the <code class="literal">NFData</code> instance should look like this:</p>
<pre class="programlisting" data-language="haskell" id="instance_nfdata_id2"><code class="kr">instance</code> <code class="kt">NFData</code> <code class="n">a</code> <code class="ow">=&gt;</code> <code class="kt">NFData</code> <code class="p">(</code><code class="kt">Tree</code> <code class="n">a</code><code class="p">)</code> <code class="kr">where</code>
  <code class="n">rnf</code> <code class="kt">Empty</code> <code class="ow">=</code> <code class="nb">()</code>
  <code class="n">rnf</code> <code class="p">(</code><code class="kt">Branch</code> <code class="n">l</code> <code class="n">a</code> <code class="n">r</code><code class="p">)</code> <code class="ow">=</code> <code class="n">rnf</code> <code class="n">l</code> <code class="p">`</code><code class="n">seq</code><code class="p">`</code> <code class="n">rnf</code> <code class="n">a</code> <code class="p">`</code><code class="n">seq</code><code class="p">`</code> <code class="n">rnf</code> <code class="n">r</code></pre>
<p id="par-eval_00000206">The idea is to just recursively apply <code class="literal">rnf</code> to the components of the
data type, composing the calls to <code class="literal">rnf</code> together with <code class="literal">seq</code>.</p>
<p id="par-eval_00000208">There are some other operations provided by <code class="literal">Control.DeepSeq</code>:</p>
<pre class="programlisting" data-language="haskell" id="deepseq__nfda"><code class="nf">deepseq</code> <code class="ow">::</code> <code class="kt">NFData</code> <code class="n">a</code> <code class="ow">=&gt;</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">b</code> <code class="ow">-&gt;</code> <code class="n">b</code>
<code class="nf">deepseq</code> <code class="n">a</code> <code class="n">b</code> <code class="ow">=</code> <code class="n">rnf</code> <code class="n">a</code> <code class="p">`</code><code class="n">seq</code><code class="p">`</code> <code class="n">b</code></pre>
<p id="par-eval_00000210">The function <code class="literal">deepseq</code> is so named for its similarity with <code class="literal">seq</code>; it is like <code class="literal">seq</code>,
but if we think of weak head normal form as being <span class="emphasis"><em>shallow</em></span>
evaluation, then normal form is <span class="emphasis"><em>deep</em></span> evaluation, hence <code class="literal">deepseq</code>.</p>
<p id="par-eval_00000211">The <code class="literal">force</code> function is defined in terms of <code class="literal">deepseq</code>:</p>
<pre class="programlisting" data-language="haskell" id="force__nfdata_id3"><code class="nf">force</code> <code class="ow">::</code> <code class="kt">NFData</code> <code class="n">a</code> <code class="ow">=&gt;</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code>
<code class="nf">force</code> <code class="n">x</code> <code class="ow">=</code> <code class="n">x</code> <code class="p">`</code><code class="n">deepseq</code><code class="p">`</code> <code class="n">x</code></pre>
<p id="par-eval_00000213">You should think of <code class="literal">force</code> as turning WHNF into NF: If the program
evaluates <code class="literal">force x</code> to WHNF, then <code class="literal">x</code> will be evaluated to NF.</p>
<div class="caution" id="evaluating_some_id1"><p id="evaluating_some_id2">Evaluating something to normal form involves traversing the whole of
its structure, so you should bear in mind that it is <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span>) for a structure of size <span class="emphasis"><em>n</em></span>, whereas
<code class="literal">seq</code> is <span class="emphasis"><em>O</em></span>(1).  It is therefore a good idea to avoid repeated uses
of <code class="literal">force</code> or <code class="literal">deepseq</code> on the same data.</p></div>
<p id="par-eval_00000214">WHNF and NF are two ends of a scale; there may be lots of <a id="id377021" class="indexterm"></a><a id="id377029" class="indexterm"></a>intermediate
"degrees of evaluation," depending on the data type.  For example, we
saw earlier that the <code class="literal">length</code> function evaluates only the <span class="emphasis"><em>spine</em></span> of a
list; that is, the list cells but not the elements.  The module
<code class="literal">Control.Seq</code> (from the <code class="literal">parallel</code> package) provides a set of
combinators that can be composed together to evaluate data structures
to varying degrees.  We won’t need it for the examples in this book,
but you may find it useful.<a id="id377059" class="indexterm"></a><a id="id377066" class="indexterm"></a><a id="id377073" class="indexterm"></a><a id="id377080" class="indexterm"></a></p>
</div>
<div class="footnotes">
<br><hr style="width: 100; align: left;">
<div id="ftn.id370618" class="footnote"><p><a href="#id370618" class="simpara"><sup class="simpara">[1] </sup></a>Technically, this is not
correct. Haskell is actually a <span class="emphasis"><em>non-strict</em></span> language, and lazy
evaluation is just one of several valid implementation strategies. But
GHC uses lazy evaluation, so we ignore this technicality for now.</p></div>
<div id="ftn.id370897" class="footnote"><p><a href="#id370897" class="simpara"><sup class="simpara">[2] </sup></a>Strictly speaking, it is overwritten by an indirect reference to the value, but the details aren’t important here. Interested readers can head over to the <a class="ulink" href="http://trac.haskell.org/ghc" target="_top">GHC wiki</a> to read the documentation about the implementation and the many papers written about its design.</p></div>
<div id="ftn.id375022" class="footnote"><p><a href="#id375022" class="simpara"><sup class="simpara">[3] </sup></a>In fact, I sorted the problems in the sample input so as to clearly demonstrate the problem.</p></div>
<div id="ftn.id375847" class="footnote"><p><a href="#id375847" class="simpara"><sup class="simpara">[4] </sup></a>This machine was an Amazon EC2 High-CPU extra-large instance.</p></div>
<div id="ftn.id376234" class="footnote"><p><a href="#id376234" class="simpara"><sup class="simpara">[5] </sup></a>However, there is an instance of <code class="literal">NFData</code> for functions, which evaluates the function to WHNF.  This is purely for convenience, because we often have data structures that contain functions and nevertheless want to evaluate them as much as possible.</p></div>
</div></section><footer><div class="navfooter">
<hr>
<table style="width: 100%; ">
<tr>
<td style="width: 40%; text-align: left; ">
<a accesskey="p" href="pt01.html">Prev</a> </td>
<td style="width: 20%; text-align: center; "><a accesskey="u" href="pt01.html">Up</a></td>
<td style="width: 40%; text-align: right; "> <a accesskey="n" href="ch03.html">Next</a>
</td>
</tr>
<tr>
<td style="width: 40%; text-align: left; vertical-align: top; ">Part I. Parallel Haskell </td>
<td style="width: 20%; text-align: center; "><a accesskey="h" href="index.html">Home</a></td>
<td style="width: 40%; text-align: right; vertical-align: top; "> Chapter 3. Evaluation Strategies</td>
</tr>
</table>
</div></footer>


	<div class="extra-footer">
		<p>© 2013, O’Reilly Media, Inc.</p>
		<ul>
			<li><a href="http://oreilly.com/terms/">Terms of Service</a></li>
			<li><a href="http://oreilly.com/oreilly/privacy.csp">Privacy Policy</a></li>
			<li>Interested in <a href="mailto:scordesse@oreilly.com">sponsoring content?</a></li>
		</ul>
	</div>
<script type="text/javascript">if (!NREUMQ.f) { NREUMQ.f=function() {
NREUMQ.push(["load",new Date().getTime()]);
var e=document.createElement("script");
e.type="text/javascript";
e.src=(("http:"===document.location.protocol)?"http:":"https:") + "//" +
  "js-agent.newrelic.com/nr-100.js";
document.body.appendChild(e);
if(NREUMQ.a)NREUMQ.a();
};
NREUMQ.a=window.onload;window.onload=NREUMQ.f;
};
NREUMQ.push(["nrfj","bam.nr-data.net","3e361aebcf","2194180","IApbRUBZXg1WEEoHDAwORh5aQl8N",6,69,new Date().getTime(),"","","","",""]);</script></body>

<!-- Mirrored from chimera.labs.oreilly.com/books/1230000000929/ch02.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 22 Dec 2016 02:54:29 GMT -->
</html>