<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<!-- Mirrored from chimera.labs.oreilly.com/books/1230000000929/ch08.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 19 Dec 2016 05:39:32 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head><script type="text/javascript">var NREUMQ=NREUMQ||[];NREUMQ.push(["mark","firstbyte",new Date().getTime()]);</script>
	<title>Parallel and Concurrent Programming in Haskell</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link href="http://dwn0odqttrkhc.cloudfront.net/assets/book-f1caceafd9c9f3a6ff72d40c54d173ab.css" media="screen" rel="stylesheet" type="text/css" />
	<link href="http://dwn0odqttrkhc.cloudfront.net/assets/default-24583441b4f47382b8932338cd56ed23.css" media="screen" rel="stylesheet" type="text/css" />
	<script src="http://dwn0odqttrkhc.cloudfront.net/assets/application-47d6ffb0c77b868d29a43eb65e940505.js" type="text/javascript"></script>
	<script src="http://dwn0odqttrkhc.cloudfront.net/assets/book-756862b9ed04d945ca53de5b8f106a83.js" type="text/javascript"></script>
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	<link href="http://dwn0odqttrkhc.cloudfront.net/assets/janrain-53eb5abed55992e21943b9d3373923e8.css" media="all" rel="stylesheet" type="text/css" />
	<meta content="authenticity_token" name="csrf-param" />
<meta content="WQ02oEFDbvBG99rmf8rwvGssMqcy27cCD64yZVVTcMY=" name="csrf-token" />
	<script type="text/javascript" charset="utf-8">
  	
		app.data = new classes.Data({"controller":{"controller":"books","action":"html"},"capturable":{"capture_server":"https://oreilly.janraincapture.com","client_id":"6n5q2k9vesqgn93k3mhevka6c3c3rsre","app_url":"https://login.oreilly.com","app_id":"xsnca5wmqe9vxv97ygh5vfejkd","load_js":"d16s8pqtk4uodx.cloudfront.net/login.oreilly.com/load.js"},"user":{"id":null,"account":"LoggedOutAccount","email":"","name":null,"gravatar_url":"http://www.gravatar.com/avatar/d41d8cd98f00b204e9800998ecf8427e?s=40&d=identicon"},"book":{"isbn":"1230000000929","chapter":"ch08.html","toc_url":"/books/1230000000929/toc_html","metadata_url":"http://d4bb7yl96lyl1.cloudfront.net/1230000000929/metadata/metadata_9b2ac4d71a3220a7d463d8d4c80f9113048bb194.json"},"abilities":{"can_destroy_all_comments":false,"can_create_comments":false},"advertisement":{"body":"<style>      \r\n.ad-profile-image {\r\n  padding: 0;\r\n  margin: 0;\r\n  max-height: 30px;\r\n }\r\n\r\n.top-banner {\r\n  position: absolute;\r\n  right: 0;\r\n  top: 34px;\r\n  z-index: 99999;\r\n}\r\n\r\np.banner-text {\r\n  margin: 0;\r\n  text-align: center;\r\n  padding-right: 10px;\r\n  width: 450px;\r\n}\r\n\r\n@media screen and (max-width: 600px) {\r\n   p.banner-text {\r\n     width: 100%;\r\n     text-align: center;\r\n  }\r\n}\r\n\r\nspan.ebook-advantage {\r\n  font-size: smaller;\r\n  display: block;\r\n}\r\n\r\ndiv.banner-container {\r\n  margin: 0 auto;\r\n}\r\n\r\ndiv.banner-container ul {\r\n  margin: 0 auto;\r\n}\r\n\r\ndiv.topad { padding-bottom: 5px; }\r\n\r\ndiv.banner-container ul li {\r\n  display: inline-block;\r\n  vertical-align: middle;\r\n}\r\n\r\ndiv.banner-container li p {\r\n  padding-top: 0;\r\n  margin-top: 0;\r\n}\r\n\r\ndiv.banner-container li.sponsor {\r\n  border-right: 1px solid rgb(125, 154, 180);\r\n  margin-right: 5px;\r\n  padding-right: 10px;\r\n}\r\n\r\ndiv.banner-container .webbutton {\r\n  background-color: #3994b6;\r\n  display: inline-block;\r\n  padding: 10px;\r\n  -webkit-border-radius: 5px;\r\n  -moz-border-radius: 5px;\r\n  border-radius: 5px;\r\n  color: #FFF;\r\n  text-align: center;\r\n  text-decoration: none;\r\n  font-size: 12px;\r\n  font-weight: bold;\r\n}\r\n\r\n</style>\r\n   \r\n<div style=\"color: rgb(125, 154, 180);\">\r\n\r\n<div class=\"banner-container\">\r\n\r\n<ul>\r\n\r\n<li class=\"sponsor\">\r\n<!--CONFERENCE SPONSOR IMAGE-->\r\n<a href=\"http://www.oscon.com/oscon2013\">\r\n<!--<img src=\"http://orm-other.s3.amazonaws.com/fluent_logo.png\" class=\"ad-profile-image\"/>-->\r\n<img src=\"http://orm-other.s3.amazonaws.com/oscon_logo.png\" class=\"ad-profile-image\"/>\r\n<!--<img src=\"http://orm-other.s3.amazonaws.com/strata_logo.png\" class=\"ad-profile-image\"/>\r\n<img src=\"http://orm-other.s3.amazonaws.com/StrataRx_logo.png\" class=\"ad-profile-image\"/>\r\n<img src=\"http://orm-other.s3.amazonaws.com/velocity_logo.png\" class=\"ad-profile-image\"/>-->\r\n</a>\r\n</li>\r\n\r\n<li>\r\n<!--AD TEXT, 2 LINES, REPLACE LINK URL AS WELL-->\r\n<p class=\"banner-text\">Enjoy this online version of <em>Parallel and Concurrent Programming in Haskell</em>. Purchase and download the DRM-free ebook on <a href=\"http://shop.oreilly.com/product/0636920026365.do\">oreilly.com</a>.<span class=\"ebook-advantage\">Learn more about the O’Reilly <a href=\"http://shop.oreilly.com/category/ebooks.do\">Ebook Advantage</a>.</span></p>\r\n</li>\r\n\r\n<li>\r\n<!--BUY BUTTON-->\r\n<a class=\"webbutton\" href=\"http://shop.oreilly.com/product/0636920026365.do\">Buy the Ebook</a>\r\n</li> \r\n\r\n</ul>\r\n\r\n</div>\r\n\r\n<!--CORNER BANNER (IF NEEDED)-->\r\n<!--<a href=\"http://shop.oreilly.com/product/0636920026365.do\" class=\"top-banner\"><img src=\"http://orm-other.s3.amazonaws.com/banner.png\" /></a>-->\r\n\r\n</div>"}});

		/* Janrain setup */
  	var janrainModal = new JanrainView();
  	$("head").append(janrainModal.render().el);

  	/* segment.io setup */
  	var analytics=analytics||[];analytics.load=function(e){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src=("https:"===document.location.protocol?"https://":"http://")+"d2dq2ahtl5zl1z.cloudfront.net/analytics.js/v1/"+e+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(t,n);var r=function(e){return function(){analytics.push([e].concat(Array.prototype.slice.call(arguments,0)))}},i=["identify","track","trackLink","trackForm","trackClick","trackSubmit","pageview","ab","alias","ready"];for(var s=0;s<i.length;s++)analytics[i[s]]=r(i[s])};
  	
  	analytics.load("hg9h6b9pae");

  	$(function() {
			app.bookapp = new BookApp();
		});
	
	</script>
</head>
<body>
	<div id="menu">
	
		<ul id="menu-left">
			<li id="home-link"><a href="http://chimera.labs.oreilly.com/"><i class="icon-house"></i></a></li>
			<li><a href="http://chimera.labs.oreilly.com/books/1230000000929">Parallel and Concurrent Programming in Haskell</a></li>
			<div class="clear"></div>
		</ul>
	
		<ul id="menu-right">
			<li id="comments-link"><a>&nbsp;</a></li>
			<li>
				<a href="#" class="dropdown-toggle" data-toggle="dropdown">Chapters</a>
				<div id="toc-popup" class="dropdown-menu"></div>
			</li>
				<li><a href="#" class="capture_modal_open" id="capture_signin_link">Log In / Sign Up</a></li>
			<li id="search-li">
				<form accept-charset="UTF-8" action="http://chimera.labs.oreilly.com/searches" id="search-form" method="get"><div style="margin:0;padding:0;display:inline"><input name="utf8" type="hidden" value="&#x2713;" /></div>
	<input name='search[q]' type="text" placeholder="Search book..." id="book-search" />

	<input id="search_bookId" name="search[bookId]" type="hidden" value="1230000000929" />
	
	<div style='display:none'>
		sorted by: 
		<select name='search[sort]' >
			<option value='relevance'>Relevance</option>
			<option value='authors'>Author(s)</option>
			<option value='title'>Title</option>
		</select>
		returning
		<select name='search[limit]' >
			<option value='5'>5</option>
			<option value='10'>10</option>
			<option value='20'>20</option>
			<option selected="selected" value='50'>50</option>
			<option value='100'>100</option>
		</select>
		values at a time.
	</div>
</form>
			</li>
			<div class="clear"></div>
		</ul>
		<div class="clear"></div>
	
</div>
	<header><div class="navheader">
<table style="width: 100%; ">
<tr><td style="text-align: center; " colspan="3">Chapter 8. Overlapping Input/Output</td></tr>
<tr>
<td style="width: 20%; text-align: left; ">
<a accesskey="p" href="ch07.html">Prev</a> </td>
<td style="width: 60%; text-align: center; ">Part II. Concurrent Haskell</td>
<td style="width: 20%; text-align: right; "> <a accesskey="n" href="ch09.html">Next</a>
</td>
</tr>
</table>
<hr>
</div></header><section class="chapter" data-original-filename="ch08_conc-overlap.asciidoc" id="sec_conc-overlap-io"><div class="titlepage"><div><div><h2 class="title">Chapter 8. Overlapping Input/Output</h2></div></div></div>
<p id="asynchronous_i"><a id="ix_ch08_conc-overlap-txt0" class="indexterm"></a><a id="ix_ch08_conc-overlap-txt1" class="indexterm"></a><a id="ix_ch08_conc-overlap-txt2" class="indexterm"></a><a id="ix_ch08_conc-overlap-txt3" class="indexterm"></a>We can use <code class="literal">MVar</code> and threads to do asynchronous I/O, where
"asynchronous" in this context means that the I/O is performed in the
background while we do other tasks.</p>
<p id="conc-overlap_00000000">Suppose we want to download some <a id="id435879" class="indexterm"></a>web pages concurrently and wait for them all to download before continuing.  We will use the following function to download a web page:</p>
<pre class="programlisting" data-language="haskell" id="geturl__strin"><code class="nf">getURL</code> <code class="ow">::</code> <code class="kt">String</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="kt">ByteString</code></pre>
<p id="conc-overlap_00000002">This function is provided by the module <code class="literal">GetURL</code> in
<code class="filename">GetURL.hs</code>, which is a small wrapper around the
API provided by the <code class="literal">HTTP</code> package.</p>
<p id="conc-overlap_00000003">Let’s use <code class="literal">forkIO</code> and <code class="literal">MVar</code> to download two web pages at the same time:</p>
<p id="conc-overlap_00000004" class="caption"><span class="emphasis"><em>geturls1.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="import_control_id4"><code class="kr">import</code> <code class="nn">Control.Concurrent</code>
<code class="kr">import</code> <code class="nn">Data.ByteString</code> <code class="k">as</code> <code class="n">B</code>
<code class="kr">import</code> <code class="nn">GetURL</code>

<code class="nf">main</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">m1</code> <code class="ow">&lt;-</code> <code class="n">newEmptyMVar</code>                                    <code class="c1">-- </code><span id="CO30-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
  <code class="n">m2</code> <code class="ow">&lt;-</code> <code class="n">newEmptyMVar</code>                                    <code class="c1">-- </code><span id="CO30-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>

  <code class="n">forkIO</code> <code class="o">$</code> <code class="kr">do</code>                                           <code class="c1">-- </code><span id="CO30-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span>
    <code class="n">r</code> <code class="ow">&lt;-</code> <code class="n">getURL</code> <code class="s">"http://www.wikipedia.org/wiki/Shovel"</code>
    <code class="n">putMVar</code> <code class="n">m1</code> <code class="n">r</code>

  <code class="n">forkIO</code> <code class="o">$</code> <code class="kr">do</code>                                           <code class="c1">-- </code><span id="CO30-4"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span>
    <code class="n">r</code> <code class="ow">&lt;-</code> <code class="n">getURL</code> <code class="s">"http://www.wikipedia.org/wiki/Spade"</code>
    <code class="n">putMVar</code> <code class="n">m2</code> <code class="n">r</code>

  <code class="n">r1</code> <code class="ow">&lt;-</code> <code class="n">takeMVar</code> <code class="n">m1</code>                                     <code class="c1">-- </code><span id="CO30-5"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/5.png" alt="5"></span>
  <code class="n">r2</code> <code class="ow">&lt;-</code> <code class="n">takeMVar</code> <code class="n">m2</code>                                     <code class="c1">-- </code><span id="CO30-6"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/6.png" alt="6"></span>
  <code class="n">print</code> <code class="p">(</code><code class="kt">B</code><code class="o">.</code><code class="n">length</code> <code class="n">r1</code><code class="p">,</code> <code class="kt">B</code><code class="o">.</code><code class="n">length</code> <code class="n">r2</code><code class="p">)</code>                      <code class="c1">-- </code><span id="CO30-7"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/7.png" alt="7"></span></pre>
<div class="calloutlist" id="conc-overlap_00000009"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO30-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> <a href="#CO30-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="create_two_new_">
Create two new empty <code class="literal">MVar</code>s to hold the
results.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO30-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="fork_a_new_thre">
Fork a new thread to download the first URL; when
the download is complete, the result is placed in the <code class="literal">MVar</code> <code class="literal">m1</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO30-4"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="do_the_same_for">
Do the same for the second URL, placing the result in <code class="literal">m2</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO30-5"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/5.png" alt="5"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="in_the_main_thr_id2">
In the main thread, this call to <code class="literal">takeMVar</code> waits for the result from <code class="literal">m1</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO30-6"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/6.png" alt="6"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="similarly_wait">
Similarly, wait for the result from <code class="literal">m2</code> (we could do these in either order).
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO30-7"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/7.png" alt="7"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="finally_print_">
Finally, print out the length in bytes of each downloaded page.
</p></td>
</tr>
</table></div>
<p id="conc-overlap_00000013">This code is rather verbose.  We could shorten it by using various
existing higher-order combinators from the Haskell library, but a
better approach would be to extract the common pattern as a new
abstraction. We want a way to perform an action <span class="emphasis"><em>asynchronously</em></span>
and later wait for its result.  So let’s define an interface that does
that, using <code class="literal">forkIO</code> and <code class="literal">MVar</code>:</p>
<pre class="programlisting" data-language="haskell" id="data_async_a___id1"><code class="kr">data</code> <code class="kt">Async</code> <code class="n">a</code> <code class="ow">=</code> <code class="kt">Async</code> <code class="p">(</code><code class="kt">MVar</code> <code class="n">a</code><code class="p">)</code>

<code class="nf">async</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">Async</code> <code class="n">a</code><code class="p">)</code>
<code class="nf">async</code> <code class="n">action</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">var</code> <code class="ow">&lt;-</code> <code class="n">newEmptyMVar</code>
  <code class="n">forkIO</code> <code class="p">(</code><code class="kr">do</code> <code class="n">r</code> <code class="ow">&lt;-</code> <code class="n">action</code><code class="p">;</code> <code class="n">putMVar</code> <code class="n">var</code> <code class="n">r</code><code class="p">)</code>
  <code class="n">return</code> <code class="p">(</code><code class="kt">Async</code> <code class="n">var</code><code class="p">)</code>

<code class="nf">wait</code> <code class="ow">::</code> <code class="kt">Async</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">a</code>
<code class="nf">wait</code> <code class="p">(</code><code class="kt">Async</code> <code class="n">var</code><code class="p">)</code> <code class="ow">=</code> <code class="n">readMVar</code> <code class="n">var</code></pre>
<p id="conc-overlap_00000017">First, we <a id="id436808" class="indexterm"></a><a id="id436817" class="indexterm"></a><a id="id436822" class="indexterm"></a>define an <code class="literal">Async</code> data type that represents an asynchronous
action that has been started.  Its implementation is just an <code class="literal">MVar</code>
that will contain the result.  Again, we are creating a new data type
so as to hide implementation details from clients, and indeed later in
this chapter we will need to extend the <code class="literal">Async</code> type with more
information.</p>
<p id="conc-overlap_00000020">It is important to use <code class="literal">readMVar</code> in <code class="literal">wait</code>, because this allows
multiple <code class="literal">wait</code> calls to be made for the same <code class="literal">Async</code>.  If we had used
a simple <code class="literal">takeMVar</code>, the second and subsequent calls to <code class="literal">wait</code> would
deadlock.  Multiple calls to <code class="literal">wait</code> for the same <code class="literal">Async</code> might arise
if we are programming in a dataflow style, as in a program that
creates a single <code class="literal">Async</code> and then two further <code class="literal">Async</code>s that both
wait for the result of the first one.  In this sense, <code class="literal">Async</code> is
behaving rather like <code class="literal">IVar</code> from the <code class="literal">Par</code> monad (<a class="xref" href="ch04.html" title="Chapter 4. Dataflow Parallelism: The Par Monad">Chapter 4</a>),
although here, the individual operations are side-effecting <code class="literal">IO</code>
operations rather than pure computations and there is no guarantee of
determinism.</p>
<p id="conc-overlap_00000021">Now we can use the <code class="literal">Async</code> interface to clean up our
web page downloading example:</p>
<p id="conc-overlap_00000022" class="caption"><span class="emphasis"><em>geturls2.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="main__do_a__id1"><code class="nf">main</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">a1</code> <code class="ow">&lt;-</code> <code class="n">async</code> <code class="p">(</code><code class="n">getURL</code> <code class="s">"http://www.wikipedia.org/wiki/Shovel"</code><code class="p">)</code>
  <code class="n">a2</code> <code class="ow">&lt;-</code> <code class="n">async</code> <code class="p">(</code><code class="n">getURL</code> <code class="s">"http://www.wikipedia.org/wiki/Spade"</code><code class="p">)</code>
  <code class="n">r1</code> <code class="ow">&lt;-</code> <code class="n">wait</code> <code class="n">a1</code>
  <code class="n">r2</code> <code class="ow">&lt;-</code> <code class="n">wait</code> <code class="n">a2</code>
  <code class="n">print</code> <code class="p">(</code><code class="kt">B</code><code class="o">.</code><code class="n">length</code> <code class="n">r1</code><code class="p">,</code> <code class="kt">B</code><code class="o">.</code><code class="n">length</code> <code class="n">r2</code><code class="p">)</code></pre>
<p id="conc-overlap_00000023">Much nicer!  To elaborate upon this slightly, <a id="id437179" class="indexterm"></a>we can make a small wrapper
called <code class="literal">timeDownload</code> that downloads a URL and reports how much data
was downloaded and how long it took, and then apply this to a list of
URLs using <code class="literal">async</code>:</p>
<p id="geturlshs_c_id1" class="caption"><span class="emphasis"><em>geturls3.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="sites__http_id1"><code class="nf">sites</code> <code class="ow">=</code> <code class="p">[</code><code class="s">"http://www.google.com"</code><code class="p">,</code>
         <code class="s">"http://www.bing.com"</code><code class="p">,</code>
         <code class="s">"http://www.yahoo.com"</code><code class="p">,</code>
         <code class="s">"http://www.wikipedia.com/wiki/Spade"</code><code class="p">,</code>
         <code class="s">"http://www.wikipedia.com/wiki/Shovel"</code><code class="p">]</code>

<code class="nf">timeDownload</code> <code class="ow">::</code> <code class="kt">String</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">timeDownload</code> <code class="n">url</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="p">(</code><code class="n">page</code><code class="p">,</code> <code class="n">time</code><code class="p">)</code> <code class="ow">&lt;-</code> <code class="n">timeit</code> <code class="o">$</code> <code class="n">getURL</code> <code class="n">url</code>   <code class="c1">-- </code><span id="CO31-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
  <code class="n">printf</code> <code class="s">"downloaded: %s (%d bytes, %.2fs)</code><code class="se">\n</code><code class="s">"</code> <code class="n">url</code> <code class="p">(</code><code class="kt">B</code><code class="o">.</code><code class="n">length</code> <code class="n">page</code><code class="p">)</code> <code class="n">time</code>

<code class="nf">main</code> <code class="ow">=</code> <code class="kr">do</code>
 <code class="n">as</code> <code class="ow">&lt;-</code> <code class="n">mapM</code> <code class="p">(</code><code class="n">async</code> <code class="o">.</code> <code class="n">timeDownload</code><code class="p">)</code> <code class="n">sites</code>  <code class="c1">-- </code><span id="CO31-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>
 <code class="n">mapM_</code> <code class="n">wait</code> <code class="n">as</code>                            <code class="c1">-- </code><span id="CO31-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></pre>
<div class="calloutlist" id="conc-overlap_00000026"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO31-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="to_time_the_get">
To time the <code class="literal">getURL</code> call, we use an auxiliary<a id="id437575" class="indexterm"></a><a id="id437581" class="indexterm"></a> function <code class="literal">timeit</code>
(defined in <span class="emphasis"><em>TimeIt.hs</em></span>).
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO31-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="mapm_maps_a_fun">
<code class="literal">mapM</code> maps a function over a list in a monad; in this case, the
<code class="literal">IO</code> monad.  The function we are mapping over the list is the
composition of <code class="literal">async</code> and <code class="literal">timeDownload</code>. That is, for each URL in
the list, we will create an <code class="literal">Async</code> that calls <code class="literal">timeDownload</code> for that
URL.  The result of the <code class="literal">mapM</code> call is the list of <code class="literal">Async</code>s created,
which we bind to <code class="literal">as</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO31-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="then_we_wait_fo">
Then we <code class="literal">wait</code> for each of the <code class="literal">Async</code>s to complete.  Notice
that in this example, each <code class="literal">Async</code> is returning only a <code class="literal">()</code> token when
it completes, rather than the web page contents as in the earlier
examples.  Hence we’re using <code class="literal">mapM_</code>, a variant of <code class="literal">mapM</code> that ignores
the result of applying the function to each list element and returns
<code class="literal">()</code>.
</p></td>
</tr>
</table></div>
<p id="conc-overlap_00000029">The program produces output like this:</p>
<pre class="screen" id="conc-overlap_00000030">downloaded: http://www.google.com (14524 bytes, 0.17s)
downloaded: http://www.bing.com (24740 bytes, 0.18s)
downloaded: http://www.wikipedia.com/wiki/Spade (62586 bytes, 0.60s)
downloaded: http://www.wikipedia.com/wiki/Shovel (68897 bytes, 0.60s)
downloaded: http://www.yahoo.com (153065 bytes, 1.11s)</pre>
<p id="conc-overlap_00000031">Our little <code class="literal">Async</code> API captures a common pattern that occurs with
concurrent programming, but so far we have ignored one crucial detail:
<a id="id437747" class="indexterm"></a>error handling.  To deal with errors, we will need to understand how
exceptions work in Haskell, and so the next section will review
Haskell’s exception-handling support before we return to the question
of error handling in <a class="xref" href="ch08.html#sec_conc-mvar-errors" title="Error Handling with Async">“Error Handling with Async”</a>.<a id="id437767" class="indexterm"></a><a id="id437777" class="indexterm"></a></p>
<div class="sect1" data-original-filename="ch08_conc-overlap.asciidoc" id="sec_exceptions">
<div class="titlepage"><div><div><h2 class="title">Exceptions in Haskell</h2></div></div></div>
<p id="conc-overlap_00000034"><a id="ix_ch08_conc-overlap-txt4" class="indexterm"></a><a id="ix_ch08_conc-overlap-txt5" class="indexterm"></a>The <a id="id437832" class="indexterm"></a><a id="id437839" class="indexterm"></a>Haskell 98 and 2010 standards provide a limited form of exceptions
in the <code class="literal">IO</code> monad.  The <code class="literal">IO</code> exception mechanism has been extended by
the <code class="literal">Control.Exception</code> module that comes with GHC to include
exceptions generated by purely functional code (e.g., <code class="literal">error</code> and
pattern-matching failure), and to define an extensible hierarchy of
exception types.  The result of this incremental development is that
there are some inconsistencies in the APIs as the Haskell 98/2010
interfaces are gradually replaced by the new, more general APIs.</p>
<p id="conc-overlap_00000036">Haskell has no special syntax or built-in semantics for exception handling;
everything is done with library functions.  Thus, the idioms for
exception catching in particular may look a little strange.  The <a id="id437895" class="indexterm"></a>tradeoff is that we
are able to build higher-level exception handling combinators that
embody more powerful abstractions, as we shall see shortly.</p>
<p id="conc-overlap_00000037">In Haskell, exceptions<a id="id437911" class="indexterm"></a> are thrown by the <code class="literal">throw</code> function:</p>
<pre class="programlisting" data-language="haskell" id="throw__except"><code class="nf">throw</code> <code class="ow">::</code> <code class="kt">Exception</code> <code class="n">e</code> <code class="ow">=&gt;</code> <code class="n">e</code> <code class="ow">-&gt;</code> <code class="n">a</code></pre>
<p id="conc-overlap_00000039">Two things to note here:</p>
<div class="itemizedlist" id="conc-overlap_00000040"><ul class="itemizedlist">
<li class="listitem">
<code class="literal">throw</code> takes a value of any type that is an instance of the
  <code class="literal">Exception</code> type class.
</li>
<li class="listitem">
<code class="literal">throw</code> returns the unrestricted type variable <code class="literal">a</code>, so it can be
  called from anywhere.
</li>
</ul></div>
<p id="conc-overlap_00000042">The<a id="id438031" class="indexterm"></a> <code class="literal">Exception</code> type class is provided by the <code class="literal">Control.Exception</code>
module and is defined as follows:</p>
<pre class="programlisting" data-language="haskell" id="class_typeable"><code class="kr">class</code> <code class="p">(</code><code class="kt">Typeable</code> <code class="n">e</code><code class="p">,</code> <code class="kt">Show</code> <code class="n">e</code><code class="p">)</code> <code class="ow">=&gt;</code> <code class="kt">Exception</code> <code class="n">e</code> <code class="kr">where</code>
  <code class="c1">-- ...</code></pre>
<p id="conc-overlap_00000044">Its <a id="id438131" class="indexterm"></a><a id="id438137" class="indexterm"></a>methods are not important here (see the
documentation for details), but the important principle is that any type that is
an instance of both <code class="literal">Typeable</code> and <code class="literal">Show</code> can be an <code class="literal">Exception</code>.<a href="#ftn.id438165" class="footnote"><sup class="footnote" id="id438165">[32]</sup></a></p>
<p id="conc-overlap_00000045">One <a id="id438187" class="indexterm"></a>common type used as an exception is <code class="literal">ErrorCall</code>:</p>
<pre class="programlisting" data-language="haskell" id="newtype_errorca"><code class="kr">newtype</code> <code class="kt">ErrorCall</code> <code class="ow">=</code> <code class="kt">ErrorCall</code> <code class="kt">String</code>
    <code class="kr">deriving</code> <code class="p">(</code><code class="kt">Typeable</code><code class="p">)</code>

<code class="kr">instance</code> <code class="kt">Show</code> <code class="kt">ErrorCall</code> <code class="kr">where</code> <code class="p">{</code> <code class="o">...</code> <code class="p">}</code>

<code class="kr">instance</code> <code class="kt">Exception</code> <code class="kt">ErrorCall</code></pre>
<p id="conc-overlap_00000049">For example, we can throw an <code class="literal">ErrorCall</code> like so:</p>
<pre class="programlisting" data-language="haskell" id="throw_errorcal">  <code class="n">throw</code> <code class="p">(</code><code class="kt">ErrorCall</code> <code class="s">"oops!"</code><code class="p">)</code></pre>
<p id="conc-overlap_00000051">In fact, the function <code class="literal">error</code> from the <code class="literal">Prelude</code> does exactly this and is
defined as:</p>
<pre class="screen" id="conc-overlap_00000052"><code class="nf">error</code> <code class="ow">::</code> <code class="kt">String</code> <code class="ow">-&gt;</code> <code class="n">a</code>
<code class="nf">error</code> <code class="n">s</code> <code class="ow">=</code> <code class="n">throw</code> <code class="p">(</code><code class="kt">ErrorCall</code> <code class="n">s</code><code class="p">)</code></pre>
<p id="conc-overlap_00000053">I/O operations <a id="id438453" class="indexterm"></a>in Haskell also throw exceptions to indicate errors, and
these are usually values of the <code class="literal">IOException</code> type.  Operations to
build and inspect <code class="literal">IOException</code> can be found in the <code class="literal">System.IO.Error</code>
library.</p>
<p id="conc-overlap_00000054">Exceptions <a id="id438486" class="indexterm"></a><a id="id438491" class="indexterm"></a><a id="id438499" class="indexterm"></a><a id="id438508" class="indexterm"></a>in Haskell can be caught, but <span class="emphasis"><em>only in the <code class="literal">IO</code> monad</em></span>.
The basic exception-catching function is <code class="literal">catch</code>:</p>
<pre class="programlisting" data-language="haskell" id="catch__except"><code class="nf">catch</code> <code class="ow">::</code> <code class="kt">Exception</code> <code class="n">e</code> <code class="ow">=&gt;</code> <code class="kt">IO</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="p">(</code><code class="n">e</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">a</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">a</code></pre>
<p id="conc-overlap_00000056">The <code class="literal">catch</code> function takes two arguments:</p>
<div class="itemizedlist" id="conc-overlap_00000057"><ul class="itemizedlist">
<li class="listitem">
The <code class="literal">IO</code> operation to perform, of type <code class="literal">IO a</code>
</li>
<li class="listitem">
An exception handler of type <code class="literal">e -&gt; IO a</code>, where <code class="literal">e</code> must be an instance of the <code class="literal">Exception</code> class
</li>
</ul></div>
<p id="conc-overlap_00000059">The behavior is as follows: the <code class="literal">IO</code> operation in the first argument
is performed, and if it throws an exception <span class="emphasis"><em>of the type expected by
the handler</em></span>, <code class="literal">catch</code> executes the handler, passing it the exception
value that was thrown.  So a call to <code class="literal">catch</code> catches only exceptions
of a particular type, determined by the argument type of the exception
handler.</p>
<p id="conc-overlap_00000060">To demonstrate this, we will need a new exception type.  Let’s make our
own in GHCi.<a href="#ftn.id438726" class="footnote"><sup class="footnote" id="id438726">[33]</sup></a> First some setup:</p>
<pre class="screen" id="conc-overlap_00000061">&gt; import Prelude hiding (catch) -- not needed for GHC 7.6.1 and later
&gt; import Control.Exception
&gt; import Data.Typeable
&gt; :set -XDeriveDataTypeable</pre>
<p id="conc-overlap_00000062">Remember<a id="id438748" class="indexterm"></a><a id="id438754" class="indexterm"></a> that to make a type an instance of <code class="literal">Exception</code>, it must also
be an instance of <code class="literal">Show</code> and <code class="literal">Typeable</code>.  To enable automatic
derivation for <code class="literal">Typeable</code>, we need to turn on the
<code class="literal">-XDeriveDataTypeable</code> flag.</p>
<div class="caution" id="conc-overlap_00000063">
<p id="conc-overlap_00000064">In GHC 7.4.x and earlier, the <code class="literal">Prelude</code> exports a function called
<code class="literal">catch</code>, which is similar to <code class="literal">Control.Exception.catch</code> but restricted to
<code class="literal">IOException</code>s.  If you’re using exceptions with GHC 7.4.x or earlier,
you should use the following:</p>
<pre class="programlisting" data-language="haskell" id="import_control_id5"><code class="kr">import</code> <code class="nn">Control.Exception</code>
<code class="kr">import</code> <code class="nn">Prelude</code> <code class="k">hiding</code> <code class="p">(</code><code class="nf">catch</code><code class="p">)</code></pre>
<p id="conc-overlap_00000066">Note that this code still works with GHC 7.6.1 and later, because it is now a warning, rather than an error, to mention a nonexistent identifier in a <code class="literal">hiding</code> clause.</p>
</div>
<p id="conc-overlap_00000069">Now we define a new type and make it an instance of <code class="literal">Exception</code>:</p>
<pre class="screen" id="conc-overlap_00000070">&gt; data MyException = MyException deriving (Show, Typeable)
&gt; instance Exception MyException</pre>
<p id="conc-overlap_00000071">Then we check that we can <code class="literal">throw</code> it:</p>
<pre class="screen" id="conc-overlap_00000072">&gt; throw MyException
*** Exception: MyException</pre>
<p id="conc-overlap_00000073">OK, now to catch it.  <a id="id438943" class="indexterm"></a>The <code class="literal">catch</code> function is normally used infix, like this: <code class="literal"><em class="replaceable"><code>action</code></em> `catch` \e -&gt; <em class="replaceable"><code>handler</code></em></code>.</p>
<p id="conc-overlap_00000075">If we try to call <code class="literal">catch</code> without adding any information about the type
of exception to catch, we will get an ambiguous type error from GHCi:</p>
<pre class="screen" id="conc-overlap_00000076">&gt; throw MyException `catch` \e -&gt; print e

&lt;interactive&gt;:10:33:
    Ambiguous type variable `a0' in the constraints:
      (Show a0) arising from a use of `print' at &lt;interactive&gt;:10:33-37
      (Exception a0)
        arising from a use of `catch' at &lt;interactive&gt;:10:19-25
    Probable fix: add a type signature that fixes these type variable(s)
    In the expression: print e
    In the second argument of `catch', namely `\ e -&gt; print e'
    In the expression: throw MyException `catch` \ e -&gt; print e</pre>
<p id="conc-overlap_00000078">So we need to add an extra type signature to tell GHCi which type of
exceptions we wanted to catch:</p>
<pre class="screen" id="conc-overlap_00000079">&gt; throw MyException `catch` \e -&gt; print (e :: MyException)
MyException</pre>
<p id="conc-overlap_00000080">The exception was successfully thrown, caught by the <code class="literal">catch</code> function,
and printed by the exception handler.  If we throw a different type of
exception, it won’t be caught by this handler:</p>
<pre class="screen" id="conc-overlap_00000081">&gt; throw (ErrorCall "oops") `catch` \e -&gt; print (e :: MyException)
*** Exception: oops</pre>
<p id="conc-overlap_00000082">What if <a id="id439050" class="indexterm"></a>we wanted to catch <span class="emphasis"><em>any</em></span> exception? In fact, it is possible to
do this because the exception types form a hierarchy, and at the top
of the hierarchy is a type called <code class="literal">SomeException</code> that includes all
exception types.  Therefore, to catch any exception, we can write an
exception handler that catches the <code class="literal">SomeException</code> type:</p>
<pre class="screen" id="conc-overlap_00000083">&gt; throw (ErrorCall "oops") `catch` \e -&gt; print (e :: SomeException)
oops</pre>
<p id="conc-overlap_00000084">Writing an exception handler that catches all exceptions is
useful in only a couple of cases, though:</p>
<div class="itemizedlist" id="conc-overlap_00000085"><ul class="itemizedlist">
<li class="listitem">
Testing and debugging, as in the above example
</li>
<li class="listitem">
Performing some cleanup, before re-throwing the exception
</li>
</ul></div>
<p id="conc-overlap_00000086">Catching <code class="literal">SomeException</code> and then continuing is not good practice in
production code, because for obvious reasons it isn’t a good idea to
ignore unknown error conditions.</p>
<p id="conc-overlap_00000087">The <code class="literal">catch</code> function is not the only way to catch exceptions.
<a id="id439138" class="indexterm"></a><a id="id439146" class="indexterm"></a>Sometimes it is more convenient to use the <code class="literal">try</code> variant instead:</p>
<pre class="programlisting" data-language="haskell" id="try__exceptio"><code class="nf">try</code> <code class="ow">::</code> <code class="kt">Exception</code> <code class="n">e</code> <code class="ow">=&gt;</code> <code class="kt">IO</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">Either</code> <code class="n">e</code> <code class="n">a</code><code class="p">)</code></pre>
<p id="conc-overlap_00000089">For example:</p>
<pre class="screen" id="conc-overlap_00000090">&gt; try (readFile "nonexistent") :: IO (Either IOException String)
Left nonexistent: openFile: does not exist (No such file or directory)</pre>
<p id="conc-overlap_00000091">Another <a id="id439266" class="indexterm"></a>variant of <code class="literal">catch</code> is <code class="literal">handle</code>, which is just <code class="literal">catch</code> with its
arguments reversed:</p>
<pre class="programlisting" data-language="haskell" id="handle__excep"><code class="nf">handle</code> <code class="ow">::</code> <code class="kt">Exception</code> <code class="n">e</code> <code class="ow">=&gt;</code> <code class="p">(</code><code class="n">e</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">a</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">a</code></pre>
<p id="conc-overlap_00000093">This is particularly useful when the exception handler is short but
the action is long. In this case, we can use a pattern like this:</p>
<pre class="programlisting" data-language="haskell" id="handle_e__">  <code class="n">handle</code> <code class="p">(</code><code class="nf">\</code><code class="n">e</code> <code class="ow">-&gt;</code> <code class="o">...</code><code class="p">)</code> <code class="o">$</code> <code class="kr">do</code>
    <code class="o">...</code></pre>
<p id="conc-overlap_00000095">It is <a id="id439459" class="indexterm"></a><a id="id439467" class="indexterm"></a>often useful to be able to perform some operation if an
exception is raised and then re-throw the exception.  For this, the
<code class="literal">onException</code> function is provided:</p>
<pre class="programlisting" data-language="haskell" id="onexception__"><code class="nf">onException</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">b</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">a</code></pre>
<p id="conc-overlap_00000097">This is straightforwardly defined using <code class="literal">catch</code>:</p>
<pre class="programlisting" data-language="haskell" id="onexception_io_"><code class="nf">onException</code> <code class="n">io</code> <code class="n">what</code>
   <code class="ow">=</code> <code class="n">io</code> <code class="p">`</code><code class="n">catch</code><code class="p">`</code> <code class="nf">\</code><code class="n">e</code> <code class="ow">-&gt;</code> <code class="kr">do</code> <code class="kr">_</code> <code class="ow">&lt;-</code> <code class="n">what</code>
                         <code class="n">throwIO</code> <code class="p">(</code><code class="n">e</code> <code class="ow">::</code> <code class="kt">SomeException</code><code class="p">)</code></pre>
<p id="conc-overlap_00000099">To re-throw the <a id="id439675" class="indexterm"></a>exception here we used <code class="literal">throwIO</code>, which is a variant
of <code class="literal">throw</code> for use in the <code class="literal">IO</code> monad:</p>
<pre class="programlisting" data-language="haskell" id="throwio__exce"><code class="nf">throwIO</code> <code class="ow">::</code> <code class="kt">Exception</code> <code class="n">e</code> <code class="ow">=&gt;</code> <code class="n">e</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">a</code></pre>
<div class="tip" id="conc-overlap_00000101"><p id="it_is_always_be">It is always better to use <code class="literal">throwIO</code> rather than <code class="literal">throw</code> in the <code class="literal">IO</code> monad
because <code class="literal">throwIO</code> guarantees strict ordering with respect to other <code class="literal">IO</code>
operations, whereas <code class="literal">throw</code> does not.</p></div>
<p id="conc-overlap_00000102">We end this short introduction to exceptions in Haskell with two very
useful functions, <code class="literal">bracket</code> and <code class="literal">finally</code>:</p>
<pre class="programlisting" data-language="haskell" id="bracket__io_a_id1"><code class="nf">bracket</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="p">(</code><code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">b</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="p">(</code><code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">c</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">c</code>

<code class="nf">finally</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">b</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">a</code></pre>
<p id="conc-overlap_00000105">These are two of the higher-level abstractions mentioned earlier.  The
<code class="literal">bracket</code> function allows us to set up an exception handler to
reliably deallocate a resource or perform some cleanup operation.
For example, suppose we want to create a temporary file on the file
system, perform some operation on it, and have the temporary file
reliably removed afterward—even if an exception occurred during the
operation.  We could use <code class="literal">bracket</code> like so:</p>
<pre class="programlisting" data-language="haskell" id="bracket_newtem">  <code class="n">bracket</code> <code class="p">(</code><code class="n">newTempFile</code> <code class="s">"temp"</code><code class="p">)</code>
          <code class="p">(</code><code class="nf">\</code><code class="n">file</code> <code class="ow">-&gt;</code> <code class="n">removeFile</code> <code class="n">file</code><code class="p">)</code>
          <code class="p">(</code><code class="nf">\</code><code class="n">file</code> <code class="ow">-&gt;</code> <code class="o">...</code><code class="p">)</code></pre>
<p id="conc-overlap_00000107">In a call <code class="literal">bracket a b c</code>, the first argument <code class="literal">a</code> is the operation
that allocates the resource (in this case, creating the temporary file),
the second argument <code class="literal">b</code> deallocates the resource again (in
this case, deleting the temporary file), and the third argument <code class="literal">c</code> is
the operation to perform.  Both <code class="literal">b</code> and <code class="literal">c</code> take the result of <code class="literal">a</code> as
an argument. In this case, that means they have access to the name of
the temporary file that was created.</p>
<p id="conc-overlap_00000108">The <code class="literal">bracket</code> function is readily defined using the pieces we already have:</p>
<pre class="programlisting" data-language="haskell" id="bracket__io_a_id2"><code class="nf">bracket</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="p">(</code><code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">b</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="p">(</code><code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">c</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">c</code>
<code class="nf">bracket</code> <code class="n">before</code> <code class="n">after</code> <code class="n">during</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">a</code> <code class="ow">&lt;-</code> <code class="n">before</code>
  <code class="n">c</code> <code class="ow">&lt;-</code> <code class="n">during</code> <code class="n">a</code> <code class="p">`</code><code class="n">onException</code><code class="p">`</code> <code class="n">after</code> <code class="n">a</code>
  <code class="n">after</code> <code class="n">a</code>
  <code class="n">return</code> <code class="n">c</code></pre>
<p id="conc-overlap_00000110">This definition suffices for now, but note that later in
<a class="xref" href="ch09.html" title="Chapter 9. Cancellation and Timeouts">Chapter 9</a>, we will revise it to add safety in the
presence of thread <a id="id440417" class="indexterm"></a><a id="id440424" class="indexterm"></a>cancellation.</p>
<p id="conc-overlap_00000111">The <code class="literal">finally</code> function is a special case of <code class="literal">bracket</code>:</p>
<pre class="programlisting" data-language="haskell" id="finally__io_a"><code class="nf">finally</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">b</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">a</code>
<code class="nf">finally</code> <code class="n">io</code> <code class="n">after</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">io</code> <code class="p">`</code><code class="n">onException</code><code class="p">`</code> <code class="n">after</code>
  <code class="n">after</code></pre>
<p id="conc-overlap_00000113">Again, we will be revising this definition later.<a id="id440576" class="indexterm"></a><a id="id440586" class="indexterm"></a></p>
</div>
<div class="sect1" data-original-filename="ch08_conc-overlap.asciidoc" id="sec_conc-mvar-errors">
<div class="titlepage"><div><div><h2 class="title">Error Handling with Async</h2></div></div></div>
<p id="conc-overlap_00000114"><a id="ix_ch08_conc-overlap-txt6" class="indexterm"></a><a id="ix_ch08_conc-overlap-txt7" class="indexterm"></a>If we run the <code class="literal">geturls2</code> example with the network cable unplugged, we
see something like this:</p>
<pre class="screen" id="conc-overlap_00000115">$ ./geturls2
geturls2: connect: does not exist (No route to host)
geturls2: connect: does not exist (No route to host)
geturls2: thread blocked indefinitely in an MVar operation</pre>
<p id="conc-overlap_00000116">What happens is that the two calls to <code class="literal">getURL</code> fail with an exception,
as <a id="id440668" class="indexterm"></a><a id="id440676" class="indexterm"></a><a id="ix_waitfunctionerrorhandling" class="indexterm"></a>they should.  This exception propagates to the top of the thread
that <code class="literal">async</code> created, where it is caught by the default exception
handler that every <code class="literal">forkIO</code> thread gets.  The default exception
handler prints the exception to <code class="literal">stderr</code>, and then the thread
terminates.  So in <code class="literal">geturls2</code>, we see two network errors printed.  But
now, because these threads have not called <code class="literal">putMVar</code> to pass a result
back to the main thread, the main thread is still blocked in
<code class="literal">takeMVar</code>.  When the child threads exit after printing their error
messages, the main thread <span class="keep-together">is then deadlocked.</span> The runtime system
notices this and sends it the <code class="literal">BlockedIndefinitelyOnMVar</code> exception,
which leads to the third error message, shown earlier.</p>
<p id="conc-overlap_00000117">This explains what we saw, but clearly this behavior is not what
we want: the program is deadlocked after the error rather than exiting
gracefully or handling it.  The natural behavior would be for the
error to be made available to the thread that calls <code class="literal">wait</code> because that
way the caller can find out whether the asynchronous computation
returned an error or a result and act accordingly.  Moreover, a
particularly convenient behavior is for <code class="literal">wait</code> to simply propagate
the exception in the current thread so that in the common case the
programmer need not write any error-handling code at all.</p>
<p id="conc-overlap_00000118">To implement this, we need to elaborate on <code class="literal">Async</code> slightly:</p>
<p id="geturlshs_c_id2" class="caption"><span class="emphasis"><em>geturls4.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="data_async_a___id2"><code class="kr">data</code> <code class="kt">Async</code> <code class="n">a</code> <code class="ow">=</code> <code class="kt">Async</code> <code class="p">(</code><code class="kt">MVar</code> <code class="p">(</code><code class="kt">Either</code> <code class="kt">SomeException</code> <code class="n">a</code><code class="p">))</code> <code class="c1">-- </code><span id="CO32-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>

<code class="nf">async</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">Async</code> <code class="n">a</code><code class="p">)</code>
<code class="nf">async</code> <code class="n">action</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">var</code> <code class="ow">&lt;-</code> <code class="n">newEmptyMVar</code>
  <code class="n">forkIO</code> <code class="p">(</code><code class="kr">do</code> <code class="n">r</code> <code class="ow">&lt;-</code> <code class="n">try</code> <code class="n">action</code><code class="p">;</code> <code class="n">putMVar</code> <code class="n">var</code> <code class="n">r</code><code class="p">)</code>  <code class="c1">-- </code><span id="CO32-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>
  <code class="n">return</code> <code class="p">(</code><code class="kt">Async</code> <code class="n">var</code><code class="p">)</code>

<code class="nf">waitCatch</code> <code class="ow">::</code> <code class="kt">Async</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">Either</code> <code class="kt">SomeException</code> <code class="n">a</code><code class="p">)</code> <code class="c1">-- </code><span id="CO32-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span>
<code class="nf">waitCatch</code> <code class="p">(</code><code class="kt">Async</code> <code class="n">var</code><code class="p">)</code> <code class="ow">=</code> <code class="n">readMVar</code> <code class="n">var</code>

<code class="nf">wait</code> <code class="ow">::</code> <code class="kt">Async</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">a</code> <code class="c1">-- </code><span id="CO32-4"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span>
<code class="nf">wait</code> <code class="n">a</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">r</code> <code class="ow">&lt;-</code> <code class="n">waitCatch</code> <code class="n">a</code>
  <code class="kr">case</code> <code class="n">r</code> <code class="kr">of</code>
    <code class="kt">Left</code> <code class="n">e</code>  <code class="ow">-&gt;</code> <code class="n">throwIO</code> <code class="n">e</code>
    <code class="kt">Right</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">return</code> <code class="n">a</code></pre>
<div class="calloutlist" id="conc-overlap_00000123"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO32-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="where_previousl_id1">
Where previously we had <code class="literal">MVar a</code>, now we have <code class="literal">MVar (Either
SomeException a)</code>.  If the <code class="literal">MVar</code> contains <code class="literal">Right a</code>, then the
operation completed successfully and returned value <code class="literal">a</code>; whereas if it
contains <code class="literal">Left e</code>, then the operation threw the exception <code class="literal">e</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO32-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_action_istr">
The <code class="literal">action</code> is<a id="id441403" class="indexterm"></a> now wrapped in <code class="literal">try</code>, which returns
<code class="literal">Either SomeException a</code>—exactly the type we need to put into the
<code class="literal">MVar</code>.  Earlier, we cautioned that catching <code class="literal">SomeException</code> is often
not a good idea, but this is one case where it is fine because we are
catching exceptions in one thread with the intention of propagating
them to another thread, and we want the behavior to be the same for
<span class="emphasis"><em>all</em></span> exceptions.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO32-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="now_we_will_pro">
Now we will provide two ways to wait for the result of an <code class="literal">Async</code>.
The<a id="id441460" class="indexterm"></a> first, <code class="literal">waitCatch</code>, returns <code class="literal">Either SomeException a</code> so the
caller can handle the error immediately.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO32-4"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_second_way_">
The second way to wait for a result is <code class="literal">wait</code>, which has the same
type as before.  However, now, if <code class="literal">wait</code> finds that the <code class="literal">Async</code>
resulted in an exception, the exception is re-thrown by <code class="literal">wait</code> itself.
This implements the convenient error-propagating behavior mentioned
previously.
</p></td>
</tr>
</table></div>
<p id="conc-overlap_00000127">Using this new <code class="literal">Async</code> layer, our <code class="literal">geturls</code> example now fails more
gracefully (see <span class="emphasis"><em>geturls4.hs</em></span> for the complete code): <a id="id441540" class="indexterm"></a></p>
<pre class="screen" id="conc-overlap_00000128">$ ./geturls4
geturls4: connect: timeout (Connection timed out)
[3]    25198 exit 1     ./geturls4
$</pre>
<p id="conc-overlap_00000129">The program <a id="id441566" class="indexterm"></a><a id="id441574" class="indexterm"></a>exited with an error code after the first failure, rather
than deadlocking as before.</p>
<p id="conc-overlap_00000130">The basic <code class="literal">Async</code> API is the same as before—<code class="literal">async</code> and <code class="literal">wait</code> have
the same types—but now it has error-handling built in, and it is
much harder for the programmer to accidentally forget to handle
errors. The only way to ignore an error is to ignore the result as well.<a id="id441610" class="indexterm"></a><a id="id441620" class="indexterm"></a></p>
</div>
<div class="sect1" data-original-filename="ch08_conc-overlap.asciidoc" id="sec_merging">
<div class="titlepage"><div><div><h2 class="title">Merging</h2></div></div></div>
<p id="conc-overlap_00000131"><a id="ix_ch08_conc-overlap-txt8" class="indexterm"></a><a id="ix_ch08_conc-overlap-txt9" class="indexterm"></a><a id="ix_ch08_conc-overlap-txt10" class="indexterm"></a><a id="ix_ch08_conc-overlap-txt11" class="indexterm"></a>Suppose we want to wait for one of several different events to occur. For example, when downloading multiple URLs, we want to perform some
action as soon as the first one has downloaded.</p>
<p id="conc-overlap_00000132">The pattern for doing this<a id="id441713" class="indexterm"></a> with <code class="literal">MVar</code> is that each of the separate
actions must put its results into the same <code class="literal">MVar</code>, so that we can
then call <code class="literal">takeMVar</code> to wait for the first such event to occur.  Here
is the <span class="emphasis"><em>geturls3.hs</em></span> example from <a class="xref" href="ch08.html" title="Chapter 8. Overlapping Input/Output">Chapter 8</a>, modified to wait
for the <span class="emphasis"><em>first</em></span> URL to complete downloading and then to report which
one it was.</p>
<p id="conc-overlap_00000133" class="caption"><span class="emphasis"><em>geturls5.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="sites__http_id2"><code class="nf">sites</code> <code class="ow">=</code> <code class="p">[</code><code class="s">"http://www.google.com"</code><code class="p">,</code>
         <code class="s">"http://www.bing.com"</code><code class="p">,</code>
         <code class="s">"http://www.yahoo.com"</code><code class="p">,</code>
         <code class="s">"http://www.wikipedia.com/wiki/Spade"</code><code class="p">,</code>
         <code class="s">"http://www.wikipedia.com/wiki/Shovel"</code><code class="p">]</code>

<code class="nf">main</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">main</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">m</code> <code class="ow">&lt;-</code> <code class="n">newEmptyMVar</code>
  <code class="kr">let</code>
    <code class="n">download</code> <code class="n">url</code> <code class="ow">=</code> <code class="kr">do</code>
       <code class="n">r</code> <code class="ow">&lt;-</code> <code class="n">getURL</code> <code class="n">url</code>
       <code class="n">putMVar</code> <code class="n">m</code> <code class="p">(</code><code class="n">url</code><code class="p">,</code> <code class="n">r</code><code class="p">)</code>

  <code class="n">mapM_</code> <code class="p">(</code><code class="n">forkIO</code> <code class="o">.</code> <code class="n">download</code><code class="p">)</code> <code class="n">sites</code>

  <code class="p">(</code><code class="n">url</code><code class="p">,</code> <code class="n">r</code><code class="p">)</code> <code class="ow">&lt;-</code> <code class="n">takeMVar</code> <code class="n">m</code>
  <code class="n">printf</code> <code class="s">"%s was first (%d bytes)</code><code class="se">\n</code><code class="s">"</code> <code class="n">url</code> <code class="p">(</code><code class="kt">B</code><code class="o">.</code><code class="n">length</code> <code class="n">r</code><code class="p">)</code>
  <code class="n">replicateM_</code> <code class="p">(</code><code class="n">length</code> <code class="n">sites</code> <code class="o">-</code> <code class="mi">1</code><code class="p">)</code> <code class="p">(</code><code class="n">takeMVar</code> <code class="n">m</code><code class="p">)</code></pre>
<p id="conc-overlap_00000137">Here, we create a single <code class="literal">MVar</code> and then fork a thread for each of the
URLs to download.  Each thread writes its result into the same <code class="literal">MVar</code>,
where the result is now a pair of the URL and its contents.  The main
thread takes the first result from the <code class="literal">MVar</code>, announces which URL was
the quickest to download, and then waits for the rest of the results
to arrive.</p>
<pre class="screen" id="conc-overlap_00000138">$ ./geturls5
http://www.google.com was first (10483 bytes)
$</pre>
<p id="conc-overlap_00000139">While <a id="id442198" class="indexterm"></a>this pattern works, it can be a little inconvenient to arrange
it so that all the events feed into the same <code class="literal">MVar</code>.  For example, suppose
we want to extend our <code class="literal">Async</code> API to allow waiting for either of two
<code class="literal">Async</code>s simultaneously, returning the result of the first one to
succeed or propagating the exception if either <code class="literal">Async</code> fails.  The
function we want is <code class="literal">waitEither</code>, with this type:</p>
<pre class="programlisting" data-language="haskell" id="waiteither__a_id1"><code class="nf">waitEither</code> <code class="ow">::</code> <code class="kt">Async</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Async</code> <code class="n">b</code> <code class="ow">-&gt;</code> <code class="kt">Async</code> <code class="p">(</code><code class="kt">Either</code> <code class="n">a</code> <code class="n">b</code><code class="p">)</code></pre>
<p id="conc-overlap_00000141">Note that because the input <code class="literal">Async</code>s have already been created, we are
too late to tell them to put their results into the same <code class="literal">MVar</code>.
Instead, we have to create two <span class="emphasis"><em>new</em></span> threads to collect the results of
each <code class="literal">Async</code> and merge them into a new <code class="literal">MVar</code>:</p>
<p id="conc-overlap_00000142" class="caption"><span class="emphasis"><em>geturls6.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="waiteither__a_id2"><code class="nf">waitEither</code> <code class="ow">::</code> <code class="kt">Async</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Async</code> <code class="n">b</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">Either</code> <code class="n">a</code> <code class="n">b</code><code class="p">)</code>
<code class="nf">waitEither</code> <code class="n">a</code> <code class="n">b</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">m</code> <code class="ow">&lt;-</code> <code class="n">newEmptyMVar</code>
  <code class="n">forkIO</code> <code class="o">$</code> <code class="kr">do</code> <code class="n">r</code> <code class="ow">&lt;-</code> <code class="n">try</code> <code class="p">(</code><code class="n">fmap</code> <code class="kt">Left</code>  <code class="p">(</code><code class="n">wait</code> <code class="n">a</code><code class="p">));</code> <code class="n">putMVar</code> <code class="n">m</code> <code class="n">r</code>
  <code class="n">forkIO</code> <code class="o">$</code> <code class="kr">do</code> <code class="n">r</code> <code class="ow">&lt;-</code> <code class="n">try</code> <code class="p">(</code><code class="n">fmap</code> <code class="kt">Right</code> <code class="p">(</code><code class="n">wait</code> <code class="n">b</code><code class="p">));</code> <code class="n">putMVar</code> <code class="n">m</code> <code class="n">r</code>
  <code class="n">wait</code> <code class="p">(</code><code class="kt">Async</code> <code class="n">m</code><code class="p">)</code></pre>
<p id="conc-overlap_00000143">To get the right error-handling behavior, <code class="literal">waitEither</code> uses <code class="literal">wait</code> to
grab each result wrapped in a <code class="literal">try</code> to catch any exceptions and then
puts each result into the newly created <code class="literal">MVar</code> <code class="literal">m</code>.  Then we make a
new <code class="literal">Async</code> from <code class="literal">m</code> and <code class="literal">wait</code> for the result of that.</p>
<p id="conc-overlap_00000144">We can<a id="id442739" class="indexterm"></a> generalize <code class="literal">waitEither</code> to wait for a list of <code class="literal">Async</code>s,
returning the result from the first one to complete:</p>
<pre class="programlisting" data-language="haskell" id="waitany__asy_id1"><code class="nf">waitAny</code> <code class="ow">::</code> <code class="p">[</code><code class="kt">Async</code> <code class="n">a</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">a</code>
<code class="nf">waitAny</code> <code class="n">as</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">m</code> <code class="ow">&lt;-</code> <code class="n">newEmptyMVar</code>
  <code class="kr">let</code> <code class="n">forkwait</code> <code class="n">a</code> <code class="ow">=</code> <code class="n">forkIO</code> <code class="o">$</code> <code class="kr">do</code> <code class="n">r</code> <code class="ow">&lt;-</code> <code class="n">try</code> <code class="p">(</code><code class="n">wait</code> <code class="n">a</code><code class="p">);</code> <code class="n">putMVar</code> <code class="n">m</code> <code class="n">r</code>
  <code class="n">mapM_</code> <code class="n">forkwait</code> <code class="n">as</code>
  <code class="n">wait</code> <code class="p">(</code><code class="kt">Async</code> <code class="n">m</code><code class="p">)</code></pre>
<p id="conc-overlap_00000146">Now, <code class="literal">waitAny</code> can be used to rewrite <span class="emphasis"><em>geturls5.hs</em></span> using <code class="literal">Async</code>:</p>
<p id="conc-overlap_00000147" class="caption"><span class="emphasis"><em>geturls6.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="main__io__m_id5"><code class="nf">main</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">main</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="kr">let</code>
    <code class="n">download</code> <code class="n">url</code> <code class="ow">=</code> <code class="kr">do</code>
       <code class="n">r</code> <code class="ow">&lt;-</code> <code class="n">getURL</code> <code class="n">url</code>
       <code class="n">return</code> <code class="p">(</code><code class="n">url</code><code class="p">,</code> <code class="n">r</code><code class="p">)</code>

  <code class="n">as</code> <code class="ow">&lt;-</code> <code class="n">mapM</code> <code class="p">(</code><code class="n">async</code> <code class="o">.</code> <code class="n">download</code><code class="p">)</code> <code class="n">sites</code>

  <code class="p">(</code><code class="n">url</code><code class="p">,</code> <code class="n">r</code><code class="p">)</code> <code class="ow">&lt;-</code> <code class="n">waitAny</code> <code class="n">as</code>
  <code class="n">printf</code> <code class="s">"%s was first (%d bytes)</code><code class="se">\n</code><code class="s">"</code> <code class="n">url</code> <code class="p">(</code><code class="kt">B</code><code class="o">.</code><code class="n">length</code> <code class="n">r</code><code class="p">)</code>
  <code class="n">mapM_</code> <code class="n">wait</code> <code class="n">as</code></pre>
<p id="conc-overlap_00000150">The code for <code class="literal">waitAny</code> is quite short and does the job, but it is
slightly annoying to have to create an extra thread per <code class="literal">Async</code> for
this simple operation.  Threads might be cheap, but we ought to be
able to merge multiple sources of events more directly.  Later in
<a class="xref" href="ch10.html" title="Chapter 10. Software Transactional Memory">Chapter 10</a>, we will see how software transactional memory allows a
neater and more efficient implementation of <code class="literal">waitAny</code>.<a id="id443326" class="indexterm"></a><a id="id443336" class="indexterm"></a><a id="id443346" class="indexterm"></a><a id="id443356" class="indexterm"></a><a id="id443367" class="indexterm"></a><a id="id443377" class="indexterm"></a></p>
</div>
<div class="footnotes">
<br><hr style="width: 100; align: left;">
<div id="ftn.id438165" class="footnote"><p><a href="#id438165" class="simpara"><sup class="simpara">[32] </sup></a>An introduction to <code class="literal">Typeable</code> is beyond the scope of this book; please refer to the documentation for the module <code class="literal">Data.Typeable</code>.</p></div>
<div id="ftn.id438726" class="footnote"><p><a href="#id438726" class="simpara"><sup class="simpara">[33] </sup></a>For this example to work in GHCi, you will need at least GHC 7.4.1</p></div>
</div></section><footer><div class="navfooter">
<hr>
<table style="width: 100%; ">
<tr>
<td style="width: 40%; text-align: left; ">
<a accesskey="p" href="ch07.html">Prev</a> </td>
<td style="width: 20%; text-align: center; "><a accesskey="u" href="pt02.html">Up</a></td>
<td style="width: 40%; text-align: right; "> <a accesskey="n" href="ch09.html">Next</a>
</td>
</tr>
<tr>
<td style="width: 40%; text-align: left; vertical-align: top; ">Chapter 7. Basic Concurrency: Threads and MVars </td>
<td style="width: 20%; text-align: center; "><a accesskey="h" href="index.html">Home</a></td>
<td style="width: 40%; text-align: right; vertical-align: top; "> Chapter 9. Cancellation and Timeouts</td>
</tr>
</table>
</div></footer>


	<div class="extra-footer">
		<p>© 2013, O’Reilly Media, Inc.</p>
		<ul>
			<li><a href="http://oreilly.com/terms/">Terms of Service</a></li>
			<li><a href="http://oreilly.com/oreilly/privacy.csp">Privacy Policy</a></li>
			<li>Interested in <a href="mailto:scordesse@oreilly.com">sponsoring content?</a></li>
		</ul>
	</div>
<script type="text/javascript">if (!NREUMQ.f) { NREUMQ.f=function() {
NREUMQ.push(["load",new Date().getTime()]);
var e=document.createElement("script");
e.type="text/javascript";
e.src=(("http:"===document.location.protocol)?"http:":"https:") + "//" +
  "js-agent.newrelic.com/nr-100.js";
document.body.appendChild(e);
if(NREUMQ.a)NREUMQ.a();
};
NREUMQ.a=window.onload;window.onload=NREUMQ.f;
};
NREUMQ.push(["nrfj","bam.nr-data.net","3e361aebcf","2194180","IApbRUBZXg1WEEoHDAwORh5aQl8N",0,24,new Date().getTime(),"","","","",""]);</script></body>

<!-- Mirrored from chimera.labs.oreilly.com/books/1230000000929/ch08.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 19 Dec 2016 05:39:32 GMT -->
</html>