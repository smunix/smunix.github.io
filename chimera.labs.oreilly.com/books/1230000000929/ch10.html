<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<!-- Mirrored from chimera.labs.oreilly.com/books/1230000000929/ch10.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 18 Dec 2016 11:04:16 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head><script type="text/javascript">var NREUMQ=NREUMQ||[];NREUMQ.push(["mark","firstbyte",new Date().getTime()]);</script>
	<title>Parallel and Concurrent Programming in Haskell</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link href="http://dwn0odqttrkhc.cloudfront.net/assets/book-f1caceafd9c9f3a6ff72d40c54d173ab.css" media="screen" rel="stylesheet" type="text/css" />
	<link href="http://dwn0odqttrkhc.cloudfront.net/assets/default-24583441b4f47382b8932338cd56ed23.css" media="screen" rel="stylesheet" type="text/css" />
	<script src="http://dwn0odqttrkhc.cloudfront.net/assets/application-47d6ffb0c77b868d29a43eb65e940505.js" type="text/javascript"></script>
	<script src="http://dwn0odqttrkhc.cloudfront.net/assets/book-756862b9ed04d945ca53de5b8f106a83.js" type="text/javascript"></script>
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	<link href="http://dwn0odqttrkhc.cloudfront.net/assets/janrain-53eb5abed55992e21943b9d3373923e8.css" media="all" rel="stylesheet" type="text/css" />
	<meta content="authenticity_token" name="csrf-param" />
<meta content="WQ02oEFDbvBG99rmf8rwvGssMqcy27cCD64yZVVTcMY=" name="csrf-token" />
	<script type="text/javascript" charset="utf-8">
  	
		app.data = new classes.Data({"controller":{"controller":"books","action":"html"},"capturable":{"capture_server":"https://oreilly.janraincapture.com","client_id":"6n5q2k9vesqgn93k3mhevka6c3c3rsre","app_url":"https://login.oreilly.com","app_id":"xsnca5wmqe9vxv97ygh5vfejkd","load_js":"d16s8pqtk4uodx.cloudfront.net/login.oreilly.com/load.js"},"user":{"id":null,"account":"LoggedOutAccount","email":"","name":null,"gravatar_url":"http://www.gravatar.com/avatar/d41d8cd98f00b204e9800998ecf8427e?s=40&d=identicon"},"book":{"isbn":"1230000000929","chapter":"ch10.html","toc_url":"/books/1230000000929/toc_html","metadata_url":"http://d4bb7yl96lyl1.cloudfront.net/1230000000929/metadata/metadata_9b2ac4d71a3220a7d463d8d4c80f9113048bb194.json"},"abilities":{"can_destroy_all_comments":false,"can_create_comments":false},"advertisement":{"body":"<style>      \r\n.ad-profile-image {\r\n  padding: 0;\r\n  margin: 0;\r\n  max-height: 30px;\r\n }\r\n\r\n.top-banner {\r\n  position: absolute;\r\n  right: 0;\r\n  top: 34px;\r\n  z-index: 99999;\r\n}\r\n\r\np.banner-text {\r\n  margin: 0;\r\n  text-align: center;\r\n  padding-right: 10px;\r\n  width: 450px;\r\n}\r\n\r\n@media screen and (max-width: 600px) {\r\n   p.banner-text {\r\n     width: 100%;\r\n     text-align: center;\r\n  }\r\n}\r\n\r\nspan.ebook-advantage {\r\n  font-size: smaller;\r\n  display: block;\r\n}\r\n\r\ndiv.banner-container {\r\n  margin: 0 auto;\r\n}\r\n\r\ndiv.banner-container ul {\r\n  margin: 0 auto;\r\n}\r\n\r\ndiv.topad { padding-bottom: 5px; }\r\n\r\ndiv.banner-container ul li {\r\n  display: inline-block;\r\n  vertical-align: middle;\r\n}\r\n\r\ndiv.banner-container li p {\r\n  padding-top: 0;\r\n  margin-top: 0;\r\n}\r\n\r\ndiv.banner-container li.sponsor {\r\n  border-right: 1px solid rgb(125, 154, 180);\r\n  margin-right: 5px;\r\n  padding-right: 10px;\r\n}\r\n\r\ndiv.banner-container .webbutton {\r\n  background-color: #3994b6;\r\n  display: inline-block;\r\n  padding: 10px;\r\n  -webkit-border-radius: 5px;\r\n  -moz-border-radius: 5px;\r\n  border-radius: 5px;\r\n  color: #FFF;\r\n  text-align: center;\r\n  text-decoration: none;\r\n  font-size: 12px;\r\n  font-weight: bold;\r\n}\r\n\r\n</style>\r\n   \r\n<div style=\"color: rgb(125, 154, 180);\">\r\n\r\n<div class=\"banner-container\">\r\n\r\n<ul>\r\n\r\n<li class=\"sponsor\">\r\n<!--CONFERENCE SPONSOR IMAGE-->\r\n<a href=\"http://www.oscon.com/oscon2013\">\r\n<!--<img src=\"http://orm-other.s3.amazonaws.com/fluent_logo.png\" class=\"ad-profile-image\"/>-->\r\n<img src=\"http://orm-other.s3.amazonaws.com/oscon_logo.png\" class=\"ad-profile-image\"/>\r\n<!--<img src=\"http://orm-other.s3.amazonaws.com/strata_logo.png\" class=\"ad-profile-image\"/>\r\n<img src=\"http://orm-other.s3.amazonaws.com/StrataRx_logo.png\" class=\"ad-profile-image\"/>\r\n<img src=\"http://orm-other.s3.amazonaws.com/velocity_logo.png\" class=\"ad-profile-image\"/>-->\r\n</a>\r\n</li>\r\n\r\n<li>\r\n<!--AD TEXT, 2 LINES, REPLACE LINK URL AS WELL-->\r\n<p class=\"banner-text\">Enjoy this online version of <em>Parallel and Concurrent Programming in Haskell</em>. Purchase and download the DRM-free ebook on <a href=\"http://shop.oreilly.com/product/0636920026365.do\">oreilly.com</a>.<span class=\"ebook-advantage\">Learn more about the O’Reilly <a href=\"http://shop.oreilly.com/category/ebooks.do\">Ebook Advantage</a>.</span></p>\r\n</li>\r\n\r\n<li>\r\n<!--BUY BUTTON-->\r\n<a class=\"webbutton\" href=\"http://shop.oreilly.com/product/0636920026365.do\">Buy the Ebook</a>\r\n</li> \r\n\r\n</ul>\r\n\r\n</div>\r\n\r\n<!--CORNER BANNER (IF NEEDED)-->\r\n<!--<a href=\"http://shop.oreilly.com/product/0636920026365.do\" class=\"top-banner\"><img src=\"http://orm-other.s3.amazonaws.com/banner.png\" /></a>-->\r\n\r\n</div>"}});

		/* Janrain setup */
  	var janrainModal = new JanrainView();
  	$("head").append(janrainModal.render().el);

  	/* segment.io setup */
  	var analytics=analytics||[];analytics.load=function(e){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src=("https:"===document.location.protocol?"https://":"http://")+"d2dq2ahtl5zl1z.cloudfront.net/analytics.js/v1/"+e+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(t,n);var r=function(e){return function(){analytics.push([e].concat(Array.prototype.slice.call(arguments,0)))}},i=["identify","track","trackLink","trackForm","trackClick","trackSubmit","pageview","ab","alias","ready"];for(var s=0;s<i.length;s++)analytics[i[s]]=r(i[s])};
  	
  	analytics.load("hg9h6b9pae");

  	$(function() {
			app.bookapp = new BookApp();
		});
	
	</script>
</head>
<body>
	<div id="menu">
	
		<ul id="menu-left">
			<li id="home-link"><a href="http://chimera.labs.oreilly.com/"><i class="icon-house"></i></a></li>
			<li><a href="http://chimera.labs.oreilly.com/books/1230000000929">Parallel and Concurrent Programming in Haskell</a></li>
			<div class="clear"></div>
		</ul>
	
		<ul id="menu-right">
			<li id="comments-link"><a>&nbsp;</a></li>
			<li>
				<a href="#" class="dropdown-toggle" data-toggle="dropdown">Chapters</a>
				<div id="toc-popup" class="dropdown-menu"></div>
			</li>
				<li><a href="#" class="capture_modal_open" id="capture_signin_link">Log In / Sign Up</a></li>
			<li id="search-li">
				<form accept-charset="UTF-8" action="http://chimera.labs.oreilly.com/searches" id="search-form" method="get"><div style="margin:0;padding:0;display:inline"><input name="utf8" type="hidden" value="&#x2713;" /></div>
	<input name='search[q]' type="text" placeholder="Search book..." id="book-search" />

	<input id="search_bookId" name="search[bookId]" type="hidden" value="1230000000929" />
	
	<div style='display:none'>
		sorted by: 
		<select name='search[sort]' >
			<option value='relevance'>Relevance</option>
			<option value='authors'>Author(s)</option>
			<option value='title'>Title</option>
		</select>
		returning
		<select name='search[limit]' >
			<option value='5'>5</option>
			<option value='10'>10</option>
			<option value='20'>20</option>
			<option selected="selected" value='50'>50</option>
			<option value='100'>100</option>
		</select>
		values at a time.
	</div>
</form>
			</li>
			<div class="clear"></div>
		</ul>
		<div class="clear"></div>
	
</div>
	<header><div class="navheader">
<table style="width: 100%; ">
<tr><td style="text-align: center; " colspan="3">Chapter 10. Software Transactional Memory</td></tr>
<tr>
<td style="width: 20%; text-align: left; ">
<a accesskey="p" href="ch09.html">Prev</a> </td>
<td style="width: 60%; text-align: center; ">Part II. Concurrent Haskell</td>
<td style="width: 20%; text-align: right; "> <a accesskey="n" href="ch11.html">Next</a>
</td>
</tr>
</table>
<hr>
</div></header><section class="chapter" data-original-filename="ch10_conc-stm.asciidoc" id="sec_stm"><div class="titlepage"><div><div><h2 class="title">Chapter 10. Software Transactional Memory</h2></div></div></div>
<p id="stm_software_t_id1"><a id="ix_ch10_conc-stm-txt0" class="indexterm"></a> <a id="id454064" class="indexterm"></a><a id="id454070" class="indexterm"></a><span class="emphasis"><em>Software transactional memory (STM)</em></span> is a technique for simplifying
concurrent programming by allowing multiple state-changing operations
to be grouped together and performed as a single atomic operation.
Strictly speaking, “software transactional memory” is an
implementation technique, whereas the language construct we are
interested in is "atomic blocks."  Unfortunately, the former term has
stuck, and so the language-level facility is called STM.</p>
<p id="conc-stm_00000000">STM solves a number of problems that arise with conventional
concurrency abstractions, which we describe here through a series of
examples.  For reference throughout the following sections, the types
and operations of the STM interface are:</p>
<p id="lst_stm" class="caption"><span class="emphasis"><em>Control.Concurrent.STM</em></span></p>
<pre class="programlisting" data-language="haskell" id="data_stm_a__a"><code class="kr">data</code> <code class="kt">STM</code> <code class="n">a</code> <code class="c1">-- abstract</code>
<code class="kr">instance</code> <code class="kt">Monad</code> <code class="kt">STM</code> <code class="c1">-- among other things</code>

<code class="nf">atomically</code> <code class="ow">::</code> <code class="kt">STM</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">a</code>

<code class="kr">data</code> <code class="kt">TVar</code> <code class="n">a</code> <code class="c1">-- abstract</code>
<code class="nf">newTVar</code>   <code class="ow">::</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="p">(</code><code class="kt">TVar</code> <code class="n">a</code><code class="p">)</code>
<code class="nf">readTVar</code>  <code class="ow">::</code> <code class="kt">TVar</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="n">a</code>
<code class="nf">writeTVar</code> <code class="ow">::</code> <code class="kt">TVar</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="nb">()</code>

<code class="nf">retry</code>     <code class="ow">::</code> <code class="kt">STM</code> <code class="n">a</code>
<code class="nf">orElse</code>    <code class="ow">::</code> <code class="kt">STM</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="n">a</code>

<code class="nf">throwSTM</code>  <code class="ow">::</code> <code class="kt">Exception</code> <code class="n">e</code> <code class="ow">=&gt;</code> <code class="n">e</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="n">a</code>
<code class="nf">catchSTM</code>  <code class="ow">::</code> <code class="kt">Exception</code> <code class="n">e</code> <code class="ow">=&gt;</code> <code class="kt">STM</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="p">(</code><code class="n">e</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="n">a</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="n">a</code></pre>
<div class="sect1" data-original-filename="ch10_conc-stm.asciidoc" id="conc-stm_00000005">
<div class="titlepage"><div><div><h2 class="title">Running Example: Managing Windows</h2></div></div></div>
<p id="conc-stm_00000006"><a id="ix_ch10_conc-stm-txt3" class="indexterm"></a>Imagine a window manager that manages multiple
desktops.  The user can move windows from one desktop to another,
while at the same time, a program can request that its own window
move from its current desktop to another desktop.  The window manager
uses multiple threads: one to listen for input from the user, a set of
threads to
listen for requests from the programs running in
each existing window, and
one thread that renders the display to the user.</p>
<p id="conc-stm_00000007">How should the program represent the state of the display?  Let’s
assume some abstract types representing desktops and windows
respectively:</p>
<pre class="programlisting" data-language="haskell" id="data_desktop_"><code class="kr">data</code> <code class="kt">Desktop</code>  <code class="c1">-- abstract</code>
<code class="kr">data</code> <code class="kt">Window</code>   <code class="c1">-- abstract</code></pre>
<p id="conc-stm_00000009">A display consists of a number <a id="id454645" class="indexterm"></a>of <code class="literal">Desktop</code>s, each of which is
displaying a set of <code class="literal">Window</code>s. To put it another way, a display
is a mapping from <code class="literal">Desktop</code> to a set of <code class="literal">Window</code> objects. The mapping changes
over time, so we want to make it mutable, and the state needs to be
shared among multiple threads.  Hence, following the pattern from
<a class="xref" href="ch07.html#sec_conc-phonebook" title="MVar as a Container for Shared State">“MVar as a Container for Shared State”</a>, we could use a <code class="literal">Map</code> stored in an <code class="literal">MVar</code>:</p>
<pre class="programlisting" data-language="haskell" id="type_display___id1"><code class="kr">type</code> <code class="kt">Display</code> <code class="ow">=</code> <code class="kt">MVar</code> <code class="p">(</code><code class="kt">Map</code> <code class="kt">Desktop</code> <code class="p">(</code><code class="kt">Set</code> <code class="kt">Window</code><code class="p">))</code></pre>
<p id="conc-stm_00000011">This would work, but the <code class="literal">MVar</code> is a single point of contention.  For
example, the <a id="id454774" class="indexterm"></a>rendering thread, which needs to look only at the
currently displayed desktop, could be blocked by a window on another
desktop that is moving itself. This structure doesn’t allow as much
concurrency as we would like.</p>
<p id="conc-stm_00000012">To allow operations on separate desktops to proceed without impeding
each other, perhaps we can have a separate <code class="literal">MVar</code> for each <a id="id454799" class="indexterm"></a>desktop:</p>
<pre class="programlisting" data-language="haskell" id="type_display___id2"><code class="kr">type</code> <code class="kt">Display</code> <code class="ow">=</code> <code class="kt">Map</code> <code class="kt">Desktop</code> <code class="p">(</code><code class="kt">MVar</code> <code class="p">(</code><code class="kt">Set</code> <code class="kt">Window</code><code class="p">))</code></pre>
<p id="conc-stm_00000014">Unfortunately, this approach also quickly runs into problems.
Consider an operation to move a window from one desktop to another:</p>
<pre class="programlisting" data-language="haskell" id="movewindow__d_id1"><code class="nf">moveWindow</code> <code class="ow">::</code> <code class="kt">Display</code> <code class="ow">-&gt;</code> <code class="kt">Window</code> <code class="ow">-&gt;</code> <code class="kt">Desktop</code> <code class="ow">-&gt;</code> <code class="kt">Desktop</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">moveWindow</code> <code class="n">disp</code> <code class="n">win</code> <code class="n">a</code> <code class="n">b</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">wa</code> <code class="ow">&lt;-</code> <code class="n">takeMVar</code> <code class="n">ma</code>
  <code class="n">wb</code> <code class="ow">&lt;-</code> <code class="n">takeMVar</code> <code class="n">mb</code>
  <code class="n">putMVar</code> <code class="n">ma</code> <code class="p">(</code><code class="kt">Set</code><code class="o">.</code><code class="n">delete</code> <code class="n">win</code> <code class="n">wa</code><code class="p">)</code>
  <code class="n">putMVar</code> <code class="n">mb</code> <code class="p">(</code><code class="kt">Set</code><code class="o">.</code><code class="n">insert</code> <code class="n">win</code> <code class="n">wb</code><code class="p">)</code>
 <code class="kr">where</code>
  <code class="n">ma</code> <code class="ow">=</code> <code class="n">disp</code> <code class="o">!</code> <code class="n">a</code>
  <code class="n">mb</code> <code class="ow">=</code> <code class="n">disp</code> <code class="o">!</code> <code class="n">b</code></pre>
<p id="conc-stm_00000016">Note that we must take both <code class="literal">MVar</code>s before we can put the results;
otherwise, another thread could potentially observe the display in a
state in which the window we are moving does not exist.  But this
raises a problem: what if there is a concurrent call <a id="id455191" class="indexterm"></a>to <code class="literal">moveWindow</code>
trying to move a window in the opposite direction?  Let’s think
through what would happen:</p>
<pre class="screen" id="conc-stm_00000017">  thread 1: moveWindow d w1 a b
  thread 2: moveWindow d w2 b a</pre>
<p id="conc-stm_00000018">Here’s one possible interleaving:</p>
<div class="itemizedlist" id="conc-stm_00000019"><ul class="itemizedlist">
<li class="listitem">
Thread 1 takes the <code class="literal">MVar</code> for desktop <code class="literal">a</code>.
</li>
<li class="listitem">
Thread 2 takes the <code class="literal">MVar</code> for desktop <code class="literal">b</code>.
</li>
<li class="listitem">
Thread 1 tries to take the <code class="literal">MVar</code> for desktop <code class="literal">b</code> and blocks.
</li>
<li class="listitem">
Thread 2 tries to take the <code class="literal">MVar</code> for desktop <code class="literal">a</code> and blocks.
</li>
</ul></div>
<p id="conc-stm_00000020">Now we have deadlock: both <a id="id455309" class="indexterm"></a><a id="id455314" class="indexterm"></a>threads are blocked on each other, and
neither can make progress. This is an instance of the classic <a class="ulink" href="http://en.wikipedia.org/wiki/Dining_philosophers_problem" target="_top">"Dining Philosophers" problem</a>.</p>
<p id="conc-stm_00000021">One solution is to impose an <a id="id455337" class="indexterm"></a>ordering on the <code class="literal">MVar</code>s and require
that all agents take <code class="literal">MVar</code>s in the correct order and release them
in the opposite order.  That is inconvenient and error-prone, though,
and furthermore we have to extend our ordering to any other state that
we might need to access concurrently.  Large systems written in
languages with locks (e.g., operating systems) are often plagued by
this problem, and managing the complexity requires building an elaborate
infrastructure to detect <a id="id455362" class="indexterm"></a>ordering violations.</p>
<p id="conc-stm_00000022">Sofware transactional memory provides a way to avoid this deadlock problem
without imposing a requirement for ordering on the programmer.  To
solve the problem using STM, we replace <code class="literal">MVar</code> with <code class="literal">TVar</code>:</p>
<pre class="programlisting" data-language="haskell" id="type_display___id3"><code class="kr">type</code> <code class="kt">Display</code> <code class="ow">=</code> <code class="kt">Map</code> <code class="kt">Desktop</code> <code class="p">(</code><code class="kt">TVar</code> <code class="p">(</code><code class="kt">Set</code> <code class="kt">Window</code><code class="p">))</code></pre>
<p id="conc-stm_00000024"><code class="literal">TVar</code> <a id="id455464" class="indexterm"></a><a id="id455470" class="indexterm"></a>stands for “transactional variable”; it is a mutable variable
that can be read or written only within the special monad <code class="literal">STM</code>, using
the operations <code class="literal">readTVar</code> and <code class="literal">writeTVar</code>:</p>
<pre class="programlisting" data-language="haskell" id="readtvar__tva"><code class="nf">readTVar</code>  <code class="ow">::</code> <code class="kt">TVar</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="n">a</code>
<code class="nf">writeTVar</code> <code class="ow">::</code> <code class="kt">TVar</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="nb">()</code></pre>
<p id="conc-stm_00000026">A computation in <a id="id455598" class="indexterm"></a>the <code class="literal">STM</code> monad can be <span class="emphasis"><em>performed</em></span> in the <code class="literal">IO</code> monad,
using the <code class="literal">atomically</code> function:</p>
<pre class="programlisting" data-language="haskell" id="atomically__s"><code class="nf">atomically</code> <code class="ow">::</code> <code class="kt">STM</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">a</code></pre>
<p id="conc-stm_00000028">When an <code class="literal">STM</code> computation is performed like this, it is called a
<span class="emphasis"><em>transaction</em></span> because the whole operation takes place atomically with
respect to the rest of the program.  No other thread can observe an
intermediate state in which only some of the operations of the transaction
have taken place.  The <code class="literal">STM</code> computation passed to
<code class="literal">atomically</code> can be arbitrarily large and can contain any number of
<code class="literal">TVar</code> operations, but as we shall see later there are performance
implications for large transactions.</p>
<p id="conc-stm_00000029">To <a id="id455718" class="indexterm"></a>implement <code class="literal">moveWindow</code> using STM, we first convert all the
operations to their <code class="literal">STM</code> equivalents, and rename the function to
<code class="literal">moveWindowSTM</code> to indicate that it is in the <code class="literal">STM</code> monad:</p>
<p id="conc-stm_00000030" class="caption"><span class="emphasis"><em>windowman.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="movewindowstm__id1"><code class="nf">moveWindowSTM</code> <code class="ow">::</code> <code class="kt">Display</code> <code class="ow">-&gt;</code> <code class="kt">Window</code> <code class="ow">-&gt;</code> <code class="kt">Desktop</code> <code class="ow">-&gt;</code> <code class="kt">Desktop</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="nb">()</code>
<code class="nf">moveWindowSTM</code> <code class="n">disp</code> <code class="n">win</code> <code class="n">a</code> <code class="n">b</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">wa</code> <code class="ow">&lt;-</code> <code class="n">readTVar</code> <code class="n">ma</code>
  <code class="n">wb</code> <code class="ow">&lt;-</code> <code class="n">readTVar</code> <code class="n">mb</code>
  <code class="n">writeTVar</code> <code class="n">ma</code> <code class="p">(</code><code class="kt">Set</code><code class="o">.</code><code class="n">delete</code> <code class="n">win</code> <code class="n">wa</code><code class="p">)</code>
  <code class="n">writeTVar</code> <code class="n">mb</code> <code class="p">(</code><code class="kt">Set</code><code class="o">.</code><code class="n">insert</code> <code class="n">win</code> <code class="n">wb</code><code class="p">)</code>
 <code class="kr">where</code>
  <code class="n">ma</code> <code class="ow">=</code> <code class="n">disp</code> <code class="o">!</code> <code class="n">a</code>
  <code class="n">mb</code> <code class="ow">=</code> <code class="n">disp</code> <code class="o">!</code> <code class="n">b</code></pre>
<p id="conc-stm_00000031">Then, we wrap this in <code class="literal">atomically</code> to make the <code class="literal">IO</code>-monad version
<code class="literal">moveWindow</code>:</p>
<pre class="programlisting" data-language="haskell" id="movewindow__d_id2"><code class="nf">moveWindow</code> <code class="ow">::</code> <code class="kt">Display</code> <code class="ow">-&gt;</code> <code class="kt">Window</code> <code class="ow">-&gt;</code> <code class="kt">Desktop</code> <code class="ow">-&gt;</code> <code class="kt">Desktop</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">moveWindow</code> <code class="n">disp</code> <code class="n">win</code> <code class="n">a</code> <code class="n">b</code> <code class="ow">=</code> <code class="n">atomically</code> <code class="o">$</code> <code class="n">moveWindowSTM</code> <code class="n">disp</code> <code class="n">win</code> <code class="n">a</code> <code class="n">b</code></pre>
<p id="conc-stm_00000033">The code <a id="id456240" class="indexterm"></a>for <code class="literal">moveWindowSTM</code> is almost identical to the <code class="literal">MVar</code>
version, but the behavior is quite different: the sequence of
operations inside <code class="literal">atomically</code> happens indivisibly as far as the rest
of the program is concerned, so the problem we encountered earlier that
required taking <code class="literal">MVar</code>s in the correct order does not occur.  What’s
more, there is no requirement that we read both <code class="literal">TVar</code>s before we
write them; this would be fine, too:</p>
<pre class="programlisting" data-language="haskell" id="movewindowstm__id2"><code class="nf">moveWindowSTM</code> <code class="ow">::</code> <code class="kt">Display</code> <code class="ow">-&gt;</code> <code class="kt">Window</code> <code class="ow">-&gt;</code> <code class="kt">Desktop</code> <code class="ow">-&gt;</code> <code class="kt">Desktop</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="nb">()</code>
<code class="nf">moveWindowSTM</code> <code class="n">disp</code> <code class="n">win</code> <code class="n">a</code> <code class="n">b</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">wa</code> <code class="ow">&lt;-</code> <code class="n">readTVar</code> <code class="n">ma</code>
  <code class="n">writeTVar</code> <code class="n">ma</code> <code class="p">(</code><code class="kt">Set</code><code class="o">.</code><code class="n">delete</code> <code class="n">win</code> <code class="n">wa</code><code class="p">)</code>
  <code class="n">wb</code> <code class="ow">&lt;-</code> <code class="n">readTVar</code> <code class="n">mb</code>
  <code class="n">writeTVar</code> <code class="n">mb</code> <code class="p">(</code><code class="kt">Set</code><code class="o">.</code><code class="n">insert</code> <code class="n">win</code> <code class="n">wb</code><code class="p">)</code>
 <code class="kr">where</code>
  <code class="n">ma</code> <code class="ow">=</code> <code class="n">disp</code> <code class="o">!</code> <code class="n">a</code>
  <code class="n">mb</code> <code class="ow">=</code> <code class="n">disp</code> <code class="o">!</code> <code class="n">b</code></pre>
<p id="conc-stm_00000035">So STM is far less error-prone here.  The approach also
scales to any number of <code class="literal">TVar</code>s, so we could easily write an operation
that moves the windows from all other desktops to the current desktop,
for example.</p>
<p id="conc-stm_00000036">Now suppose that we want to swap two windows, moving window <span class="emphasis"><em>W</em></span> from
desktop <span class="emphasis"><em>A</em></span> to <span class="emphasis"><em>B</em></span>, and simultaneously <span class="emphasis"><em>V</em></span> from <span class="emphasis"><em>B</em></span> to <span class="emphasis"><em>A</em></span>.  With the <code class="literal">MVar</code>
representation, we would have to write a special purpose operation to do this, because it has to take the <code class="literal">MVar</code>s for <span class="emphasis"><em>A</em></span> and <span class="emphasis"><em>B</em></span> (in the
right order) and then put both <code class="literal">MVar</code>s back with the new contents.
With STM, however, we can express this much more neatly by simply
making two calls to <code class="literal">moveWindowSTM</code>:</p>
<p id="conc-stm_00000037" class="caption"><span class="emphasis"><em>windowman.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="swapwindows__"><code class="nf">swapWindows</code> <code class="ow">::</code> <code class="kt">Display</code>
            <code class="ow">-&gt;</code> <code class="kt">Window</code> <code class="ow">-&gt;</code> <code class="kt">Desktop</code>
            <code class="ow">-&gt;</code> <code class="kt">Window</code> <code class="ow">-&gt;</code> <code class="kt">Desktop</code>
            <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">swapWindows</code> <code class="n">disp</code> <code class="n">w</code> <code class="n">a</code> <code class="n">v</code> <code class="n">b</code> <code class="ow">=</code> <code class="n">atomically</code> <code class="o">$</code> <code class="kr">do</code>
  <code class="n">moveWindowSTM</code> <code class="n">disp</code> <code class="n">w</code> <code class="n">a</code> <code class="n">b</code>
  <code class="n">moveWindowSTM</code> <code class="n">disp</code> <code class="n">v</code> <code class="n">b</code> <code class="n">a</code></pre>
<p id="conc-stm_00000038">This demonstrates <a id="id456863" class="indexterm"></a>the <span class="emphasis"><em>composability</em></span> of STM
operations: any operation of type <code class="literal">STM a</code> can be composed with others
to form a larger atomic transaction.  For this reason, <code class="literal">STM</code>
operations are usually provided without the <code class="literal">atomically</code> wrapper so
that clients can compose them as necessary before finally wrapping
the entire operation in <code class="literal">atomically</code>.</p>
<div class="note" id="conc-stm_00000039">
<p id="conc-stm_00000040"><a id="id456908" class="indexterm"></a><a id="id456914" class="indexterm"></a>Why is <code class="literal">STM</code> a different monad from <code class="literal">IO</code>?  The STM implementation
relies on being able to <span class="emphasis"><em>roll back</em></span> the effects of a transaction in
the event of a conflict with another transaction (and for other
reasons, as we shall see shortly).  A transaction can be rolled
back only if we can track exactly what effects it has, and this would not
be possible if arbitrary I/O were allowed inside a transaction—we
might have performed some I/O that cannot be undone, like making a
noise or launching some missiles.  For this reason, the <code class="literal">STM</code> monad
permits only side effects on <code class="literal">TVar</code>s, and the STM implementation
tracks these effects to ensure the correct transaction
semantics.  We will discuss the implementation of STM and its
performance implications in more detail in <a class="xref" href="ch10.html#sec_stm-cost" title="Performance">“Performance”</a>.</p>
<p id="conc-stm_00000041">This is an example of using the Haskell type system to enforce a
safety invariant.  We are guaranteed that every transaction is
actually a transaction, because the type system prevents arbitrary
side-effects from being performed in the <code class="literal">STM</code> monad.</p>
</div>
<p id="conc-stm_00000042">So far, we covered the basic facilities of STM and showed that STM
can be used to scale atomicity in a composable way.  STM improves
the expressibility and robustness of concurrent programs. The benefits of STM in Haskell go
further, however. In the following sections, we show how STM can be
used to make blocking abstractions compose, and how STM can be used to
manage complexity in the presence of failure and interruption.<a id="id456987" class="indexterm"></a></p>
</div>
<div class="sect1" data-original-filename="ch10_conc-stm.asciidoc" id="sec_stm-blockng">
<div class="titlepage"><div><div><h2 class="title">Blocking</h2></div></div></div>
<p id="conc-stm_00000043"><a id="ix_ch10_conc-stm-txt4" class="indexterm"></a><a id="ix_ch10_conc-stm-txt5" class="indexterm"></a><a id="ix_ch10_conc-stm-txt6" class="indexterm"></a><a id="ix_ch10_conc-stm-txt7" class="indexterm"></a>An important part of concurrent programming is dealing with
<span class="emphasis"><em>blocking</em></span> when we need to wait for some condition to be true,
or to acquire a particular resource.  STM provides an ingenious way to
do this with a single operation:</p>
<pre class="programlisting" data-language="haskell" id="retry__stm_a"><code class="nf">retry</code> <code class="ow">::</code> <code class="kt">STM</code> <code class="n">a</code></pre>
<p id="conc-stm_00000045">The meaning <a id="id457108" class="indexterm"></a>of <code class="literal">retry</code> is simply "abandon the current transaction and
run it again."  An example should help to clarify how <code class="literal">retry</code> works. Let’s consider how to implement <code class="literal">MVar</code> using STM because <code class="literal">takeMVar</code>
and <code class="literal">putMVar</code> need to be able to block when the <code class="literal">MVar</code> is empty or
full, respectively.</p>
<p id="conc-stm_00000046"><a id="ix_TMVardatatype" class="indexterm"></a>First the data type: an <code class="literal">MVar</code> is always in one of two states; either it is
full and contains a value, or it is empty. We model this with a
<code class="literal">TVar</code> containing <code class="literal">Maybe a</code>:<a href="#ftn.id457192" class="footnote"><sup class="footnote" id="id457192">[39]</sup></a></p>
<p id="conc-stm_00000047" class="caption"><span class="emphasis"><em>tmvar.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="newtype_tmvar_a"><code class="kr">newtype</code> <code class="kt">TMVar</code> <code class="n">a</code> <code class="ow">=</code> <code class="kt">TMVar</code> <code class="p">(</code><code class="kt">TVar</code> <code class="p">(</code><code class="kt">Maybe</code> <code class="n">a</code><code class="p">))</code></pre>
<p id="conc-stm_00000048">To make an empty <code class="literal">TMVar</code>, we simply need a <code class="literal">TVar</code> containing <code class="literal">Nothing</code>:</p>
<pre class="programlisting" data-language="haskell" id="newemptytmvar_"><code class="nf">newEmptyTMVar</code> <code class="ow">::</code> <code class="kt">STM</code> <code class="p">(</code><code class="kt">TMVar</code> <code class="n">a</code><code class="p">)</code>
<code class="nf">newEmptyTMVar</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">t</code> <code class="ow">&lt;-</code> <code class="n">newTVar</code> <code class="kt">Nothing</code>
  <code class="n">return</code> <code class="p">(</code><code class="kt">TMVar</code> <code class="n">t</code><code class="p">)</code></pre>
<p id="conc-stm_00000050">Now to <a id="id457433" class="indexterm"></a>code <code class="literal">takeTMVar</code>, which blocks if the desired variable is empty
and returns the content once the variable is set:</p>
<pre class="programlisting" data-language="haskell" id="taketmvar__tm"><code class="nf">takeTMVar</code> <code class="ow">::</code> <code class="kt">TMVar</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="n">a</code>
<code class="nf">takeTMVar</code> <code class="p">(</code><code class="kt">TMVar</code> <code class="n">t</code><code class="p">)</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">m</code> <code class="ow">&lt;-</code> <code class="n">readTVar</code> <code class="n">t</code>                       <code class="c1">-- </code><span id="CO35-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
  <code class="kr">case</code> <code class="n">m</code> <code class="kr">of</code>
    <code class="kt">Nothing</code> <code class="ow">-&gt;</code> <code class="n">retry</code>                    <code class="c1">-- </code><span id="CO35-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>
    <code class="kt">Just</code> <code class="n">a</code>  <code class="ow">-&gt;</code> <code class="kr">do</code>
      <code class="n">writeTVar</code> <code class="n">t</code> <code class="kt">Nothing</code>               <code class="c1">-- </code><span id="CO35-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span>
      <code class="n">return</code> <code class="n">a</code></pre>
<div class="calloutlist" id="conc-stm_00000052"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO35-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="read_the_curren_id1">
Read the current contents of the <code class="literal">TVar</code>, which we inspect with a <code class="literal">case</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO35-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="if_the_tvar_con_id1">
If the <code class="literal">TVar</code> contains <code class="literal">Nothing</code>, then the <code class="literal">TMVar</code> is empty, so
we need to block. The <code class="literal">retry</code> operation says, "Run the current transaction again," which will have the desired effect: we keep
rerunning the transaction until the <code class="literal">TVar</code> no longer contains
<code class="literal">Nothing</code> and the other <code class="literal">case</code> branch is taken. Of course, we don’t really want to blindly rerun the transaction over
and over again, making our CPU hot for no good reason.  The STM
implementation knows that there is no point rerunning the transaction
unless something different is likely to happen, and that can be true only if one or more of the <code class="literal">TVar</code>s that were read by the current
transaction have changed. In fact, what happens is that the current
thread is <span class="emphasis"><em>blocked</em></span> until one of the <code class="literal">TVar</code>s that it is reading is written
to, at which point the thread is unblocked again and the transaction
is rerun.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO35-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="if_the_tvar_con_id2">
If the <code class="literal">TVar</code> contains <code class="literal">Just a</code>, we empty the <code class="literal">TMVar</code> by
writing <code class="literal">Nothing</code> into it and then return the <code class="literal">a</code>.
</p></td>
</tr>
</table></div>
<p id="conc-stm_00000055">The implementation <a id="id457817" class="indexterm"></a>of <code class="literal">putMVar</code> is straightforward:</p>
<pre class="programlisting" data-language="haskell" id="puttmvar__tmv"><code class="nf">putTMVar</code> <code class="ow">::</code> <code class="kt">TMVar</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="nb">()</code>
<code class="nf">putTMVar</code> <code class="p">(</code><code class="kt">TMVar</code> <code class="n">t</code><code class="p">)</code> <code class="n">a</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">m</code> <code class="ow">&lt;-</code> <code class="n">readTVar</code> <code class="n">t</code>
  <code class="kr">case</code> <code class="n">m</code> <code class="kr">of</code>
    <code class="kt">Nothing</code> <code class="ow">-&gt;</code> <code class="kr">do</code>
      <code class="n">writeTVar</code> <code class="n">t</code> <code class="p">(</code><code class="kt">Just</code> <code class="n">a</code><code class="p">)</code>
      <code class="n">return</code> <code class="nb">()</code>
    <code class="kt">Just</code> <code class="kr">_</code>  <code class="ow">-&gt;</code> <code class="n">retry</code></pre>
<p id="conc-stm_00000058">So now that we have a replacement <a id="id458055" class="indexterm"></a>for <code class="literal">MVar</code> built using STM, what can we do with it?  Well, <code class="literal">STM</code> operations are composable, so we can
perform operations on multiple <code class="literal">TMVar</code>s at the same time:</p>
<pre class="programlisting" data-language="haskell" id="atomically__do">  <code class="n">atomically</code> <code class="o">$</code> <code class="kr">do</code>
    <code class="n">a</code> <code class="ow">&lt;-</code> <code class="n">takeTMVar</code> <code class="n">ta</code>
    <code class="n">b</code> <code class="ow">&lt;-</code> <code class="n">takeTMVar</code> <code class="n">tb</code>
    <code class="n">return</code> <code class="p">(</code><code class="n">a</code><code class="p">,</code><code class="n">b</code><code class="p">)</code></pre>
<p id="conc-stm_00000060">This STM transaction succeeds when and only when both <code class="literal">TMVar</code>s are full;
otherwise it is blocked.  This explains why <code class="literal">retry</code> must abandon the
whole transaction: if the first <code class="literal">takeTMVar</code> succeeds but the second
one retries, we do not want the effect of the first <code class="literal">takeTMVar</code> to
take place.</p>
<p id="conc-stm_00000061">This example is difficult to program with <code class="literal">MVar</code> because taking a
single <code class="literal">MVar</code> is a side effect that is visible to the rest of the
program, and hence cannot be easily undone if the other <code class="literal">MVar</code> is
empty.  One way to implement it is with a <span class="emphasis"><em>third</em></span> <code class="literal">MVar</code> acting as a
lock to control access to the other two, but then of course all other
clients have to be aware of the locking protocol.<a id="id458246" class="indexterm"></a></p>
</div>
<div class="sect1" data-original-filename="ch10_conc-stm.asciidoc" id="sec_stm-block-until-changes">
<div class="titlepage"><div><div><h2 class="title">Blocking Until Something Changes</h2></div></div></div>
<p id="conc-stm_00000063">The <code class="literal">retry</code> <a id="id458278" class="indexterm"></a>operation allows us to block on arbitrary conditions.  As
a concrete example, we can use <code class="literal">retry</code> to implement the rendering
thread in our window manager example.  The behavior we want is this:</p>
<div class="itemizedlist" id="conc-stm_00000064"><ul class="itemizedlist">
<li class="listitem">
One desktop is designated as having the <span class="emphasis"><em>focus</em></span>.  The
  focused desktop is the one displayed by the rendering thread.
</li>
<li class="listitem">
The user may request that the focus be changed at any time.
</li>
<li class="listitem">
Windows may move around and appear or disappear of their own
  accord, and the rendering thread must update its display
  accordingly.
</li>
</ul></div>
<p id="conc-stm_00000066">We are supplied with a named <a id="id458334" class="indexterm"></a>function <code class="literal">render</code> which handles the business of
rendering windows on the display.  It should be called whenever the
window layout changes:<a href="#ftn.id458347" class="footnote"><sup class="footnote" id="id458347">[40]</sup></a></p>
<pre class="programlisting" data-language="haskell" id="render__set_w"><code class="nf">render</code> <code class="ow">::</code> <code class="kt">Set</code> <code class="kt">Window</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code></pre>
<p id="conc-stm_00000068">The currently focused desktop is a piece of state that is shared by
the rendering thread and some other thread that handles user input.
Therefore, we represent that by a <code class="literal">TVar</code>:</p>
<pre class="programlisting" data-language="haskell" id="type_userfocus_"><code class="kr">type</code> <code class="kt">UserFocus</code> <code class="ow">=</code> <code class="kt">TVar</code> <code class="kt">Desktop</code></pre>
<p id="conc-stm_00000070">Next, we define an auxiliary <a id="id458458" class="indexterm"></a>function <code class="literal">getWindows</code> that takes the
<code class="literal">Display</code> and the <code class="literal">UserFocus</code> and returns the set of windows to render
in the <code class="literal">STM</code> monad.  The implementation is straightforward: read the
current focus and look up the contents of the appropriate desktop in
the <code class="literal">Display</code>:</p>
<p id="conc-stm_00000071" class="caption"><span class="emphasis"><em>windowman.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="getwindows__d"><code class="nf">getWindows</code> <code class="ow">::</code> <code class="kt">Display</code> <code class="ow">-&gt;</code> <code class="kt">UserFocus</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="p">(</code><code class="kt">Set</code> <code class="kt">Window</code><code class="p">)</code>
<code class="nf">getWindows</code> <code class="n">disp</code> <code class="n">focus</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">desktop</code> <code class="ow">&lt;-</code> <code class="n">readTVar</code> <code class="n">focus</code>
  <code class="n">readTVar</code> <code class="p">(</code><code class="n">disp</code> <code class="o">!</code> <code class="n">desktop</code><code class="p">)</code></pre>
<p id="conc-stm_00000072">Finally, we can implement the <a id="id458661" class="indexterm"></a>rendering thread.  The general plan is
to repeatedly read the current state with <code class="literal">getWindows</code> and call
<code class="literal">render</code> to render it, but use <code class="literal">retry</code> to avoid calling <code class="literal">render</code> when
nothing has changed.  Here is the code:</p>
<pre class="programlisting" data-language="haskell" id="renderthread_"><code class="nf">renderThread</code> <code class="ow">::</code> <code class="kt">Display</code> <code class="ow">-&gt;</code> <code class="kt">UserFocus</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">renderThread</code> <code class="n">disp</code> <code class="n">focus</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">wins</code> <code class="ow">&lt;-</code> <code class="n">atomically</code> <code class="o">$</code> <code class="n">getWindows</code> <code class="n">disp</code> <code class="n">focus</code>    <code class="c1">-- </code><span id="CO36-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
  <code class="n">loop</code> <code class="n">wins</code>                                     <code class="c1">-- </code><span id="CO36-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>
 <code class="kr">where</code>
  <code class="n">loop</code> <code class="n">wins</code> <code class="ow">=</code> <code class="kr">do</code>                                <code class="c1">-- </code><span id="CO36-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span>
    <code class="n">render</code> <code class="n">wins</code>                                 <code class="c1">-- </code><span id="CO36-4"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span>
    <code class="n">next</code> <code class="ow">&lt;-</code> <code class="n">atomically</code> <code class="o">$</code> <code class="kr">do</code>
               <code class="n">wins'</code> <code class="ow">&lt;-</code> <code class="n">getWindows</code> <code class="n">disp</code> <code class="n">focus</code>   <code class="c1">-- </code><span id="CO36-5"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/5.png" alt="5"></span>
               <code class="kr">if</code> <code class="p">(</code><code class="n">wins</code> <code class="o">==</code> <code class="n">wins'</code><code class="p">)</code>               <code class="c1">-- </code><span id="CO36-6"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/6.png" alt="6"></span>
                   <code class="kr">then</code> <code class="n">retry</code>                   <code class="c1">-- </code><span id="CO36-7"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/7.png" alt="7"></span>
                   <code class="kr">else</code> <code class="n">return</code> <code class="n">wins'</code>            <code class="c1">-- </code><span id="CO36-8"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/8.png" alt="8"></span>
    <code class="n">loop</code> <code class="n">next</code></pre>
<div class="calloutlist" id="conc-stm_00000074"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO36-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="first_we_read_">
First, we read the current set of windows to display.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO36-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="we_use_this_as_">
We use this as the initial value for the <code class="literal">loop</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO36-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_loop_takes_">
The loop takes the current set of windows as an argument, renders the windows, and then blocks until something changes that
requires re-rendering.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO36-4"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="each_iteration__id1">
Each iteration calls <code class="literal">render</code> to display the
current state and then enters a transaction to read the next
state.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO36-5"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/5.png" alt="5"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="inside_the_tran">
Inside the transaction, we read the current state.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO36-6"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/6.png" alt="6"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="we_compare_it_t">
We compare it to the state we just rendered.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO36-7"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/7.png" alt="7"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="if_the_states_a_id1">
If the states are the same, then there is no need to do anything, so we call <code class="literal">retry</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO36-8"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/8.png" alt="8"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="if_the_states_a_id2">
If the states are different, then we return the new state, and the loop
iterates with the new state.
</p></td>
</tr>
</table></div>
<p id="conc-stm_00000082">The effect of the <code class="literal">retry</code> is precisely what we need: it waits until
the value read by <code class="literal">getWindows</code> could possibly be different, because
another thread has successfully completed a transaction that writes to
one of the <code class="literal">TVar</code>s that is read by <code class="literal">getWindows</code>.  That encompasses
both changes to the <code class="literal">focus</code> (because the user switched to a different
desktop), and changes to the contents of the current desktop (because
a window moved, appeared, or disappeared).  Furthermore, changes to
other desktops can take place without the rendering thread being woken
up.</p>
<p id="conc-stm_00000083">If it weren’t for STM’s <code class="literal">retry</code> operation, we’d have to implement
this complex logic ourselves, including implementing the signals
between <a id="id459236" class="indexterm"></a><a id="id459242" class="indexterm"></a>threads that modify the state and the rendering thread.  This
is anti-modular, because operations that modify the state have to know
about the observers that need to act on changes.  Furthermore, it
gives rise to a common source of concurrency bugs: <span class="emphasis"><em>lost wakeups</em></span>.  If we forgot to signal the rendering thread, the
display wouldn’t be updated.  In this case, the effects are somewhat
benign. In a more complex scenario, lost wakeups often lead to
deadlocks: the woken thread was supposed to complete an
operation on which other threads are waiting.</p>
</div>
<div class="sect1" data-original-filename="ch10_conc-stm.asciidoc" id="sec_stm-merging">
<div class="titlepage"><div><div><h2 class="title">Merging with STM</h2></div></div></div>
<p id="conc-stm_00000084"><a id="ix_ch10_conc-stm-txt10" class="indexterm"></a><a id="ix_ch10_conc-stm-txt10a" class="indexterm"></a><a id="ix_ch10_conc-stm-txt11" class="indexterm"></a>Recall that in <a class="xref" href="ch08.html#sec_merging" title="Merging">“Merging”</a> we considered the problem of waiting for any
event from a set of possible events.  Typically this requires the
events to be merged into a <a id="id459329" class="indexterm"></a><a id="id459337" class="indexterm"></a>single <code class="literal">MVar</code> or <code class="literal">Chan</code> so that we can
wait for the next event using <code class="literal">takeMVar</code> or <code class="literal">readChan</code>.  In turn, this
means that the source of each event needs to know which <code class="literal">MVar</code>(s) or
<code class="literal">Chan</code>(s) to send it to, rather than each event being a completely
independent entity.</p>
<p id="conc-stm_00000085">The more general problem of taking either of two <code class="literal">MVar</code>s requires
creating two new threads to take each <code class="literal">MVar</code> and put the result into a
third <code class="literal">MVar</code>.  However, even this doesn’t really solve the problem: if
we wanted to take <span class="emphasis"><em>at most</em></span> one of two <code class="literal">MVar</code>s, then (as far as I am aware) there is no way to do it; you just have to construct
your program in a different way so that it doesn’t need to do this.</p>
<p id="conc-stm_00000086">STM provides a neat solution to both of these problems in the form of
an operation that we have not yet introduced:</p>
<pre class="programlisting" data-language="haskell" id="orelse__stm_a"><code class="nf">orElse</code> <code class="ow">::</code> <code class="kt">STM</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="n">a</code></pre>
<p id="conc-stm_00000088">The <a id="id459497" class="indexterm"></a>operation <code class="literal">orElse a b</code> has the following behavior:</p>
<div class="itemizedlist" id="conc-stm_00000089"><ul class="itemizedlist">
<li class="listitem">
First, <code class="literal">a</code> is executed.  If <code class="literal">a</code> returns a result, then the <code class="literal">orElse</code> call
  returns it and ends.
</li>
<li class="listitem">
If <code class="literal">a</code> calls <code class="literal">retry</code> instead, <span class="emphasis"><em><code class="literal">a</code></em></span>'s effects are
  discarded_ and <code class="literal">b</code> is executed instead.
</li>
</ul></div>
<p id="conc-stm_00000091"><a id="id459577" class="indexterm"></a>The <code class="literal">orElse</code> operator lets us combine two blocking transactions such
that <span class="emphasis"><em>one</em></span> is performed but not both.  This is exactly what we
need for composing several event sources, or for taking at most one of
two <code class="literal">MVar</code>s (actually <code class="literal">TMVar</code>s, of course).  The latter is coded
as follows:</p>
<p id="conc-stm_00000092" class="caption"><span class="emphasis"><em>code/tmvar.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="takeeithertmvar"><code class="nf">takeEitherTMVar</code> <code class="ow">::</code> <code class="kt">TMVar</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">TMVar</code> <code class="n">b</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="p">(</code><code class="kt">Either</code> <code class="n">a</code> <code class="n">b</code><code class="p">)</code>
<code class="nf">takeEitherTMVar</code> <code class="n">ma</code> <code class="n">mb</code> <code class="ow">=</code>
  <code class="n">fmap</code> <code class="kt">Left</code> <code class="p">(</code><code class="n">takeTMVar</code> <code class="n">ma</code><code class="p">)</code>
    <code class="p">`</code><code class="n">orElse</code><code class="p">`</code>
  <code class="n">fmap</code> <code class="kt">Right</code> <code class="p">(</code><code class="n">takeTMVar</code> <code class="n">mb</code><code class="p">)</code></pre>
<p id="conc-stm_00000093">There are two calls to <code class="literal">takeTMVar</code>, with their results wrapped in
<code class="literal">Left</code> and <code class="literal">Right</code>, respectively, composed together with <code class="literal">orElse</code>.</p>
<p id="conc-stm_00000094">One thing to note is that <code class="literal">orElse</code> is left-biased: if both <code class="literal">TMVar</code>s
are non-empty, <code class="literal">takeEitherTMVar</code> will always return the contents
of the first one.  Whether this is problematic depends on the
application. Be aware that the left-biased nature of <code class="literal">orElse</code> can have
implications for fairness in some situations.</p>
<p id="conc-stm_00000095">STM provides two complementary ways to compose blocking
operations together: the ordinary monadic bind gives us "and", and
<code class="literal">orElse</code> gives us "or".<a id="id459875" class="indexterm"></a><a id="id459885" class="indexterm"></a><a id="id459895" class="indexterm"></a></p>
</div>
<div class="sect1" data-original-filename="ch10_conc-stm.asciidoc" id="sec_stm-async">
<div class="titlepage"><div><div><h2 class="title">Async Revisited</h2></div></div></div>
<p id="conc-stm_00000096"><a id="ix_ch10_conc-stm-txt12" class="indexterm"></a>Recall in <a class="xref" href="ch08.html#sec_merging" title="Merging">“Merging”</a> that we <a id="id459941" class="indexterm"></a>defined <code class="literal">waitEither</code> for the <code class="literal">Async</code>
abstraction by forking two extra threads.  STM’s <code class="literal">orElse</code> now allows
us to define <code class="literal">waitEither</code> much more efficiently.  Furthermore, the
extra flexibility of STM lets us compose <code class="literal">Async</code>s together in
more interesting ways.  But first, we need to rewrite the <code class="literal">Async</code>
implementation in terms of STM, rather than <code class="literal">MVar</code>.  The translation
is straightforward: we just replace <code class="literal">MVar</code> with <code class="literal">TMVar</code>.</p>
<pre class="programlisting" data-language="haskell" id="data_async_a___id4"><code class="kr">data</code> <code class="kt">Async</code> <code class="n">a</code> <code class="ow">=</code> <code class="kt">Async</code> <code class="kt">ThreadId</code> <code class="p">(</code><code class="kt">TMVar</code> <code class="p">(</code><code class="kt">Either</code> <code class="kt">SomeException</code> <code class="n">a</code><code class="p">))</code></pre>
<p id="conc-stm_00000098">The <code class="literal">async</code> function looks familiar, with only an additional
<code class="literal">atomically</code> to wrap the call to <code class="literal">putTMVar</code> in the child thread:</p>
<pre class="programlisting" data-language="haskell" id="async__io_a__id5"><code class="nf">async</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">Async</code> <code class="n">a</code><code class="p">)</code>
<code class="nf">async</code> <code class="n">action</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">var</code> <code class="ow">&lt;-</code> <code class="n">newEmptyTMVarIO</code>
  <code class="n">t</code> <code class="ow">&lt;-</code> <code class="n">forkFinally</code> <code class="n">action</code> <code class="p">(</code><code class="n">atomically</code> <code class="o">.</code> <code class="n">putTMVar</code> <code class="n">var</code><code class="p">)</code>
  <code class="n">return</code> <code class="p">(</code><code class="kt">Async</code> <code class="n">t</code> <code class="n">var</code><code class="p">)</code></pre>
<p id="conc-stm_00000100">Here we <a id="id460300" class="indexterm"></a>used <code class="literal">newEmptyTMVarIO</code>, which is a convenient version of
<code class="literal">newEmptyTMVar</code> in the <code class="literal">IO</code> monad.</p>
<p id="conc-stm_00000101"><a id="id460329" class="indexterm"></a><a id="id460335" class="indexterm"></a>The <code class="literal">waitCatchSTM</code> function is like <code class="literal">waitCatch</code>, but in the <code class="literal">STM</code>
monad:</p>
<pre class="programlisting" data-language="haskell" id="waitcatchstm__id1"><code class="nf">waitCatchSTM</code> <code class="ow">::</code> <code class="kt">Async</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="p">(</code><code class="kt">Either</code> <code class="kt">SomeException</code> <code class="n">a</code><code class="p">)</code>
<code class="nf">waitCatchSTM</code> <code class="p">(</code><code class="kt">Async</code> <code class="kr">_</code> <code class="n">var</code><code class="p">)</code> <code class="ow">=</code> <code class="n">readTMVar</code> <code class="n">var</code></pre>
<p id="conc-stm_00000103">And we can define <code class="literal">waitSTM</code>, the version of <code class="literal">waitCatchSTM</code> that
re-throws an exception result, in terms of <code class="literal">waitCatchSTM</code>:</p>
<pre class="programlisting" data-language="haskell" id="waitstm__asyn"><code class="nf">waitSTM</code> <code class="ow">::</code> <code class="kt">Async</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="n">a</code>
<code class="nf">waitSTM</code> <code class="n">a</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">r</code> <code class="ow">&lt;-</code> <code class="n">waitCatchSTM</code> <code class="n">a</code>
  <code class="kr">case</code> <code class="n">r</code> <code class="kr">of</code>
    <code class="kt">Left</code> <code class="n">e</code>  <code class="ow">-&gt;</code> <code class="n">throwSTM</code> <code class="n">e</code>
    <code class="kt">Right</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">return</code> <code class="n">a</code></pre>
<p id="conc-stm_00000105">Now we can <a id="id460668" class="indexterm"></a>define <code class="literal">waitEither</code> by composing two calls to <code class="literal">waitSTM</code>
using <code class="literal">orElse</code>:</p>
<pre class="programlisting" data-language="haskell" id="waiteither__a_id3"><code class="nf">waitEither</code> <code class="ow">::</code> <code class="kt">Async</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Async</code> <code class="n">b</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">Either</code> <code class="n">a</code> <code class="n">b</code><code class="p">)</code>
<code class="nf">waitEither</code> <code class="n">a</code> <code class="n">b</code> <code class="ow">=</code> <code class="n">atomically</code> <code class="o">$</code>
  <code class="n">fmap</code> <code class="kt">Left</code> <code class="p">(</code><code class="n">waitSTM</code> <code class="n">a</code><code class="p">)</code>
    <code class="p">`</code><code class="n">orElse</code><code class="p">`</code>
  <code class="n">fmap</code> <code class="kt">Right</code> <code class="p">(</code><code class="n">waitSTM</code> <code class="n">b</code><code class="p">)</code></pre>
<p id="conc-stm_00000107">More generally, we can wait for any number of <code class="literal">Async</code>s
simultaneously.  The <a id="id460899" class="indexterm"></a>function <code class="literal">waitAny</code> does this by first mapping
<code class="literal">waitSTM</code> over a list of <code class="literal">Async</code>s and then composing the calls
together by folding them with <code class="literal">orElse</code>:</p>
<pre class="programlisting" data-language="haskell" id="waitany__asy_id2"><code class="nf">waitAny</code> <code class="ow">::</code> <code class="p">[</code><code class="kt">Async</code> <code class="n">a</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">a</code>
<code class="nf">waitAny</code> <code class="n">asyncs</code> <code class="ow">=</code>
  <code class="n">atomically</code> <code class="o">$</code> <code class="n">foldr</code> <code class="n">orElse</code> <code class="n">retry</code> <code class="o">$</code> <code class="n">map</code> <code class="n">waitSTM</code> <code class="n">asyncs</code></pre>
<p id="conc-stm_00000109">In <a class="xref" href="ch08.html#sec_merging" title="Merging">“Merging”</a> (<span class="emphasis"><em>geturls6.hs</em></span>), we downloaded several URLs simultaneously
and reported the first one to finish by using a version of <code class="literal">waitAny</code>
that forked a new thread for each <code class="literal">Async</code> to wait for.  Using the
above definition of <code class="literal">waitAny</code> with the STM version of <code class="literal">Async</code>, we can
now solve the same problem without forking a new thread per
<code class="literal">Async</code>:</p>
<p id="conc-stm_00000110" class="caption"><span class="emphasis"><em>geturlsfirst.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="main__io__m_id6"><code class="nf">main</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">main</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="kr">let</code>
    <code class="n">download</code> <code class="n">url</code> <code class="ow">=</code> <code class="kr">do</code>
       <code class="n">r</code> <code class="ow">&lt;-</code> <code class="n">getURL</code> <code class="n">url</code>
       <code class="n">return</code> <code class="p">(</code><code class="n">url</code><code class="p">,</code> <code class="n">r</code><code class="p">)</code>

  <code class="n">as</code> <code class="ow">&lt;-</code> <code class="n">mapM</code> <code class="p">(</code><code class="n">async</code> <code class="o">.</code> <code class="n">download</code><code class="p">)</code> <code class="n">sites</code>

  <code class="p">(</code><code class="n">url</code><code class="p">,</code> <code class="n">r</code><code class="p">)</code> <code class="ow">&lt;-</code> <code class="n">waitAny</code> <code class="n">as</code>
  <code class="n">printf</code> <code class="s">"%s was first (%d bytes)</code><code class="se">\n</code><code class="s">"</code> <code class="n">url</code> <code class="p">(</code><code class="kt">B</code><code class="o">.</code><code class="n">length</code> <code class="n">r</code><code class="p">)</code>
  <code class="n">mapM_</code> <code class="n">wait</code> <code class="n">as</code></pre>
<p id="conc-stm_00000111">The program works as before, creating an <code class="literal">Async</code> to download each URL
in the list.  Then it calls <code class="literal">waitAny</code> to get the first result, reports
it, and finally waits for the rest to complete.<a id="id461410" class="indexterm"></a></p>
</div>
<div class="sect1" data-original-filename="ch10_conc-stm.asciidoc" id="sec_tchan">
<div class="titlepage"><div><div><h2 class="title">Implementing Channels with STM</h2></div></div></div>
<p id="conc-stm_00000112"><a id="ix_ch10_conc-stm-txt13" class="indexterm"></a><a id="ix_ch10_conc-stm-txt14" class="indexterm"></a>In this section, we’ll implement the <code class="literal">Chan</code> type from
<a class="xref" href="ch07.html#sec_channels" title="MVar as a Building Block: Unbounded Channels">“MVar as a Building Block: Unbounded Channels”</a> using STM.  As we’ll see, using STM to implement
<code class="literal">Chan</code> is rather less tricky than using <code class="literal">MVar</code>s, and furthermore we
are able to add complex operations that were difficult or
impossible using <code class="literal">MVar</code>s.</p>
<p id="conc-stm_00000113">The STM version of <code class="literal">Chan</code> is <a id="id461507" class="indexterm"></a>called <code class="literal">TChan</code>, and the interface we wish to implement is as follows:<a href="#ftn.id461523" class="footnote"><sup class="footnote" id="id461523">[41]</sup></a></p>
<pre class="programlisting" data-language="haskell" id="data_tchan_a_ne"><code class="kr">data</code> <code class="kt">TChan</code> <code class="n">a</code>

<code class="nf">newTChan</code>   <code class="ow">::</code> <code class="kt">STM</code> <code class="p">(</code><code class="kt">TChan</code> <code class="n">a</code><code class="p">)</code>
<code class="nf">writeTChan</code> <code class="ow">::</code> <code class="kt">TChan</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="nb">()</code>
<code class="nf">readTChan</code>  <code class="ow">::</code> <code class="kt">TChan</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="n">a</code></pre>
<p id="conc-stm_00000116">This is exactly the same as <code class="literal">Chan</code>, except that we <a id="id461695" class="indexterm"></a>renamed <code class="literal">Chan</code> to
<code class="literal">TChan</code>, and all the operations are in the <code class="literal">STM</code> monad rather than
<code class="literal">IO</code>.  The full code for the implementation is given next.</p>
<p id="lst_tchan" class="caption"><span class="formalpara-title">TChan.hs: </span>
</p>
<pre class="programlisting" data-language="haskell" id="data_tchan_a___id2"><code class="kr">data</code> <code class="kt">TChan</code> <code class="n">a</code> <code class="ow">=</code> <code class="kt">TChan</code> <code class="p">(</code><code class="kt">TVar</code> <code class="p">(</code><code class="kt">TVarList</code> <code class="n">a</code><code class="p">))</code>
                     <code class="p">(</code><code class="kt">TVar</code> <code class="p">(</code><code class="kt">TVarList</code> <code class="n">a</code><code class="p">))</code>

<code class="kr">type</code> <code class="kt">TVarList</code> <code class="n">a</code> <code class="ow">=</code> <code class="kt">TVar</code> <code class="p">(</code><code class="kt">TList</code> <code class="n">a</code><code class="p">)</code>
<code class="kr">data</code> <code class="kt">TList</code> <code class="n">a</code> <code class="ow">=</code> <code class="kt">TNil</code> <code class="o">|</code> <code class="kt">TCons</code> <code class="n">a</code> <code class="p">(</code><code class="kt">TVarList</code> <code class="n">a</code><code class="p">)</code>

<code class="nf">newTChan</code> <code class="ow">::</code> <code class="kt">STM</code> <code class="p">(</code><code class="kt">TChan</code> <code class="n">a</code><code class="p">)</code>
<code class="nf">newTChan</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">hole</code> <code class="ow">&lt;-</code> <code class="n">newTVar</code> <code class="kt">TNil</code>
  <code class="n">read</code> <code class="ow">&lt;-</code> <code class="n">newTVar</code> <code class="n">hole</code>
  <code class="n">write</code> <code class="ow">&lt;-</code> <code class="n">newTVar</code> <code class="n">hole</code>
  <code class="n">return</code> <code class="p">(</code><code class="kt">TChan</code> <code class="n">read</code> <code class="n">write</code><code class="p">)</code>

<code class="nf">readTChan</code> <code class="ow">::</code> <code class="kt">TChan</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="n">a</code>
<code class="nf">readTChan</code> <code class="p">(</code><code class="kt">TChan</code> <code class="n">readVar</code> <code class="kr">_</code><code class="p">)</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">listHead</code> <code class="ow">&lt;-</code> <code class="n">readTVar</code> <code class="n">readVar</code>
  <code class="n">head</code> <code class="ow">&lt;-</code> <code class="n">readTVar</code> <code class="n">listHead</code>
  <code class="kr">case</code> <code class="n">head</code> <code class="kr">of</code>
    <code class="kt">TNil</code> <code class="ow">-&gt;</code> <code class="n">retry</code>
    <code class="kt">TCons</code> <code class="n">val</code> <code class="n">tail</code> <code class="ow">-&gt;</code> <code class="kr">do</code>
        <code class="n">writeTVar</code> <code class="n">readVar</code> <code class="n">tail</code>
        <code class="n">return</code> <code class="n">val</code>

<code class="nf">writeTChan</code> <code class="ow">::</code> <code class="kt">TChan</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="nb">()</code>
<code class="nf">writeTChan</code> <code class="p">(</code><code class="kt">TChan</code> <code class="kr">_</code> <code class="n">writeVar</code><code class="p">)</code> <code class="n">a</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">newListEnd</code> <code class="ow">&lt;-</code> <code class="n">newTVar</code> <code class="kt">TNil</code>
  <code class="n">listEnd</code> <code class="ow">&lt;-</code> <code class="n">readTVar</code> <code class="n">writeVar</code>
  <code class="n">writeTVar</code> <code class="n">writeVar</code> <code class="n">newListEnd</code>
  <code class="n">writeTVar</code> <code class="n">listEnd</code> <code class="p">(</code><code class="kt">TCons</code> <code class="n">a</code> <code class="n">newListEnd</code><code class="p">)</code></pre>
<p class="caption">
</p>
<p id="conc-stm_00000122">The implementation is similar in structure to the <code class="literal">MVar</code> version in
<a class="xref" href="ch07.html#sec_channels" title="MVar as a Building Block: Unbounded Channels">“MVar as a Building Block: Unbounded Channels”</a>, so we do not describe it line by line; however, we
will point out a few important details:</p>
<div class="itemizedlist" id="conc-stm_00000123"><ul class="itemizedlist">
<li class="listitem">
All the operations are in the <code class="literal">STM</code> monad, so to use them they
  need to be wrapped in <code class="literal">atomically</code> (but they can also be composed;
  more about that later).
</li>
<li class="listitem">
<a id="id462544" class="indexterm"></a><a id="id462552" class="indexterm"></a>The <code class="literal">TList</code> type needs a <code class="literal">TNil</code> constructor to indicate an empty
  list; in the <code class="literal">MVar</code> implementation, the empty list was represented
  implicitly by an empty <code class="literal">MVar</code>.
</li>
<li class="listitem">
Blocking <a id="id462591" class="indexterm"></a>in <code class="literal">readTChan</code> is implemented by a call to <code class="literal">retry</code>.
</li>
<li class="listitem">
Nowhere did we have to worry about what happens when a read
  executes concurrently with a write, because all the operations are
  atomic.
</li>
</ul></div>
<p id="conc-stm_00000128">We now describe three distinct benefits of the STM implementation
compared with <a id="id462642" class="indexterm"></a>using <code class="literal">MVar</code>s.</p>
<div class="sect2" id="conc-stm_00000129">
<div class="titlepage"><div><div><h3 class="title">More Operations Are Possible</h3></div></div></div>
<p id="in__we_mention">In <a class="xref" href="ch07.html#sec_channels" title="MVar as a Building Block: Unbounded Channels">“MVar as a Building Block: Unbounded Channels”</a>, we mentioned the
<a id="id462675" class="indexterm"></a>operation <code class="literal">unGetChan</code>, which could not be implemented with the desired
semantics using <code class="literal">MVar</code>s.  Here is its implementation with STM:</p>
<pre class="programlisting" data-language="haskell" id="ungettchan__t"><code class="nf">unGetTChan</code> <code class="ow">::</code> <code class="kt">TChan</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="nb">()</code>
<code class="nf">unGetTChan</code> <code class="p">(</code><code class="kt">TChan</code> <code class="n">readVar</code> <code class="kr">_</code><code class="p">)</code> <code class="n">a</code> <code class="ow">=</code> <code class="kr">do</code>
   <code class="n">listHead</code> <code class="ow">&lt;-</code> <code class="n">readTVar</code> <code class="n">readVar</code>
   <code class="n">newHead</code> <code class="ow">&lt;-</code> <code class="n">newTVar</code> <code class="p">(</code><code class="kt">TCons</code> <code class="n">a</code> <code class="n">listHead</code><code class="p">)</code>
   <code class="n">writeTVar</code> <code class="n">readVar</code> <code class="n">newHead</code></pre>
<p id="conc-stm_00000131">The obvious implementation does the right thing here.  Other
operations that were not possible with <code class="literal">MVar</code>s are straightforward
with STM; an example <a id="id462894" class="indexterm"></a>is <code class="literal">isEmptyTChan</code>, the <code class="literal">MVar</code> version that
suffers from the same problem as <code class="literal">unGetChan</code>:</p>
<pre class="programlisting" data-language="haskell" id="isemptytchan_"><code class="nf">isEmptyTChan</code> <code class="ow">::</code> <code class="kt">TChan</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="kt">Bool</code>
<code class="nf">isEmptyTChan</code> <code class="p">(</code><code class="kt">TChan</code> <code class="n">read</code> <code class="n">_write</code><code class="p">)</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">listhead</code> <code class="ow">&lt;-</code> <code class="n">readTVar</code> <code class="n">read</code>
  <code class="n">head</code> <code class="ow">&lt;-</code> <code class="n">readTVar</code> <code class="n">listhead</code>
  <code class="kr">case</code> <code class="n">head</code> <code class="kr">of</code>
    <code class="kt">TNil</code> <code class="ow">-&gt;</code> <code class="n">return</code> <code class="kt">True</code>
    <code class="kt">TCons</code> <code class="kr">_</code> <code class="kr">_</code> <code class="ow">-&gt;</code> <code class="n">return</code> <code class="kt">False</code></pre>
</div>
<div class="sect2" id="conc-stm_00000133">
<div class="titlepage"><div><div><h3 class="title">Composition of Blocking Operations</h3></div></div></div>
<p id="because_blockin">Because blocking STM
computations can be composed together, we can build <a id="id463138" class="indexterm"></a><a id="id463144" class="indexterm"></a>composite
operations like <code class="literal">readEitherTChan</code>:</p>
<pre class="programlisting" data-language="haskell" id="readeithertchan_id1"><code class="nf">readEitherTChan</code> <code class="ow">::</code> <code class="kt">TChan</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">TChan</code> <code class="n">b</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="p">(</code><code class="kt">Either</code> <code class="n">a</code> <code class="n">b</code><code class="p">)</code></pre>
<p id="conc-stm_00000135">This function reads a value from either of the two <code class="literal">TChan</code>s passed
as arguments, or blocks if they are both empty.  Its implementation
should look familiar, being similar <a id="id463256" class="indexterm"></a>to <a class="link" href="ch10.html#conc-stm_00000092"><code class="literal">takeEitherTMVar</code></a>:</p>
<pre class="programlisting" data-language="haskell" id="readeithertchan_id2"><code class="nf">readEitherTChan</code> <code class="ow">::</code> <code class="kt">TChan</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">TChan</code> <code class="n">b</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="p">(</code><code class="kt">Either</code> <code class="n">a</code> <code class="n">b</code><code class="p">)</code>
<code class="nf">readEitherTChan</code> <code class="n">a</code> <code class="n">b</code> <code class="ow">=</code>
  <code class="n">fmap</code> <code class="kt">Left</code> <code class="p">(</code><code class="n">readTChan</code> <code class="n">a</code><code class="p">)</code>
    <code class="p">`</code><code class="n">orElse</code><code class="p">`</code>
  <code class="n">fmap</code> <code class="kt">Right</code> <code class="p">(</code><code class="n">readTChan</code> <code class="n">b</code><code class="p">)</code></pre>
</div>
<div class="sect2" id="conc-stm_00000137">
<div class="titlepage"><div><div><h3 class="title">Asynchronous Exception Safety</h3></div></div></div>
<p id="asynchronous_ex_id1"><a id="id463461" class="indexterm"></a><a id="id463469" class="indexterm"></a>Up until now, we have said nothing
about how exceptions in STM behave.  The <code class="literal">STM</code> monad supports
exceptions much like the <code class="literal">IO</code> monad, with two operations:</p>
<pre class="programlisting" data-language="haskell" id="throwstm__exc"><code class="nf">throwSTM</code>  <code class="ow">::</code> <code class="kt">Exception</code> <code class="n">e</code> <code class="ow">=&gt;</code> <code class="n">e</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="n">a</code>
<code class="nf">catchSTM</code>  <code class="ow">::</code> <code class="kt">Exception</code> <code class="n">e</code> <code class="ow">=&gt;</code> <code class="kt">STM</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="p">(</code><code class="n">e</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="n">a</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="n">a</code></pre>
<p id="conc-stm_00000139"><a id="id463640" class="indexterm"></a><a id="id463645" class="indexterm"></a>The <code class="literal">throwSTM</code> operation throws an exception, and <code class="literal">catchSTM</code> catches
exceptions and invokes a handler, just like <code class="literal">catch</code> in the <code class="literal">IO</code> monad.
However, exceptions in STM are different in one vital way: in
<code class="literal">catchSTM m h</code>, if <code class="literal">m</code> raises an exception, then <span class="emphasis"><em>all of its effects
are discarded</em></span>, and then the handler <code class="literal">h</code> is invoked.  As a degenerate
case, if there is no enclosing <code class="literal">catchSTM</code> at all, then all of the effects
of the transaction are discarded and the exception is propagated out
of <code class="literal">atomically</code>.</p>
<p id="conc-stm_00000143">An example should help to demonstrate the motivation for this
behavior.  Imagine an <code class="literal">STM</code> operation <code class="literal">readCheck</code> defined as follows:</p>
<pre class="programlisting" data-language="haskell" id="readcheck__tc"><code class="nf">readCheck</code> <code class="ow">::</code> <code class="kt">TChan</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="n">a</code>
<code class="nf">readCheck</code> <code class="n">chan</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">a</code> <code class="ow">&lt;-</code> <code class="n">readTChan</code> <code class="n">chan</code>
  <code class="n">checkValue</code> <code class="n">a</code></pre>
<p id="conc-stm_00000145"><a id="id463834" class="indexterm"></a>Where <code class="literal">checkValue</code> is an operation that imposes some extra constraints
on the value read from the channel.  Now suppose <code class="literal">checkValue</code>
raises an exception (perhaps accidentally, e.g., divide-by-zero).  We
would prefer it if the <code class="literal">readTChan</code> had not happened because an element
of the channel would be lost.  Furthermore, we would like <code class="literal">readCheck</code>
to have this behavior regardless of whether there is an enclosing
exception handler or not.  Hence <code class="literal">catchSTM</code> discards the effects of
its first argument in the event of an <span class="keep-together">exception</span>.</p>
<p id="conc-stm_00000146">The discarding-effects behavior is even more useful in the case of
<span class="emphasis"><em>asynchronous</em></span> exceptions.  If an asynchronous exception occurs during
an STM transaction, the effects of the transaction are discarded, just
as for a synchronous exception.  So in most cases, asynchronous
exception safety in STM consists of doing <span class="emphasis"><em>absolutely nothing at all</em></span>.
There are no locks to replace, so there is no need for exception handlers or
<code class="literal">bracket</code> and no need to worry about which critical sections to
protect with <code class="literal">mask</code>.</p>
<p id="conc-stm_00000147">The implementation <a id="id463915" class="indexterm"></a>of <code class="literal">TChan</code> given earlier is entirely safe with
respect to asynchronous exceptions as it stands, and moreover any
compositions of these operations are also safe.</p>
<p id="conc-stm_00000148">STM provides a nice way to write code that is automatically safe with
respect to asynchronous exceptions, so it can be useful even for state
that is not shared between threads.  The only catch is that we have to
use STM consistently for all our state, but having made that leap,
asynchronous exception safety comes for free.<a id="id463940" class="indexterm"></a><a id="id463950" class="indexterm"></a></p>
</div>
</div>
<div class="sect1" data-original-filename="ch10_conc-stm.asciidoc" id="sec_stm-tqueue">
<div class="titlepage"><div><div><h2 class="title">An Alternative Channel Implementation</h2></div></div></div>
<p id="conc-stm_00000149"><a id="ix_ch10_conc-stm-txt15" class="indexterm"></a><a id="ix_ch10_conc-stm-txt16" class="indexterm"></a>In the previous section, we implemented a channel type that was
analogous to the <code class="literal">MVar</code>-based <code class="literal">Chan</code>, in that it has a similar
implementation structure and the same basic operations.  However, the
flexibility of STM gives us more choices in how to construct channels,
and in fact if we don’t need <code class="literal">dupChan</code>, we can implement a much
more efficient <a id="id464026" class="indexterm"></a>channel abstraction.</p>
<p id="conc-stm_00000150">The key observation is that in STM, an operation can block on any
condition whatsoever.  This means we can represent the channel
contents by any <a id="id464041" class="indexterm"></a>data structure we choose.  For example, even a simple
list works:</p>
<p id="conc-stm_00000151" class="caption"><span class="emphasis"><em>TList.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="newtype_tlist_a"><code class="kr">newtype</code> <code class="kt">TList</code> <code class="n">a</code> <code class="ow">=</code> <code class="kt">TList</code> <code class="p">(</code><code class="kt">TVar</code> <code class="p">[</code><code class="n">a</code><code class="p">])</code>

<code class="nf">newTList</code> <code class="ow">::</code> <code class="kt">STM</code> <code class="p">(</code><code class="kt">TList</code> <code class="n">a</code><code class="p">)</code>
<code class="nf">newTList</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">v</code>  <code class="ow">&lt;-</code> <code class="n">newTVar</code> <code class="kt">[]</code>
  <code class="n">return</code> <code class="p">(</code><code class="kt">TList</code> <code class="n">v</code><code class="p">)</code>

<code class="nf">writeTList</code> <code class="ow">::</code> <code class="kt">TList</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="nb">()</code>
<code class="nf">writeTList</code> <code class="p">(</code><code class="kt">TList</code> <code class="n">v</code><code class="p">)</code> <code class="n">a</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">list</code> <code class="ow">&lt;-</code> <code class="n">readTVar</code> <code class="n">v</code>
  <code class="n">writeTVar</code> <code class="n">v</code> <code class="p">(</code><code class="n">list</code> <code class="o">++</code> <code class="p">[</code><code class="n">a</code><code class="p">])</code>

<code class="nf">readTList</code> <code class="ow">::</code> <code class="kt">TList</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="n">a</code>
<code class="nf">readTList</code> <code class="p">(</code><code class="kt">TList</code> <code class="n">v</code><code class="p">)</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">xs</code> <code class="ow">&lt;-</code> <code class="n">readTVar</code> <code class="n">v</code>
  <code class="kr">case</code> <code class="n">xs</code> <code class="kr">of</code>
    <code class="kt">[]</code>      <code class="ow">-&gt;</code> <code class="n">retry</code>
    <code class="p">(</code><code class="n">x</code><code class="kt">:</code><code class="n">xs'</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kr">do</code>
      <code class="n">writeTVar</code> <code class="n">v</code> <code class="n">xs'</code>
      <code class="n">return</code> <code class="n">x</code></pre>
<p id="conc-stm_00000155">This is a channel abstraction with the same behavior as <code class="literal">TChan</code>;
<code class="literal">readTList</code> blocks when the channel is empty, because it can detect
the empty list and call <code class="literal">retry</code>.</p>
<p id="conc-stm_00000156">There is a performance problem with this representation, though.  Note
that <code class="literal">writeTList</code> must add an element to the <span class="emphasis"><em>end</em></span> of the list, which,
using the standard Haskell list datatype, requires an <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span>) append
operation.</p>
<p id="conc-stm_00000157">The solution is to use a different queue data structure that
supports <span class="emphasis"><em>O</em></span>(1) enqueue and dequeue operations.  There is a folklore
technique for representing a queue that has the desired property: the
idea is to represent a queue as two lists, <code class="literal">xs</code> and <code class="literal">ys</code>, where
the whole contents of the list is given by <code class="literal">xs ++ reverse ys</code>.  That
is, to take an element from the front we take it from <code class="literal">xs</code>, and to add
an element to the back we add it to the front of <code class="literal">ys</code>; both of these
operations are <span class="emphasis"><em>O</em></span>(1).  But what if <code class="literal">xs</code> is empty and we need to take
an element?  In that case, we must reverse <code class="literal">ys</code> and let that become the
new <code class="literal">xs</code>.  So while most of the time, taking an element from the front
is <span class="emphasis"><em>O</em></span>(1), occasionally it is <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span>).  However, we know that each list
element is reversed only once, so on average the complexity of both
enqueue and dequeue is <span class="emphasis"><em>O</em></span>(1).<a href="#ftn.id464679" class="footnote"><sup class="footnote" id="id464679">[42]</sup></a></p>
<p id="conc-stm_00000158">We can use this technique to represent the channel contents.  This is the code:</p>
<p id="conc-stm_00000159" class="caption"><span class="emphasis"><em>TQueue.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="data_tqueue_a_"><code class="kr">data</code> <code class="kt">TQueue</code> <code class="n">a</code> <code class="ow">=</code> <code class="kt">TQueue</code> <code class="p">(</code><code class="kt">TVar</code> <code class="p">[</code><code class="n">a</code><code class="p">])</code> <code class="p">(</code><code class="kt">TVar</code> <code class="p">[</code><code class="n">a</code><code class="p">])</code>

<code class="nf">newTQueue</code> <code class="ow">::</code> <code class="kt">STM</code> <code class="p">(</code><code class="kt">TQueue</code> <code class="n">a</code><code class="p">)</code>
<code class="nf">newTQueue</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">read</code>  <code class="ow">&lt;-</code> <code class="n">newTVar</code> <code class="kt">[]</code>
  <code class="n">write</code> <code class="ow">&lt;-</code> <code class="n">newTVar</code> <code class="kt">[]</code>
  <code class="n">return</code> <code class="p">(</code><code class="kt">TQueue</code> <code class="n">read</code> <code class="n">write</code><code class="p">)</code>

<code class="nf">writeTQueue</code> <code class="ow">::</code> <code class="kt">TQueue</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="nb">()</code>
<code class="nf">writeTQueue</code> <code class="p">(</code><code class="kt">TQueue</code> <code class="n">_read</code> <code class="n">write</code><code class="p">)</code> <code class="n">a</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">listend</code> <code class="ow">&lt;-</code> <code class="n">readTVar</code> <code class="n">write</code>
  <code class="n">writeTVar</code> <code class="n">write</code> <code class="p">(</code><code class="n">a</code><code class="kt">:</code><code class="n">listend</code><code class="p">)</code>

<code class="nf">readTQueue</code> <code class="ow">::</code> <code class="kt">TQueue</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="n">a</code>
<code class="nf">readTQueue</code> <code class="p">(</code><code class="kt">TQueue</code> <code class="n">read</code> <code class="n">write</code><code class="p">)</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">xs</code> <code class="ow">&lt;-</code> <code class="n">readTVar</code> <code class="n">read</code>
  <code class="kr">case</code> <code class="n">xs</code> <code class="kr">of</code>
    <code class="p">(</code><code class="n">x</code><code class="kt">:</code><code class="n">xs'</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kr">do</code> <code class="n">writeTVar</code> <code class="n">read</code> <code class="n">xs'</code>
                  <code class="n">return</code> <code class="n">x</code>
    <code class="kt">[]</code> <code class="ow">-&gt;</code> <code class="kr">do</code> <code class="n">ys</code> <code class="ow">&lt;-</code> <code class="n">readTVar</code> <code class="n">write</code>
             <code class="kr">case</code> <code class="n">ys</code> <code class="kr">of</code>
               <code class="kt">[]</code> <code class="ow">-&gt;</code> <code class="n">retry</code>                      <code class="c1">-- </code><span id="CO37-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
               <code class="kr">_</code>  <code class="ow">-&gt;</code> <code class="kr">do</code> <code class="kr">let</code> <code class="p">(</code><code class="n">z</code><code class="kt">:</code><code class="n">zs</code><code class="p">)</code> <code class="ow">=</code> <code class="n">reverse</code> <code class="n">ys</code> <code class="c1">-- </code><span id="CO37-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>
                        <code class="n">writeTVar</code> <code class="n">write</code> <code class="kt">[]</code>
                        <code class="n">writeTVar</code> <code class="n">read</code> <code class="n">zs</code>
                        <code class="n">return</code> <code class="n">z</code></pre>
<div class="calloutlist" id="conc-stm_00000163"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO37-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="if_we_are_readi">
If we are reading from the channel and the <code class="literal">read</code> list is empty,
then we check the <code class="literal">write</code> list.  If that is also empty, then we block.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO37-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="if_the_ys_list_">
If the <code class="literal">ys</code> list is non-empty, then we must reverse it and make it
the new <code class="literal">xs</code> list, and then return the first element of the new <code class="literal">xs</code> as the
value we read from the channel.
</p></td>
</tr>
</table></div>
<p id="conc-stm_00000164">+
There is one subtlety here: we must be careful that the <code class="literal">reverse</code> is
done lazily, which is why we use a <code class="literal">let</code> rather than <code class="literal">case</code> here.  If
we were to pattern-match on the result of the <code class="literal">reverse</code> strictly,
the STM transaction could not complete until the reverse finished
(see <a class="xref" href="ch10.html#sec_stm-cost" title="Performance">“Performance”</a>).</p>
<p id="conc-stm_00000165">Another happy consequence of this representation choice is that we are
able to use a separate <code class="literal">TVar</code> for each list. This means that in the
common case, readers and writers can proceed independently without
conflict, which is important if we use this data structure in a
parallel setting.</p>
<p id="conc-stm_00000166">This implementation of channels in STM outperforms both the
<code class="literal">MVar</code>-based <code class="literal">Chan</code> and the <code class="literal">TVar</code>-based <code class="literal">TChan</code>.  A simple
benchmark program can be found in <code class="filename">chanbench.hs</code> with
three different scenarios:</p>
<div class="itemizedlist" id="conc-stm_00000167"><ul class="itemizedlist">
<li class="listitem">
Two threads, one reading from and one writing to the channel
</li>
<li class="listitem">
One thread, writing a large number of values and then reading them
</li>
<li class="listitem">
One thread, repeatedly writing and then reading a number of values
</li>
</ul></div>
<p id="conc-stm_00000168">On my computer<a id="id465616" class="indexterm"></a>, <code class="literal">TQueue</code> is about the same as <code class="literal">Chan</code> on the first
test and wins by about 20% on the second and third test.</p>
<p id="conc-stm_00000169">Why is <code class="literal">TQueue</code> so much faster?  The main reason is that the data
structure representing the channel contents is much more compact and
thus faster to operate on: ordinary linked lists are very cheap in Haskell,
whereas operations on <code class="literal">TVar</code> and <code class="literal">MVar</code> are much more expensive.<a id="id465664" class="indexterm"></a><a id="id465674" class="indexterm"></a></p>
</div>
<div class="sect1" data-original-filename="ch10_conc-stm.asciidoc" id="sec_stm-bounded-chan">
<div class="titlepage"><div><div><h2 class="title">Bounded Channels</h2></div></div></div>
<p id="conc-stm_00000170"><a id="ix_ch10_conc-stm-txt17" class="indexterm"></a><a id="ix_ch10_conc-stm-txt18" class="indexterm"></a>So far, we have seen <a id="id465726" class="indexterm"></a><a id="id465732" class="indexterm"></a><a id="id465740" class="indexterm"></a>one-place channels (<code class="literal">MVar</code> and <code class="literal">TMVar</code>) and
unbounded channels (<code class="literal">Chan</code> and <code class="literal">TChan</code>), but in practice we often want
something between the two.  The one-place channel does not allow
sufficient concurrency: consider multiple writers with a single
reader. If there is a burst of writing activity, most of the
writers will block waiting for the reading thread to catch up, and
there will be a lot of context switching as the reader services each
writer in turn.  The unbounded channel has a different pathology: if
the reading thread cannot keep up with the writers, the size of
the channel will keep growing without bound, and in the worst case we
could run out of <a id="id465778" class="indexterm"></a>memory.</p>
<p id="conc-stm_00000171">Ideally, there should be some limit on the size of the channel so
that the channel can absorb bursts of writing activity without
the danger that heavy writing will use too much memory.</p>
<p id="conc-stm_00000172">Fortunately, STM makes it quite straightforward to build a bounded
channel.  All we need to do is keep track of the current capacity in
the channel and arrange that writing to the channel blocks if the
channel is currently full.  This implementation is based <a id="id465804" class="indexterm"></a>on <code class="literal">TQueue</code>:</p>
<p id="conc-stm_00000173" class="caption"><span class="emphasis"><em>TBQueue.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="data_tbqueue_a_"><code class="kr">data</code> <code class="kt">TBQueue</code> <code class="n">a</code> <code class="ow">=</code> <code class="kt">TBQueue</code> <code class="p">(</code><code class="kt">TVar</code> <code class="kt">Int</code><code class="p">)</code> <code class="p">(</code><code class="kt">TVar</code> <code class="p">[</code><code class="n">a</code><code class="p">])</code> <code class="p">(</code><code class="kt">TVar</code> <code class="p">[</code><code class="n">a</code><code class="p">])</code> <code class="c1">-- </code><span id="CO38-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>

<code class="nf">newTBQueue</code> <code class="ow">::</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="p">(</code><code class="kt">TBQueue</code> <code class="n">a</code><code class="p">)</code>
<code class="nf">newTBQueue</code> <code class="n">size</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">read</code>  <code class="ow">&lt;-</code> <code class="n">newTVar</code> <code class="kt">[]</code>
  <code class="n">write</code> <code class="ow">&lt;-</code> <code class="n">newTVar</code> <code class="kt">[]</code>
  <code class="n">cap</code>   <code class="ow">&lt;-</code> <code class="n">newTVar</code> <code class="n">size</code>
  <code class="n">return</code> <code class="p">(</code><code class="kt">TBQueue</code> <code class="n">cap</code> <code class="n">read</code> <code class="n">write</code><code class="p">)</code>

<code class="nf">writeTBQueue</code> <code class="ow">::</code> <code class="kt">TBQueue</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="nb">()</code>
<code class="nf">writeTBQueue</code> <code class="p">(</code><code class="kt">TBQueue</code> <code class="n">cap</code> <code class="n">_read</code> <code class="n">write</code><code class="p">)</code> <code class="n">a</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">avail</code> <code class="ow">&lt;-</code> <code class="n">readTVar</code> <code class="n">cap</code>                         <code class="c1">-- </code><span id="CO38-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>
  <code class="kr">if</code> <code class="n">avail</code> <code class="o">==</code> <code class="mi">0</code>                                 <code class="c1">-- </code><span id="CO38-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span>
     <code class="kr">then</code> <code class="n">retry</code>                                 <code class="c1">-- </code><span id="CO38-4"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span>
     <code class="kr">else</code> <code class="n">writeTVar</code> <code class="n">cap</code> <code class="p">(</code><code class="n">avail</code> <code class="o">-</code> <code class="mi">1</code><code class="p">)</code>             <code class="c1">-- </code><span id="CO38-5"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/5.png" alt="5"></span>
  <code class="n">listend</code> <code class="ow">&lt;-</code> <code class="n">readTVar</code> <code class="n">write</code>
  <code class="n">writeTVar</code> <code class="n">write</code> <code class="p">(</code><code class="n">a</code><code class="kt">:</code><code class="n">listend</code><code class="p">)</code>

<code class="nf">readTBQueue</code> <code class="ow">::</code> <code class="kt">TBQueue</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">STM</code> <code class="n">a</code>
<code class="nf">readTBQueue</code> <code class="p">(</code><code class="kt">TBQueue</code> <code class="n">cap</code> <code class="n">read</code> <code class="n">write</code><code class="p">)</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">avail</code> <code class="ow">&lt;-</code> <code class="n">readTVar</code> <code class="n">cap</code>                         <code class="c1">-- </code><span id="CO38-6"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/6.png" alt="6"></span>
  <code class="n">writeTVar</code> <code class="n">cap</code> <code class="p">(</code><code class="n">avail</code> <code class="o">+</code> <code class="mi">1</code><code class="p">)</code>
  <code class="n">xs</code> <code class="ow">&lt;-</code> <code class="n">readTVar</code> <code class="n">read</code>
  <code class="kr">case</code> <code class="n">xs</code> <code class="kr">of</code>
    <code class="p">(</code><code class="n">x</code><code class="kt">:</code><code class="n">xs'</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kr">do</code> <code class="n">writeTVar</code> <code class="n">read</code> <code class="n">xs'</code>
                  <code class="n">return</code> <code class="n">x</code>
    <code class="kt">[]</code> <code class="ow">-&gt;</code> <code class="kr">do</code> <code class="n">ys</code> <code class="ow">&lt;-</code> <code class="n">readTVar</code> <code class="n">write</code>
             <code class="kr">case</code> <code class="n">ys</code> <code class="kr">of</code>
               <code class="kt">[]</code> <code class="ow">-&gt;</code> <code class="n">retry</code>
               <code class="kr">_</code>  <code class="ow">-&gt;</code> <code class="kr">do</code> <code class="kr">let</code> <code class="p">(</code><code class="n">z</code><code class="kt">:</code><code class="n">zs</code><code class="p">)</code> <code class="ow">=</code> <code class="n">reverse</code> <code class="n">ys</code>
                        <code class="n">writeTVar</code> <code class="n">write</code> <code class="kt">[]</code>
                        <code class="n">writeTVar</code> <code class="n">read</code> <code class="n">zs</code>
                        <code class="n">return</code> <code class="n">z</code></pre>
<div class="calloutlist" id="conc-stm_00000177"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO38-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_tbqueue_dat">
The <code class="literal">TBQueue</code> data type is like the <code class="literal">TQueue</code> we saw previously
but has an extra <code class="literal">TVar Int</code> to store the channel’s current capacity.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO38-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="in_writetbqueue">
In <code class="literal">writeTBQueue</code>, we first read the current capacity.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO38-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="if_the_capacity">
If the capacity is zero, meaning the channel is full,
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO38-4"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="we_call_retry_t">
we call <code class="literal">retry</code> to block.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO38-5"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/5.png" alt="5"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="otherwise_decr">
Otherwise, decrease the capacity by 1, because we are about to add another element.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO38-6"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/6.png" alt="6"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="when_reading_w">
When reading, we always increment the capacity.
</p></td>
</tr>
</table></div>
<p id="conc-stm_00000179">In the <code class="filename">chanbench.hs</code> channel benchmark, the bounded
channel performs almost as well as <code class="literal">TQueue</code> in the first test,
although it doesn’t do so well in the third test, performing about the
same as <code class="literal">TChan</code>.  The second test, which writes a large number of
items to the channel, inevitably fails <a id="id466948" class="indexterm"></a><a id="id466954" class="indexterm"></a><a id="id466962" class="indexterm"></a>with <code class="literal">TBQueue</code>.</p>
<div class="tip" id="conc-stm_00000180">
<p id="the_danger_with">The danger with bounded channels is that it is possible to write a
program with a lurking deadlock that is only discovered much later
when the program is running in production.  This is because the vast
majority of the time <code class="literal">writeTBQueue</code> does not block, but once in a
while, probably under heavy load, the channel fills up and
<code class="literal">writeTBQueue</code> blocks.  If the program depends on <code class="literal">writeTBQueue</code> not
blocking, it may deadlock.  How might we get into this situation?
It is the dining philosophers problem again:</p>
<pre class="screen" id="conc-stm_00000181">thread 1:
  x &lt;- atomically $ readTBQueue q1
  y &lt;- atomically $ readTBQueue q2

thread 2:
  atomically $ writeTBQueue q2 y
  atomically $ writeTBQueue q1 x</pre>
<p id="conc-stm_00000183">This sequence will work perfectly well until <code class="literal">q2</code> becomes
full, at which point we get a deadlock.  If the communication pattern
is obscured by other code, we might not realize there’s a
problem.</p>
<p id="conc-stm_00000184">There’s no silver bullet. The best advice is to test your code
thoroughly with a buffer size of 1, because that will tend to expose
any deadlocks of this kind during testing.  Note that deadlocks will
often be detected by the runtime system and result in an exception
rather than a hang; see <a class="xref" href="ch15.html#sec_deadlock" title="Detecting Deadlock">“Detecting Deadlock”</a>.<a id="id467050" class="indexterm"></a><a id="id467060" class="indexterm"></a></p>
</div>
</div>
<div class="sect1" data-original-filename="ch10_conc-stm.asciidoc" id="sec_stm-whynot">
<div class="titlepage"><div><div><h2 class="title">What Can We Not Do with STM?</h2></div></div></div>
<p id="conc-stm_00000185"><a id="ix_ch10_conc-stm-txt19" class="indexterm"></a>STM offers a qualitative improvement over <code class="literal">MVar</code> in various ways:
composable atomicity, composable blocking, and simpler error handling.
Therefore, it is reasonable to ask whether we need <code class="literal">MVar</code> at all, and
whether there is anything that is harder to accomplish with STM than
with <code class="literal">MVar</code>.</p>
<p id="conc-stm_00000186">One unsurprising advantage <a id="id467126" class="indexterm"></a>of <code class="literal">MVar</code> is that it
is faster than STM.  But even though a straightforward comparison of, say,
<code class="literal">takeMVar</code> against <code class="literal">atomically . takeTMVar</code> will show that <code class="literal">takeMVar</code>
is faster, we should not assume that using <code class="literal">MVar</code> will
always result in faster code.  As we saw in the previous section, we
can build a channel using STM that outperforms the <code class="literal">MVar</code>-based
version, and furthermore is composable.</p>
<p id="conc-stm_00000187">In fact, <code class="literal">MVar</code> does have one other important advantage over STM, which
we mentioned earlier<a id="id467186" class="indexterm"></a><a id="id467195" class="indexterm"></a><a id="id467200" class="indexterm"></a>: <span class="emphasis"><em>fairness</em></span>.  When multiple threads block on
an <code class="literal">MVar</code>, they are guaranteed to be woken up in FIFO order, and no
single thread can be blocked in <code class="literal">takeMVar</code> indefinitely so long as
there is a constant supply of <code class="literal">putMVar</code>s.  In contrast, when multiple
threads are blocked in STM transactions that depend on a particular
<code class="literal">TVar</code>, and the <code class="literal">TVar</code> is modified by another thread, it is not enough
to just wake up one of the blocked transactions—the runtime must
wake them all.  To see why, consider the following:</p>
<pre class="programlisting" data-language="haskell" id="do_x__taketmv"><code class="kr">do</code> <code class="n">x</code> <code class="ow">&lt;-</code> <code class="n">takeTMVar</code> <code class="n">m</code>
   <code class="n">when</code> <code class="p">(</code><code class="n">x</code> <code class="o">/=</code> <code class="mi">42</code><code class="p">)</code> <code class="n">retry</code></pre>
<p id="conc-stm_00000189">A transaction can block on an arbitrary condition, so the runtime
doesn’t know whether any individual transaction will be able to make
progress after the <code class="literal">TVar</code> is changed; it must run the
transaction to find out.  Hence, when there are multiple transactions
that might be unblocked, we have to run them all; after all, they
might <span class="emphasis"><em>all</em></span> be able to continue now. Because the runtime has to run all the blocked transactions, there is no guarantee that threads will
be unblocked in FIFO order and no guarantee of fairness.</p>
<p id="conc-stm_00000190">You might wonder whether we could <span class="emphasis"><em>implement</em></span> fairness using STM.  For
example, suppose we want to add <a id="id467349" class="indexterm"></a><a id="id467357" class="indexterm"></a>fairness to our <code class="literal">TMVar</code>
implementation.  We will need to represent explicitly the queue of
blocked <code class="literal">takeTMVar</code>s, perhaps as a list of <code class="literal">TVar</code>s, each waiting
to receive a value. Conversely, the blocked <code class="literal">putTMVar</code>s could also
be a list of <code class="literal">TVar</code>s, each with a value to put.  In fact, we could
represent all the blocked threads by a list of <code class="literal">TVar (Maybe a)</code>.</p>
<p id="conc-stm_00000191"><a id="id467410" class="indexterm"></a>So this could be the <code class="literal">TMVar</code> data type:</p>
<pre class="programlisting" data-language="haskell" id="data_tmvar_a__"><code class="kr">data</code> <code class="kt">TMVar</code> <code class="n">a</code> <code class="ow">=</code> <code class="kt">TMVar</code> <code class="p">(</code><code class="kt">TVar</code> <code class="p">(</code><code class="kt">Maybe</code> <code class="n">a</code><code class="p">))</code> <code class="p">(</code><code class="kt">TVar</code> <code class="p">[</code><code class="kt">TVar</code> <code class="p">(</code><code class="kt">Maybe</code> <code class="n">a</code><code class="p">)])</code></pre>
<p id="conc-stm_00000193">Now consider <a id="id467533" class="indexterm"></a>how <code class="literal">putMVar</code> would work.  There are three cases to consider:</p>
<div class="variablelist" id="the_tmvar_is_em"><dl class="variablelist">
<dt><span class="term">
The <code class="literal">TMVar</code> is empty, and there are no blocked <code class="literal">takeTMVar</code>s
</span></dt>
<dd>
  Store the value in the <code class="literal">TMVar</code> and return.
</dd>
<dt><span class="term">
The <code class="literal">TMVar</code> is empty, and there are some blocked <code class="literal">takeTMVar</code>s
</span></dt>
<dd>
  Removes the first blocked <code class="literal">takeTMVar</code> from the queue and put the
  value in its <code class="literal">TVar</code>.
</dd>
<dt><span class="term">
The <code class="literal">TMVar</code> is full
</span></dt>
<dd>
  We must create a new <code class="literal">TVar</code> containing <code class="literal">Just a</code> (the value to be
  put), add this to the end of the list of blocked <code class="literal">putTMVar</code>s, and
  then wait until the <code class="literal">TVar</code> contents becomes <code class="literal">Nothing</code>.
</dd>
</dl></div>
<p id="conc-stm_00000196">The last case is the tricky one: we cannot write a transaction that
<span class="emphasis"><em>both</em></span> has a visible effect (adds something to the list) <span class="emphasis"><em>and</em></span> calls
<code class="literal">retry</code>, because calling <code class="literal">retry</code> abandons any changes to <code class="literal">TVar</code>s
made by the current transaction.</p>
<p id="conc-stm_00000198">The only way to implement fairness is to abandon composability.  We
can implement a <code class="literal">TMVar</code> with the structure I suggested, but the
operations must be in the <code class="literal">IO</code> monad, not the <code class="literal">STM</code> monad. The trick
is to have the STM transaction return <a id="id467721" class="indexterm"></a>an <code class="literal">IO</code> action that is executed
after the STM transaction completes. I’ll leave the implementation as
an exercise for the reader.</p>
<p id="conc-stm_00000199">In general, the class of operations that STM cannot express are those
that involve multi-way communication between <a id="id467746" class="indexterm"></a><a id="id467751" class="indexterm"></a>threads.  The simplest
example is a synchronous channel, in which both the reader and the
writer must be present simultaneously for the operation to go ahead.
We cannot implement this in STM, at least compositionally, for the
same reason that we cannot implement <code class="literal">TMVar</code> with fairness: the
operations need to block <span class="emphasis"><em>and</em></span> have a visible effect—advertise that
there is a blocked thread—simultaneously.<a id="id467774" class="indexterm"></a></p>
</div>
<div class="sect1" data-original-filename="ch10_conc-stm.asciidoc" id="sec_stm-cost">
<div class="titlepage"><div><div><h2 class="title">Performance</h2></div></div></div>
<p id="conc-stm_00000201"><a id="ix_ch10_conc-stm-txt20" class="indexterm"></a>As with most abstractions, STM has a runtime cost.  If we understand
the cost model, we can avoid writing code that hits the bad
cases.  So in this section I’ll give an informal description of the
implementation of STM, with enough detail that the
reader can understand the <a id="id467819" class="indexterm"></a>cost model.</p>
<p id="conc-stm_00000202">An STM transaction works by accumulating a <span class="emphasis"><em>log</em></span> of <code class="literal">readTVar</code>
and <code class="literal">writeTVar</code> operations that have happened so far during the
transaction.  The log is used in three ways:</p>
<div class="itemizedlist" id="conc-stm_00000204"><ul class="itemizedlist">
<li class="listitem">
By storing <code class="literal">writeTVar</code> operations in the log rather than
  applying them to main memory immediately, discarding the effects of
  a transaction is easy; we just throw away the log.  Hence, aborting
  a transaction has a fixed small cost.
</li>
<li class="listitem">
Each <code class="literal">readTVar</code> must traverse the log to check whether the
  <code class="literal">TVar</code> was written by an earlier <code class="literal">writeTVar</code>.  Hence, <code class="literal">readTVar</code> is
  an O(<span class="emphasis"><em>n</em></span>) operation in the length of the log.
</li>
<li class="listitem">
Because the log contains a record of all the <code class="literal">readTVar</code>
  operations, it can be used to discover the full set of <code class="literal">TVar</code>s read
  during the transaction, which we need to know in order to implement
  <code class="literal">retry</code>.
</li>
</ul></div>
<p id="conc-stm_00000208">When a transaction reaches the end, the STM implementation compares
the log against the contents of memory.  If the current contents of
memory match the values read by <code class="literal">readTVar</code>, the effects of the
transaction are <span class="emphasis"><em>committed</em></span> to memory, and if not, the log is
discarded and the transaction runs again from the beginning.  This
process takes place atomically by locking all the <code class="literal">TVar</code>s involved
in the transaction for the duration.  The STM implementation in GHC
does not use <a id="id467955" class="indexterm"></a><a id="id467961" class="indexterm"></a>global locks; only the <code class="literal">TVar</code>s involved in the
transaction are locked during commit, so transactions operating on
disjoint sets of <code class="literal">TVar</code>s can proceed without interference.</p>
<p id="conc-stm_00000209">There are two important rules of thumb:</p>
<div class="itemizedlist" id="never_read_an_u_id1"><ul class="itemizedlist">
<li class="listitem">
Never read an unbounded number <a id="id468002" class="indexterm"></a>of <code class="literal">TVar</code>s in a single transaction
because the <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span>) performance of <code class="literal">readTVar</code> then gives <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span><sup>2</sup>)
for the whole transaction.
</li>
<li class="listitem">
Try to avoid expensive evaluation inside a transaction because this
  will cause the transaction to take a long time, increasing the
  chance that another transaction will modify one or more of the same
  <code class="literal">TVar</code>s, causing the current transaction to be re-executed.  In
  the worst case, a long-running transaction re-executes indefinitely
  because it is repeatedly aborted by shorter transactions.
</li>
</ul></div>
<p id="conc-stm_00000210">It is possible that a future STM implementation may use a different
<a id="id468061" class="indexterm"></a>data structure to store the log, reducing the <code class="literal">readTVar</code> overhead to
<span class="emphasis"><em>O</em></span>(log <span class="emphasis"><em>n</em></span>) or better (on average), but the likelihood that a
long transaction will fail to commit would still be an issue.  To
avoid that problem, intelligent contention-management is required,
which is an area of active research.</p>
<p id="conc-stm_00000211"><a id="id468090" class="indexterm"></a><a id="id468098" class="indexterm"></a>The <code class="literal">retry</code> operation uses the transaction log to find out which
<code class="literal">TVar</code>s were accessed by the transaction, because changes to any of
these <code class="literal">TVar</code>s must trigger a rerun of the current transaction.
Hence, each <code class="literal">TVar</code> has a <span class="emphasis"><em>watch list</em></span> of threads that should be
woken up if the <code class="literal">TVar</code> is modified, and <code class="literal">retry</code> adds the current
thread to the watch list of all the <code class="literal">TVar</code>s read during the current
transaction.  Hence, <code class="literal">retry</code> is <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span>) in the number of <code class="literal">TVar</code>s
read during the transaction.  When a transaction is committed, if any
of the modified <code class="literal">TVar</code>s has a watch list, then the threads on the list
are all woken up.</p>
<p id="conc-stm_00000212">One other thing to watch out for is composing too many <a id="id468186" class="indexterm"></a>blocking
operations together.  If we wanted to wait for a list of <code class="literal">TMVar</code>s to
become full, we might be tempted to do this:</p>
<pre class="programlisting" data-language="haskell" id="atomically__ma"><code class="nf">atomically</code> <code class="o">$</code> <code class="n">mapM</code> <code class="n">takeTMVar</code> <code class="n">ts</code></pre>
<p id="conc-stm_00000214">Imagine that the <code class="literal">TMVar</code>s all started empty and became full one at a
time in the same order as the list <code class="literal">ts</code>.  Each time a new <code class="literal">TMVar</code>
becomes full, the transaction wakes up and runs again, going to sleep
at the next empty <code class="literal">TMVar</code>.  We’ll run the transaction from the start,
once for every element of <code class="literal">ts</code>, so the whole operation is <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span><sup>2</sup>).
If instead, we had written this code:</p>
<pre class="programlisting" data-language="haskell" id="mapm_atomicall"><code class="nf">mapM</code> <code class="p">(</code><code class="n">atomically</code> <code class="o">.</code> <code class="n">takeTMVar</code><code class="p">)</code> <code class="n">ts</code></pre>
<p id="conc-stm_00000216">then it is <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span>), although now the semantics are different—it is
not a single transaction anymore—but if these semantics are acceptable,
then the second form will be much faster.<a id="id468344" class="indexterm"></a></p>
</div>
<div class="sect1" data-original-filename="ch10_conc-stm.asciidoc" id="sec_stm-summary">
<div class="titlepage"><div><div><h2 class="title">Summary</h2></div></div></div>
<p id="conc-stm_00000218">To summarize, STM provides several benefits for concurrent
programming:</p>
<div class="variablelist" id="conc-stm_00000222"><dl class="variablelist">
<dt><span class="term">
<a id="id468378" class="indexterm"></a>Composable atomicity
</span></dt>
<dd>
You can construct arbitrarily large atomic
  operations on shared state, which can simplify the implementation of
  concurrent data structures with fine-grained locking.
</dd>
<dt><span class="term">
<a id="id468397" class="indexterm"></a>Composable blocking
</span></dt>
<dd>
You can build operations that
  choose between multiple blocking operations, which is
  very difficult with <code class="literal">MVar</code>s and other low-level concurrency
  abstractions.
</dd>
<dt><span class="term">
Robustness in the presence of failure and cancellation
</span></dt>
<dd>
  A transaction in progress is aborted if an exception occurs, so STM
  makes it easy to maintain invariants on state in the presence of
  exceptions.
</dd>
</dl></div>
</div>
<div class="footnotes">
<br><hr style="width: 100; align: left;">
<div id="ftn.id457192" class="footnote"><p><a href="#id457192" class="simpara"><sup class="simpara">[39] </sup></a>The <code class="literal">TMVar</code> implementation is available from the <code class="literal">Control.Concurrent.STM.TMVar</code> module in the <code class="literal">stm</code> package.</p></div>
<div id="ftn.id458347" class="footnote"><p><a href="#id458347" class="simpara"><sup class="simpara">[40] </sup></a>We are assuming that the actual window contents
are rendered via some separate means, e.g., compositing.</p></div>
<div id="ftn.id461523" class="footnote"><p><a href="#id461523" class="simpara"><sup class="simpara">[41] </sup></a>The implementation
  is available in the module <code class="literal">Control.Concurrent.STM.TChan</code> from the
  <code class="literal">stm</code> package.</p></div>
<div id="ftn.id464679" class="footnote"><p><a href="#id464679" class="simpara"><sup class="simpara">[42] </sup></a>Technically, the complexity is
<span class="emphasis"><em>amortized</em></span> <span class="emphasis"><em>O</em></span>(1).  For more details on these kinds of data structures,
I recommend reading Okasaki’s <span class="emphasis"><em>Purely Functional Data Structures</em></span> (Cambridge University Press, 1999).</p></div>
</div></section><footer><div class="navfooter">
<hr>
<table style="width: 100%; ">
<tr>
<td style="width: 40%; text-align: left; ">
<a accesskey="p" href="ch09.html">Prev</a> </td>
<td style="width: 20%; text-align: center; "><a accesskey="u" href="pt02.html">Up</a></td>
<td style="width: 40%; text-align: right; "> <a accesskey="n" href="ch11.html">Next</a>
</td>
</tr>
<tr>
<td style="width: 40%; text-align: left; vertical-align: top; ">Chapter 9. Cancellation and Timeouts </td>
<td style="width: 20%; text-align: center; "><a accesskey="h" href="index.html">Home</a></td>
<td style="width: 40%; text-align: right; vertical-align: top; "> Chapter 11. Higher-Level Concurrency Abstractions</td>
</tr>
</table>
</div></footer>


	<div class="extra-footer">
		<p>© 2013, O’Reilly Media, Inc.</p>
		<ul>
			<li><a href="http://oreilly.com/terms/">Terms of Service</a></li>
			<li><a href="http://oreilly.com/oreilly/privacy.csp">Privacy Policy</a></li>
			<li>Interested in <a href="mailto:scordesse@oreilly.com">sponsoring content?</a></li>
		</ul>
	</div>
<script type="text/javascript">if (!NREUMQ.f) { NREUMQ.f=function() {
NREUMQ.push(["load",new Date().getTime()]);
var e=document.createElement("script");
e.type="text/javascript";
e.src=(("http:"===document.location.protocol)?"http:":"https:") + "//" +
  "js-agent.newrelic.com/nr-100.js";
document.body.appendChild(e);
if(NREUMQ.a)NREUMQ.a();
};
NREUMQ.a=window.onload;window.onload=NREUMQ.f;
};
NREUMQ.push(["nrfj","bam.nr-data.net","3e361aebcf","2194180","IApbRUBZXg1WEEoHDAwORh5aQl8N",18,287,new Date().getTime(),"","","","",""]);</script></body>

<!-- Mirrored from chimera.labs.oreilly.com/books/1230000000929/ch10.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 18 Dec 2016 11:04:16 GMT -->
</html>