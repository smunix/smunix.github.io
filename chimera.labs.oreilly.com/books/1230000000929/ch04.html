<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<!-- Mirrored from chimera.labs.oreilly.com/books/1230000000929/ch04.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 25 Dec 2016 16:54:49 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head><script type="text/javascript">var NREUMQ=NREUMQ||[];NREUMQ.push(["mark","firstbyte",new Date().getTime()]);</script>
	<title>Parallel and Concurrent Programming in Haskell</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link href="http://dwn0odqttrkhc.cloudfront.net/assets/book-f1caceafd9c9f3a6ff72d40c54d173ab.css" media="screen" rel="stylesheet" type="text/css" />
	<link href="http://dwn0odqttrkhc.cloudfront.net/assets/default-24583441b4f47382b8932338cd56ed23.css" media="screen" rel="stylesheet" type="text/css" />
	<script src="http://dwn0odqttrkhc.cloudfront.net/assets/application-47d6ffb0c77b868d29a43eb65e940505.js" type="text/javascript"></script>
	<script src="http://dwn0odqttrkhc.cloudfront.net/assets/book-756862b9ed04d945ca53de5b8f106a83.js" type="text/javascript"></script>
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	<link href="http://dwn0odqttrkhc.cloudfront.net/assets/janrain-53eb5abed55992e21943b9d3373923e8.css" media="all" rel="stylesheet" type="text/css" />
	<meta content="authenticity_token" name="csrf-param" />
<meta content="WQ02oEFDbvBG99rmf8rwvGssMqcy27cCD64yZVVTcMY=" name="csrf-token" />
	<script type="text/javascript" charset="utf-8">
  	
		app.data = new classes.Data({"controller":{"controller":"books","action":"html"},"capturable":{"capture_server":"https://oreilly.janraincapture.com","client_id":"6n5q2k9vesqgn93k3mhevka6c3c3rsre","app_url":"https://login.oreilly.com","app_id":"xsnca5wmqe9vxv97ygh5vfejkd","load_js":"d16s8pqtk4uodx.cloudfront.net/login.oreilly.com/load.js"},"user":{"id":null,"account":"LoggedOutAccount","email":"","name":null,"gravatar_url":"http://www.gravatar.com/avatar/d41d8cd98f00b204e9800998ecf8427e?s=40&d=identicon"},"book":{"isbn":"1230000000929","chapter":"ch04.html","toc_url":"/books/1230000000929/toc_html","metadata_url":"http://d4bb7yl96lyl1.cloudfront.net/1230000000929/metadata/metadata_9b2ac4d71a3220a7d463d8d4c80f9113048bb194.json"},"abilities":{"can_destroy_all_comments":false,"can_create_comments":false},"advertisement":{"body":"<style>      \r\n.ad-profile-image {\r\n  padding: 0;\r\n  margin: 0;\r\n  max-height: 30px;\r\n }\r\n\r\n.top-banner {\r\n  position: absolute;\r\n  right: 0;\r\n  top: 34px;\r\n  z-index: 99999;\r\n}\r\n\r\np.banner-text {\r\n  margin: 0;\r\n  text-align: center;\r\n  padding-right: 10px;\r\n  width: 450px;\r\n}\r\n\r\n@media screen and (max-width: 600px) {\r\n   p.banner-text {\r\n     width: 100%;\r\n     text-align: center;\r\n  }\r\n}\r\n\r\nspan.ebook-advantage {\r\n  font-size: smaller;\r\n  display: block;\r\n}\r\n\r\ndiv.banner-container {\r\n  margin: 0 auto;\r\n}\r\n\r\ndiv.banner-container ul {\r\n  margin: 0 auto;\r\n}\r\n\r\ndiv.topad { padding-bottom: 5px; }\r\n\r\ndiv.banner-container ul li {\r\n  display: inline-block;\r\n  vertical-align: middle;\r\n}\r\n\r\ndiv.banner-container li p {\r\n  padding-top: 0;\r\n  margin-top: 0;\r\n}\r\n\r\ndiv.banner-container li.sponsor {\r\n  border-right: 1px solid rgb(125, 154, 180);\r\n  margin-right: 5px;\r\n  padding-right: 10px;\r\n}\r\n\r\ndiv.banner-container .webbutton {\r\n  background-color: #3994b6;\r\n  display: inline-block;\r\n  padding: 10px;\r\n  -webkit-border-radius: 5px;\r\n  -moz-border-radius: 5px;\r\n  border-radius: 5px;\r\n  color: #FFF;\r\n  text-align: center;\r\n  text-decoration: none;\r\n  font-size: 12px;\r\n  font-weight: bold;\r\n}\r\n\r\n</style>\r\n   \r\n<div style=\"color: rgb(125, 154, 180);\">\r\n\r\n<div class=\"banner-container\">\r\n\r\n<ul>\r\n\r\n<li class=\"sponsor\">\r\n<!--CONFERENCE SPONSOR IMAGE-->\r\n<a href=\"http://www.oscon.com/oscon2013\">\r\n<!--<img src=\"http://orm-other.s3.amazonaws.com/fluent_logo.png\" class=\"ad-profile-image\"/>-->\r\n<img src=\"http://orm-other.s3.amazonaws.com/oscon_logo.png\" class=\"ad-profile-image\"/>\r\n<!--<img src=\"http://orm-other.s3.amazonaws.com/strata_logo.png\" class=\"ad-profile-image\"/>\r\n<img src=\"http://orm-other.s3.amazonaws.com/StrataRx_logo.png\" class=\"ad-profile-image\"/>\r\n<img src=\"http://orm-other.s3.amazonaws.com/velocity_logo.png\" class=\"ad-profile-image\"/>-->\r\n</a>\r\n</li>\r\n\r\n<li>\r\n<!--AD TEXT, 2 LINES, REPLACE LINK URL AS WELL-->\r\n<p class=\"banner-text\">Enjoy this online version of <em>Parallel and Concurrent Programming in Haskell</em>. Purchase and download the DRM-free ebook on <a href=\"http://shop.oreilly.com/product/0636920026365.do\">oreilly.com</a>.<span class=\"ebook-advantage\">Learn more about the O’Reilly <a href=\"http://shop.oreilly.com/category/ebooks.do\">Ebook Advantage</a>.</span></p>\r\n</li>\r\n\r\n<li>\r\n<!--BUY BUTTON-->\r\n<a class=\"webbutton\" href=\"http://shop.oreilly.com/product/0636920026365.do\">Buy the Ebook</a>\r\n</li> \r\n\r\n</ul>\r\n\r\n</div>\r\n\r\n<!--CORNER BANNER (IF NEEDED)-->\r\n<!--<a href=\"http://shop.oreilly.com/product/0636920026365.do\" class=\"top-banner\"><img src=\"http://orm-other.s3.amazonaws.com/banner.png\" /></a>-->\r\n\r\n</div>"}});

		/* Janrain setup */
  	var janrainModal = new JanrainView();
  	$("head").append(janrainModal.render().el);

  	/* segment.io setup */
  	var analytics=analytics||[];analytics.load=function(e){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src=("https:"===document.location.protocol?"https://":"http://")+"d2dq2ahtl5zl1z.cloudfront.net/analytics.js/v1/"+e+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(t,n);var r=function(e){return function(){analytics.push([e].concat(Array.prototype.slice.call(arguments,0)))}},i=["identify","track","trackLink","trackForm","trackClick","trackSubmit","pageview","ab","alias","ready"];for(var s=0;s<i.length;s++)analytics[i[s]]=r(i[s])};
  	
  	analytics.load("hg9h6b9pae");

  	$(function() {
			app.bookapp = new BookApp();
		});
	
	</script>
</head>
<body>
	<div id="menu">
	
		<ul id="menu-left">
			<li id="home-link"><a href="http://chimera.labs.oreilly.com/"><i class="icon-house"></i></a></li>
			<li><a href="http://chimera.labs.oreilly.com/books/1230000000929">Parallel and Concurrent Programming in Haskell</a></li>
			<div class="clear"></div>
		</ul>
	
		<ul id="menu-right">
			<li id="comments-link"><a>&nbsp;</a></li>
			<li>
				<a href="#" class="dropdown-toggle" data-toggle="dropdown">Chapters</a>
				<div id="toc-popup" class="dropdown-menu"></div>
			</li>
				<li><a href="#" class="capture_modal_open" id="capture_signin_link">Log In / Sign Up</a></li>
			<li id="search-li">
				<form accept-charset="UTF-8" action="http://chimera.labs.oreilly.com/searches" id="search-form" method="get"><div style="margin:0;padding:0;display:inline"><input name="utf8" type="hidden" value="&#x2713;" /></div>
	<input name='search[q]' type="text" placeholder="Search book..." id="book-search" />

	<input id="search_bookId" name="search[bookId]" type="hidden" value="1230000000929" />
	
	<div style='display:none'>
		sorted by: 
		<select name='search[sort]' >
			<option value='relevance'>Relevance</option>
			<option value='authors'>Author(s)</option>
			<option value='title'>Title</option>
		</select>
		returning
		<select name='search[limit]' >
			<option value='5'>5</option>
			<option value='10'>10</option>
			<option value='20'>20</option>
			<option selected="selected" value='50'>50</option>
			<option value='100'>100</option>
		</select>
		values at a time.
	</div>
</form>
			</li>
			<div class="clear"></div>
		</ul>
		<div class="clear"></div>
	
</div>
	<header><div class="navheader">
<table style="width: 100%; ">
<tr><td style="text-align: center; " colspan="3">Chapter 4. Dataflow Parallelism: The Par Monad</td></tr>
<tr>
<td style="width: 20%; text-align: left; ">
<a accesskey="p" href="ch03.html">Prev</a> </td>
<td style="width: 60%; text-align: center; ">Part I. Parallel Haskell</td>
<td style="width: 20%; text-align: right; "> <a accesskey="n" href="ch05.html">Next</a>
</td>
</tr>
</table>
<hr>
</div></header><section class="chapter" data-original-filename="ch04_par-monad.asciidoc" id="sec_par-monad"><div class="titlepage"><div><div><h2 class="title">Chapter 4. Dataflow Parallelism: The Par Monad</h2></div></div></div>
<p id="dataflowpar_mon"><a id="ix_ch04_par-monad-txt0" class="indexterm"></a><a id="ix_ch04_par-monad-txt1" class="indexterm"></a>In the previous two chapters, we looked at the <code class="literal">Eval</code> monad and
Strategies, which work in conjunction with lazy evaluation to express
parallelism.  A Strategy consumes a lazy data structure and evaluates
parts of it in parallel.  This model has some advantages: it allows
the decoupling of the algorithm from the parallelism, and it allows
parallel evaluation strategies to be built compositionally.  But
Strategies and <code class="literal">Eval</code> are not always the most convenient or effective
way to express parallelism.  We might not want to build a <a id="id389353" class="indexterm"></a><a id="id389361" class="indexterm"></a>lazy data
structure, for example.  Lazy evaluation brings the nice modularity
properties that we get with Strategies, but on the flip side, lazy
evaluation can make it tricky to understand and diagnose performance.</p>
<p id="in_this_chapter_id1">In this chapter, we’ll explore another parallel programming model, the
<code class="literal">Par</code> monad, with a different set of tradeoffs.  The goal of the <code class="literal">Par</code>
monad is to be more explicit about granularity and data dependencies,
and to avoid the reliance on lazy evaluation, but without sacrificing
the determinism that we value for parallel programming.
In this programming model, the programmer has to give more
detail but in return gains more control.  The <code class="literal">Par</code> monad has some
other interesting benefits; for example, it is implemented entirely as
a Haskell library and the implementation can be readily modified to
accommodate alternative scheduling strategies.</p>
<p id="the_interface_i">The interface is based around a monad called, unsurprisingly, <code class="literal">Par</code>:</p>
<pre class="programlisting" data-language="haskell" id="newtype_par_a_i"><code class="kr">newtype</code> <code class="kt">Par</code> <code class="n">a</code>
<code class="kr">instance</code> <code class="kt">Applicative</code> <code class="kt">Par</code>
<code class="kr">instance</code> <code class="kt">Monad</code> <code class="kt">Par</code>

<code class="nf">runPar</code> <code class="ow">::</code> <code class="kt">Par</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code></pre>
<p id="a_computation_i">A computation in the <code class="literal">Par</code> monad can be run using <code class="literal">runPar</code> to produce
a pure result.  The purpose of <code class="literal">Par</code> is to introduce parallelism, so
we need a way to create parallel tasks:</p>
<pre class="programlisting" data-language="haskell" id="fork__par__"><code class="nf">fork</code> <code class="ow">::</code> <code class="kt">Par</code> <code class="nb">()</code> <code class="ow">-&gt;</code> <code class="kt">Par</code> <code class="nb">()</code></pre>
<p id="the_par_computa">The <code class="literal">Par</code> computation passed as the argument<a id="id389582" class="indexterm"></a> to <code class="literal">fork</code> (the “child”)
is executed in parallel with the caller of <code class="literal">fork</code> (the “parent”).
But <code class="literal">fork</code> doesn’t return anything to the parent, so you might be
wondering how we get the result back if we start a parallel
computation with <code class="literal">fork</code>. Values can be passed between <code class="literal">Par</code> computations
using <a id="id389625" class="indexterm"></a>the <code class="literal">IVar</code> type<a href="#ftn.id389641" class="footnote"><sup class="footnote" id="id389641">[11]</sup></a> and its operations:</p>
<pre class="programlisting" data-language="haskell" id="data_ivar_a__"><code class="kr">data</code> <code class="kt">IVar</code> <code class="n">a</code>  <code class="c1">-- instance Eq</code>

<code class="nf">new</code> <code class="ow">::</code> <code class="kt">Par</code> <code class="p">(</code><code class="kt">IVar</code> <code class="n">a</code><code class="p">)</code>
<code class="nf">put</code> <code class="ow">::</code> <code class="kt">NFData</code> <code class="n">a</code> <code class="ow">=&gt;</code> <code class="kt">IVar</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Par</code> <code class="nb">()</code>
<code class="nf">get</code> <code class="ow">::</code> <code class="kt">IVar</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Par</code> <code class="n">a</code></pre>
<p id="think_of_an_iva">Think of an <code class="literal">IVar</code> as a box that starts empty.  <a id="id389833" class="indexterm"></a>The <code class="literal">put</code>
operation stores a value in the box, and <code class="literal">get</code> reads the value.  If
the <code class="literal">get</code> operation finds the box empty, then it waits until the box is
filled by a <code class="literal">put</code>.  So an <code class="literal">IVar</code> lets you communicate values between
parallel <code class="literal">Par</code> computations, because you can <code class="literal">put</code> a value in the box
in one place and <code class="literal">get</code> it in another.</p>
<p id="once_filled_th">Once filled, the box stays full; <a id="id389894" class="indexterm"></a>the <code class="literal">get</code> operation doesn’t remove
the value from the box.  It is an error to call <code class="literal">put</code> more than once
on the same <code class="literal">IVar</code>.</p>
<p id="the_ivar_type_i">The <code class="literal">IVar</code> type is a relative of the <code class="literal">MVar</code> type that we shall see
later in the context of Concurrent Haskell (<a class="xref" href="ch07.html#sec_mvars" title="Communication: MVars">“Communication: MVars”</a>), the main
difference being that an <code class="literal">IVar</code> can be written only once.  An <code class="literal">IVar</code>
is also like a <span class="emphasis"><em>future</em></span> or <span class="emphasis"><em>promise</em></span>, concepts that may be familiar to
you from other parallel or concurrent languages<a id="id389965" class="indexterm"></a>.</p>
<div class="caution" id="there_is_nothin_id1">
<p id="there_is_nothin_id2">There is nothing in the types to stop you from returning an <code class="literal">IVar</code> from
<code class="literal">runPar</code> and passing it to another call of <code class="literal">runPar</code>.  This is a Very
Bad Idea; don’t do it.  The implementation of the <code class="literal">Par</code> monad assumes
that <code class="literal">IVar</code>s are created and used within the same <code class="literal">runPar</code>, and
breaking this assumption could lead to a runtime error, deadlock,
or worse.</p>
<p id="the_library_cou">The library could prevent you from doing this using qualified types
in the same way that the <code class="literal">ST</code> monad prevents you from returning an
<code class="literal">STRef</code> from <code class="literal">runST</code>.  This is planned for a future version.</p>
</div>
<p id="together_fork_">Together, <code class="literal">fork</code> and <code class="literal">IVar</code>s allow the construction of <span class="emphasis"><em>dataflow</em></span>
networks.  Let’s see how that works with a few simple examples.</p>
<p id="well_start_in_">We’ll start in the same way we did in <a class="xref" href="ch02.html" title="Chapter 2. Basic Parallelism: The Eval Monad">Chapter 2</a>: write some
code to perform two independent computations in parallel.  As before,
I’m going to use <a id="id390086" class="indexterm"></a>the <code class="literal">fib</code> function to simulate some work we want
to do:</p>
<p id="parmonadhs_c" class="caption"><span class="emphasis"><em>parmonad.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="runpar__do_i_">    <code class="n">runPar</code> <code class="o">$</code> <code class="kr">do</code>
      <code class="n">i</code> <code class="ow">&lt;-</code> <code class="n">new</code>                          <code class="c1">-- </code><span id="CO8-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
      <code class="n">j</code> <code class="ow">&lt;-</code> <code class="n">new</code>                          <code class="c1">-- </code><span id="CO8-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>
      <code class="n">fork</code> <code class="p">(</code><code class="n">put</code> <code class="n">i</code> <code class="p">(</code><code class="n">fib</code> <code class="n">n</code><code class="p">))</code>              <code class="c1">-- </code><span id="CO8-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span>
      <code class="n">fork</code> <code class="p">(</code><code class="n">put</code> <code class="n">j</code> <code class="p">(</code><code class="n">fib</code> <code class="n">m</code><code class="p">))</code>              <code class="c1">-- </code><span id="CO8-4"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span>
      <code class="n">a</code> <code class="ow">&lt;-</code> <code class="n">get</code> <code class="n">i</code>                        <code class="c1">-- </code><span id="CO8-5"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/5.png" alt="5"></span>
      <code class="n">b</code> <code class="ow">&lt;-</code> <code class="n">get</code> <code class="n">j</code>                        <code class="c1">-- </code><span id="CO8-6"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/6.png" alt="6"></span>
      <code class="n">return</code> <code class="p">(</code><code class="n">a</code><code class="o">+</code><code class="n">b</code><code class="p">)</code>                      <code class="c1">-- </code><span id="CO8-7"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/7.png" alt="7"></span></pre>
<div class="calloutlist"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO8-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> <a href="#CO8-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="creates_two_new">
Creates two new <code class="literal">IVar</code>s to hold the results, <code class="literal">i</code> and <code class="literal">j</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO8-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> <a href="#CO8-4"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="fork_two_indepe">
<code class="literal">fork</code> two independent <code class="literal">Par</code> computations.  The first puts the
value of <code class="literal">fib n</code> into the <code class="literal">IVar</code> <code class="literal">i</code>, and the second puts the value of
<code class="literal">fib m</code> into the <code class="literal">IVar</code> <code class="literal">j</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO8-5"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/5.png" alt="5"></span></a> <a href="#CO8-6"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/6.png" alt="6"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_parent_of_t">
The parent of the two <code class="literal">fork</code>s calls <code class="literal">get</code> to wait for the
results from <code class="literal">i</code> and <code class="literal">j</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO8-7"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/7.png" alt="7"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="finally_add_th">
Finally, add the results and return.
</p></td>
</tr>
</table></div>
<p id="when_run_this_">When run, this program evaluates <code class="literal">fib n</code> and <code class="literal">fib m</code> in parallel.
To try it yourself, compile <span class="emphasis"><em>parmonad.hs</em></span> and run it passing two
values for <code class="literal">n</code> and <code class="literal">m</code>, for example:</p>
<pre class="screen" id="parmonad_">$ ./parmonad 34 35 +RTS -N2</pre>
<p id="the_pattern_in_">The pattern in this program is represented graphically in
<a class="xref" href="ch04.html#fig_parmonad" title="Figure 4-1. Simple Par example">Figure 4-1</a>.</p>
<div class="figure" id="fig_parmonad">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0401.png" alt="Simple Par example"></div></div>
<div class="figure-title">Figure 4-1. Simple Par example</div>
</div>
<p id="the_diagram_mak">The diagram makes it clear that what we are creating is <a id="id390602" class="indexterm"></a>a <span class="emphasis"><em>dataflow
graph</em></span>: that is, a graph in which the nodes (<code class="literal">fib n</code>, etc.) contain the computation
and data flows down the edges (<code class="literal">i</code> and <code class="literal">j</code>).  To be concrete, each <code class="literal">fork</code> in the
program creates a node, each <code class="literal">new</code> creates an edge, and <code class="literal">get</code> and
<code class="literal">put</code> connect the edges to the nodes.</p>
<p id="from_the_diagra">From the diagram, we can see that the two nodes containing <code class="literal">fib n</code> and
<code class="literal">fib m</code> are independent of each other, and that is why they can be
computed in parallel, which is exactly what the <code class="literal">monad-par</code> library
will do.  However, the dataflow graph doesn’t exist in any explicit
form at runtime; the library works by keeping track of all the
computations that can currently be performed <a id="id390682" class="indexterm"></a>(a <span class="emphasis"><em>work pool</em></span>), and
dividing those amongst the available processors using an appropriate
scheduling strategy.  The dataflow graph is just a way to visualize
and understand the structure of the parallelism.  Unfortunately, right
now there’s no way to generate a visual representation of the dataflow graph from some <code class="literal">Par</code> monad
code, but hopefully in the future someone will write a tool to do
that.</p>
<p id="using_dataflow_">Using dataflow to express parallelism is quite an old idea; there were
people experimenting with custom hardware architectures designed
around dataflow back in the 1970s and 1980s.  In contrast to those designs
that were focused on exploiting very fine-grained parallelism
automatically, here we are using dataflow as an explicit <a id="id390714" class="indexterm"></a>parallel
programming model.  But we are using dataflow here for the same reasons
that it was attractive back then: instead of saying
what is to be done in parallel, we only describe the data dependencies,
thereby exposing all the implicit parallelism to be exploited.</p>
<p id="while_the_par_m">While the <code class="literal">Par</code> monad is particularly suited to expressing dataflow
networks, it can also express other common patterns.  For example,
we can build an equivalent of the <code class="literal">parMap</code> combinator that we saw
earlier in <a class="xref" href="ch02.html" title="Chapter 2. Basic Parallelism: The Eval Monad">Chapter 2</a>.  To make it easier to define <code class="literal">parMap</code>,
let’s first build a simple abstraction for a parallel computation that
returns a result:</p>
<pre class="programlisting" data-language="haskell" id="spawn__nfdata"><code class="nf">spawn</code> <code class="ow">::</code> <code class="kt">NFData</code> <code class="n">a</code> <code class="ow">=&gt;</code> <code class="kt">Par</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Par</code> <code class="p">(</code><code class="kt">IVar</code> <code class="n">a</code><code class="p">)</code>
<code class="nf">spawn</code> <code class="n">p</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">i</code> <code class="ow">&lt;-</code> <code class="n">new</code>
  <code class="n">fork</code> <code class="p">(</code><code class="kr">do</code> <code class="n">x</code> <code class="ow">&lt;-</code> <code class="n">p</code><code class="p">;</code> <code class="n">put</code> <code class="n">i</code> <code class="n">x</code><code class="p">)</code>
  <code class="n">return</code> <code class="n">i</code></pre>
<p id="spawn_functioni"><a id="id390937" class="indexterm"></a>The <code class="literal">spawn</code> function forks a computation in parallel and returns an <code class="literal">IVar</code> that can be used to wait for the result.  For convenience,
<code class="literal">spawn</code> is already provided by <code class="literal">Control</code><code class="literal">.Monad.Par</code>.</p>
<p id="parallel_map_co">Parallel map consists of calling <code class="literal">spawn</code> to apply the function to
each element of the list and then waiting for all the results:</p>
<pre class="programlisting" data-language="haskell" id="parmapm__nfda"><code class="nf">parMapM</code> <code class="ow">::</code> <code class="kt">NFData</code> <code class="n">b</code> <code class="ow">=&gt;</code> <code class="p">(</code><code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Par</code> <code class="n">b</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="n">a</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="kt">Par</code> <code class="p">[</code><code class="n">b</code><code class="p">]</code>
<code class="nf">parMapM</code> <code class="n">f</code> <code class="n">as</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">ibs</code> <code class="ow">&lt;-</code> <code class="n">mapM</code> <code class="p">(</code><code class="n">spawn</code> <code class="o">.</code> <code class="n">f</code><code class="p">)</code> <code class="n">as</code>
  <code class="n">mapM</code> <code class="n">get</code> <code class="n">ibs</code></pre>
<p id="parmapm_is_als">(<code class="literal">parMapM</code> is also provided by <code class="literal">Control.Monad.Par</code>, albeit in a more
generalized form than the version shown here.)</p>
<p id="note_that_the_f">Note that the function argument, <code class="literal">f</code>, returns its result in the <code class="literal">Par</code>
monad; this means that <code class="literal">f</code> itself can create further parallelism using
<code class="literal">fork</code> and the other <code class="literal">Par</code> operations.  When the function argument of
a map is monadic, convention is to add the <code class="literal">M</code> suffix to the function
name, hence <code class="literal">parMapM</code>.</p>
<p id="it_is_straightf">It is straightforward to define a variant <a id="id391260" class="indexterm"></a>of <code class="literal">parMapM</code> that takes a
non-monadic function instead, by inserting a <code class="literal">return</code>:</p>
<pre class="programlisting" data-language="haskell" id="parmap__nfdat"><code class="nf">parMap</code> <code class="ow">::</code> <code class="kt">NFData</code> <code class="n">b</code> <code class="ow">=&gt;</code> <code class="p">(</code><code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">b</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="n">a</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="kt">Par</code> <code class="p">[</code><code class="n">b</code><code class="p">]</code>
<code class="nf">parMap</code> <code class="n">f</code> <code class="n">as</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">ibs</code> <code class="ow">&lt;-</code> <code class="n">mapM</code> <code class="p">(</code><code class="n">spawn</code> <code class="o">.</code> <code class="n">return</code> <code class="o">.</code> <code class="n">f</code><code class="p">)</code> <code class="n">as</code>
  <code class="n">mapM</code> <code class="n">get</code> <code class="n">ibs</code></pre>
<p id="one_other_thing">One other thing to note here is that, unlike the <code class="literal">parMap</code> we saw in
<a class="xref" href="ch02.html" title="Chapter 2. Basic Parallelism: The Eval Monad">Chapter 2</a>, <code class="literal">parMapM</code> and <code class="literal">parMap</code> wait for all the results
before returning. Depending on the context, this may or may not be the
most useful behavior. If you don’t want to wait for the results, then you could always just <a id="id391513" class="indexterm"></a>use <code class="literal">mapM (spawn . f)</code>, which
returns a list <a id="id391526" class="indexterm"></a>of <code class="literal">IVar</code>s.</p>
<div class="sidebar" id="strictness_of_put">
<div class="titlepage"><div><div><div class="sidebar-title">Strictness of put</div></div></div></div>
<p id="the_put_functio">The <code class="literal">put</code> function calls <code class="literal">deepseq</code> on the value it puts in the <code class="literal">IVar</code>,
which is why its type has an <code class="literal">NFData</code> constraint.  This is a
deliberate design choice; in the <code class="literal">Par</code> monad, we want the work to
happen where we expect it to, so we rule out the possibility that an
unevaluated expression is transferred via an <code class="literal">IVar</code>.</p>
<p id="this_means_that_id1">This means that <code class="literal">put</code> causes a traversal of the value stored in
the <code class="literal">IVar</code>, which can be expensive if the value is a large data
structure.  For this reason, there’s a backdoor to use if you know
what you’re doing:</p>
<pre class="programlisting" data-language="haskell" id="put___ivar_a_"><code class="nf">put_</code> <code class="ow">::</code> <code class="kt">IVar</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Par</code> <code class="nb">()</code></pre>
<p id="the_put__operat">The <code class="literal">put_</code> operation evaluates the value to WHNF only.  Replacing
<code class="literal">put</code> with <code class="literal">put_</code> can save some time if you know that the argument is
already fully evaluated.</p>
</div>
<div class="sect1" data-original-filename="ch04_par-monad.asciidoc" id="sec_par-monad-shortest-paths">
<div class="titlepage"><div><div><h2 class="title">Example: Shortest Paths in a Graph</h2></div></div></div>
<p id="dataflowand_flo"><a id="ix_ch04_par-monad-txt2" class="indexterm"></a><a id="ix_ch04_par-monad-txt3" class="indexterm"></a><a id="ix_ch04_par-monad-txt4" class="indexterm"></a>The Floyd-Warshall algorithm finds the lengths of the shortest paths
between all pairs of nodes in a weighted directed graph.  The
algorithm is quite simple and can be expressed as a function over
three vertices.  Assuming vertices are numbered from one, and we have
a function <code class="literal">weight g i j</code> that gives the weight of the edge from <code class="literal">i</code>
to <code class="literal">j</code> in graph <code class="literal">g</code>, the algorithm is described by this <a id="id391780" class="indexterm"></a>pseudocode:</p>
<pre class="screen" id="shortestpath__id1">shortestPath :: Graph -&gt; Vertex -&gt; Vertex -&gt; Vertex -&gt; Weight
shortestPath g i j 0 = weight g i j
shortestPath g i j k = min (shortestPath g i j (k-1))
                           (shortestPath g i k (k-1) + shortestPath g k j (k-1))</pre>
<p id="you_can_think_o">You can think of the algorithm intuitively this way: <code class="literal">shortestPath g i j k</code> gives the length of the shortest path from <code class="literal">i</code> to <code class="literal">j</code>, passing through vertices up to <code class="literal">k</code>
only.  At <code class="literal">k == 0</code>, the paths between each pair of vertices consists
of the direct edges only.  For a non-zero <code class="literal">k</code>, there are two cases:
either the shortest path from <code class="literal">i</code> to <code class="literal">j</code> passes through <code class="literal">k</code>, or it
does not.  The shortest path passing through <code class="literal">k</code> is given by the sum
of the shortest path from <code class="literal">i</code> to <code class="literal">k</code> and from <code class="literal">k</code> to <code class="literal">j</code>. Then the
shortest path from <code class="literal">i</code> to <code class="literal">j</code> is the minimum of the two choices,
either passing through <code class="literal">k</code> or not.</p>
<p id="we_wouldnt_wan">We wouldn’t want to implement the algorithm like this directly,
because it requires an exponential number of <a id="id391916" class="indexterm"></a>recursive calls.  This is a
classic example of a dynamic programming problem: rather than
recursing top-down, we can build the solution bottom-up, so that
earlier results can be used when computing later ones.  In this case,
we want to start by computing the shortest paths between all pairs of
nodes for <code class="literal">k == 0</code>, then for <code class="literal">k == 1</code>, and so on until <code class="literal">k</code> reaches the
maximum vertex.  Each step is <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span><sup>2</sup>) in the vertices, so the
whole algorithm is <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span><sup>3</sup>).</p>
<p id="the_algorithm_i_id1">The algorithm is often run over an <a id="id391970" class="indexterm"></a>adjacency matrix, which is a very
efficient representation of a dense graph.  But here we’re going to
assume a <a id="id391981" class="indexterm"></a>sparse graph (most pairs of vertices do not have an edge
between them), and use a representation more suitable for this case:</p>
<p id="fwsparsesparse" class="caption"><span class="emphasis"><em>fwsparse/SparseGraph.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="type_vertex__i"><code class="kr">type</code> <code class="kt">Vertex</code> <code class="ow">=</code> <code class="kt">Int</code>
<code class="kr">type</code> <code class="kt">Weight</code> <code class="ow">=</code> <code class="kt">Int</code>

<code class="kr">type</code> <code class="kt">Graph</code> <code class="ow">=</code> <code class="kt">IntMap</code> <code class="p">(</code><code class="kt">IntMap</code> <code class="kt">Weight</code><code class="p">)</code>

<code class="nf">weight</code> <code class="ow">::</code> <code class="kt">Graph</code> <code class="ow">-&gt;</code> <code class="kt">Vertex</code> <code class="ow">-&gt;</code> <code class="kt">Vertex</code> <code class="ow">-&gt;</code> <code class="kt">Maybe</code> <code class="kt">Weight</code>
<code class="nf">weight</code> <code class="n">g</code> <code class="n">i</code> <code class="n">j</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">jmap</code> <code class="ow">&lt;-</code> <code class="kt">Map</code><code class="o">.</code><code class="n">lookup</code> <code class="n">i</code> <code class="n">g</code>
  <code class="kt">Map</code><code class="o">.</code><code class="n">lookup</code> <code class="n">j</code> <code class="n">jmap</code></pre>
<p id="the_graph_is_es">The graph is essentially a mapping from pairs of nodes to weights, but
it is represented more efficiently as a two-layer map.  For example, to find
the edge between <code class="literal">i</code> and <code class="literal">j</code>, we look up <code class="literal">i</code> in the outer map,
yielding another map in which we look up <code class="literal">j</code> to find the weight.  The<a id="id392274" class="indexterm"></a>
function <code class="literal">weight</code> embodies this pair of lookups using the <code class="literal">Maybe</code>
monad.  If there is no edge between the two vertices, then <code class="literal">weight</code>
returns <code class="literal">Nothing</code>.</p>
<p id="here_is_the_seq">Here is the sequential implementation of the shortest path algorithm:</p>
<p id="fwsparsefwspar" class="caption"><span class="emphasis"><em>fwsparse/fwsparse.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="shortestpaths__id1"><code class="nf">shortestPaths</code> <code class="ow">::</code> <code class="p">[</code><code class="kt">Vertex</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="kt">Graph</code> <code class="ow">-&gt;</code> <code class="kt">Graph</code>
<code class="nf">shortestPaths</code> <code class="n">vs</code> <code class="n">g</code> <code class="ow">=</code> <code class="n">foldl'</code> <code class="n">update</code> <code class="n">g</code> <code class="n">vs</code>            <code class="c1">-- </code><span id="CO9-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
 <code class="kr">where</code>
  <code class="n">update</code> <code class="n">g</code> <code class="n">k</code> <code class="ow">=</code> <code class="kt">Map</code><code class="o">.</code><code class="n">mapWithKey</code> <code class="n">shortmap</code> <code class="n">g</code>           <code class="c1">-- </code><span id="CO9-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>
   <code class="kr">where</code>
     <code class="n">shortmap</code> <code class="ow">::</code> <code class="kt">Vertex</code> <code class="ow">-&gt;</code> <code class="kt">IntMap</code> <code class="kt">Weight</code> <code class="ow">-&gt;</code> <code class="kt">IntMap</code> <code class="kt">Weight</code>
     <code class="n">shortmap</code> <code class="n">i</code> <code class="n">jmap</code> <code class="ow">=</code> <code class="n">foldr</code> <code class="n">shortest</code> <code class="kt">Map</code><code class="o">.</code><code class="n">empty</code> <code class="n">vs</code> <code class="c1">-- </code><span id="CO9-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span>
        <code class="kr">where</code> <code class="n">shortest</code> <code class="n">j</code> <code class="n">m</code> <code class="ow">=</code>
                <code class="kr">case</code> <code class="p">(</code><code class="n">old</code><code class="p">,</code><code class="n">new</code><code class="p">)</code> <code class="kr">of</code>                  <code class="c1">-- </code><span id="CO9-4"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span>
                   <code class="p">(</code><code class="kt">Nothing</code><code class="p">,</code> <code class="kt">Nothing</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="n">m</code>
                   <code class="p">(</code><code class="kt">Nothing</code><code class="p">,</code> <code class="kt">Just</code> <code class="n">w</code> <code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">Map</code><code class="o">.</code><code class="n">insert</code> <code class="n">j</code> <code class="n">w</code> <code class="n">m</code>
                   <code class="p">(</code><code class="kt">Just</code> <code class="n">w</code><code class="p">,</code>  <code class="kt">Nothing</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">Map</code><code class="o">.</code><code class="n">insert</code> <code class="n">j</code> <code class="n">w</code> <code class="n">m</code>
                   <code class="p">(</code><code class="kt">Just</code> <code class="n">w1</code><code class="p">,</code> <code class="kt">Just</code> <code class="n">w2</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">Map</code><code class="o">.</code><code class="n">insert</code> <code class="n">j</code> <code class="p">(</code><code class="n">min</code> <code class="n">w1</code> <code class="n">w2</code><code class="p">)</code> <code class="n">m</code>
                <code class="kr">where</code>
                  <code class="n">old</code> <code class="ow">=</code> <code class="kt">Map</code><code class="o">.</code><code class="n">lookup</code> <code class="n">j</code> <code class="n">jmap</code>          <code class="c1">-- </code><span id="CO9-5"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/5.png" alt="5"></span>
                  <code class="n">new</code> <code class="ow">=</code> <code class="kr">do</code> <code class="n">w1</code> <code class="ow">&lt;-</code> <code class="n">weight</code> <code class="n">g</code> <code class="n">i</code> <code class="n">k</code>      <code class="c1">-- </code><span id="CO9-6"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/6.png" alt="6"></span>
                           <code class="n">w2</code> <code class="ow">&lt;-</code> <code class="n">weight</code> <code class="n">g</code> <code class="n">k</code> <code class="n">j</code>
                           <code class="n">return</code> <code class="p">(</code><code class="n">w1</code><code class="o">+</code><code class="n">w2</code><code class="p">)</code></pre>
<p id="shortestpaths_t"><code class="literal">shortestPaths</code> takes a list of vertices in addition to the graph; we
could have derived this from the graph, but it’s slightly more
convenient to pass it in.  The result is also a <code class="literal">Graph</code>, but instead
of containing the weights of the edges between vertices, it contains
the lengths of the shortest paths between vertices.  For simplicity,
we’re not returning the shortest paths themselves, although this can
be added without affecting the asymptotic time or space complexity.</p>
<div class="calloutlist"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO9-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_algorithm_a">
The algorithm as a whole is a left-fold over the list of vertices;
this corresponds to iterating over values of <code class="literal">k</code> in the pseudocode
description shown earlier.  At each stage we add a new vertex to the set of
vertices that can be used to construct paths, until at the end we have
paths that can use all the vertices.  Note that we use the strict
left-fold<a id="id393146" class="indexterm"></a><a id="id393152" class="indexterm"></a>, <code class="literal">foldl'</code>, to ensure that we’re evaluating the graph at
every step and not building up a chain of thunks (we’re also using a
strict <code class="literal">IntMap</code> to avoid thunks building up inside the <code class="literal">Graph</code>; this
turns out to be vital for avoiding a space leak).
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO9-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_update_upda">
The <code class="literal">update</code> <a id="id393196" class="indexterm"></a>function computes each step by mapping the function
<code class="literal">shortmap</code> over the outer <code class="literal">IntMap</code> in the graph.  There’s no need to
map over the whole list of vertices because we know that any vertex
that does not have an entry in the outer map cannot have a path to any
other vertex (although it might have <span class="emphasis"><em>incoming</em></span> paths).
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO9-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="shortmap_takes_">
<code class="literal">shortmap</code> takes <code class="literal">i</code>, the current vertex, and <code class="literal">jmap</code>, the mapping
of shortest paths from <code class="literal">i</code>.  This function <span class="emphasis"><em>does</em></span> need to consider
every vertex in the graph as a possible destination because there may
be vertices that we can reach from <code class="literal">i</code> via <code class="literal">k</code>, but which do
not currently have an entry in <code class="literal">jmap</code>.  So here we’re building up a
new <code class="literal">jmap</code> by folding over the list of vertices, <code class="literal">vs</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO9-5"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/5.png" alt="5"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="for_a_given_j_">
For a given <code class="literal">j</code>, look up the current shortest path from <code class="literal">i</code> to
<code class="literal">j</code>, and call it <code class="literal">old</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO9-6"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/6.png" alt="6"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="look_up_the_sho">
Look up the shortest path from <code class="literal">i</code> to <code class="literal">j</code> via <code class="literal">k</code> (if one
exists), and call it <code class="literal">new</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO9-4"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="find_the_minimu">
Find the minimum of <code class="literal">old</code> and <code class="literal">new</code>, and insert it into the new
mapping. Naturally, one path is the winner if the other path does not
exist.
</p></td>
</tr>
</table></div>
<p id="the_algorithm_i_id2">The algorithm is a nest of three loops. The outer loop is a left-fold
with a data dependency between iterations, so it cannot be
parallelized (as a side note, <a id="id393392" class="indexterm"></a>folds can be parallelized only when the
operation being folded is associative, and then the linear fold can be
turned into a tree).  The next loop, however, is a map:</p>
<pre class="programlisting" data-language="haskell" id="update_g_k__ma">  <code class="n">update</code> <code class="n">g</code> <code class="n">k</code> <code class="ow">=</code> <code class="kt">Map</code><code class="o">.</code><code class="n">mapWithKey</code> <code class="n">shortmap</code> <code class="n">g</code></pre>
<p id="as_we_know_map">As we know, maps parallelize nicely.  Will this give the right
<a id="id393464" class="indexterm"></a>granularity?  The map is over the outer <code class="literal">IntMap</code> of the <code class="literal">Graph</code>, so
there will be as many tasks as there are vertices without edges.
There will typically be at least hundreds of edges in the graph, so
there are clearly enough separate work items to keep even tens of
cores busy.  Furthermore, each task is an <span class="emphasis"><em>O</em></span>(<span class="emphasis"><em>n</em></span>) loop over the list
of vertices, so we are unlikely to have problems with the granularity
being too fine.</p>
<p id="lets_consider_">Let’s consider how to add parallelism here.  It’s not an ordinary
<code class="literal">map</code>—we’re using <a id="id393508" class="indexterm"></a>the <code class="literal">mapWithKey</code> function provided by <code class="literal">Data.IntMap</code>
to map directly over the <code class="literal">IntMap</code>.  We could turn the <code class="literal">IntMap</code> into a
list, run a standard <code class="literal">parMap</code> over that, and then turn it back into an
<code class="literal">IntMap</code>, but the conversion to and from a list would add some
overhead.  Fortunately, the <code class="literal">IntMap</code> library provides a way to
traverse an <code class="literal">IntMap</code> in a monad:</p>
<pre class="programlisting" data-language="haskell" id="traversewithkey"><code class="nf">traverseWithKey</code> <code class="ow">::</code> <code class="kt">Applicative</code> <code class="n">t</code>
                <code class="ow">=&gt;</code> <code class="p">(</code><code class="kt">Key</code> <code class="ow">-&gt;</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">t</code> <code class="n">b</code><code class="p">)</code>
                <code class="ow">-&gt;</code> <code class="kt">IntMap</code> <code class="n">a</code>
                <code class="ow">-&gt;</code> <code class="n">t</code> <code class="p">(</code><code class="kt">IntMap</code> <code class="n">b</code><code class="p">)</code></pre>
<p id="dont_worry_if_">Don’t worry if you’re not familiar with <a id="id393693" class="indexterm"></a><a id="id393698" class="indexterm"></a>the <code class="literal">Applicative</code> type class; most of the time, you can read <code class="literal">Applicative</code> as <code class="literal">Monad</code> and you’ll be fine.  All the standard <code class="literal">Monad</code> types are also <code class="literal">Applicative</code>, and in general any <code class="literal">Monad</code> can be made into an <code class="literal">Applicative</code> easily.<a href="#ftn.id393748" class="footnote"><sup class="footnote" id="id393748">[12]</sup></a></p>
<p id="so_traversewith">So <code class="literal">traverseWithKey</code> essentially maps a monadic function over the
<code class="literal">IntMap</code>, for any monad <code class="literal">t</code>.  The monadic function is passed not only
the element <code class="literal">a</code>, but also the <code class="literal">Key</code>, which is just what we need here:
<code class="literal">shortmap</code> needs both the key (the source vertex) and the element (the
map from destination vertices to weights).</p>
<p id="so_we_want_to_b">So we want to behave like <code class="literal">parMap</code>, except that we’ll use
<code class="literal">traverseWithKey</code> to map over the <code class="literal">IntMap</code>.  Here is the parallel code
for <code class="literal">update</code>:</p>
<pre class="programlisting" data-language="haskell" id="update_g_k__ru">  <code class="n">update</code> <code class="n">g</code> <code class="n">k</code> <code class="ow">=</code> <code class="n">runPar</code> <code class="o">$</code> <code class="kr">do</code>
    <code class="n">m</code> <code class="ow">&lt;-</code> <code class="kt">Map</code><code class="o">.</code><code class="n">traverseWithKey</code> <code class="p">(</code><code class="nf">\</code><code class="n">i</code> <code class="n">jmap</code> <code class="ow">-&gt;</code> <code class="n">spawn</code> <code class="p">(</code><code class="n">return</code> <code class="p">(</code><code class="n">shortmap</code> <code class="n">i</code> <code class="n">jmap</code><code class="p">)))</code> <code class="n">g</code>
    <code class="n">traverse</code> <code class="n">get</code> <code class="n">m</code></pre>
<p id="weve_put_runpa">We’ve put <code class="literal">runPar</code> inside <code class="literal">update</code>; the rest of the <code class="literal">shortestPaths</code>
function will remain as before, and all the parallelism is confined to
<code class="literal">update</code>.  We’re calling <code class="literal">traverseWithKey</code> to <code class="literal">spawn</code> a call to
<code class="literal">shortmap</code> for each of the elements of the <code class="literal">IntMap</code>.  The result of
this call will be an <a id="id394048" class="indexterm"></a><code class="literal">IntMap (IVar (IntMap Weight))</code>; that is, there’s an <code class="literal">IVar</code> in place of each element.  To get the new <code class="literal">Graph</code>, we need
to call <code class="literal">get</code> on each of these <code class="literal">IVar</code>s and produce a new <code class="literal">Graph</code>
with all the elements, which is what the final call to <code class="literal">traverse</code>
does.  The <code class="literal">traverse</code> function is from <a id="id394105" class="indexterm"></a>the <code class="literal">Traversable</code> class; for
our purposes here, it is like <code class="literal">traverseWithKey</code> but doesn’t pass the
<code class="literal">Key</code> to the function.</p>
<p id="lets_take_a_lo">Let’s take a look at the speedup we get from this code.  Running the
original program on a random graph with 800 edges over 1,000 vertices:</p>
<pre class="screen" id="fwsparse__id1">$ ./fwsparse 1000 800 +RTS -s
...
  Total   time    4.16s  (  4.17s elapsed)</pre>
<p id="and_our_paralle">And our parallel version, first on one core:</p>
<pre class="screen" id="fwsparse__id2">$ ./fwsparse1 1000 800 +RTS -s
...
  Total   time    4.54s  (  4.57s elapsed)</pre>
<p id="adding_the_para">Adding the parallel traversal has cost us about 10% overhead; this is
quite a lot, and if we were optimizing this program for real, we would
want to look into whether that overhead can be reduced.  Perhaps it is
caused by doing <a id="id394172" class="indexterm"></a><a id="id394180" class="indexterm"></a>one <code class="literal">runPar</code> per iteration (a <code class="literal">runPar</code> is
quite expensive) or perhaps <code class="literal">traverseWithKey</code> is expensive.</p>
<p id="the_speedup_on_">The speedup on four cores is fairly respectable:</p>
<pre class="screen" id="fwsparse__id3">$ ./fwsparse1 1000 800 +RTS -s -N4
...
  Total   time    5.27s  (  1.38s elapsed)</pre>
<p id="this_gives_us_a">This gives us a speedup of 3.02 over the sequential version.  To improve
this speedup further, the first target would be to reduce the overhead
of the parallel version.<a id="id394231" class="indexterm"></a><a id="id394240" class="indexterm"></a><a id="id394249" class="indexterm"></a></p>
</div>
<div class="sect1" data-original-filename="ch04_par-monad.asciidoc" id="sec_par-monad-streams">
<div class="titlepage"><div><div><h2 class="title">Pipeline Parallelism</h2></div></div></div>
<p id="dataflowpipleli"><a id="ix_ch04_par-monad-txt5" class="indexterm"></a><a id="ix_ch04_par-monad-txt6" class="indexterm"></a><a id="ix_ch04_par-monad-txt7" class="indexterm"></a>Next, we’re going to look at a different way to expose parallelism:
<span class="emphasis"><em>pipeline</em></span> parallelism.  Back in <a class="xref" href="ch03.html#sec_parBuffer" title="Parallelizing Lazy Streams with parBuffer">“Parallelizing Lazy Streams with parBuffer”</a>, we saw how to use
parallelism in a program that consumed and produced input lazily,
although in that case we <a id="id394331" class="indexterm"></a>used <span class="emphasis"><em>data parallelism</em></span>, which is parallelism between
the stream elements.  Here, we’re going to show how to make use of
parallelism between the stages of a pipeline. For example, we might have a pipeline that looks like this:</p>
<div class="informalfigure" id="informalfigure"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_04in01.png"></div></div>
<p id="each_stage_of_t">Each stage of the pipeline is doing some computation on the
<a id="id394368" class="indexterm"></a>stream elements and maintaining state as it does so.  When a
pipeline stage maintains some state, we can’t exploit parallelism between
the stream elements as we did in <a class="xref" href="ch03.html#sec_parBuffer" title="Parallelizing Lazy Streams with parBuffer">“Parallelizing Lazy Streams with parBuffer”</a>.  Instead, we would
like each of the pipeline stages to run on a separate core, with the
data streaming between them.  The <code class="literal">Par</code> monad, together with the
techniques in this section, allows us to do that.</p>
<p id="the_basic_idea_">The basic idea is as follows: instead of representing the stream as a
lazy list, use an explicit representation of a stream:</p>
<pre class="programlisting" data-language="haskell" id="data_ilist_a___id1"><code class="kr">data</code> <code class="kt">IList</code> <code class="n">a</code>
  <code class="ow">=</code> <code class="kt">Nil</code>
  <code class="o">|</code> <code class="kt">Cons</code> <code class="n">a</code> <code class="p">(</code><code class="kt">IVar</code> <code class="p">(</code><code class="kt">IList</code> <code class="n">a</code><code class="p">))</code>

<code class="kr">type</code> <code class="kt">Stream</code> <code class="n">a</code> <code class="ow">=</code> <code class="kt">IVar</code> <code class="p">(</code><code class="kt">IList</code> <code class="n">a</code><code class="p">)</code></pre>
<p id="ilist_data_type"><a id="id394534" class="indexterm"></a>An <code class="literal">IList</code> is a list with an <code class="literal">IVar</code> as the tail.  This allows the
producer to generate the list incrementally, while a consumer runs in
parallel, grabbing elements as they are produced.  <a id="id394556" class="indexterm"></a>A <code class="literal">Stream</code> is an
<code class="literal">IVar</code> containing an <code class="literal">IList</code>.</p>
<p id="well_need_a_fe">We’ll need a few functions for working with <code class="literal">Stream</code>s.  First, we need a
generic producer that turns a lazy list into a <code class="literal">Stream</code>:</p>
<pre class="programlisting" data-language="haskell" id="streamfromlist_"><code class="nf">streamFromList</code> <code class="ow">::</code> <code class="kt">NFData</code> <code class="n">a</code> <code class="ow">=&gt;</code> <code class="p">[</code><code class="n">a</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="kt">Par</code> <code class="p">(</code><code class="kt">Stream</code> <code class="n">a</code><code class="p">)</code>
<code class="nf">streamFromList</code> <code class="n">xs</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">var</code> <code class="ow">&lt;-</code> <code class="n">new</code>                            <code class="c1">-- </code><span id="CO10-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
  <code class="n">fork</code> <code class="o">$</code> <code class="n">loop</code> <code class="n">xs</code> <code class="n">var</code>                    <code class="c1">-- </code><span id="CO10-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>
  <code class="n">return</code> <code class="n">var</code>                            <code class="c1">-- </code><span id="CO10-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span>
 <code class="kr">where</code>
  <code class="n">loop</code> <code class="kt">[]</code> <code class="n">var</code> <code class="ow">=</code> <code class="n">put</code> <code class="n">var</code> <code class="kt">Nil</code>             <code class="c1">-- </code><span id="CO10-4"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span>
  <code class="n">loop</code> <code class="p">(</code><code class="n">x</code><code class="kt">:</code><code class="n">xs</code><code class="p">)</code> <code class="n">var</code> <code class="ow">=</code> <code class="kr">do</code>                  <code class="c1">-- </code><span id="CO10-5"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/5.png" alt="5"></span>
    <code class="n">tail</code> <code class="ow">&lt;-</code> <code class="n">new</code>                         <code class="c1">-- </code><span id="CO10-6"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/6.png" alt="6"></span>
    <code class="n">put</code> <code class="n">var</code> <code class="p">(</code><code class="kt">Cons</code> <code class="n">x</code> <code class="n">tail</code><code class="p">)</code>               <code class="c1">-- </code><span id="CO10-7"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/7.png" alt="7"></span>
    <code class="n">loop</code> <code class="n">xs</code> <code class="n">tail</code>                        <code class="c1">-- </code><span id="CO10-8"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/8.png" alt="8"></span></pre>
<div class="calloutlist"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO10-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="creates_the_iva">
Creates the <code class="literal">IVar</code> that will be the <code class="literal">Stream</code> itself.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO10-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="forks_the_loop_">
<code class="literal">fork</code>s the loop that will create the <code class="literal">Stream</code> contents.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO10-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="returns_the_str">
Returns the <code class="literal">Stream</code> to the caller.  The <code class="literal">Stream</code> is now being created in parallel.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO10-4"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="this_loop_trave">
This <code class="literal">loop</code> traverses the input list, producing the <code class="literal">IList</code> as it
goes.  The first argument is the list, and the second argument is the
<code class="literal">IVar</code> into which to store the <code class="literal">IList</code>.  In the case of an empty list, we
simply store an empty <code class="literal">IList</code> into the <code class="literal">IVar</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO10-5"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/5.png" alt="5"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="in_the_case_of_">
In the case of a non-empty list,
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO10-6"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/6.png" alt="6"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="we_create_a_new">
we create a new <code class="literal">IVar</code> for the
tail,
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO10-7"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/7.png" alt="7"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="and_store_a_con">
and store a <code class="literal">Cons</code> cell representing this element into the current
<code class="literal">IVar</code>.  Note that this fully evaluates the list element <code class="literal">x</code>, because
<code class="literal">put</code> is strict.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO10-8"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/8.png" alt="8"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="recurse_to_crea">
Recurse to create the rest of the stream.
</p></td>
</tr>
</table></div>
<p id="next_well_wri">Next, we’ll write a consumer <a id="id395194" class="indexterm"></a>of <code class="literal">Stream</code>s, <code class="literal">streamFold</code>:</p>
<pre class="programlisting" data-language="haskell" id="streamfold__"><code class="nf">streamFold</code> <code class="ow">::</code> <code class="p">(</code><code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">b</code> <code class="ow">-&gt;</code> <code class="n">a</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Stream</code> <code class="n">b</code> <code class="ow">-&gt;</code> <code class="kt">Par</code> <code class="n">a</code>
<code class="nf">streamFold</code> <code class="n">fn</code> <code class="o">!</code><code class="n">acc</code> <code class="n">instrm</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">ilst</code> <code class="ow">&lt;-</code> <code class="n">get</code> <code class="n">instrm</code>
  <code class="kr">case</code> <code class="n">ilst</code> <code class="kr">of</code>
    <code class="kt">Nil</code>      <code class="ow">-&gt;</code> <code class="n">return</code> <code class="n">acc</code>
    <code class="kt">Cons</code> <code class="n">h</code> <code class="n">t</code> <code class="ow">-&gt;</code> <code class="n">streamFold</code> <code class="n">fn</code> <code class="p">(</code><code class="n">fn</code> <code class="n">acc</code> <code class="n">h</code><code class="p">)</code> <code class="n">t</code></pre>
<p id="this_is_a_left">This is a left-fold over the <code class="literal">Stream</code> and is defined exactly as you
would expect: recursing through the <code class="literal">IList</code> and accumulating the result
until the end of the <code class="literal">Stream</code> is reached.  If the <code class="literal">streamFold</code>
consumes all the available stream elements and catches up with the
producer, it will block in the <code class="literal">get</code> call waiting for the next
element.</p>
<p id="the_final_opera">The final operation we’ll need is a map over <code class="literal">Stream</code>s.  This is
both a producer and a consumer:</p>
<pre class="programlisting" data-language="haskell" id="streammap__nf"><code class="nf">streamMap</code> <code class="ow">::</code> <code class="kt">NFData</code> <code class="n">b</code> <code class="ow">=&gt;</code> <code class="p">(</code><code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">b</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">Stream</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Par</code> <code class="p">(</code><code class="kt">Stream</code> <code class="n">b</code><code class="p">)</code>
<code class="nf">streamMap</code> <code class="n">fn</code> <code class="n">instrm</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">outstrm</code> <code class="ow">&lt;-</code> <code class="n">new</code>
  <code class="n">fork</code> <code class="o">$</code> <code class="n">loop</code> <code class="n">instrm</code> <code class="n">outstrm</code>
  <code class="n">return</code> <code class="n">outstrm</code>
 <code class="kr">where</code>
  <code class="n">loop</code> <code class="n">instrm</code> <code class="n">outstrm</code> <code class="ow">=</code> <code class="kr">do</code>
    <code class="n">ilst</code> <code class="ow">&lt;-</code> <code class="n">get</code> <code class="n">instrm</code>
    <code class="kr">case</code> <code class="n">ilst</code> <code class="kr">of</code>
      <code class="kt">Nil</code> <code class="ow">-&gt;</code> <code class="n">put</code> <code class="n">outstrm</code> <code class="kt">Nil</code>
      <code class="kt">Cons</code> <code class="n">h</code> <code class="n">t</code> <code class="ow">-&gt;</code> <code class="kr">do</code>
        <code class="n">newtl</code> <code class="ow">&lt;-</code> <code class="n">new</code>
        <code class="n">put</code> <code class="n">outstrm</code> <code class="p">(</code><code class="kt">Cons</code> <code class="p">(</code><code class="n">fn</code> <code class="n">h</code><code class="p">)</code> <code class="n">newtl</code><code class="p">)</code>
        <code class="n">loop</code> <code class="n">t</code> <code class="n">newtl</code></pre>
<p id="theres_nothing_id1">There’s nothing particularly surprising here—the pattern is a
combination of the producer we saw in <code class="literal">streamFromList</code> and the consumer
in <code class="literal">streamFold</code>.</p>
<p id="to_demonstrate_">To demonstrate that this works, I’ll construct an example using the
RSA encryption code that we saw earlier in <a class="xref" href="ch03.html#sec_parBuffer" title="Parallelizing Lazy Streams with parBuffer">“Parallelizing Lazy Streams with parBuffer”</a>.
However, this time, in order to construct a nontrivial pipeline, I’ll compose
together encryption and decryption; encryption will produce a stream
that decryption consumes (admittedly this isn’t a realistic use case,
but it does demonstrate pipeline parallelism).</p>
<p id="previouslydecry">Previously<a id="id395961" class="indexterm"></a><a id="id395967" class="indexterm"></a>, <code class="literal">encrypt</code> and <code class="literal">decrypt</code> consumed and produced lazy
<code class="literal">ByteStrings</code>.  Now they work over <code class="literal">Stream ByteString</code> in the <code class="literal">Par</code>
monad, and are expressed as a <code class="literal">streamMap</code>:</p>
<p id="rsapipelinehs" class="caption"><span class="emphasis"><em>rsa-pipeline.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="encrypt__inte_id2"><code class="nf">encrypt</code> <code class="ow">::</code> <code class="kt">Integer</code> <code class="ow">-&gt;</code> <code class="kt">Integer</code> <code class="ow">-&gt;</code> <code class="kt">Stream</code> <code class="kt">ByteString</code> <code class="ow">-&gt;</code> <code class="kt">Par</code> <code class="p">(</code><code class="kt">Stream</code> <code class="kt">ByteString</code><code class="p">)</code>
<code class="nf">encrypt</code> <code class="n">n</code> <code class="n">e</code> <code class="n">s</code> <code class="ow">=</code> <code class="n">streamMap</code> <code class="p">(</code><code class="kt">B</code><code class="o">.</code><code class="n">pack</code> <code class="o">.</code> <code class="n">show</code> <code class="o">.</code> <code class="n">power</code> <code class="n">e</code> <code class="n">n</code> <code class="o">.</code> <code class="n">code</code><code class="p">)</code> <code class="n">s</code>

<code class="nf">decrypt</code> <code class="ow">::</code> <code class="kt">Integer</code> <code class="ow">-&gt;</code> <code class="kt">Integer</code> <code class="ow">-&gt;</code> <code class="kt">Stream</code> <code class="kt">ByteString</code> <code class="ow">-&gt;</code> <code class="kt">Par</code> <code class="p">(</code><code class="kt">Stream</code> <code class="kt">ByteString</code><code class="p">)</code>
<code class="nf">decrypt</code> <code class="n">n</code> <code class="n">d</code> <code class="n">s</code> <code class="ow">=</code> <code class="n">streamMap</code> <code class="p">(</code><code class="kt">B</code><code class="o">.</code><code class="n">pack</code> <code class="o">.</code> <code class="n">decode</code> <code class="o">.</code> <code class="n">power</code> <code class="n">d</code> <code class="n">n</code> <code class="o">.</code> <code class="n">integer</code><code class="p">)</code> <code class="n">s</code></pre>
<p id="the_following_f_id1">The following function composes these together and also adds a
<code class="literal">streamFromList</code> to create the input <code class="literal">Stream</code> and a <code class="literal">streamFold</code> to
consume the result:</p>
<pre class="programlisting" data-language="haskell" id="pipeline__int"><code class="nf">pipeline</code> <code class="ow">::</code> <code class="kt">Integer</code> <code class="ow">-&gt;</code> <code class="kt">Integer</code> <code class="ow">-&gt;</code> <code class="kt">Integer</code> <code class="ow">-&gt;</code> <code class="kt">ByteString</code> <code class="ow">-&gt;</code> <code class="kt">ByteString</code>
<code class="nf">pipeline</code> <code class="n">n</code> <code class="n">e</code> <code class="n">d</code> <code class="n">b</code> <code class="ow">=</code> <code class="n">runPar</code> <code class="o">$</code> <code class="kr">do</code>
  <code class="n">s0</code> <code class="ow">&lt;-</code> <code class="n">streamFromList</code> <code class="p">(</code><code class="n">chunk</code> <code class="p">(</code><code class="n">size</code> <code class="n">n</code><code class="p">)</code> <code class="n">b</code><code class="p">)</code>
  <code class="n">s1</code> <code class="ow">&lt;-</code> <code class="n">encrypt</code> <code class="n">n</code> <code class="n">e</code> <code class="n">s0</code>
  <code class="n">s2</code> <code class="ow">&lt;-</code> <code class="n">decrypt</code> <code class="n">n</code> <code class="n">d</code> <code class="n">s1</code>
  <code class="n">xs</code> <code class="ow">&lt;-</code> <code class="n">streamFold</code> <code class="p">(</code><code class="nf">\</code><code class="n">x</code> <code class="n">y</code> <code class="ow">-&gt;</code> <code class="p">(</code><code class="n">y</code> <code class="kt">:</code> <code class="n">x</code><code class="p">))</code> <code class="kt">[]</code> <code class="n">s2</code>
  <code class="n">return</code> <code class="p">(</code><code class="kt">B</code><code class="o">.</code><code class="n">unlines</code> <code class="p">(</code><code class="n">reverse</code> <code class="n">xs</code><code class="p">))</code></pre>
<p id="note_that_strea">Note that <a id="id396770" class="indexterm"></a>the <code class="literal">streamFold</code> produces a list of <code class="literal">ByteString</code>s at the end,
to which we apply <code class="literal">unlines</code>, and then the caller prints out the
result.</p>
<p id="this_works_rath">This works rather nicely: I see a speedup of 1.45 running the program
over a large text file.  What’s the <a id="id396804" class="indexterm"></a>maximum speedup we can achieve
here?  Well, there are four independent pipeline stages:
<code class="literal">streamFromList</code>, two <code class="literal">streamMap</code>s, and a <code class="literal">streamFold</code>, although
only the two maps really involve any significant
computation.<a href="#ftn.id396832" class="footnote"><sup class="footnote" id="id396832">[13]</sup></a>
So the best we can hope for is to reduce the running time to the
longer of the two maps.  We can verify, by timing the <span class="emphasis"><em>rsa.hs</em></span> program,
that encryption takes approximately twice as long as decryption, which
means that we can expect a speedup of about 1.5, which is close to
the sample run here.</p>
<p id="the_threadscope">The ThreadScope profile of this program is quite revealing. <a class="xref" href="ch04.html#fig_rsa-pipeline" title="Figure 4-2. ThreadScope profile of rsa-pipeline">Figure 4-2</a> is a
typical section from it.</p>
<div class="figure" id="fig_rsa-pipeline">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0402.png" alt="ThreadScope profile of rsa-pipeline"></div></div>
<div class="figure-title">Figure 4-2. ThreadScope profile of rsa-pipeline</div>
</div>
<p id="hec__appears_t">HEC 0 appears to be doing the encryption, and HEC 1 the decryption.
Decryption is faster than encryption, so HEC 1 repeatedly gets stuck
waiting for the next element of the encrypted stream; this accounts
for the gaps in execution we see on HEC 1.</p>
<p id="one_interesting">One interesting thing to note about this profile is that the pipeline
stages tend to stay on the same core.  This is because each pipeline
stage is a <a id="id396899" class="indexterm"></a>single <code class="literal">fork</code> (a single node in the dataflow
graph) and the <code class="literal">Par</code> scheduler will run a task to completion on the
current core before starting on the next task.  Keeping each pipeline
stage running on a single core is good for locality.</p>
<div class="sect2" id="_rate_limiting_the_producer">
<div class="titlepage"><div><div><h3 class="title">Rate-Limiting the Producer</h3></div></div></div>
<p id="pipleline_paral_id1"><a id="ix_ch04_par-monad-txt8" class="indexterm"></a>In our previous example, the consumer was faster than the producer.  If,
instead, the producer had been faster than the consumer, then there would be
nothing to stop the producer from getting a long way ahead of the consumer
and building up a long <code class="literal">IList</code> <a id="id396957" class="indexterm"></a>chain in memory.  This is undesirable,
because large heap data structures incur overhead due to garbage
collection, so we might want to rate-limit the producer to avoid it
getting too far ahead.  There’s a trick that adds some automatic
rate-limiting to the stream API. It entails adding another
constructor to the <code class="literal">IList</code> type:</p>
<pre class="programlisting" data-language="haskell" id="data_ilist_a___id2"><code class="kr">data</code> <code class="kt">IList</code> <code class="n">a</code>
  <code class="ow">=</code> <code class="kt">Nil</code>
  <code class="o">|</code> <code class="kt">Cons</code> <code class="n">a</code> <code class="p">(</code><code class="kt">IVar</code> <code class="p">(</code><code class="kt">IList</code> <code class="n">a</code><code class="p">))</code>
  <code class="o">|</code> <code class="kt">Fork</code> <code class="p">(</code><code class="kt">Par</code> <code class="nb">()</code><code class="p">)</code> <code class="p">(</code><code class="kt">IList</code> <code class="n">a</code><code class="p">)</code>  <code class="c1">-- </code><span id="CO11-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></pre>
<div class="calloutlist"><table style="border: 0; "><tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO11-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_idea_is_tha">
The idea is that the creator of the <code class="literal">IList</code> produces a fixed
amount of the list and inserts <a id="id397134" class="indexterm"></a><a id="id397142" class="indexterm"></a><a id="id397148" class="indexterm"></a>a <code class="literal">Fork</code> constructor containing
another <code class="literal">Par</code> computation that will produce more of the list.  The
consumer, upon finding a <code class="literal">Fork</code>, calls <code class="literal">fork</code> to start production of
the next chunk of the list.  The <code class="literal">Fork</code> doesn’t have to be at the end;
for example, the list might be produced in chunks of 200 elements,
with the first <code class="literal">Fork</code> being at the 100 element mark, and every 200
elements thereafter.  This would mean that at any time there would be
at least 100 and up to 300 elements waiting to be consumed.
</p></td>
</tr></table></div>
<p id="ill_leave_the_">I’ll leave the rest of the implementation of this idea as an exercise for you to try on your own.
See if you can modify <code class="literal">streamFromList</code>, <code class="literal">streamFold</code>, and <code class="literal">streamMap</code>
to incorporate the <code class="literal">Fork</code> constructor.  The chunk size and fork
distance should be parameters to the producers (<code class="literal">streamFromList</code> and
<code class="literal">streamMap</code>).<a id="id397241" class="indexterm"></a></p>
</div>
<div class="sect2" id="_limitations_of_pipeline_parallelism">
<div class="titlepage"><div><div><h3 class="title">Limitations of Pipeline Parallelism</h3></div></div></div>
<p id="pipleline_paral_id2"><a id="id397263" class="indexterm"></a>Pipeline parallelism is limited in that we can expose only as much
parallelism as we have pipeline stages.  It therefore tends to be less
effective than <a id="id397273" class="indexterm"></a>data parallelism, which can expose a lot more
parallelism.  Still, pipeline parallelism is a useful tool to have in
your toolbox.</p>
<p id="the_earlier_exa">The earlier example also exposes a limitation of the <code class="literal">Par</code> monad; we cannot
produce a lazy stream <a id="id397296" class="indexterm"></a>from <code class="literal">runPar</code> itself.  The call to <code class="literal">streamFold</code>
accumulates the entire list before it returns. You can’t return an
<code class="literal">IList</code> from <code class="literal">runPar</code> and consume it in another <code class="literal">runPar</code>, because
returning <a id="id397337" class="indexterm"></a>an <code class="literal">IVar</code> from <code class="literal">runPar</code> is illegal and will
probably result in an error. Besides, <code class="literal">runPar</code> always runs all the
forked <code class="literal">Par</code> computations to completion before returning, because this
is necessary to ensure deterministic results.  There is an <code class="literal">IO</code>
version of the <code class="literal">Par</code> monad that we’ll encounter <a id="id397383" class="indexterm"></a>in
<a class="xref" href="ch13.html#sec_conc-monad-par-io" title="The ParIO monad">“The ParIO monad”</a>, and you could use that for lazy streaming,
although unlike the pure <code class="literal">Par</code> monad, determinism is not guaranteed
when using the <code class="literal">IO</code> version.<a id="id397408" class="indexterm"></a><a id="id397418" class="indexterm"></a><a id="id397427" class="indexterm"></a></p>
</div>
</div>
<div class="sect1" data-original-filename="ch04_par-monad.asciidoc" id="sec_par-monad-timetable">
<div class="titlepage"><div><div><h2 class="title">Example: A Conference Timetable</h2></div></div></div>
<p id="constraint_sati_id1"><a id="ix_ch04_par-monad-txt9" class="indexterm"></a><a id="ix_ch04_par-monad-txt10" class="indexterm"></a><a id="ix_ch04_par-monad-txt11" class="indexterm"></a>In this section, we’ll look at a program that finds a valid
timetable for a conference.<a href="#ftn.id397495" class="footnote"><sup class="footnote" id="id397495">[14]</sup></a> The outline of the problem is this:</p>
<div class="itemizedlist" id="the_conference__id1"><ul class="itemizedlist">
<li class="listitem">
The conference runs <span class="emphasis"><em>T</em></span> parallel tracks, and each track has the
   same number of talk slots, <span class="emphasis"><em>S</em></span>; hence there are <span class="emphasis"><em>T * S</em></span> talk slots
   in total.  For simplicity, we assume that the talk slots all start
   and finish at the same time across the tracks.
</li>
<li class="listitem">
There are at most <span class="emphasis"><em>T * S</em></span> talks to assign to tracks and slots (if
   there are fewer talks than slots, we can make up the
   difference with dummy talks that represent empty slots).
</li>
<li class="listitem">
There are a number of attendees who have each expressed a
   preference for some talks they would like to see.
</li>
<li class="listitem">
The goal is to assign talks to slots and tracks so that the
   attendees can attend all the talks they want to see; that is, we
   never schedule two talks that an attendee wanted to see on two
   different tracks in the same slot.
</li>
</ul></div>
<p id="heres_a_small_">Here’s a small example.  Suppose we have two tracks and two slots, and
four talks named <span class="emphasis"><em>A</em></span>, <span class="emphasis"><em>B</em></span>, <span class="emphasis"><em>C</em></span>, and <span class="emphasis"><em>D</em></span>.  There are four attendees—<span class="emphasis"><em>P</em></span>, <span class="emphasis"><em>Q</em></span>, <span class="emphasis"><em>R</em></span>, and <span class="emphasis"><em>S</em></span>—and each wants to go to two talks:</p>
<div class="itemizedlist" id="p_wants_to_see__id1"><ul class="itemizedlist">
<li class="listitem">
<span class="emphasis"><em>P</em></span> wants to see <span class="emphasis"><em>A</em></span> and <span class="emphasis"><em>B</em></span>
</li>
<li class="listitem">
<span class="emphasis"><em>Q</em></span> wants to see <span class="emphasis"><em>B</em></span> and <span class="emphasis"><em>C</em></span>
</li>
<li class="listitem">
<span class="emphasis"><em>R</em></span> wants to see <span class="emphasis"><em>C</em></span> and <span class="emphasis"><em>D</em></span>
</li>
<li class="listitem">
<span class="emphasis"><em>S</em></span> wants to see <span class="emphasis"><em>A</em></span> and <span class="emphasis"><em>D</em></span>
</li>
</ul></div>
<p id="one_solution_is">One solution is:</p>
<div class="informaltable" id="track_slot__sl"><table style="width: 30%; border-collapse: collapse;">
<colgroup>
<col class="col_1">
<col class="col_2">
<col class="col_3">
</colgroup>
<thead><tr>
<td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Track</td>
<td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> Slot 1    </td>
<td style="border-bottom: 0.5pt solid ; "> Slot 2</td>
</tr></thead>
<tbody>
<tr>
<td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p id="simpara_id13">1</p></td>
<td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p id="b"><span class="emphasis"><em>B</em></span></p></td>
<td style="border-bottom: 0.5pt solid ; "><p id="c"><span class="emphasis"><em>C</em></span></p></td>
</tr>
<tr>
<td style="border-right: 0.5pt solid ; "><p id="simpara_id14">2</p></td>
<td style="border-right: 0.5pt solid ; "><p id="d"><span class="emphasis"><em>D</em></span></p></td>
<td><p id="a"><span class="emphasis"><em>A</em></span></p></td>
</tr>
</tbody>
</table></div>
<p id="there_are_other">There are other solutions, but they are symmetrical with this one
(interchange either the tracks or the slots or both).</p>
<p id="timetabling_is_">Timetabling is an instance of a <span class="emphasis"><em>constraint satisfaction</em></span> problem: we’re
finding assignments for variables (talk slots) that satisfy the
constraints (attendees' preferences).  The problem requires an
exhaustive search, but we can be more clever than just generating all
the possible assignments and testing each one.  We can fill in the
timetable incrementally: assign a talk to the first slot of the first
track, then find a talk for the first slot of the second track that
doesn’t introduce a conflict, and so on until we’ve filled up the
first slot of all the tracks.  Then we proceed to the second slot and
so on until we’ve filled the whole timetable.  This incremental
approach prunes a lot of the search space because we avoid searching
for solutions when the partial grid already contains a conflict.<a href="#ftn.id397787" class="footnote"><sup class="footnote" id="id397787">[15]</sup></a></p>
<p id="if_at_any_point">If at any point we cannot fill a slot without causing a conflict, we
have <a id="id397799" class="indexterm"></a>to <span class="emphasis"><em>backtrack</em></span> to the previous slot and choose a different talk
instead.  If we exhaust all the possibilities at the previous slot,
then we have to backtrack further.  So, in general, the search pattern
is a <a id="id397811" class="indexterm"></a>tree.  A fragment of the search tree for the example above is
shown in <a class="xref" href="ch04.html#fig_timetable_tree" title="Figure 4-3. Tree-shaped search pattern for the timetabling problem">Figure 4-3</a>.</p>
<div class="figure" id="fig_timetable_tree">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0403.png" alt="Tree-shaped search pattern for the timetabling problem"></div></div>
<div class="figure-title">Figure 4-3. Tree-shaped search pattern for the timetabling problem</div>
</div>
<p id="if_we_are_inter">If we are interested in <span class="emphasis"><em>all</em></span> the solutions (perhaps because we want
to pick the best one according to some criteria), we have to explore
the whole tree.</p>
<p id="algorithms_that_id1">Algorithms that have this tree-shaped structure are often <a id="id397862" class="indexterm"></a>called
<span class="emphasis"><em>divide and conquer</em></span>.  A divide-and-conquer algorithm is one in which
the problem is recursively split into smaller subproblems that are
solved separately, then combined to form the whole solution.  In this
case, starting from the empty timetable, we’re dividing the solution
space according to which talk goes in the first slot, and then by
which talk goes in the second slot, and so on recursively until we
fill the timetable.  Divide-and-conquer algorithms have some nice
properties, not least of which is that they parallelize well because
the branches are independent of one another.</p>
<p id="so_lets_look_a">So let’s look at how to code up a solution in Haskell.  First, we need
a type to represent talks; for simplicity, I’ll just number them:</p>
<p id="timetablehs__id2" class="caption"><span class="emphasis"><em>timetable.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="newtype_talk__"><code class="kr">newtype</code> <code class="kt">Talk</code> <code class="ow">=</code> <code class="kt">Talk</code> <code class="kt">Int</code>
  <code class="kr">deriving</code> <code class="p">(</code><code class="kt">Eq</code><code class="p">,</code><code class="kt">Ord</code><code class="p">)</code>

<code class="kr">instance</code> <code class="kt">NFData</code> <code class="kt">Talk</code>

<code class="kr">instance</code> <code class="kt">Show</code> <code class="kt">Talk</code> <code class="kr">where</code>
  <code class="n">show</code> <code class="p">(</code><code class="kt">Talk</code> <code class="n">t</code><code class="p">)</code> <code class="ow">=</code> <code class="n">show</code> <code class="n">t</code></pre>
<p id="an_attendee_is_">An attendee is represented by her name and the talks she wants to
attend:</p>
<pre class="programlisting" data-language="haskell" id="data_person__p"><code class="kr">data</code> <code class="kt">Person</code> <code class="ow">=</code> <code class="kt">Person</code>
  <code class="p">{</code> <code class="n">name</code>  <code class="ow">::</code> <code class="kt">String</code>
  <code class="p">,</code> <code class="n">talks</code> <code class="ow">::</code> <code class="p">[</code><code class="kt">Talk</code><code class="p">]</code>
  <code class="p">}</code>
  <code class="kr">deriving</code> <code class="p">(</code><code class="kt">Show</code><code class="p">)</code></pre>
<p id="and_the_complet">And the complete timetable is represented as a list of lists of <code class="literal">Talk</code>.  Each list represents a
single slot. So if there are four tracks and three slots, for example,
the timetable will be three lists of four elements each.</p>
<pre class="programlisting" data-language="haskell" id="type_timetable_"><code class="kr">type</code> <code class="kt">TimeTable</code> <code class="ow">=</code> <code class="p">[[</code><code class="kt">Talk</code><code class="p">]]</code></pre>
<p id="heres_the_top">Here’s the top-level function: it takes a list of <code class="literal">Person</code>, a list of
<code class="literal">Talk</code>, the number of tracks and slots, and returns a list <a id="id398244" class="indexterm"></a>of
<code class="literal">TimeTable</code>:</p>
<pre class="programlisting" data-language="haskell" id="timetable__p_id1"><code class="nf">timetable</code> <code class="ow">::</code> <code class="p">[</code><code class="kt">Person</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="kt">Talk</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="kt">TimeTable</code><code class="p">]</code>
<code class="nf">timetable</code> <code class="n">people</code> <code class="n">allTalks</code> <code class="n">maxTrack</code> <code class="n">maxSlot</code> <code class="ow">=</code></pre>
<p id="first_im_goin">First, I’m going to cache some information about which talks clash with
each other.  That is, for each talk, we want to know which other talks
cannot be scheduled in the same slot, because one or more attendees
want to see both of them.  This information is collected in a <code class="literal">Map</code>
called <code class="literal">clashes</code>, which is built from the <code class="literal">[Person]</code> passed to
<code class="literal">timetable</code>:</p>
<pre class="programlisting" data-language="haskell" id="clashes__map_">  <code class="n">clashes</code> <code class="ow">::</code> <code class="kt">Map</code> <code class="kt">Talk</code> <code class="p">[</code><code class="kt">Talk</code><code class="p">]</code>
  <code class="n">clashes</code> <code class="ow">=</code> <code class="kt">Map</code><code class="o">.</code><code class="n">fromListWith</code> <code class="n">union</code>
     <code class="p">[</code> <code class="p">(</code><code class="n">t</code><code class="p">,</code> <code class="n">ts</code><code class="p">)</code>
     <code class="o">|</code> <code class="n">s</code> <code class="ow">&lt;-</code> <code class="n">people</code>
     <code class="p">,</code> <code class="p">(</code><code class="n">t</code><code class="p">,</code> <code class="n">ts</code><code class="p">)</code> <code class="ow">&lt;-</code> <code class="n">selects</code> <code class="p">(</code><code class="n">talks</code> <code class="n">s</code><code class="p">)</code> <code class="p">]</code></pre>
<p id="the_auxiliary_s">The auxiliary <a id="id398620" class="indexterm"></a>function <code class="literal">selects</code> takes a list and returns a list of
pairs, one pair for each item in the input list. The first element of
each pair is an element, and the second is the original list with that
element removed. For efficient implementation, <code class="literal">selects</code> does not
preserve the order of the elements. Example output:</p>
<pre class="screen" id="main_selects_">*Main&gt; selects [1..3]
[(1,[2,3]),(2,[1,3]),(3,[2,1])]</pre>
<p id="now_we_can_writ">Now we can write the algorithm itself.  Remember that the algorithm
is recursive: at each stage, we start with a partially filled-in
timetable, and we want to determine all the possible ways of filling
in the next slot and recursively generate all the solutions from
those.  The recursive function is <a id="id398660" class="indexterm"></a>called <code class="literal">generate</code>. Here is its type:</p>
<pre class="programlisting" data-language="haskell" id="generate__int">  <code class="n">generate</code> <code class="ow">::</code> <code class="kt">Int</code>          <code class="c1">-- current slot number</code>
           <code class="ow">-&gt;</code> <code class="kt">Int</code>          <code class="c1">-- current track number</code>
           <code class="ow">-&gt;</code> <code class="p">[[</code><code class="kt">Talk</code><code class="p">]]</code>     <code class="c1">-- slots allocated so far</code>
           <code class="ow">-&gt;</code> <code class="p">[</code><code class="kt">Talk</code><code class="p">]</code>       <code class="c1">-- talks in this slot</code>
           <code class="ow">-&gt;</code> <code class="p">[</code><code class="kt">Talk</code><code class="p">]</code>       <code class="c1">-- talks that can be allocated in this slot</code>
           <code class="ow">-&gt;</code> <code class="p">[</code><code class="kt">Talk</code><code class="p">]</code>       <code class="c1">-- all talks remaining to be allocated</code>
           <code class="ow">-&gt;</code> <code class="p">[</code><code class="kt">TimeTable</code><code class="p">]</code>  <code class="c1">-- all possible solutions</code></pre>
<p id="the_first_two_a">The first two arguments tell us where in the timetable we are,
and the second two arguments are the partially complete timetable.  In
fact, we’re filling in the slots in reverse order, but the slots are
independent of one another so it makes no difference.  The last two
arguments keep track of which talks remain to be assigned: the first
is the list of talks that we can put in the current slot (taking into
account clashes with other talks already in this slot), and the second
is the complete list of talks still left to assign.</p>
<p id="the_implementat_id1">The implementation of <code class="literal">generate</code> looks a little dense, but I’ll walk
through it step by step:</p>
<pre class="programlisting" data-language="haskell" id="generate_slotno">  <code class="n">generate</code> <code class="n">slotNo</code> <code class="n">trackNo</code> <code class="n">slots</code> <code class="n">slot</code> <code class="n">slotTalks</code> <code class="n">talks</code>
     <code class="o">|</code> <code class="n">slotNo</code> <code class="o">==</code> <code class="n">maxSlot</code>   <code class="ow">=</code> <code class="p">[</code><code class="n">slots</code><code class="p">]</code>                                    <code class="c1">-- </code><span id="CO12-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
     <code class="o">|</code> <code class="n">trackNo</code> <code class="o">==</code> <code class="n">maxTrack</code> <code class="ow">=</code>
         <code class="n">generate</code> <code class="p">(</code><code class="n">slotNo</code><code class="o">+</code><code class="mi">1</code><code class="p">)</code> <code class="mi">0</code> <code class="p">(</code><code class="n">slot</code><code class="kt">:</code><code class="n">slots</code><code class="p">)</code> <code class="kt">[]</code> <code class="n">talks</code> <code class="n">talks</code>              <code class="c1">-- </code><span id="CO12-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>
     <code class="o">|</code> <code class="n">otherwise</code> <code class="ow">=</code> <code class="n">concat</code>                                               <code class="c1">-- </code><span id="CO12-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span>
         <code class="p">[</code> <code class="n">generate</code> <code class="n">slotNo</code> <code class="p">(</code><code class="n">trackNo</code><code class="o">+</code><code class="mi">1</code><code class="p">)</code> <code class="n">slots</code> <code class="p">(</code><code class="n">t</code><code class="kt">:</code><code class="n">slot</code><code class="p">)</code> <code class="n">slotTalks'</code> <code class="n">talks'</code> <code class="c1">-- </code><span id="CO12-4"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span>
         <code class="o">|</code> <code class="p">(</code><code class="n">t</code><code class="p">,</code> <code class="n">ts</code><code class="p">)</code> <code class="ow">&lt;-</code> <code class="n">selects</code> <code class="n">slotTalks</code>                                 <code class="c1">-- </code><span id="CO12-5"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/5.png" alt="5"></span>
         <code class="p">,</code> <code class="kr">let</code> <code class="n">clashesWithT</code> <code class="ow">=</code> <code class="kt">Map</code><code class="o">.</code><code class="n">findWithDefault</code> <code class="kt">[]</code> <code class="n">t</code> <code class="n">clashes</code>          <code class="c1">-- </code><span id="CO12-6"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/6.png" alt="6"></span>
         <code class="p">,</code> <code class="kr">let</code> <code class="n">slotTalks'</code> <code class="ow">=</code> <code class="n">filter</code> <code class="p">(`</code><code class="n">notElem</code><code class="p">`</code> <code class="n">clashesWithT</code><code class="p">)</code> <code class="n">ts</code>          <code class="c1">-- </code><span id="CO12-7"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/7.png" alt="7"></span>
         <code class="p">,</code> <code class="kr">let</code> <code class="n">talks'</code> <code class="ow">=</code> <code class="n">filter</code> <code class="p">(</code><code class="o">/=</code> <code class="n">t</code><code class="p">)</code> <code class="n">talks</code>                             <code class="c1">-- </code><span id="CO12-8"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/8.png" alt="8"></span>
         <code class="p">]</code></pre>
<div class="calloutlist"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO12-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="if_weve_filled_id1">
If we’ve filled in all the slots, we’re done; the current list of
slots is a solution.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO12-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="if_weve_filled_id2">
If we’ve filled in all the tracks for the current slot, move on to
the next slot.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO12-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="otherwise_wer">
Otherwise, we’re going to fill in the next talk in this slot.
The result is the concatenation of all the solutions arising from the
possibilities for filling in that talk.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO12-5"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/5.png" alt="5"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="here_we_select_">
Here we select all the possibilities for the next talk from
<code class="literal">slotTalks</code>, binding the next talk to <code class="literal">t</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO12-6"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/6.png" alt="6"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="decide_which_ot">
Decide which other talks clash with <code class="literal">t</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO12-7"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/7.png" alt="7"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="remove_from_slo">
Remove from <code class="literal">slotTalks</code> the talks that clash with <code class="literal">t</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO12-8"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/8.png" alt="8"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="remove_t_from_t">
Remove <code class="literal">t</code> from <code class="literal">talks</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO12-4"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="for_each_t_rec">
For each <code class="literal">t</code>, recursively call <code class="literal">generate</code> with the new partial solution.
</p></td>
</tr>
</table></div>
<p id="finally_we_nee">Finally, we need to call <code class="literal">generate</code> with the empty timetable to start
things off:</p>
<pre class="programlisting" data-language="haskell" id="generate___">  <code class="n">generate</code> <code class="mi">0</code> <code class="mi">0</code> <code class="kt">[]</code> <code class="kt">[]</code> <code class="n">allTalks</code> <code class="n">allTalks</code></pre>
<p id="the_program_is_">The program is equipped with some machinery to generate test data, so
we can see how long it takes with a variety of inputs.  Unfortunately,
it turns out to be hard to find some parameters that don’t either take
forever or complete instantaneously, but here’s one set:</p>
<pre class="screen" id="timetable_">$ ./timetable 4 3 11 10 3 +RTS -s</pre>
<p id="the_commandlin">The command-line arguments set the parameters for the search: 4
slots, 3 tracks, 11 total talks, and 10 participants who
each want to go to 3 talks.  This takes about 1 second to
calculate the number of possible timetables (about 31,000).</p>
<div class="sect2" id="_adding_parallelism">
<div class="titlepage"><div><div><h3 class="title">Adding Parallelism</h3></div></div></div>
<p id="constraint_sati_id2"><a id="ix_ch04_par-monad-txt12" class="indexterm"></a>This code is already quite involved, and if we try to parallelize
it directly, it is likely to get more complicated.  We’d prefer to separate the parallelism as far as possible from the algorithm code.  With Strategies (<a class="xref" href="ch03.html" title="Chapter 3. Evaluation Strategies">Chapter 3</a>), we did this
by generating a <a id="id399734" class="indexterm"></a>lazy data structure. But this application is an example where generating a
lazy data structure doesn’t work very well, because we would have to
return the entire search tree as a data structure.</p>
<p id="instead_i_want">Instead, I want to demonstrate another technique for separating the
parallelism from the algorithm: building a <span class="emphasis"><em>parallel skeleton</em></span>.  A
<a id="id399757" class="indexterm"></a>parallel skeleton is nothing more than a higher-order function that
abstracts a pattern of computation.  We’ve already seen one parallel
skeleton<a id="id399769" class="indexterm"></a>: <code class="literal">parMap</code>, the function that describes data parallelism,
abstracted over the function to apply in parallel.  Here we need a
different skeleton, which I’ll call <a id="id399787" class="indexterm"></a>the <span class="emphasis"><em>search</em></span> skeleton (although
it’s a variant of a more general divide-and-conquer skeleton).</p>
<p id="ill_start_by_r">I’ll start by refactoring the algorithm into a skeleton and its
instantiation, and then add parallelism to the skeleton.  The type of
the <code class="literal">search</code> skeleton is as follows:</p>
<p id="timetablehs__id3" class="caption"><span class="emphasis"><em>timetable1.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="search___par_id2"><code class="nf">search</code> <code class="ow">::</code> <code class="p">(</code> <code class="n">partial</code> <code class="ow">-&gt;</code> <code class="kt">Maybe</code> <code class="n">solution</code> <code class="p">)</code>   <code class="c1">-- </code><span id="CO13-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
       <code class="ow">-&gt;</code> <code class="p">(</code> <code class="n">partial</code> <code class="ow">-&gt;</code> <code class="p">[</code> <code class="n">partial</code> <code class="p">]</code> <code class="p">)</code>      <code class="c1">-- </code><span id="CO13-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>
       <code class="ow">-&gt;</code> <code class="n">partial</code>                         <code class="c1">-- </code><span id="CO13-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span>
       <code class="ow">-&gt;</code> <code class="p">[</code><code class="n">solution</code><code class="p">]</code>                      <code class="c1">-- </code><span id="CO13-4"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span></pre>
<p id="search_function"><a id="id400000" class="indexterm"></a>The <code class="literal">search</code> function is polymorphic in two types: <code class="literal">partial</code> is the type of partial
solutions, and <code class="literal">solution</code> is the type of complete solutions.  We’ll
see how these are instantiated in our example shortly.</p>
<div class="calloutlist"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO13-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_first_argum_id2">
The first argument to <code class="literal">search</code> is a function that tells whether a
particular <code class="literal">partial</code> solution corresponds to a complete <code class="literal">solution</code>,
and if so, what the solution is.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO13-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_second_argu_id1">
The second argument takes a <code class="literal">partial</code> solution and refines it to a
list of further <code class="literal">partial</code> solutions.  It is expected that this process
doesn’t continue forever!
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO13-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="to_get_things_s">
To get things started, we need an initial, empty value of type
<code class="literal">partial</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO13-4"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_result_is_a_id1">
The result is a list of <code class="literal">solution</code>s.
</p></td>
</tr>
</table></div>
<p id="the_definition_">The definition of <code class="literal">search</code> is quite straightforward.  It’s one of
those functions that is almost impossible to get wrong, because the
type describes exactly what it does:</p>
<pre class="programlisting" data-language="haskell" id="search_finished"><code class="nf">search</code> <code class="n">finished</code> <code class="n">refine</code> <code class="n">emptysoln</code> <code class="ow">=</code> <code class="n">generate</code> <code class="n">emptysoln</code>
  <code class="kr">where</code>
    <code class="n">generate</code> <code class="n">partial</code>
       <code class="o">|</code> <code class="kt">Just</code> <code class="n">soln</code> <code class="ow">&lt;-</code> <code class="n">finished</code> <code class="n">partial</code> <code class="ow">=</code> <code class="p">[</code><code class="n">soln</code><code class="p">]</code>
       <code class="o">|</code> <code class="n">otherwise</code>  <code class="ow">=</code> <code class="n">concat</code> <code class="p">(</code><code class="n">map</code> <code class="n">generate</code> <code class="p">(</code><code class="n">refine</code> <code class="n">partial</code><code class="p">))</code></pre>
<p id="now_to_refactor">Now to refactor <code class="literal">timetable</code> to use <code class="literal">search</code>.  The basic idea is that
the arguments to <code class="literal">generate</code> constitute the partial solution, so we’ll
just package them up:</p>
<pre class="programlisting" data-language="haskell" id="type_partial__"><code class="kr">type</code> <code class="kt">Partial</code> <code class="ow">=</code> <code class="p">(</code><code class="kt">Int</code><code class="p">,</code> <code class="kt">Int</code><code class="p">,</code> <code class="p">[[</code><code class="kt">Talk</code><code class="p">]],</code> <code class="p">[</code><code class="kt">Talk</code><code class="p">],</code> <code class="p">[</code><code class="kt">Talk</code><code class="p">],</code> <code class="p">[</code><code class="kt">Talk</code><code class="p">])</code></pre>
<p id="the_rest_of_the">The rest of the refactoring is mechanical, so I won’t describe it in
detail. The result is:</p>
<pre class="programlisting" data-language="haskell" id="timetable__p_id2"><code class="nf">timetable</code> <code class="ow">::</code> <code class="p">[</code><code class="kt">Person</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="kt">Talk</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="kt">TimeTable</code><code class="p">]</code>
<code class="nf">timetable</code> <code class="n">people</code> <code class="n">allTalks</code> <code class="n">maxTrack</code> <code class="n">maxSlot</code> <code class="ow">=</code>
  <code class="n">search</code> <code class="n">finished</code> <code class="n">refine</code> <code class="n">emptysoln</code>
 <code class="kr">where</code>
  <code class="n">emptysoln</code> <code class="ow">=</code> <code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="kt">[]</code><code class="p">,</code> <code class="kt">[]</code><code class="p">,</code> <code class="n">allTalks</code><code class="p">,</code> <code class="n">allTalks</code><code class="p">)</code>

  <code class="n">finished</code> <code class="p">(</code><code class="n">slotNo</code><code class="p">,</code> <code class="n">trackNo</code><code class="p">,</code> <code class="n">slots</code><code class="p">,</code> <code class="n">slot</code><code class="p">,</code> <code class="n">slotTalks</code><code class="p">,</code> <code class="n">talks</code><code class="p">)</code>
     <code class="o">|</code> <code class="n">slotNo</code> <code class="o">==</code> <code class="n">maxSlot</code> <code class="ow">=</code> <code class="kt">Just</code> <code class="n">slots</code>
     <code class="o">|</code> <code class="n">otherwise</code>         <code class="ow">=</code> <code class="kt">Nothing</code>

  <code class="n">clashes</code> <code class="ow">::</code> <code class="kt">Map</code> <code class="kt">Talk</code> <code class="p">[</code><code class="kt">Talk</code><code class="p">]</code>
  <code class="n">clashes</code> <code class="ow">=</code> <code class="kt">Map</code><code class="o">.</code><code class="n">fromListWith</code> <code class="n">union</code>
     <code class="p">[</code> <code class="p">(</code><code class="n">t</code><code class="p">,</code> <code class="n">ts</code><code class="p">)</code>
     <code class="o">|</code> <code class="n">s</code> <code class="ow">&lt;-</code> <code class="n">people</code>
     <code class="p">,</code> <code class="p">(</code><code class="n">t</code><code class="p">,</code> <code class="n">ts</code><code class="p">)</code> <code class="ow">&lt;-</code> <code class="n">selects</code> <code class="p">(</code><code class="n">talks</code> <code class="n">s</code><code class="p">)</code> <code class="p">]</code>

  <code class="n">refine</code> <code class="p">(</code><code class="n">slotNo</code><code class="p">,</code> <code class="n">trackNo</code><code class="p">,</code> <code class="n">slots</code><code class="p">,</code> <code class="n">slot</code><code class="p">,</code> <code class="n">slotTalks</code><code class="p">,</code> <code class="n">talks</code><code class="p">)</code>
     <code class="o">|</code> <code class="n">trackNo</code> <code class="o">==</code> <code class="n">maxTrack</code> <code class="ow">=</code> <code class="p">[(</code><code class="n">slotNo</code><code class="o">+</code><code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="n">slot</code><code class="kt">:</code><code class="n">slots</code><code class="p">,</code> <code class="kt">[]</code><code class="p">,</code> <code class="n">talks</code><code class="p">,</code> <code class="n">talks</code><code class="p">)]</code>
     <code class="o">|</code> <code class="n">otherwise</code> <code class="ow">=</code>
         <code class="p">[</code> <code class="p">(</code><code class="n">slotNo</code><code class="p">,</code> <code class="n">trackNo</code><code class="o">+</code><code class="mi">1</code><code class="p">,</code> <code class="n">slots</code><code class="p">,</code> <code class="n">t</code><code class="kt">:</code><code class="n">slot</code><code class="p">,</code> <code class="n">slotTalks'</code><code class="p">,</code> <code class="n">talks'</code><code class="p">)</code>
         <code class="o">|</code> <code class="p">(</code><code class="n">t</code><code class="p">,</code> <code class="n">ts</code><code class="p">)</code> <code class="ow">&lt;-</code> <code class="n">selects</code> <code class="n">slotTalks</code>
         <code class="p">,</code> <code class="kr">let</code> <code class="n">clashesWithT</code> <code class="ow">=</code> <code class="kt">Map</code><code class="o">.</code><code class="n">findWithDefault</code> <code class="kt">[]</code> <code class="n">t</code> <code class="n">clashes</code>
         <code class="p">,</code> <code class="kr">let</code> <code class="n">slotTalks'</code> <code class="ow">=</code> <code class="n">filter</code> <code class="p">(`</code><code class="n">notElem</code><code class="p">`</code> <code class="n">clashesWithT</code><code class="p">)</code> <code class="n">ts</code>
         <code class="p">,</code> <code class="kr">let</code> <code class="n">talks'</code> <code class="ow">=</code> <code class="n">filter</code> <code class="p">(</code><code class="o">/=</code> <code class="n">t</code><code class="p">)</code> <code class="n">talks</code>
         <code class="p">]</code></pre>
<p id="the_algorithm_w">The algorithm works exactly as before. All we did was pull out
the <a id="id402145" class="indexterm"></a>search pattern as a higher-order function and call it.</p>
<p id="now_to_parallel">Now to parallelize the <code class="literal">search</code> skeleton.  As you might expect, the basic idea is that at
each stage, we’ll spawn off the <a id="id402165" class="indexterm"></a>recursive calls in parallel and then collect the results.  Here’s how to express that using the <code class="literal">Par</code> monad:</p>
<p id="timetablehs__id4" class="caption"><span class="emphasis"><em>timetable2.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="parsearch__nf_id1"><code class="nf">parsearch</code> <code class="ow">::</code> <code class="kt">NFData</code> <code class="n">solution</code>
      <code class="ow">=&gt;</code> <code class="p">(</code> <code class="n">partial</code> <code class="ow">-&gt;</code> <code class="kt">Maybe</code> <code class="n">solution</code> <code class="p">)</code>
      <code class="ow">-&gt;</code> <code class="p">(</code> <code class="n">partial</code> <code class="ow">-&gt;</code> <code class="p">[</code> <code class="n">partial</code> <code class="p">]</code> <code class="p">)</code>
      <code class="ow">-&gt;</code> <code class="n">partial</code>
      <code class="ow">-&gt;</code> <code class="p">[</code><code class="n">solution</code><code class="p">]</code>

<code class="nf">parsearch</code> <code class="n">finished</code> <code class="n">refine</code> <code class="n">emptysoln</code>
  <code class="ow">=</code> <code class="n">runPar</code> <code class="o">$</code> <code class="n">generate</code> <code class="n">emptysoln</code>
  <code class="kr">where</code>
    <code class="n">generate</code> <code class="n">partial</code>
       <code class="o">|</code> <code class="kt">Just</code> <code class="n">soln</code> <code class="ow">&lt;-</code> <code class="n">finished</code> <code class="n">partial</code> <code class="ow">=</code> <code class="n">return</code> <code class="p">[</code><code class="n">soln</code><code class="p">]</code>
       <code class="o">|</code> <code class="n">otherwise</code>  <code class="ow">=</code> <code class="kr">do</code>
           <code class="n">solnss</code> <code class="ow">&lt;-</code> <code class="n">parMapM</code> <code class="n">generate</code> <code class="p">(</code><code class="n">refine</code> <code class="n">partial</code><code class="p">)</code>
           <code class="n">return</code> <code class="p">(</code><code class="n">concat</code> <code class="n">solnss</code><code class="p">)</code></pre>
<p id="were_using_par">We’re using <code class="literal">parMapM</code> to call <code class="literal">generate</code> in parallel on the
list of partial solutions returned by <code class="literal">refine</code>, and then concatenating
the results.  However, this doesn’t work out too well; on the
parameter set we used before, it adds a factor of five overhead.  The
problem is that as we get near the leaves of the search tree, the
granularity is too fine in relation to the overhead of spawning the
calls in parallel.</p>
<p id="so_we_need_a_wa_id1">So we need a way to make the <a id="id402558" class="indexterm"></a>granularity coarser.  We can’t use
chunking, because we don’t have a flat list here; we have a tree.  For
tree-shaped parallelism we need to use a different technique: <a id="id402570" class="indexterm"></a>a <span class="emphasis"><em>depth
threshold</em></span>.  The basic idea is quite simple: spawn recursive calls in
parallel down to a certain depth, and below that depth use the
original sequential algorithm.</p>
<p id="parsearch_funct"><a id="id402586" class="indexterm"></a>Our <code class="literal">parsearch</code> function needs an extra parameter, namely the depth
to parallelize to:</p>
<p id="timetablehs__id5" class="caption"><span class="emphasis"><em>timetable3.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="parsearch__nf_id2"><code class="nf">parsearch</code> <code class="ow">::</code> <code class="kt">NFData</code> <code class="n">solution</code>
      <code class="ow">=&gt;</code> <code class="kt">Int</code>
      <code class="ow">-&gt;</code> <code class="p">(</code> <code class="n">partial</code> <code class="ow">-&gt;</code> <code class="kt">Maybe</code> <code class="n">solution</code> <code class="p">)</code>   <code class="c1">-- finished?</code>
      <code class="ow">-&gt;</code> <code class="p">(</code> <code class="n">partial</code> <code class="ow">-&gt;</code> <code class="p">[</code> <code class="n">partial</code> <code class="p">]</code> <code class="p">)</code>      <code class="c1">-- refine a solution</code>
      <code class="ow">-&gt;</code> <code class="n">partial</code>                         <code class="c1">-- initial solution</code>
      <code class="ow">-&gt;</code> <code class="p">[</code><code class="n">solution</code><code class="p">]</code>

<code class="nf">parsearch</code> <code class="n">maxdepth</code> <code class="n">finished</code> <code class="n">refine</code> <code class="n">emptysoln</code>
  <code class="ow">=</code> <code class="n">runPar</code> <code class="o">$</code> <code class="n">generate</code> <code class="mi">0</code> <code class="n">emptysoln</code>
  <code class="kr">where</code>
    <code class="n">generate</code> <code class="n">d</code> <code class="n">partial</code> <code class="o">|</code> <code class="n">d</code> <code class="o">&gt;=</code> <code class="n">maxdepth</code>               <code class="c1">-- </code><span id="CO14-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
       <code class="ow">=</code> <code class="n">return</code> <code class="p">(</code><code class="n">search</code> <code class="n">finished</code> <code class="n">refine</code> <code class="n">partial</code><code class="p">)</code>
    <code class="n">generate</code> <code class="n">d</code> <code class="n">partial</code>
       <code class="o">|</code> <code class="kt">Just</code> <code class="n">soln</code> <code class="ow">&lt;-</code> <code class="n">finished</code> <code class="n">partial</code> <code class="ow">=</code> <code class="n">return</code> <code class="p">[</code><code class="n">soln</code><code class="p">]</code>
       <code class="o">|</code> <code class="n">otherwise</code>  <code class="ow">=</code> <code class="kr">do</code>
           <code class="n">solnss</code> <code class="ow">&lt;-</code> <code class="n">parMapM</code> <code class="p">(</code><code class="n">generate</code> <code class="p">(</code><code class="n">d</code><code class="o">+</code><code class="mi">1</code><code class="p">))</code> <code class="p">(</code><code class="n">refine</code> <code class="n">partial</code><code class="p">)</code>
           <code class="n">return</code> <code class="p">(</code><code class="n">concat</code> <code class="n">solnss</code><code class="p">)</code></pre>
<div class="calloutlist"><table style="border: 0; "><tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO14-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_depth_argum">
The depth argument <code class="literal">d</code> increases by one each time we make a
recursive call to <code class="literal">generate</code>.  If it reaches the <code class="literal">maxdepth</code> passed as
an argument to <code class="literal">parsearch</code>, then we call <code class="literal">search</code> (the
sequential algorithm) to do the rest of the search below this point.
</p></td>
</tr></table></div>
<p id="using_a_depth_o">Using a depth of three in this case works reasonably well and gets us a
speedup of about three on four cores relative to the original sequential
version.  Adding the skeleton unfortunately incurs some overhead, but
in return it gains us some worthwhile modularity: it would have been
difficult to add the depth threshold without first abstracting the
skeleton.</p>
<p id="here_are_the_ma">Here are the main points to take away from this example:</p>
<div class="itemizedlist" id="treeshaped_di_id1"><ul class="itemizedlist">
<li class="listitem">
Tree-shaped (<span class="emphasis"><em>divide and conquer</em></span>) computations parallelize well.
</li>
<li class="listitem">
You can abstract the parallel pattern as a <span class="emphasis"><em>skeleton</em></span> using
   higher-order functions.
</li>
<li class="listitem">
To control the granularity in a tree-shaped computation, add a
   <span class="emphasis"><em>depth threshold</em></span>, and use the sequential version of the algorithm
   below a certain <a id="id403176" class="indexterm"></a>depth.<a id="id403184" class="indexterm"></a><a id="id403191" class="indexterm"></a><a id="id403198" class="indexterm"></a><a id="id403205" class="indexterm"></a>
</li>
</ul></div>
</div>
</div>
<div class="sect1" data-original-filename="ch04_par-monad.asciidoc" id="sec_par-monad-infer">
<div class="titlepage"><div><div><h2 class="title">Example: A Parallel Type Inferencer</h2></div></div></div>
<p id="dataflowtype_in"><a id="ix_ch04_par-monad-txt13" class="indexterm"></a><a id="ix_ch04_par-monad-txt14" class="indexterm"></a>In this section, we will parallelize a type inference engine, such as
you might find in a compiler for a <a id="id403247" class="indexterm"></a><a id="id403254" class="indexterm"></a><a id="id403260" class="indexterm"></a>functional language.  The purpose
of this example is to demonstrate two things: one, that parallelism
can be readily applied to program analysis problems, and two,
that the dataflow model works well even when the structure of the
parallelism is entirely dependent on the input and cannot be
predicted beforehand.</p>
<p id="the_outline_of_">The outline of the problem is as follows: given a list of bindings of
the form <code class="literal">x = e</code> for a variable <code class="literal">x</code> and expression <code class="literal">e</code>, infer the
types for each of the variables.  Expressions consist of integers,
variables, application, lambda expressions, <code class="literal">let</code> expressions, and
arithmetic operators (<code class="literal">+</code>, <code class="literal">-</code>, <code class="literal">*</code>, <code class="literal">/</code>).</p>
<p id="we_can_test_the">We can test the type inference engine on a few simple examples.  Load
it in GHCi (from the directory <span class="emphasis"><em>parinfer</em></span> in the sample code):</p>
<pre class="screen" id="ghci_parinfer">$ ghci parinfer.hs</pre>
<p id="the_function_te">The function <code class="literal">test</code> typechecks an expression.  Simple arithmetic
expressions have type <code class="literal">Int</code>:</p>
<pre class="screen" id="main_test__">*Main&gt; test "1 + 2"
Int</pre>
<p id="we_can_use_lamb">We can use lambda expressions, <code class="literal">let</code> expressions, and higher-order
functions, just like in Haskell:</p>
<pre class="screen" id="main_test_">*Main&gt; test "\\x -&gt; x"
a0 -&gt; a0
*Main&gt; test "\\x -&gt; x + 1"
Int -&gt; Int
*Main&gt; test "\\g -&gt; \\h -&gt; g (h 3)"
(a2 -&gt; a3) -&gt; (Int -&gt; a2) -&gt; a3</pre>
<p id="note_that_in_o">(Note that in order to get the backslash character in <a id="id403375" class="indexterm"></a>a Haskell <code class="literal">String</code>, we
need to use <code class="literal">"\\"</code>.)</p>
<p id="when_the_type_i">When the type inferencer is run as a standalone program, it typechecks
a file of bindings, and infers a type for each one.  For simplicity, we
assume the list of bindings is ordered and nonrecursive; any variable
used in an expression has to be defined earlier in the list.
Later bindings may also shadow earlier ones.</p>
<p id="for_example_co">For example, consider the following set of bindings for which we want to infer types:</p>
<pre class="screen" id="f___g__">  f = ...
  g = ... f ...
  h = ... f ...
  j = ... g ... h ...</pre>
<p id="im_using_the_n">I’m using the notation "<code class="literal">... f ...</code>" to stand for an expression
involving <code class="literal">f</code>.  The specific expression isn’t important here, only
that it mentions <code class="literal">f</code>.</p>
<p id="we_could_procee">We could proceed in a linear fashion through the list of bindings:
first inferring the type for <code class="literal">f</code>, then the type for <code class="literal">g</code>, then the type for
<code class="literal">h</code>, and so on.  However, if we look at the dataflow graph for this
set of bindings (<a class="xref" href="ch04.html#fig_parinfer" title="Figure 4-4. Flow of types between f, g, h, j">Figure 4-4</a>), we can see that there is some <span class="keep-together">parallelism</span>.</p>
<div class="figure" id="fig_parinfer">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0404.png" alt="Flow of types between f, g, h, j"></div></div>
<div class="figure-title">Figure 4-4. Flow of types between f, g, h, j</div>
</div>
<p id="clearly_we_can_">Clearly we can infer the types of <code class="literal">g</code> and <code class="literal">h</code> in parallel, once the type of <code class="literal">f</code> is known.  When viewed this way, we can see that type inference is a natural fit for the dataflow model; we can consider each binding to be a node in the
graph, and the edges of the graph carry inferred types from bindings
to usage sites in the program.</p>
<p id="building_a_data">Building a dataflow graph for the type inference problem allows
parallelism to be automatically extracted from the type inference
process.  The actual amount of parallelism present depends entirely on
the structure of the input program, however.  An input program in
which every binding depends on the previous one in the list would have
no parallelism to extract.  Fortunately, most programs aren’t like
that—usually there is a decent amount of parallelism implicit in the
dependency structure.</p>
<p id="note_that_were">Note that we’re not necessarily exploiting <span class="emphasis"><em>all</em></span> the available
parallelism here.  There might be parallelism available within the
inference of individual bindings.  However, to try to parallelize too
deeply might cause <a id="id403521" class="indexterm"></a>granularity problems, and parallelizing the
outer level is likely to gain the most reward.</p>
<p id="the_type_infere">The type inference engine that I’m using for this example is a rather
ancient piece of code that I modified to add parallelism.<a href="#ftn.id403537" class="footnote"><sup class="footnote" id="id403537">[16]</sup></a> The changes to add parallelism were quite modest.<a href="#ftn.id403547" class="footnote"><sup class="footnote" id="id403547">[17]</sup></a></p>
<p id="the_types_from_">The types from the inference engine that we will need to work with are
as follows:</p>
<pre class="programlisting" data-language="haskell" id="type_varid__st"><code class="kr">type</code> <code class="kt">VarId</code> <code class="ow">=</code> <code class="kt">String</code> <code class="c1">-- Variables</code>
<code class="kr">data</code> <code class="kt">Term</code>     <code class="c1">-- Terms in the input program</code>
<code class="kr">data</code> <code class="kt">Env</code>      <code class="c1">-- Environment, mapping VarId to PolyType</code>
<code class="kr">data</code> <code class="kt">PolyType</code> <code class="c1">-- Polymorphic types</code></pre>
<p id="in_programming_">In programming language terminology, an <a id="id403640" class="indexterm"></a>environment is a mapping that
assigns some meaning to the variables of an expression.  A type
inference engine uses an environment to assign types to variables;
this is the purpose of <a id="id403648" class="indexterm"></a>the <code class="literal">Env</code> type.  When we typecheck an
expression, we must supply an <code class="literal">Env</code> that gives the types of the
variables that the expression mentions.  An <code class="literal">Env</code> is created using
<code class="literal">makeEnv</code>:</p>
<pre class="programlisting" data-language="haskell" id="makeenv__va"><code class="nf">makeEnv</code> <code class="ow">::</code> <code class="p">[(</code><code class="kt">VarId</code><code class="p">,</code><code class="kt">PolyType</code><code class="p">)]</code> <code class="ow">-&gt;</code> <code class="kt">Env</code></pre>
<p id="to_determine_wh">To determine which variables we need to populate the <code class="literal">Env</code> with, we
need a way to extract the free (unbound) variables of an expression;
this is what <a id="id403736" class="indexterm"></a>the <code class="literal">freeVars</code> function does:</p>
<pre class="programlisting" data-language="haskell" id="freevars__ter"><code class="nf">freeVars</code> <code class="ow">::</code> <code class="kt">Term</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="kt">VarId</code><code class="p">]</code></pre>
<p id="the_underlying_">The underlying type inference engine for expressions takes a <code class="literal">Term</code>
and an <code class="literal">Env</code> that supplies the types for the free variables of the
<code class="literal">Term</code> and delivers <a id="id403808" class="indexterm"></a>a <code class="literal">PolyType</code>:</p>
<pre class="programlisting" data-language="haskell" id="infertoprhs__"><code class="nf">inferTopRhs</code> <code class="ow">::</code> <code class="kt">Env</code> <code class="ow">-&gt;</code> <code class="kt">Term</code> <code class="ow">-&gt;</code> <code class="kt">PolyType</code></pre>
<p id="while_the_seque">While the sequential part of the inference
engine uses an <code class="literal">Env</code> that maps <code class="literal">VarId</code>s to <code class="literal">PolyType</code>s, the parallel
part of the inference engine will use an environment that maps
<code class="literal">VarId</code>s to <code class="literal">IVar PolyType</code>, so that we can <code class="literal">fork</code> the inference
engine for a given binding, and then wait for its result
later.<a href="#ftn.id403899" class="footnote"><sup class="footnote" id="id403899">[18]</sup></a>  The
environment for the parallel type inferencer is <a id="id403916" class="indexterm"></a>called <code class="literal">TopEnv</code>:</p>
<pre class="programlisting" data-language="haskell" id="type_topenv__m"><code class="kr">type</code> <code class="kt">TopEnv</code> <code class="ow">=</code> <code class="kt">Map</code> <code class="kt">VarId</code> <code class="p">(</code><code class="kt">IVar</code> <code class="kt">PolyType</code><code class="p">)</code></pre>
<p id="all_that_remain">All that remains is to write the top-level loop.  We’ll do this in two
stages. First, a function to infer the type of a single binding<a id="id403984" class="indexterm"></a>:</p>
<pre class="programlisting" data-language="haskell" id="inferbind__to"><code class="nf">inferBind</code> <code class="ow">::</code> <code class="kt">TopEnv</code> <code class="ow">-&gt;</code> <code class="p">(</code><code class="kt">VarId</code><code class="p">,</code><code class="kt">Term</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">Par</code> <code class="kt">TopEnv</code>
<code class="nf">inferBind</code> <code class="n">topenv</code> <code class="p">(</code><code class="n">x</code><code class="p">,</code><code class="n">u</code><code class="p">)</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">vu</code> <code class="ow">&lt;-</code> <code class="n">new</code>                                                     <code class="c1">-- </code><span id="CO15-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
  <code class="n">fork</code> <code class="o">$</code> <code class="kr">do</code>                                                     <code class="c1">-- </code><span id="CO15-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>
    <code class="kr">let</code> <code class="n">fu</code> <code class="ow">=</code> <code class="kt">Set</code><code class="o">.</code><code class="n">toList</code> <code class="p">(</code><code class="n">freeVars</code> <code class="n">u</code><code class="p">)</code>                            <code class="c1">-- </code><span id="CO15-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span>
    <code class="n">tfu</code> <code class="ow">&lt;-</code> <code class="n">mapM</code> <code class="p">(</code><code class="n">get</code> <code class="o">.</code> <code class="n">fromJust</code> <code class="o">.</code> <code class="n">flip</code> <code class="kt">Map</code><code class="o">.</code><code class="n">lookup</code> <code class="n">topenv</code><code class="p">)</code> <code class="n">fu</code>    <code class="c1">-- </code><span id="CO15-4"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span>
    <code class="kr">let</code> <code class="n">aa</code> <code class="ow">=</code> <code class="n">makeEnv</code> <code class="p">(</code><code class="n">zip</code> <code class="n">fu</code> <code class="n">tfu</code><code class="p">)</code>                               <code class="c1">-- </code><span id="CO15-5"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/5.png" alt="5"></span>
    <code class="n">put</code> <code class="n">vu</code> <code class="p">(</code><code class="n">inferTopRhs</code> <code class="n">aa</code> <code class="n">u</code><code class="p">)</code>                                   <code class="c1">-- </code><span id="CO15-6"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/6.png" alt="6"></span>
  <code class="n">return</code> <code class="p">(</code><code class="kt">Map</code><code class="o">.</code><code class="n">insert</code> <code class="n">x</code> <code class="n">vu</code> <code class="n">topenv</code><code class="p">)</code>                               <code class="c1">-- </code><span id="CO15-7"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/7.png" alt="7"></span></pre>
<div class="calloutlist"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO15-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="create_an_ivar">
Create an <code class="literal">IVar</code>, <code class="literal">vu</code>, to hold the type of this binding.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO15-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="fork_the_comput_id1">
Fork the computation that does the type inference.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO15-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_inputs_to_t">
The inputs to this type inference are the types of the variables
mentioned in the expression <code class="literal">u</code>.  Hence we call <code class="literal">freeVars</code> to get
those variables.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO15-4"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="for_each_of_the">
For each of the free variables, look up its <code class="literal">IVar</code> in the
<code class="literal">topenv</code>, and then call <code class="literal">get</code> on it.  Hence this step will wait until
the types of all the free variables are available before proceeding.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO15-5"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/5.png" alt="5"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="build_an_env_fr">
Build an <code class="literal">Env</code> from the free variables and their types.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO15-6"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/6.png" alt="6"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="infer_the_type_">
Infer the type of the expression <code class="literal">u</code>, and put the result in the
<code class="literal">IVar</code> we created at the beginning.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO15-7"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/7.png" alt="7"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="back_in_the_par">
Back in the parent, return <code class="literal">topenv</code> extended with <code class="literal">x</code> mapped to
the new <code class="literal">IVar</code> <code class="literal">vu</code>.
</p></td>
</tr>
</table></div>
<p id="next_we_inferto">Next we <a id="id404582" class="indexterm"></a>use <code class="literal">inferBind</code> to define <code class="literal">inferTop</code>, which infers types for a
list of bindings:</p>
<pre class="programlisting" data-language="haskell" id="infertop__top"><code class="nf">inferTop</code> <code class="ow">::</code> <code class="kt">TopEnv</code> <code class="ow">-&gt;</code> <code class="p">[(</code><code class="kt">VarId</code><code class="p">,</code><code class="kt">Term</code><code class="p">)]</code> <code class="ow">-&gt;</code> <code class="kt">Par</code> <code class="p">[(</code><code class="kt">VarId</code><code class="p">,</code><code class="kt">PolyType</code><code class="p">)]</code>
<code class="nf">inferTop</code> <code class="n">topenv0</code> <code class="n">binds</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">topenv1</code> <code class="ow">&lt;-</code> <code class="n">foldM</code> <code class="n">inferBind</code> <code class="n">topenv0</code> <code class="n">binds</code>                          <code class="c1">-- </code><span id="CO16-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
  <code class="n">mapM</code> <code class="p">(</code><code class="nf">\</code><code class="p">(</code><code class="n">v</code><code class="p">,</code><code class="n">i</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kr">do</code> <code class="n">t</code> <code class="ow">&lt;-</code> <code class="n">get</code> <code class="n">i</code><code class="p">;</code> <code class="n">return</code> <code class="p">(</code><code class="n">v</code><code class="p">,</code><code class="n">t</code><code class="p">))</code> <code class="p">(</code><code class="kt">Map</code><code class="o">.</code><code class="n">toList</code> <code class="n">topenv1</code><code class="p">)</code> <code class="c1">-- </code><span id="CO16-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></pre>
<div class="calloutlist"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO16-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="use_foldm_from">
Use <code class="literal">foldM</code> (from <code class="literal">Control.Monad</code>) to perform <code class="literal">inferBind</code> over
each binding, accumulating a <code class="literal">TopEnv</code> that will contain a mapping for
each of the variables.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO16-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="wait_for_all_th">
Wait for all the type inference to happen, and
collect the results.  Hence we turn the <code class="literal">TopEnv</code> back into a list and
call <code class="literal">get</code> on all of the <code class="literal">IVar</code>s.
</p></td>
</tr>
</table></div>
<p id="this_parallel_i">This parallel implementation works quite nicely.  To demonstrate it,
I’ve constructed a synthetic input for the type checker, a fragment of
which is given below (the full version is in the file
<span class="emphasis"><em>parinfer/benchmark.in</em></span>).</p>
<pre class="screen" id="id__xx__a_">id = \x-&gt;x ;

a = \f -&gt; f id id ;
a = \f -&gt; f a a ;
a = \f -&gt; f a a ;
...
a = let f = a in \x -&gt; x ;

b = \f -&gt; f id id ;
b = \f -&gt; f b b ;
b = \f -&gt; f b b ;
...
b = let f = b in \x -&gt; x ;

c = \f -&gt; f id id ;
c = \f -&gt; f c c ;
c = \f -&gt; f c c ;
...
c = let f = c in \x -&gt; x ;

d = \f -&gt; f id id ;
d = \f -&gt; f d d ;
d = \f -&gt; f d d ;
...
d = let f = d in \x -&gt; x ;</pre>
<p id="there_are_four_">There are four sequences of bindings that can be inferred in
parallel.  The first sequence is the set of bindings for <code class="literal">a</code> (each
successive binding for <code class="literal">a</code> shadows the previous one), then
identical sequences named <code class="literal">b</code>, <code class="literal">c</code>, and <code class="literal">d</code>.  Each binding in a
sequence depends on the previous one, but the sequences are
independent of one another.  This means that our parallel typechecking
algorithm should automatically infer types for the <code class="literal">a</code>, <code class="literal">b</code>, <code class="literal">c</code>, and
<code class="literal">d</code> bindings in parallel, giving a <a id="id405046" class="indexterm"></a>maximum speedup of 4.</p>
<p id="with_one_proces">With one processor, the result should be something like this:</p>
<pre class="screen" id="parinfer_b_id1">$ ./parinfer &lt;benchmark.in +RTS -s
...
  Total   time    4.71s  (  4.72s elapsed)</pre>
<p id="the_result_with">The result with two processors represents a speedup of 1.96:</p>
<pre class="screen" id="parinfer_b_id2">$ ./parinfer &lt;benchmark.in +RTS -s -N2
...
  Total   time    4.79s  (  2.41s elapsed)</pre>
<p id="with_three_proc">With three processors, the result is:</p>
<pre class="screen" id="parinfer_b_id3">$ ./parinfer &lt;benchmark.in +RTS -s -N3
...
  Total   time    4.92s  (  2.42s elapsed)</pre>
<p id="this_is_almost_">This is almost exactly the same as with two processors!  But this is to be
expected: there are four independent problems, so the best we can do
is to overlap the first three and then run the final one.  Thus the
program will take the same amount of time as with two processors,
where we could overlap two problems at a time. Adding the fourth
processor allows all four problems to be overlapped, resulting in a speedup of 3.66: <a id="id405115" class="indexterm"></a><a id="id405124" class="indexterm"></a></p>
<pre class="screen" id="parinfer_b_id4">$ ./parinfer &lt;benchmark.in +RTS -s -N4
...
  Total   time    5.10s  (  1.29s elapsed)</pre>
</div>
<div class="sect1" data-original-filename="ch04_par-monad.asciidoc" id="sec_par-monad-scheds">
<div class="titlepage"><div><div><h2 class="title">Using Different Schedulers</h2></div></div></div>
<p id="par_monadschedu"><a id="id405159" class="indexterm"></a><a id="id405166" class="indexterm"></a>The <code class="literal">Par</code> <a id="id405179" class="indexterm"></a>monad is implemented as a library in Haskell, so
aspects of its behavior can be changed without changing GHC or its
runtime system.  One way in which this is useful is in changing the
scheduling strategy; certain scheduling strategies are better suited
to certain patterns of execution.</p>
<p id="librariesmonad"><a id="id405196" class="indexterm"></a><a id="id405204" class="indexterm"></a>The <code class="literal">monad-par</code> library comes with two schedulers: the "Trace"
scheduler and the "Direct" scheduler, where the latter is the default. <a id="id405218" class="indexterm"></a> In general the Trace scheduler performs slightly worse than the <a id="id405225" class="indexterm"></a>Direct scheduler, but not always; it’s worth trying both with your code to see which gives the better results.</p>
<p id="to_choose_one_o">To choose one or the other, just import the appropriate module.  For
example, to use the Trace scheduler instead of the Direct scheduler:</p>
<pre class="programlisting" data-language="haskell" id="import_control_id1"><code class="kr">import</code> <code class="nn">Control.Monad.Par.Scheds.Trace</code>
   <code class="c1">-- instead of Control.Monad.Par</code></pre>
<p id="remember_that_y">Remember that you need to make this change in <span class="emphasis"><em>all</em></span> the modules of
your program that import <code class="literal">Control.Monad.Par</code>.</p>
</div>
<div class="sect1" data-original-filename="ch04_par-monad.asciidoc" id="sec_par-monad-reflections">
<div class="titlepage"><div><div><h2 class="title">The Par Monad Compared to Strategies</h2></div></div></div>
<p id="par_monadstrate"><a id="ix_ch04_par-monad-txt15" class="indexterm"></a><a id="ix_ch04_par-monad-txt16" class="indexterm"></a>I’ve presented two different parallel programming models, each with advantages and disadvantages.  In reality, though, both approaches are
suitable for a wide range of tasks; most Parallel Haskell benchmarks
achieve broadly similar results when coded with either Strategies or
the <code class="literal">Par</code> monad.  So which to choose is to some extent a matter of
personal preference.  However, there are a number of trade-offs that
are worth bearing in mind, as these might tip the balance one way
or the other for your code:</p>
<div class="itemizedlist" id="as_a_general_ru_id1"><ul class="itemizedlist">
<li class="listitem">
As a general rule of thumb, if your algorithm naturally produces a
  <a id="id405351" class="indexterm"></a>lazy data structure, then writing a <code class="literal">Strategy</code> to evaluate it in parallel will probably work well.  If not, then it can be more straightforward to use the <code class="literal">Par</code> monad to express the parallelism.
</li>
<li class="listitem">
The <code class="literal">runPar</code> <a id="id405386" class="indexterm"></a>function itself is relatively expensive, whereas
  <code class="literal">runEval</code> <a id="id405402" class="indexterm"></a><a id="id405410" class="indexterm"></a><a id="id405418" class="indexterm"></a>is free.  So when using the <code class="literal">Par</code> monad, you should usually
  try to thread the <code class="literal">Par</code> monad around to all the places that need
  parallelism to avoid needing multiple <code class="literal">runPar</code> calls.  If this is
  inconvenient, then <code class="literal">Eval</code> or Strategies might be a better choice.
  In particular, nested calls to <code class="literal">runPar</code> (where a <code class="literal">runPar</code> is
  evaluated during the course of executing another <code class="literal">Par</code> computation)
  usually give poor results.
</li>
<li class="listitem">
Strategies allow a separation between algorithm and parallelism,
  which can allow more reuse and a cleaner specification of
  parallelism.  However, using a <a id="id405477" class="indexterm"></a>parallel skeleton works with both
  approaches.
</li>
<li class="listitem">
The <code class="literal">Par</code> monad has more overhead than the <code class="literal">Eval</code> monad. At the
  present time, <code class="literal">Eval</code> tends to perform better at finer <a id="id405511" class="indexterm"></a><a id="id405519" class="indexterm"></a>granularities,
  due to the direct runtime system support for sparks.  At larger
  granularities, <code class="literal">Par</code> and <code class="literal">Eval</code> perform approximately the same.
</li>
<li class="listitem">
The <code class="literal">Par</code> monad is implemented entirely in a Haskell library (the
  <code class="literal">monad-par</code> package), and is thus easily modified.  There is a choice of scheduling strategies (see  <a class="xref" href="ch04.html#sec_par-monad-scheds" title="Using Different Schedulers">“Using Different Schedulers”</a>).
</li>
<li class="listitem">
The <code class="literal">Eval</code> monad has more diagnostics in <a id="id405580" class="indexterm"></a>ThreadScope.  There are
  graphs that show different aspects of <a id="id405590" class="indexterm"></a>sparks: creation rate,
  conversion rate, and so on.  The <code class="literal">Par</code> monad is not currently
  integrated with ThreadScope.
</li>
<li class="listitem">
The <code class="literal">Par</code> monad does not support <a id="id405618" class="indexterm"></a>speculative parallelism in the
  sense <a id="id405626" class="indexterm"></a>that <code class="literal">rpar</code> does (<a class="xref" href="ch03.html#sec_par-strat-speculative" title="GC’d Sparks and Speculative Parallelism">“GC’d Sparks and Speculative Parallelism”</a>); parallelism in the <code class="literal">Par</code> monad is always executed.<a id="id405653" class="indexterm"></a><a id="id405663" class="indexterm"></a><a id="id405673" class="indexterm"></a>
</li>
</ul></div>
</div>
<div class="footnotes">
<br><hr style="width: 100; align: left;">
<div id="ftn.id389641" class="footnote"><p><a href="#id389641" class="simpara"><sup class="simpara">[11] </sup></a><code class="literal">IVar</code> has this name because it is an implementation of I-Structures, a concept from an early Parallel
Haskell variant called <span class="emphasis"><em>pH</em></span>.</p></div>
<div id="ftn.id393748" class="footnote"><p><a href="#id393748" class="simpara"><sup class="simpara">[12] </sup></a>For more details, see the documentation for <code class="literal">Control.Monad.Applicative</code>.</p></div>
<div id="ftn.id396832" class="footnote"><p><a href="#id396832" class="simpara"><sup class="simpara">[13] </sup></a>You can verify this for yourself by profiling the
<span class="emphasis"><em>rsa.hs</em></span> program.  Most of the execution time is spent in <code class="literal">power</code>.</p></div>
<div id="ftn.id397495" class="footnote"><p><a href="#id397495" class="simpara"><sup class="simpara">[14] </sup></a>I’m avoiding the term "schedule" here because we already use it a lot in concurrent programming.</p></div>
<div id="ftn.id397787" class="footnote"><p><a href="#id397787" class="simpara"><sup class="simpara">[15] </sup></a>I should mention that even with some pruning, an exhaustive search will be impractical beyond a small number of slots. Real-world solutions to this kind of problem use heuristics.</p></div>
<div id="ftn.id403537" class="footnote"><p><a href="#id403537" class="simpara"><sup class="simpara">[16] </sup></a>This code was authored by Philip Wadler and found in the <code class="literal">nofib</code> benchmark suite of Haskell programs.</p></div>
<div id="ftn.id403547" class="footnote"><p><a href="#id403547" class="simpara"><sup class="simpara">[17] </sup></a>I did, however, take the liberty of modernizing the code in various ways, although that wasn’t strictly necessary.</p></div>
<div id="ftn.id403899" class="footnote"><p><a href="#id403899" class="simpara"><sup class="simpara">[18] </sup></a>We are ignoring the possibility of type errors here; in a real implementation, the <code class="literal">IVar</code> would probably contain an <code class="literal">Either</code> type representing either the inferred type or an error.</p></div>
</div></section><footer><div class="navfooter">
<hr>
<table style="width: 100%; ">
<tr>
<td style="width: 40%; text-align: left; ">
<a accesskey="p" href="ch03.html">Prev</a> </td>
<td style="width: 20%; text-align: center; "><a accesskey="u" href="pt01.html">Up</a></td>
<td style="width: 40%; text-align: right; "> <a accesskey="n" href="ch05.html">Next</a>
</td>
</tr>
<tr>
<td style="width: 40%; text-align: left; vertical-align: top; ">Chapter 3. Evaluation Strategies </td>
<td style="width: 20%; text-align: center; "><a accesskey="h" href="index.html">Home</a></td>
<td style="width: 40%; text-align: right; vertical-align: top; "> Chapter 5. Data Parallel Programming with Repa</td>
</tr>
</table>
</div></footer>


	<div class="extra-footer">
		<p>© 2013, O’Reilly Media, Inc.</p>
		<ul>
			<li><a href="http://oreilly.com/terms/">Terms of Service</a></li>
			<li><a href="http://oreilly.com/oreilly/privacy.csp">Privacy Policy</a></li>
			<li>Interested in <a href="mailto:scordesse@oreilly.com">sponsoring content?</a></li>
		</ul>
	</div>
<script type="text/javascript">if (!NREUMQ.f) { NREUMQ.f=function() {
NREUMQ.push(["load",new Date().getTime()]);
var e=document.createElement("script");
e.type="text/javascript";
e.src=(("http:"===document.location.protocol)?"http:":"https:") + "//" +
  "js-agent.newrelic.com/nr-100.js";
document.body.appendChild(e);
if(NREUMQ.a)NREUMQ.a();
};
NREUMQ.a=window.onload;window.onload=NREUMQ.f;
};
NREUMQ.push(["nrfj","bam.nr-data.net","3e361aebcf","2194180","IApbRUBZXg1WEEoHDAwORh5aQl8N",11,236,new Date().getTime(),"","","","",""]);</script></body>

<!-- Mirrored from chimera.labs.oreilly.com/books/1230000000929/ch04.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 25 Dec 2016 16:54:49 GMT -->
</html>