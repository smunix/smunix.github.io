<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<!-- Mirrored from chimera.labs.oreilly.com/books/1230000000929/ch06.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 18 Dec 2016 20:55:07 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head><script type="text/javascript">var NREUMQ=NREUMQ||[];NREUMQ.push(["mark","firstbyte",new Date().getTime()]);</script>
	<title>Parallel and Concurrent Programming in Haskell</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link href="http://dwn0odqttrkhc.cloudfront.net/assets/book-f1caceafd9c9f3a6ff72d40c54d173ab.css" media="screen" rel="stylesheet" type="text/css" />
	<link href="http://dwn0odqttrkhc.cloudfront.net/assets/default-24583441b4f47382b8932338cd56ed23.css" media="screen" rel="stylesheet" type="text/css" />
	<script src="http://dwn0odqttrkhc.cloudfront.net/assets/application-47d6ffb0c77b868d29a43eb65e940505.js" type="text/javascript"></script>
	<script src="http://dwn0odqttrkhc.cloudfront.net/assets/book-756862b9ed04d945ca53de5b8f106a83.js" type="text/javascript"></script>
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	<link href="http://dwn0odqttrkhc.cloudfront.net/assets/janrain-53eb5abed55992e21943b9d3373923e8.css" media="all" rel="stylesheet" type="text/css" />
	<meta content="authenticity_token" name="csrf-param" />
<meta content="WQ02oEFDbvBG99rmf8rwvGssMqcy27cCD64yZVVTcMY=" name="csrf-token" />
	<script type="text/javascript" charset="utf-8">
  	
		app.data = new classes.Data({"controller":{"controller":"books","action":"html"},"capturable":{"capture_server":"https://oreilly.janraincapture.com","client_id":"6n5q2k9vesqgn93k3mhevka6c3c3rsre","app_url":"https://login.oreilly.com","app_id":"xsnca5wmqe9vxv97ygh5vfejkd","load_js":"d16s8pqtk4uodx.cloudfront.net/login.oreilly.com/load.js"},"user":{"id":null,"account":"LoggedOutAccount","email":"","name":null,"gravatar_url":"http://www.gravatar.com/avatar/d41d8cd98f00b204e9800998ecf8427e?s=40&d=identicon"},"book":{"isbn":"1230000000929","chapter":"ch06.html","toc_url":"/books/1230000000929/toc_html","metadata_url":"http://d4bb7yl96lyl1.cloudfront.net/1230000000929/metadata/metadata_9b2ac4d71a3220a7d463d8d4c80f9113048bb194.json"},"abilities":{"can_destroy_all_comments":false,"can_create_comments":false},"advertisement":{"body":"<style>      \r\n.ad-profile-image {\r\n  padding: 0;\r\n  margin: 0;\r\n  max-height: 30px;\r\n }\r\n\r\n.top-banner {\r\n  position: absolute;\r\n  right: 0;\r\n  top: 34px;\r\n  z-index: 99999;\r\n}\r\n\r\np.banner-text {\r\n  margin: 0;\r\n  text-align: center;\r\n  padding-right: 10px;\r\n  width: 450px;\r\n}\r\n\r\n@media screen and (max-width: 600px) {\r\n   p.banner-text {\r\n     width: 100%;\r\n     text-align: center;\r\n  }\r\n}\r\n\r\nspan.ebook-advantage {\r\n  font-size: smaller;\r\n  display: block;\r\n}\r\n\r\ndiv.banner-container {\r\n  margin: 0 auto;\r\n}\r\n\r\ndiv.banner-container ul {\r\n  margin: 0 auto;\r\n}\r\n\r\ndiv.topad { padding-bottom: 5px; }\r\n\r\ndiv.banner-container ul li {\r\n  display: inline-block;\r\n  vertical-align: middle;\r\n}\r\n\r\ndiv.banner-container li p {\r\n  padding-top: 0;\r\n  margin-top: 0;\r\n}\r\n\r\ndiv.banner-container li.sponsor {\r\n  border-right: 1px solid rgb(125, 154, 180);\r\n  margin-right: 5px;\r\n  padding-right: 10px;\r\n}\r\n\r\ndiv.banner-container .webbutton {\r\n  background-color: #3994b6;\r\n  display: inline-block;\r\n  padding: 10px;\r\n  -webkit-border-radius: 5px;\r\n  -moz-border-radius: 5px;\r\n  border-radius: 5px;\r\n  color: #FFF;\r\n  text-align: center;\r\n  text-decoration: none;\r\n  font-size: 12px;\r\n  font-weight: bold;\r\n}\r\n\r\n</style>\r\n   \r\n<div style=\"color: rgb(125, 154, 180);\">\r\n\r\n<div class=\"banner-container\">\r\n\r\n<ul>\r\n\r\n<li class=\"sponsor\">\r\n<!--CONFERENCE SPONSOR IMAGE-->\r\n<a href=\"http://www.oscon.com/oscon2013\">\r\n<!--<img src=\"http://orm-other.s3.amazonaws.com/fluent_logo.png\" class=\"ad-profile-image\"/>-->\r\n<img src=\"http://orm-other.s3.amazonaws.com/oscon_logo.png\" class=\"ad-profile-image\"/>\r\n<!--<img src=\"http://orm-other.s3.amazonaws.com/strata_logo.png\" class=\"ad-profile-image\"/>\r\n<img src=\"http://orm-other.s3.amazonaws.com/StrataRx_logo.png\" class=\"ad-profile-image\"/>\r\n<img src=\"http://orm-other.s3.amazonaws.com/velocity_logo.png\" class=\"ad-profile-image\"/>-->\r\n</a>\r\n</li>\r\n\r\n<li>\r\n<!--AD TEXT, 2 LINES, REPLACE LINK URL AS WELL-->\r\n<p class=\"banner-text\">Enjoy this online version of <em>Parallel and Concurrent Programming in Haskell</em>. Purchase and download the DRM-free ebook on <a href=\"http://shop.oreilly.com/product/0636920026365.do\">oreilly.com</a>.<span class=\"ebook-advantage\">Learn more about the O’Reilly <a href=\"http://shop.oreilly.com/category/ebooks.do\">Ebook Advantage</a>.</span></p>\r\n</li>\r\n\r\n<li>\r\n<!--BUY BUTTON-->\r\n<a class=\"webbutton\" href=\"http://shop.oreilly.com/product/0636920026365.do\">Buy the Ebook</a>\r\n</li> \r\n\r\n</ul>\r\n\r\n</div>\r\n\r\n<!--CORNER BANNER (IF NEEDED)-->\r\n<!--<a href=\"http://shop.oreilly.com/product/0636920026365.do\" class=\"top-banner\"><img src=\"http://orm-other.s3.amazonaws.com/banner.png\" /></a>-->\r\n\r\n</div>"}});

		/* Janrain setup */
  	var janrainModal = new JanrainView();
  	$("head").append(janrainModal.render().el);

  	/* segment.io setup */
  	var analytics=analytics||[];analytics.load=function(e){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src=("https:"===document.location.protocol?"https://":"http://")+"d2dq2ahtl5zl1z.cloudfront.net/analytics.js/v1/"+e+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(t,n);var r=function(e){return function(){analytics.push([e].concat(Array.prototype.slice.call(arguments,0)))}},i=["identify","track","trackLink","trackForm","trackClick","trackSubmit","pageview","ab","alias","ready"];for(var s=0;s<i.length;s++)analytics[i[s]]=r(i[s])};
  	
  	analytics.load("hg9h6b9pae");

  	$(function() {
			app.bookapp = new BookApp();
		});
	
	</script>
</head>
<body>
	<div id="menu">
	
		<ul id="menu-left">
			<li id="home-link"><a href="http://chimera.labs.oreilly.com/"><i class="icon-house"></i></a></li>
			<li><a href="http://chimera.labs.oreilly.com/books/1230000000929">Parallel and Concurrent Programming in Haskell</a></li>
			<div class="clear"></div>
		</ul>
	
		<ul id="menu-right">
			<li id="comments-link"><a>&nbsp;</a></li>
			<li>
				<a href="#" class="dropdown-toggle" data-toggle="dropdown">Chapters</a>
				<div id="toc-popup" class="dropdown-menu"></div>
			</li>
				<li><a href="#" class="capture_modal_open" id="capture_signin_link">Log In / Sign Up</a></li>
			<li id="search-li">
				<form accept-charset="UTF-8" action="http://chimera.labs.oreilly.com/searches" id="search-form" method="get"><div style="margin:0;padding:0;display:inline"><input name="utf8" type="hidden" value="&#x2713;" /></div>
	<input name='search[q]' type="text" placeholder="Search book..." id="book-search" />

	<input id="search_bookId" name="search[bookId]" type="hidden" value="1230000000929" />
	
	<div style='display:none'>
		sorted by: 
		<select name='search[sort]' >
			<option value='relevance'>Relevance</option>
			<option value='authors'>Author(s)</option>
			<option value='title'>Title</option>
		</select>
		returning
		<select name='search[limit]' >
			<option value='5'>5</option>
			<option value='10'>10</option>
			<option value='20'>20</option>
			<option selected="selected" value='50'>50</option>
			<option value='100'>100</option>
		</select>
		values at a time.
	</div>
</form>
			</li>
			<div class="clear"></div>
		</ul>
		<div class="clear"></div>
	
</div>
	<header><div class="navheader">
<table style="width: 100%; ">
<tr><td style="text-align: center; " colspan="3">Chapter 6. GPU Programming with Accelerate</td></tr>
<tr>
<td style="width: 20%; text-align: left; ">
<a accesskey="p" href="ch05.html">Prev</a> </td>
<td style="width: 60%; text-align: center; ">Part I. Parallel Haskell</td>
<td style="width: 20%; text-align: right; "> <a accesskey="n" href="pt02.html">Next</a>
</td>
</tr>
</table>
<hr>
</div></header><section class="chapter" data-original-filename="ch06_par-accel.asciidoc" id="sec_par-accel"><div class="titlepage"><div><div><h2 class="title">Chapter 6. GPU Programming with Accelerate</h2></div></div></div>
<p id="accelerateaccel"><a id="ix_ch06_par-accel-txt0" class="indexterm"></a><a id="ix_ch06_par-accel-txt1" class="indexterm"></a><a id="ix_ch06_par-accel-txt2" class="indexterm"></a>The most powerful processor in your computer may not be the
CPU. Modern <a id="id414939" class="indexterm"></a><a id="id414945" class="indexterm"></a>graphics processing units (GPUs) usually have something on
the order of 10 to 100 times more raw compute power than the
general-purpose CPU.  However, the GPU is a very different beast from
the CPU, and we can’t just run ordinary Haskell programs on it.  A
GPU consists of a large number of parallel processing units, each of
which is much less powerful than one core of your CPU, so to unlock
the power of a GPU we need a highly parallel workload.  Furthermore,
the processors of a GPU all run exactly the same code in lockstep, so
they are suitable only for data-parallel tasks where the operations to
perform on each data item are identical.</p>
<p id="in_recent_years">In recent years GPUs have become less graphics-specific and more
suitable for performing general-purpose parallel processing tasks.
However, GPUs are still programmed in a different way from the CPU
because they have a different instruction set architecture.  A
special-purpose compiler is needed to compile code for the GPU, and
the source code is normally written in a language that resembles a
restricted subset of C. Two such languages are in widespread use:
<a id="id414972" class="indexterm"></a><a id="id414978" class="indexterm"></a><a id="id414984" class="indexterm"></a>NVidia’s CUDA and OpenCL.  These languages are very low-level and
expose lots of details about the workings of the GPU, such as how and
when to move data between the CPU’s memory and the GPU’s memory.</p>
<p id="clearly_we_wou">Clearly, we would like to be able to make use of the vast computing
power of the GPU from Haskell without having to write code in CUDA or
OpenCL.  This is where the Accelerate library comes in: Accelerate
is an embedded domain-specific language (EDSL) for programming
the GPU.  It allows us to write Haskell code in a somewhat stylized form
and have it run directly on the GPU.  For certain tasks, we can obtain
orders of magnitude speedup by using Accelerate.</p>
<p id="during_the_cour">During the course of this chapter, I’ll be introducing the various
concepts of Accelerate, starting with the basic data types and
operations and progressing to full-scale examples that run on the
GPU.</p>
<p id="as_with_repa_in">As with Repa in the previous chapter, I’ll be illustrating many of
the Accelerate operations by typing expressions into GHCi.
Accelerate comes with an <a id="id415022" class="indexterm"></a>interpreter, which means that for
experimenting with Accelerate code, you don’t need a machine with a
GPU.  To play with examples yourself, first make sure the <code class="literal">accelerate</code>
package is installed:</p>
<pre class="screen" id="cabal_install_id2">$ cabal install accelerate</pre>
<p id="the_accelerate_">The <code class="literal">accelerate</code> package provides the basic infrastructure, which includes the <code class="literal">Data</code><code class="literal">.Array.Accelerate</code> module for constructing array computations, and <code class="literal">Data</code><code class="literal">.Array.Accelerate.Interpreter</code> for interpreting them.  To actually run an Accelerate computation on a GPU, you will also need a supported GPU card and the <code class="literal">accelerate-cuda</code> package; I’ll cover that later in <a class="xref" href="ch06.html#sec_par-accel-gpu" title="Running on the GPU">“Running on the GPU”</a>.</p>
<p id="when_you_have_t">When you have the <code class="literal">accelerate</code> package installed, you can start up
GHCi and import the necessary modules:</p>
<pre class="screen" id="ghci_prelude">$ ghci
Prelude&gt; import Data.Array.Accelerate as A
Prelude A&gt; import Data.Array.Accelerate.Interpreter as I
Prelude A I&gt;</pre>
<p id="as_well_see_a">As we’ll see, Accelerate shares many concepts with Repa.  In
particular, array shapes and indices are the same, and Accelerate
also has the concept of shape-polymorphic operations like fold.<a id="id415130" class="indexterm"></a><a id="id415140" class="indexterm"></a></p>
<div class="sect1" data-original-filename="ch06_par-accel.asciidoc" id="sec_par-accel-overview">
<div class="titlepage"><div><div><h2 class="title">Overview</h2></div></div></div>
<p id="i_mentioned_ear">I mentioned earlier that Accelerate is an <a id="id415166" class="indexterm"></a>embedded domain-specific
language for programming GPUs. More specifically, it is a
deeply embedded DSL. This means that programs are written in Haskell
syntax using operations of the library, but the method by which the
program runs is different from a conventional Haskell program.  A
program fragment that uses Accelerate works like this:</p>
<div class="itemizedlist" id="the_haskell_cod_id1"><ul class="itemizedlist">
<li class="listitem">
The Haskell code generates a data structure in an internal
  representation that the programmer doesn’t get to see.
</li>
<li class="listitem">
This data structure is then compiled into GPU code using the <code class="literal">accelerate-cuda</code> package and run
  directly on the GPU. When you don’t have a <a id="id415204" class="indexterm"></a>GPU, the <code class="literal">accelerate</code>
  package <span class="emphasis"><em>interprets</em></span> the code instead, using Accelerate’s
  built-in interpreter.  Both methods give the same results, but of
  course running on the GPU should be far faster.
</li>
</ul></div>
<p id="both_steps_happ">Both steps happen while the Haskell program is running; there’s no
extra compile step, apart from compiling the Haskell program itself.</p>
<p id="by_the_magic_of">By the magic of Haskell’s overloading and abstraction facilities, the
Haskell code that you write using Accelerate usually looks much like
ordinary Haskell code, even though it generates another program rather
than actually producing the result directly.</p>
<p id="while_reading_t">While reading this chapter, you probably want to have a copy of the
Accelerate <a class="ulink" href="http://hackage.haskell.org/package/accelerate/" target="_top">API documentation</a> at hand.</p>
</div>
<div class="sect1" data-original-filename="ch06_par-accel.asciidoc" id="sec_par-accel-arrays">
<div class="titlepage"><div><div><h2 class="title">Arrays and Indices</h2></div></div></div>
<p id="acceleratearray_id1"><a id="ix_ch06_par-accel-txt5" class="indexterm"></a><a id="ix_ch06_par-accel-txt6" class="indexterm"></a><a id="ix_ch06_par-accel-txt7" class="indexterm"></a><a id="id415312" class="indexterm"></a><a id="id415318" class="indexterm"></a>As with Repa, Accelerate is a framework for programming with
arrays. An Accelerate computation takes arrays as inputs and
delivers one or more arrays as output.  The type of Accelerate
arrays has only two parameters, though:</p>
<pre class="programlisting" data-language="haskell" id="data_array_sh_e"><code class="kr">data</code> <code class="kt">Array</code> <code class="n">sh</code> <code class="n">e</code></pre>
<p id="here_e_is_the_">Here, <code class="literal">e</code> is the element type, and <code class="literal">sh</code> is the shape.  There is no <a id="id415376" class="indexterm"></a>representation type. Even though Accelerate does have delayed arrays internally and compositions of array operations are fused in much the same way as in Repa, arrays are not explicitly tagged with a representation type.</p>
<p id="shapes_and_indi">Shapes and indices use the same data types as Repa (for more details see <a class="xref" href="ch05.html#sec_par-repa-arrays" title="Arrays, Shapes, and Indices">“Arrays, Shapes, and Indices”</a>):</p>
<pre class="programlisting" data-language="haskell" id="data_z__z_data_id2"><code class="kr">data</code> <code class="kt">Z</code> <code class="ow">=</code> <code class="kt">Z</code>
<code class="kr">data</code> <code class="n">tail</code> <code class="kt">:.</code> <code class="n">head</code> <code class="ow">=</code> <code class="n">tail</code> <code class="kt">:.</code> <code class="n">head</code></pre>
<p id="and_there_are_s">And there are some convenient type synonyms for common shapes:</p>
<pre class="programlisting" data-language="haskell" id="type_dim__z_t_id2"><code class="kr">type</code> <code class="kt">DIM0</code> <code class="ow">=</code> <code class="kt">Z</code>
<code class="kr">type</code> <code class="kt">DIM1</code> <code class="ow">=</code> <code class="kt">DIM0</code> <code class="kt">:.</code> <code class="kt">Int</code>
<code class="kr">type</code> <code class="kt">DIM2</code> <code class="ow">=</code> <code class="kt">DIM1</code> <code class="kt">:.</code> <code class="kt">Int</code></pre>
<p id="because_arrays_">Because <a id="id415578" class="indexterm"></a><a id="id415586" class="indexterm"></a>arrays of dimensionality zero and one are common, the library
provides type synonyms for those:</p>
<pre class="programlisting" data-language="haskell" id="type_scalar_e_"><code class="kr">type</code> <code class="kt">Scalar</code> <code class="n">e</code> <code class="ow">=</code> <code class="kt">Array</code> <code class="kt">DIM0</code> <code class="n">e</code>
<code class="kr">type</code> <code class="kt">Vector</code> <code class="n">e</code> <code class="ow">=</code> <code class="kt">Array</code> <code class="kt">DIM1</code> <code class="n">e</code></pre>
<p id="you_can_build_a">You can build arrays and experiment with them in ordinary Haskell code
<a id="id415685" class="indexterm"></a>using <code class="literal">fromList</code>:</p>
<pre class="programlisting" data-language="haskell" id="fromlist__sh"><code class="nf">fromList</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">Shape</code> <code class="n">sh</code><code class="p">,</code> <code class="kt">Elt</code> <code class="n">e</code><code class="p">)</code> <code class="ow">=&gt;</code> <code class="n">sh</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="n">e</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="kt">Array</code> <code class="n">sh</code> <code class="n">e</code></pre>
<p id="as_we_saw_with_">As we saw with Repa, we have to be careful to give GHC enough type
information to fix the type of the indices (to <code class="literal">Int</code>), and the same is
true in Accelerate.  Let’s build a 10-element vector using <code class="literal">fromList</code>:</p>
<pre class="screen" id="fromlist_z_id1">&gt; fromList (Z:.10) [1..10] :: Vector Int
Array (Z :. 10) [1,2,3,4,5,6,7,8,9,10]</pre>
<p id="similarly_we_c_id2">Similarly, we can make a two-dimensional array, with three rows of five
columns:</p>
<pre class="screen" id="fromlist_z_id2">&gt; fromList (Z:.3:.5) [1..] :: Array DIM2 Int
Array (Z :. 3 :. 5) [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]</pre>
<p id="the_operation_f">The operation for <a id="id415856" class="indexterm"></a><a id="id415862" class="indexterm"></a>indexing one of these arrays is <code class="literal">indexArray</code>:</p>
<pre class="screen" id="let_arr__fro_id5">&gt; let arr = fromList (Z:.3:.5) [1..] :: Array DIM2 Int
&gt; indexArray arr (Z:.2:.1)
12</pre>
<p id="there_is_also_">(There is also <a id="id415892" class="indexterm"></a>a <code class="literal">!</code> operator that performs indexing, but unlike
<code class="literal">indexArray</code> it can only be used in the context of an Accelerate
computation, which we’ll see shortly.)</p>
<p id="one_thing_to_re">One thing to remember is that in Accelerate, arrays cannot be nested; it is
impossible to build an array of arrays.  This is because arrays must
be able to be mapped directly into flat arrays on the GPU, which has
no support for <a id="id415923" class="indexterm"></a><a id="id415930" class="indexterm"></a>nested arrays.</p>
<p id="we_can_however">We can, however, have arrays of <a id="id415944" class="indexterm"></a>tuples.  For example:</p>
<pre class="screen" id="fromlist_z_id3">&gt; fromList (Z:.2:.3) (Prelude.zip [1..] [1..]) :: Array DIM2 (Int,Int)
Array (Z :. 2 :. 3) [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6)]</pre>
<p id="internally_acc">Internally, Accelerate will translate an array of tuples into a tuple of
arrays; this is done entirely automatically, and we don’t need to worry
about it.  Arrays of tuples are a very useful structure, as we shall
see.<a id="id415971" class="indexterm"></a><a id="id415980" class="indexterm"></a><a id="id415990" class="indexterm"></a></p>
</div>
<div class="sect1" data-original-filename="ch06_par-accel.asciidoc" id="sec_par-accel-running">
<div class="titlepage"><div><div><h2 class="title">Running a Simple Accelerate Computation</h2></div></div></div>
<p id="accelerateprogr"><a id="ix_ch06_par-accel-txt8" class="indexterm"></a>So far, we have been experimenting with arrays in the context of ordinary Haskell code; we haven’t constructed an actual Accelerate computation over arrays yet.  An Accelerate computation takes the form <code class="literal">run</code> <em class="replaceable"><code>E</code></em>, where:</p>
<pre class="programlisting" data-language="haskell" id="run__arrays_a"><code class="nf">run</code> <code class="ow">::</code> <code class="kt">Arrays</code> <code class="n">a</code> <code class="ow">=&gt;</code> <code class="kt">Acc</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code></pre>
<p id="the_expression__id2">The expression <em class="replaceable"><code>E</code></em> has type <code class="literal">Acc a</code>, which means “an accelerated computation that delivers a value of type <code class="literal">a</code>.”  The
<code class="literal">Arrays</code> class allows <code class="literal">a</code> to be either an array or a tuple of
arrays. A value of type <code class="literal">Acc a</code> is really a data structure (we’ll see
in a moment how to build it), and the <code class="literal">run</code> function evaluates the
data structure to produce a result.  There are two versions of <code class="literal">run</code>:
one exported by <code class="literal">Data.Array.Accelerate.Interpreter</code> that we will be
using for experimentation and testing, and another exported by
<code class="literal">Data.Array.Accelerate.CUDA</code> (in the <code class="literal">accelerate-cuda</code> package) that
runs the computation on the GPU.</p>
<p id="lets_try_a_ver">Let’s try a very simple example.  Starting with the 3×5 array of
<code class="literal">Int</code> from the previous section, let’s add one to every element:</p>
<pre class="screen" id="let_arr__fro_id6">&gt; let arr = fromList (Z:.3:.5) [1..] :: Array DIM2 Int
&gt; run $ A.map (+1) (use arr)
Array (Z :. 3 :. 5) [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]</pre>
<p id="breaking_this_d">Breaking this down, first we <a id="id416203" class="indexterm"></a>call <code class="literal">A.map</code>, which is the <code class="literal">map</code> function
from <code class="literal">Data.Array.Accelerate</code>; recall that we used <code class="literal">import
Data.Array.Accelerate as A</code> earlier.  We have to use the
qualified name, because there are two <code class="literal">map</code> functions in scope:
<code class="literal">A.map</code> and <code class="literal">Prelude.map</code>.</p>
<p id="here_is_the_typ">Here is the type of <code class="literal">A.map</code>:</p>
<pre class="screen" id="amap__shape"><code class="nf">A.map</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">Shape</code> <code class="n">ix</code><code class="p">,</code> <code class="kt">Elt</code> <code class="n">a</code><code class="p">,</code> <code class="kt">Elt</code> <code class="n">b</code><code class="p">)</code>
      <code class="ow">=&gt;</code> <code class="p">(</code><code class="kt">Exp</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="n">b</code><code class="p">)</code>
      <code class="ow">-&gt;</code> <code class="kt">Acc</code> <code class="p">(</code><code class="kt">Array</code> <code class="n">ix</code> <code class="n">a</code><code class="p">)</code>
      <code class="ow">-&gt;</code> <code class="kt">Acc</code> <code class="p">(</code><code class="kt">Array</code> <code class="n">ix</code> <code class="n">b</code><code class="p">)</code></pre>
<p id="a_few_things_wi">A few things will probably seem unusual about this type.  First let’s look at the second argument. This is the array
to map over, but rather than just an <code class="literal">Array ix a</code>, it is an <code class="literal">Acc (Array ix a)</code>—that is, an array in the Accelerate world rather than
the ordinary Haskell world.  We need to somehow turn our <code class="literal">Array DIM2
Int</code> into an <code class="literal">Acc (Array DIM2 Int)</code>.  This is what <a id="id416474" class="indexterm"></a>the <code class="literal">use</code> function
is for:</p>
<pre class="programlisting" data-language="haskell" id="use__arrays_a"><code class="nf">use</code> <code class="ow">::</code> <code class="kt">Arrays</code> <code class="n">arrays</code> <code class="ow">=&gt;</code> <code class="n">arrays</code> <code class="ow">-&gt;</code> <code class="kt">Acc</code> <code class="n">arrays</code></pre>
<p id="the_use_functio">The <code class="literal">use</code> function is the way to take arrays from Haskell and inject
them into an Accelerate computation. This
might actually involve copying the array from the computer’s main
memory into the GPU’s memory.</p>
<p id="the_first_argum_id3">The first argument to <code class="literal">A.map</code> has type <code class="literal">Exp a -&gt; Exp b</code>.  Here, <code class="literal">Exp</code>
is a bit like <code class="literal">Acc</code>. It represents a computation in the world of
Accelerate, but whereas <code class="literal">Acc</code> is a computation delivering an array,
<code class="literal">Exp</code> is a computation delivering a single value.</p>
<p id="in_the_example_">In the example we passed <code class="literal">(+1)</code> as the first argument to map.  This
expression is overloaded in Haskell with type <code class="literal">Num a =&gt; a -&gt; a</code>, and
we’re accustomed to seeing it used at types like <code class="literal">Int -&gt; Int</code> and
<code class="literal">Double -&gt; Double</code>.  Here, however, it is being used at type <code class="literal">Exp Int
-&gt; Exp Int</code>; this is possible because Accelerate provides an instance
for <code class="literal">Num (Exp a)</code>, so expressions built using integer
constants and overloaded <code class="literal">Num</code> operations work just fine in the world
of <code class="literal">Exp</code>.<a href="#ftn.id416657" class="footnote"><sup class="footnote" id="id416657">[22]</sup></a></p>
<p id="heres_another_">Here’s another example, which squares every element in the array:</p>
<pre class="screen" id="run__amap_">&gt; run $ A.map (^2) (use arr)
Array (Z :. 3 :. 5) [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225]</pre>
<p id="we_can_inject_v">We can inject values into the Accelerate world with functions such as
<code class="literal">use</code> (and some more that we’ll see shortly), but the only way to get
data <span class="emphasis"><em>out</em></span> of an Accelerate computation is to run it with <code class="literal">run</code>, and
then the result becomes available to the caller as an ordinary Haskell
value.<a id="id416724" class="indexterm"></a></p>
<div class="sidebar" id="type_classes_elt_arrays_and_shape">
<div class="titlepage"><div><div><div class="sidebar-title">Type Classes: Elt, Arrays, and Shape</div></div></div></div>
<p id="acceleratearray_id2"><a id="id416748" class="indexterm"></a><a id="id416756" class="indexterm"></a><a id="id416764" class="indexterm"></a><a id="id416772" class="indexterm"></a><a id="id416780" class="indexterm"></a><a id="id416786" class="indexterm"></a><a id="id416792" class="indexterm"></a>There are a few type classes that commonly appear in the
operations from <code class="literal">Data.Array.Accelerate</code>.
The types are restricted to a fixed set, and aside from this we don’t need
to know anything more about them; indeed, Accelerate hides the methods
from the public API.  Briefly, these are the three type classes you
will encounter most often:</p>
<div class="variablelist" id="elt_the_class_o"><dl class="variablelist">
<dt><span class="term">
<code class="literal">Elt</code>
</span></dt>
<dd>
  The class of types that may be array elements.  Includes all the
  usual numeric types, as well as indices and tuples.  In types of the
  form <code class="literal">Exp e</code>, the <code class="literal">e</code> is often required to be an instance of <code class="literal">Elt</code>.
  Note in particular that arrays are not an instance of <code class="literal">Elt</code>; this is
  the mechanism by which Accelerate enforces that arrays cannot be
  nested.
</dd>
<dt><span class="term">
<code class="literal">Arrays</code>
</span></dt>
<dd>
  This type class includes arrays and tuples of arrays.  In <code class="literal">Acc a</code>,
  the <code class="literal">a</code> must always be an instance of the type class <code class="literal">Arrays</code>.
</dd>
<dt><span class="term">
<code class="literal">Shape</code>
</span></dt>
<dd>
  The class of shapes and indices.  This class includes only <code class="literal">Z</code> and
  <code class="literal">:.</code> and is used to ensure that values used as shapes and indices
  are constructed from these two types.
</dd>
</dl></div>
<p id="see_the_acceler">See the Accelerate documentation for a full list of the instances of
each class.</p>
</div>
</div>
<div class="sect1" data-original-filename="ch06_par-accel.asciidoc" id="sec_par-accel-scalar">
<div class="titlepage"><div><div><h2 class="title">Scalar Arrays</h2></div></div></div>
<p id="arrays_in_accel_id1"><a id="id416940" class="indexterm"></a><a id="id416948" class="indexterm"></a>Sometimes we want to use a single value in a place where the API only
allows an array; this is quite common in Accelerate because most
operations are over arrays.  For example, the result of <code class="literal">run</code> contains
only arrays, not scalars, so if we want to return a single value, we have to
wrap it in an array first.  <a id="id416963" class="indexterm"></a>The <code class="literal">unit</code> operation is provided for this
purpose:</p>
<pre class="programlisting" data-language="haskell" id="unit__elt_e_"><code class="nf">unit</code> <code class="ow">::</code> <code class="kt">Elt</code> <code class="n">e</code> <code class="ow">=&gt;</code> <code class="kt">Exp</code> <code class="n">e</code> <code class="ow">-&gt;</code> <code class="kt">Acc</code> <code class="p">(</code><code class="kt">Scalar</code> <code class="n">e</code><code class="p">)</code></pre>
<p id="recall_that_sca">Recall that <code class="literal">Scalar</code> is a type synonym for <code class="literal">Array DIM0</code>; an array with
zero dimensions has only one element.  Now we can return a single
value from <code class="literal">run</code>:</p>
<pre class="screen" id="run__unit_">&gt; run $ unit (3::Exp Int)
Array (Z) [3]</pre>
<p id="the_dual_to_uni">The dual to <code class="literal">unit</code> <a id="id417096" class="indexterm"></a>is <code class="literal">the</code>, which extracts a single value from a
<code class="literal">Scalar</code>:</p>
<pre class="programlisting" data-language="haskell" id="the__elt_e_"><code class="nf">the</code> <code class="ow">::</code> <code class="kt">Elt</code> <code class="n">e</code> <code class="ow">=&gt;</code> <code class="kt">Acc</code> <code class="p">(</code><code class="kt">Scalar</code> <code class="n">e</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="n">e</code></pre>
</div>
<div class="sect1" data-original-filename="ch06_par-accel.asciidoc" id="sec_par-accel-index">
<div class="titlepage"><div><div><h2 class="title">Indexing Arrays</h2></div></div></div>
<p id="arrays_in_accel_id2"><a id="id417206" class="indexterm"></a><a id="id417214" class="indexterm"></a><a id="id417222" class="indexterm"></a>The <code class="literal">!</code> operator indexes into an array:</p>
<pre class="screen" id="_shape_i"><code class="p">(</code><code class="nf">!</code><code class="p">)</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">Shape</code> <code class="n">ix</code><code class="p">,</code> <code class="kt">Elt</code> <code class="n">e</code><code class="p">)</code> <code class="ow">=&gt;</code> <code class="kt">Acc</code> <code class="p">(</code><code class="kt">Array</code> <code class="n">ix</code> <code class="n">e</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="n">ix</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="n">e</code></pre>
<p id="unlike_the_inde">Unlike the <code class="literal">indexArray</code> function that we saw earlier, the <code class="literal">!</code> operator
works in the Accelerate world; the array argument has type <code class="literal">Acc (Array ix e)</code>, and the index is an <code class="literal">Exp ix</code>.  So how do we get from an ordinary index like <code class="literal">Z:.3</code> to an <code class="literal">Exp (Z:.Int)</code>?  There is a handy
function <code class="literal">index1</code> for exactly this purpose:</p>
<pre class="programlisting" data-language="haskell" id="index__exp_i_id1"><code class="nf">index1</code> <code class="ow">::</code> <code class="kt">Exp</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="p">(</code><code class="kt">Z</code> <code class="kt">:.</code> <code class="kt">Int</code><code class="p">)</code></pre>
<p id="so_now_we_can_i">So now we can index into an array.  Putting these together in GHCi:</p>
<pre class="screen" id="let_arr__fro_id7">&gt; let arr = fromList (Z:.10) [1..10] :: Array DIM1 Int
&gt; run $ unit (use arr ! index1 3)
Array (Z) [4]</pre>
</div>
<div class="sect1" data-original-filename="ch06_par-accel.asciidoc" id="sec_par-accel-creating-arrays">
<div class="titlepage"><div><div><h2 class="title">Creating Arrays Inside Acc</h2></div></div></div>
<p id="acceleratecreat"><a id="ix_ch06_par-accel-txt18" class="indexterm"></a><a id="ix_ch06_par-accel-txt19" class="indexterm"></a>We saw earlier how to create arrays using <code class="literal">fromList</code> and then inject them into the <code class="literal">Acc</code> world with <code class="literal">use</code>.  This is not a particularly
efficient way to create arrays. Even if the compiler is clever enough
to optimize away the intermediate list, the array data will still have
to be copied over to the GPU’s memory.  So it’s usually better to
create arrays inside <code class="literal">Acc</code>.  The Accelerate library provides a few
ways to create arrays inside <code class="literal">Acc</code>; the simplest one is <code class="literal">fill</code>:</p>
<pre class="programlisting" data-language="haskell" id="fill__shape_"><code class="nf">fill</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">Shape</code> <code class="n">sh</code><code class="p">,</code> <code class="kt">Elt</code> <code class="n">e</code><code class="p">)</code> <code class="ow">=&gt;</code> <code class="kt">Exp</code> <code class="n">sh</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="n">e</code> <code class="ow">-&gt;</code> <code class="kt">Acc</code> <code class="p">(</code><code class="kt">Array</code> <code class="n">sh</code> <code class="n">e</code><code class="p">)</code></pre>
<p id="fill_operationt"><a id="id417699" class="indexterm"></a>The <code class="literal">fill</code> operation creates an array of the specified shape in which
all elements have the same value.  We can create arrays in which the
elements are drawn from a sequence by <a id="id417713" class="indexterm"></a><a id="id417719" class="indexterm"></a>using <code class="literal">enumFromN</code> and
<code class="literal">enumFromStepN</code>:</p>
<pre class="programlisting" data-language="haskell" id="enumfromn__s"><code class="nf">enumFromN</code>     <code class="ow">::</code> <code class="p">(</code><code class="kt">Shape</code> <code class="n">sh</code><code class="p">,</code> <code class="kt">Elt</code> <code class="n">e</code><code class="p">,</code> <code class="kt">IsNum</code> <code class="n">e</code><code class="p">)</code>
              <code class="ow">=&gt;</code> <code class="kt">Exp</code> <code class="n">sh</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="n">e</code> <code class="ow">-&gt;</code> <code class="kt">Acc</code> <code class="p">(</code><code class="kt">Array</code> <code class="n">sh</code> <code class="n">e</code><code class="p">)</code>

<code class="nf">enumFromStepN</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">Shape</code> <code class="n">sh</code><code class="p">,</code> <code class="kt">Elt</code> <code class="n">e</code><code class="p">,</code> <code class="kt">IsNum</code> <code class="n">e</code><code class="p">)</code>
              <code class="ow">=&gt;</code> <code class="kt">Exp</code> <code class="n">sh</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="n">e</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="n">e</code> <code class="ow">-&gt;</code> <code class="kt">Acc</code> <code class="p">(</code><code class="kt">Array</code> <code class="n">sh</code> <code class="n">e</code><code class="p">)</code></pre>
<p id="in_enumfromn_t">In <code class="literal">enumFromN</code>, the first argument is the shape and the second is the value of the first element.  For example, <code class="literal">enumFromN</code> <code class="literal">(index1</code> <em class="replaceable"><code>N</code></em><code class="literal">)</code> <em class="replaceable"><code>M</code></em> is the same as <code class="literal">use</code> <code class="literal">(fromList (Z:.</code><em class="replaceable"><code>N</code></em><code class="literal">)</code> <code class="literal">[</code><em class="replaceable"><code>M</code></em><code class="literal">..])</code>.</p>
<p id="the_enumfromste">The <code class="literal">enumFromStepN</code> function is the same, except that we can specify
the increment between the element values.  For instance, to create a
two-dimensional array of shape three rows of five columns, where the elements
are drawn from the sequence <code class="literal">[15,14..]</code>:</p>
<pre class="screen" id="run__enumfro">&gt; run $ enumFromStepN (index2 3 5) 15 (-1) :: Array DIM2 Int
Array (Z :. 3 :. 5) [15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]</pre>
<p id="note_that_we_us">Note that we used <code class="literal">index2</code>, the two-dimensional version of <code class="literal">index1</code>
that we saw earlier, to create the shape argument.</p>
<p id="a_more_general_">A more general way to create arrays is provided <a id="id418135" class="indexterm"></a>by <code class="literal">generate</code>:</p>
<pre class="programlisting" data-language="haskell" id="generate__sh"><code class="nf">generate</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">Shape</code> <code class="n">ix</code><code class="p">,</code> <code class="kt">Elt</code> <code class="n">a</code><code class="p">)</code>
         <code class="ow">=&gt;</code> <code class="kt">Exp</code> <code class="n">ix</code> <code class="ow">-&gt;</code> <code class="p">(</code><code class="kt">Exp</code> <code class="n">ix</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="n">a</code><code class="p">)</code>
         <code class="ow">-&gt;</code> <code class="kt">Acc</code> <code class="p">(</code><code class="kt">Array</code> <code class="n">ix</code> <code class="n">a</code><code class="p">)</code></pre>
<p id="this_time_the__id1">This time, the values of the elements are determined by a user-supplied
function from <code class="literal">Exp ix</code> to <code class="literal">Exp a</code>; that is, the function that will be
applied to each index in the array to determine the element value at
that position.  This is exactly like the <code class="literal">fromFunction</code> operation
we used in Repa, except that here we must supply a function in the
<code class="literal">Exp</code> world rather than an arbitrary Haskell function.</p>
<p id="for_instance_t">For instance, to create a two-dimensional array in which every element
is given by the sum of its <code class="literal">x</code> and <code class="literal">y</code> coordinates, we can use
<code class="literal">generate</code>:</p>
<pre class="screen" id="run__generat">&gt; run $ generate (index2 3 5) (\ix -&gt; let Z:.y:.x = unlift ix in x + y)
Array (Z :. 3 :. 5) [0,1,2,3,4,1,2,3,4,5,2,3,4,5,6]</pre>
<p id="lets_look_in_m">Let’s look in more detail at the function argument:</p>
<pre class="programlisting" data-language="haskell" id="ix__let_zy">  <code class="nf">\</code><code class="n">ix</code> <code class="ow">-&gt;</code> <code class="kr">let</code> <code class="kt">Z:.</code><code class="n">y</code><code class="kt">:.</code><code class="n">x</code> <code class="ow">=</code> <code class="n">unlift</code> <code class="n">ix</code> <code class="kr">in</code> <code class="n">x</code> <code class="o">+</code> <code class="n">y</code></pre>
<p id="the_function_as">The function as a whole must have type <code class="literal">Exp DIM2 -&gt; Exp Int</code>, and
hence <code class="literal">ix</code> has type <code class="literal">Exp DIM2</code>.  We need to extract the <code class="literal">x</code> and <code class="literal">y</code>
values from the index, which means we need to deconstruct the <code class="literal">Exp
DIM2</code>.  The <a id="id418493" class="indexterm"></a>function <code class="literal">unlift</code> does this; in general, you should think
of <code class="literal">unlift</code> as a way to take apart a structured value inside an <code class="literal">Exp</code>.
It works for tuples and indices. In the previous example, we’re using
<code class="literal">unlift</code> at the following type:<a href="#ftn.id418525" class="footnote"><sup class="footnote" id="id418525">[23]</sup></a></p>
<pre class="programlisting" data-language="haskell" id="unlift__exp_"><code class="nf">unlift</code> <code class="ow">::</code> <code class="kt">Exp</code> <code class="p">(</code><code class="kt">Z</code> <code class="kt">:.</code> <code class="kt">Int</code> <code class="kt">:.</code> <code class="kt">Int</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">Z</code> <code class="kt">:.</code> <code class="kt">Exp</code> <code class="kt">Int</code> <code class="kt">:.</code> <code class="kt">Exp</code> <code class="kt">Int</code></pre>
<p id="the_result_is_a_id3">The result is a <code class="literal">DIM2</code> value in the Haskell world, so we can pattern
match against <code class="literal">Z:.x:.y</code> to extract the <code class="literal">x</code> and <code class="literal">y</code> values, both of type <code class="literal">Exp Int</code>.  Then <code class="literal">x + y</code> gives us the sum of <code class="literal">x</code> and <code class="literal">y</code> as an <code class="literal">Exp Int</code>, by virtue of the overloaded <code class="literal">+</code> operator.</p>
<p id="there_is_a_dual">There is a dual to <code class="literal">unlift</code>, unsurprisingly <a id="id418729" class="indexterm"></a>called <code class="literal">lift</code>, which does
the opposite transformation.  In fact, the <code class="literal">index2</code> function that we
used in the <code class="literal">generate</code> example earlier is defined in terms of <code class="literal">lift</code>:</p>
<pre class="programlisting" data-language="haskell" id="index__exp_i_id2"><code class="nf">index2</code> <code class="ow">::</code> <code class="kt">Exp</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="kt">DIM2</code>
<code class="nf">index2</code> <code class="n">i</code> <code class="n">j</code> <code class="ow">=</code> <code class="n">lift</code> <code class="p">(</code><code class="kt">Z</code> <code class="kt">:.</code> <code class="n">i</code> <code class="kt">:.</code> <code class="n">j</code><code class="p">)</code></pre>
<p id="this_use_of_lif">This use of <code class="literal">lift</code> has the following type:</p>
<pre class="programlisting" data-language="haskell" id="lift__z__ex"><code class="nf">lift</code> <code class="ow">::</code> <code class="kt">Z</code> <code class="kt">:.</code> <code class="kt">Exp</code> <code class="kt">Int</code> <code class="kt">:.</code> <code class="kt">Exp</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="p">(</code><code class="kt">Z</code> <code class="kt">:.</code> <code class="kt">Int</code> <code class="kt">:.</code> <code class="kt">Int</code><code class="p">)</code></pre>
<p id="the_lift_and_un">The <code class="literal">lift</code> and <code class="literal">unlift</code> functions are essential when we’re working
with indices in Accelerate, and as we’ll see later, they’re useful
for working with tuples as well.<a id="id419015" class="indexterm"></a><a id="id419025" class="indexterm"></a></p>
</div>
<div class="sect1" data-original-filename="ch06_par-accel.asciidoc" id="sec_par-accel-zip">
<div class="titlepage"><div><div><h2 class="title">Zipping Two Arrays</h2></div></div></div>
<p id="arrays_in_accel_id3"><a id="id419048" class="indexterm"></a><a id="id419056" class="indexterm"></a><a id="id419064" class="indexterm"></a>The <code class="literal">zipWith</code> function combines two arrays to produce a third array
by applying the supplied function to corresponding elements of the
input arrays:</p>
<pre class="programlisting" data-language="haskell" id="zipwith__sha"><code class="nf">zipWith</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">Shape</code> <code class="n">ix</code><code class="p">,</code> <code class="kt">Elt</code> <code class="n">a</code><code class="p">,</code> <code class="kt">Elt</code> <code class="n">b</code><code class="p">,</code> <code class="kt">Elt</code> <code class="n">c</code><code class="p">)</code>
        <code class="ow">=&gt;</code> <code class="p">(</code><code class="kt">Exp</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="n">b</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="n">c</code><code class="p">)</code>
        <code class="ow">-&gt;</code> <code class="kt">Acc</code> <code class="p">(</code><code class="kt">Array</code> <code class="n">ix</code> <code class="n">a</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">Acc</code> <code class="p">(</code><code class="kt">Array</code> <code class="n">ix</code> <code class="n">b</code><code class="p">)</code>
        <code class="ow">-&gt;</code> <code class="kt">Acc</code> <code class="p">(</code><code class="kt">Array</code> <code class="n">ix</code> <code class="n">c</code><code class="p">)</code></pre>
<p id="the_first_argum_id4">The first argument is the function to apply to each pair of elements,
and the second and third arguments are the input arrays.  For example,
zipping two arrays with <code class="literal">(+)</code>:</p>
<pre class="screen" id="let_a__enumf_id1">&gt; let a = enumFromN (index2 2 3) 1 :: Acc (Array DIM2 Int)
&gt; let b = enumFromStepN (index2 2 3) 6 (-1) :: Acc (Array DIM2 Int)
&gt; run $ A.zipWith (+) a b
Array (Z :. 2 :. 3) [7,7,7,7,7,7]</pre>
<p id="here_we_zipped_">Here we zipped together two arrays of identical shape, but what
happens if the shapes are different?  The type of <code class="literal">zipWith</code> requires
that the input arrays have identical dimensionality, but the sizes of
the dimensions might be different.  For example, we’ll use the same
2×3 array as before, but zip it with a 3×5 array containing
elements <code class="literal">[10, 20..]</code>:</p>
<pre class="screen" id="let_a__enumf_id2">&gt; let a = enumFromN (index2 2 3) 1 :: Acc (Array DIM2 Int)
&gt; let b = enumFromStepN (index2 3 5) 10 10 :: Acc (Array DIM2 Int)
&gt; run $ A.zipWith (+) a b
Array (Z :. 2 :. 3) [11,22,33,64,75,86]</pre>
<p id="what_happened_i">What happened is that <code class="literal">zipWith</code> used the overlapping intersection of
the two arrays.  With two-dimensional arrays, you can visualize it like
this: lay one array on top of the other, with their upper-left-hand
corners at the same point, and pair together the elements
that coincide. The final array has the shape of the overlapping
portion of the two arrays.<a id="id419396" class="indexterm"></a></p>
</div>
<div class="sect1" data-original-filename="ch06_par-accel.asciidoc" id="sec_par-accel-constants">
<div class="titlepage"><div><div><h2 class="title">Constants</h2></div></div></div>
<p id="accelerateconst"><a id="id419421" class="indexterm"></a><a id="id419429" class="indexterm"></a>We saw earlier that simple integer literals and numeric operations are
automatically operations in <code class="literal">Exp</code> by virtue of being overloaded.  But
what if we already have an <code class="literal">Int</code> value and we need an <code class="literal">Exp Int</code>?  This
is what the function <code class="literal">constant</code> is for:</p>
<pre class="programlisting" data-language="haskell" id="constant__elt"><code class="nf">constant</code> <code class="ow">::</code> <code class="kt">Elt</code> <code class="n">t</code> <code class="ow">=&gt;</code> <code class="n">t</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="n">t</code></pre>
<p id="note_that_const">Note that <code class="literal">constant</code> works only for instances of <code class="literal">Elt</code>,
which you may recall is the class of types allowed to be array
elements, including numeric types, indices, and tuples of <code class="literal">Elt</code>s.</p>
</div>
<div class="sect1" data-original-filename="ch06_par-accel.asciidoc" id="sec_par-accel-shortest-paths">
<div class="titlepage"><div><div><h2 class="title">Example: Shortest Paths</h2></div></div></div>
<p id="accelerateimple"><a id="ix_ch06_par-accel-txt20" class="indexterm"></a><a id="ix_ch06_par-accel-txt21" class="indexterm"></a>As our first full-scale example, we’ll again tackle the Floyd-Warshall
<a id="id419587" class="indexterm"></a>shortest paths algorithm. For details of the algorithm, please see the
Repa example in <a class="xref" href="ch05.html#sec_par-repa-shortest-paths" title="Example: Computing Shortest Paths">“Example: Computing Shortest Paths”</a>; the algorithm here
will be identical, except that we’re going to run it on a GPU using
Accelerate to see how much faster it goes.</p>
<p id="here_are_the_ty">Here are the type of graphs, represented as adjacency matrices:</p>
<p id="fwaccelhs_co" class="caption"><span class="emphasis"><em>fwaccel.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="type_weight__i_id2"><code class="kr">type</code> <code class="kt">Weight</code> <code class="ow">=</code> <code class="kt">Int32</code>
<code class="kr">type</code> <code class="kt">Graph</code> <code class="ow">=</code> <code class="kt">Array</code> <code class="kt">DIM2</code> <code class="kt">Weight</code></pre>
<p id="the_algorithm_i_id3">The algorithm is a sequence of steps, each of which takes a value for
<code class="literal">k</code> and a <code class="literal">Graph</code> as input and produces a new <code class="literal">Graph</code>. First, we’ll
write the code for an individual step before we see how to put
multiple steps together.  Here is the code for a step:</p>
<pre class="programlisting" data-language="haskell" id="step__acc_sc"><code class="nf">step</code> <code class="ow">::</code> <code class="kt">Acc</code> <code class="p">(</code><code class="kt">Scalar</code> <code class="kt">Int</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">Acc</code> <code class="kt">Graph</code> <code class="ow">-&gt;</code> <code class="kt">Acc</code> <code class="kt">Graph</code>
<code class="nf">step</code> <code class="n">k</code> <code class="n">g</code> <code class="ow">=</code> <code class="n">generate</code> <code class="p">(</code><code class="n">shape</code> <code class="n">g</code><code class="p">)</code> <code class="n">sp</code>                           <code class="c1">-- </code><span id="CO22-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
 <code class="kr">where</code>
   <code class="n">k'</code> <code class="ow">=</code> <code class="n">the</code> <code class="n">k</code>                                              <code class="c1">-- </code><span id="CO22-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>

   <code class="n">sp</code> <code class="ow">::</code> <code class="kt">Exp</code> <code class="kt">DIM2</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="kt">Weight</code>
   <code class="n">sp</code> <code class="n">ix</code> <code class="ow">=</code> <code class="kr">let</code>
             <code class="p">(</code><code class="kt">Z</code> <code class="kt">:.</code> <code class="n">i</code> <code class="kt">:.</code> <code class="n">j</code><code class="p">)</code> <code class="ow">=</code> <code class="n">unlift</code> <code class="n">ix</code>                     <code class="c1">-- </code><span id="CO22-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span>
           <code class="kr">in</code>
             <code class="kt">A</code><code class="o">.</code><code class="n">min</code> <code class="p">(</code><code class="n">g</code> <code class="o">!</code> <code class="p">(</code><code class="n">index2</code> <code class="n">i</code> <code class="n">j</code><code class="p">))</code>                      <code class="c1">-- </code><span id="CO22-4"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span>
                   <code class="p">(</code><code class="n">g</code> <code class="o">!</code> <code class="p">(</code><code class="n">index2</code> <code class="n">i</code> <code class="n">k'</code><code class="p">)</code> <code class="o">+</code> <code class="n">g</code> <code class="o">!</code> <code class="p">(</code><code class="n">index2</code> <code class="n">k'</code> <code class="n">j</code><code class="p">))</code></pre>
<div class="calloutlist"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO22-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_step_functi">
The <code class="literal">step</code> function takes two arguments: <code class="literal">k</code>, which is the
iteration number, and <code class="literal">g</code>, which is the graph produced by the previous
iteration.  In each step, we’re computing the lengths of the shortest
paths between each two elements, using only vertices up to <code class="literal">k</code>.  The
graph from the previous iteration, <code class="literal">g</code>, gives us the lengths of the
shortest paths using vertices up to <code class="literal">k - 1</code>.  The result of this step
is a new <code class="literal">Graph</code>, produced by calling the <code class="literal">generate</code> function.  The
new array has the same shape as <code class="literal">g</code>, and the elements of the array are
determined by the function <code class="literal">sp</code>, defined in the <code class="literal">where</code> clause.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO22-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_k_argument_">
The <code class="literal">k</code> argument is passed in as a scalar array; the sidebar
explains why.  To extract the value from the array, we call <code class="literal">the</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO22-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_sp_function_id2">
The <code class="literal">sp</code> function takes the index of an element in the array and
returns the value of the element at that position.  We need to
<code class="literal">unlift</code> the input index to extract the two components, <code class="literal">i</code> and <code class="literal">j</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO22-4"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="this_is_the_cor">
This is the core of the algorithm; to determine the length of the
shortest path between <code class="literal">i</code> and <code class="literal">j</code>, we take the minimum of the previous
shortest path from <code class="literal">i</code> to <code class="literal">j</code>, and the path that goes from <code class="literal">i</code> to <code class="literal">k</code>
and then from <code class="literal">k</code> to <code class="literal">j</code>.  All of these lookups in the <code class="literal">g</code> graph are
performed using the <code class="literal">!</code> operator, and using <code class="literal">index2</code> to construct the indices<a id="id420373" class="indexterm"></a><a id="id420381" class="indexterm"></a><a id="id420387" class="indexterm"></a>.
</p></td>
</tr>
</table></div>
<div class="sidebar" id="passing_inputs_as_arrays">
<div class="titlepage"><div><div><div class="sidebar-title">Passing Inputs as Arrays</div></div></div></div>
<p id="why_did_we_pass">Why did we pass in the <code class="literal">k</code> value as an <code class="literal">Acc (Scalar Int)</code> rather than
a plain <code class="literal">Int</code>?  After all, we could use <code class="literal">constant</code> to convert an <code class="literal">Int</code>
into an <code class="literal">Exp Int</code> that we could use with <code class="literal">index2</code>.  The answer is quite
subtle, and to understand it we first need to know a little more about
how Accelerate works.  When the program runs, the Accelerate
library evaluates the expression passed to <code class="literal">run</code> to make a series of
CUDA fragments (called <span class="emphasis"><em>kernels</em></span>).  Each kernel takes some arrays as
inputs and produces arrays as outputs.  In our example, each call
to <code class="literal">step</code> will produce a kernel, and when we compose a sequence of
<code class="literal">step</code> calls together, we get a series of kernels.  Each kernel is
a piece of CUDA code that has to be compiled and loaded onto the GPU;
this can take a while, so Accelerate remembers the kernels it has
seen before and tries to reuse them.</p>
<p id="our_goal_with_s">Our goal with <code class="literal">step</code> is to make a kernel that will be reused.  If we
don’t reuse the same kernel for each <code class="literal">step</code>, the overhead of
compiling new kernels will ruin the performance.</p>
<p id="we_can_look_at_">We can look at the code that Accelerate sees when it evaluates the
argument to <code class="literal">run</code> by evaluating an <code class="literal">Acc</code> expression in GHCi.  Here’s
what a typical call to <code class="literal">step</code> evaluates to:</p>
<pre class="screen" id="step_unit_c">&gt; step (unit (constant 2)) (use (fromList (Z:.3:.3) [1..9]))
let a0 = use ((Array (Z :. 3 :. 3) [1,2,3,4,5,6,7,8,9]))
in let a1 = unit 2
   in generate
        (shape a0)
        (\x0 -&gt; ...)</pre>
<p id="ive_omitted_th">I’ve omitted the innards of the <code class="literal">generate</code> argument for space, but by
all means try it yourself.  The important thing to notice here is the line
<code class="literal">let a1 = unit 2</code>; this is the scalar array for the <code class="literal">k</code> argument to
step, and it is outside the call to <code class="literal">generate</code>.  The <code class="literal">generate</code>
function is what turns into the CUDA kernel, and to arrange that we
get the same CUDA kernel each time we need the arguments to <code class="literal">generate</code>
to remain constant.</p>
<p id="now_see_what_ha">Now see what happens if we change <code class="literal">step</code> so that it takes an <code class="literal">Int</code> as
an argument instead.  I’ve replaced the <code class="literal">Acc (Scalar Int)</code> with <code class="literal">Int</code>,
and changed <code class="literal">k' = the k</code> to <code class="literal">k' = constant k</code>.</p>
<pre class="screen" id="step__use_">&gt; step 2 (use (fromList (Z:.3:.3) [1..9]))
let a0 = use ((Array (Z :. 3 :. 3) [1,2,3,4,5,6,7,8,9]))
in generate
     (shape a0)
     (\x0 -&gt; min (let x1 = 2
                  in ... ))</pre>
<p id="previously_the">Previously, the code created by <code class="literal">k</code> was defined outside
the <code class="literal">generate</code> call, but now the definition <code class="literal">let x1 = 2</code> is embedded
inside the call.  Hence each <code class="literal">generate</code> call will have a different <code class="literal">k</code> value
embedded in it, which will defeat Accelerate’s caching of CUDA
kernels.</p>
<p id="the_rule_of_thu">The rule of thumb is that if you’re running a sequence of array
operations inside <code class="literal">Acc</code>, make sure that the things that change are
always passed in as arrays and not embedded in the code as constants.</p>
<p id="how_can_you_tel">How can you tell if you get it wrong?  One way is to look at the code
as we just did.  Another way is to use the debugging options provided
by the <code class="literal">accelerate-cuda</code> package, which are described briefly in
<a class="xref" href="ch06.html#sec_par-accel-cuda-debugging" title="Debugging the CUDA Backend">“Debugging the CUDA Backend”</a>.</p>
</div>
<p id="now_that_we_hav_id1">Now that we have the <code class="literal">step</code> function, we can write the wrapper that
composes the sequence of <code class="literal">step</code> calls together:</p>
<pre class="programlisting" data-language="haskell" id="shortestpathsac"><code class="nf">shortestPathsAcc</code> <code class="ow">::</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="kt">Acc</code> <code class="kt">Graph</code> <code class="ow">-&gt;</code> <code class="kt">Acc</code> <code class="kt">Graph</code>
<code class="nf">shortestPathsAcc</code> <code class="n">n</code> <code class="n">g0</code> <code class="ow">=</code> <code class="n">foldl1</code> <code class="p">(</code><code class="o">&gt;-&gt;</code><code class="p">)</code> <code class="n">steps</code> <code class="n">g0</code>              <code class="c1">-- </code><span id="CO23-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
 <code class="kr">where</code>
  <code class="n">steps</code> <code class="ow">::</code> <code class="p">[</code> <code class="kt">Acc</code> <code class="kt">Graph</code> <code class="ow">-&gt;</code> <code class="kt">Acc</code> <code class="kt">Graph</code> <code class="p">]</code>                      <code class="c1">-- </code><span id="CO23-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>
  <code class="n">steps</code> <code class="ow">=</code>  <code class="p">[</code> <code class="n">step</code> <code class="p">(</code><code class="n">unit</code> <code class="p">(</code><code class="n">constant</code> <code class="n">k</code><code class="p">))</code> <code class="o">|</code> <code class="n">k</code> <code class="ow">&lt;-</code> <code class="p">[</code><code class="mi">0</code> <code class="o">..</code> <code class="n">n</code><code class="o">-</code><code class="mi">1</code><code class="p">]</code> <code class="p">]</code>  <code class="c1">-- </code><span id="CO23-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></pre>
<div class="calloutlist"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO23-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="first_we_constr">
First we construct a list of the steps, where each takes a
<code class="literal">Graph</code> and delivers a <code class="literal">Graph</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO23-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_list_of_ste">
The list of steps is constructed by applying <code class="literal">step</code> to each value
of <code class="literal">k</code> in the sequence <code class="literal">0 .. n-1</code>, wrapping the <code class="literal">k</code> values up as
scalar arrays using <code class="literal">unit</code> and <code class="literal">constant</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO23-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; ">
<p id="to_put_the_sequ">
To put the sequence together, Accelerate provides a special
operation designed for this task:
</p>
<pre class="screen" id="_array"><code class="p">(</code><code class="nf">&gt;-&gt;</code><code class="p">)</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">Arrays</code> <code class="n">a</code><code class="p">,</code> <code class="kt">Arrays</code> <code class="n">b</code><code class="p">,</code> <code class="kt">Arrays</code> <code class="n">c</code><code class="p">)</code>
       <code class="ow">=&gt;</code> <code class="p">(</code><code class="kt">Acc</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Acc</code> <code class="n">b</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="p">(</code><code class="kt">Acc</code> <code class="n">b</code> <code class="ow">-&gt;</code> <code class="kt">Acc</code> <code class="n">c</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">Acc</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Acc</code> <code class="n">c</code></pre>
<p id="this_is_called_">This is called the <a id="id421292" class="indexterm"></a><a id="id421298" class="indexterm"></a>pipeline operator, because it is used to connect two <code class="literal">Acc</code> computations together in a pipeline, where the output from the first is fed into the input of the second.  We could achieve this with simple function composition, but the advantage of using the <code class="literal">&gt;-&gt;</code> operator is that it tells Accelerate that there is no sharing between the two computations, and any intermediate arrays used by the first computation can be garbage-collected when the second begins. Without this operator, it is possible to fill up memory when running algorithms with many iterations.  So our <code class="literal">shortestPathsAcc</code> function connects together the sequence of <code class="literal">step</code> calls by left-folding with <code class="literal">&gt;-&gt;</code> and then passes <code class="literal">g0</code> as the input to the pipeline.</p>
</td>
</tr>
</table></div>
<p id="now_that_we_hav_id2">Now that we have defined the complete computation, we can write a function that wraps <code class="literal">run</code> around it:</p>
<pre class="programlisting" data-language="haskell" id="shortestpaths__id4"><code class="nf">shortestPaths</code> <code class="ow">::</code> <code class="kt">Graph</code> <code class="ow">-&gt;</code> <code class="kt">Graph</code>
<code class="nf">shortestPaths</code> <code class="n">g0</code> <code class="ow">=</code> <code class="n">run</code> <code class="p">(</code><code class="n">shortestPathsAcc</code> <code class="n">n</code> <code class="p">(</code><code class="n">use</code> <code class="n">g0</code><code class="p">))</code>
  <code class="kr">where</code>
    <code class="kt">Z</code> <code class="kt">:.</code> <code class="kr">_</code> <code class="kt">:.</code> <code class="n">n</code> <code class="ow">=</code> <code class="n">arrayShape</code> <code class="n">g0</code></pre>
<p id="we_can_try_the_">We can try the program on test data, using the Accelerate
interpreter:</p>
<pre class="screen" id="shortestpaths">&gt; shortestPaths testGraph
Array (Z :. 6 :. 6) [0,16,999,13,20,20,19,0,999,5,4,9,11,27,0,24,31,31,18,3,
999,0,7,7,15,4,999,1,0,8,11,17,999,14,21,0]</pre>
<div class="sect2" id="sec_par-accel-gpu">
<div class="titlepage"><div><div><h3 class="title">Running on the GPU</h3></div></div></div>
<p id="gpus_graphics_"><a id="ix_ch06_par-accel-txt22" class="indexterm"></a>To run the program on a real GPU, you’ll need a supported GPU card
and some additional software.  Consult the Accelerate documentation
to help you get things set up.  Then install the
<code class="literal">accelerate-cuda</code> package:</p>
<pre class="screen" id="cabal_install_id3">$ cabal install accelerate-cuda -fdebug</pre>
<p id="ive_enabled_de">I’ve enabled debugging support here with the <code class="literal">-fdebug</code> flag, which
lets us pass some extra options to the program to see what the GPU is
doing.</p>
<p id="to_use_accelera">To use Accelerate’s <a id="id421581" class="indexterm"></a>CUDA support, we need to use:</p>
<pre class="programlisting" data-language="haskell" id="import_dataarr_id1"><code class="kr">import</code> <code class="nn">Data.Array.Accelerate.CUDA</code></pre>
<p id="in_place_of">in place of:</p>
<pre class="programlisting" data-language="haskell" id="import_dataarr_id2"><code class="kr">import</code> <code class="nn">Data.Array.Accelerate.Interpreter</code></pre>
<p id="a_version_of_th">A version of the shortest paths program that has this is in
<code class="literal">fwaccel-gpu.hs</code>.  Compile it in the usual way:</p>
<pre class="screen" id="ghc_o_fwacc">$ ghc -O2 fwaccel.hs -threaded</pre>
<p id="the_program_inc">The program includes a benchmarking wrapper that generates a large
graph over which to run the algorithm.  Let’s run it on a graph with 2,000
nodes:<a href="#ftn.id421665" class="footnote"><sup class="footnote" id="id421665">[24]</sup></a></p>
<pre class="screen" id="fwaccel_">$ ./fwaccel 2000 +RTS -s
...
  Total   time   14.71s  ( 16.25s elapsed)</pre>
<p id="for_comparison">For comparison, I tried the <a id="id421685" class="indexterm"></a>Repa version of this program on a graph of the same size, using seven cores on the same machine:<a href="#ftn.id421695" class="footnote"><sup class="footnote" id="id421695">[25]</sup></a></p>
<pre class="screen" id="fwdense__id2">$ ./fwdense1 2000 +RTS -s -N7
...
  Total   time  259.78s  ( 40.13s elapsed)</pre>
<p id="so_the_accelera">So the Accelerate program running on the GPU is significantly faster
than Repa.  Moreover, about 3.5s of the runtime of the Accelerate
program is taken up by initializing the GPU on this machine, which we
can see by running the program with a small input size.<a id="id421716" class="indexterm"></a></p>
</div>
<div class="sect2" id="sec_par-accel-cuda-debugging">
<div class="titlepage"><div><div><h3 class="title">Debugging the CUDA Backend</h3></div></div></div>
<p id="acceleratedebug"><a id="id421738" class="indexterm"></a><a id="id421745" class="indexterm"></a><a id="id421754" class="indexterm"></a><a id="id421762" class="indexterm"></a>When the <code class="literal">accelerate-cuda</code> package is compiled with <code class="literal">-fdebug</code>, there
are a few extra debugging options available.  These are the most useful ones<a id="id421784" class="indexterm"></a><a id="id421790" class="indexterm"></a>:</p>
<div class="variablelist" id="dverbose_print"><dl class="variablelist">
<dt><span class="term">
<code class="literal">-dverbose</code>
</span></dt>
<dd>
  Prints some information about the type and capabilities of the
  GPU being used.
</dd>
<dt><span class="term">
<code class="literal">-ddump-cc</code>
</span></dt>
<dd>
  Prints information about CUDA kernels as they are compiled and
  run.  Using this option will tell you whether your program is
  generating the number of kernels that you were expecting.
</dd>
</dl></div>
<p id="for_a_more_comp">For a more complete list, see the <span class="emphasis"><em>accelerate-cuda.cabal</em></span> file in the
<code class="literal">accelerate-cuda</code> package sources.<a id="id421851" class="indexterm"></a><a id="id421861" class="indexterm"></a></p>
</div>
</div>
<div class="sect1" data-original-filename="ch06_par-accel.asciidoc" id="sec_par-accel-mandel">
<div class="titlepage"><div><div><h2 class="title">Example: A Mandelbrot Set Generator</h2></div></div></div>
<p id="acceleratecondi"><a id="ix_ch06_par-accel-txt23" class="indexterm"></a><a id="ix_ch06_par-accel-txt24" class="indexterm"></a><a id="ix_ch06_par-accel-txt25" class="indexterm"></a>In this second example, we’ll build a <a id="id422079" class="indexterm"></a>Mandelbrot set generator that
runs on the GPU.  The end result will be the picture in
<a class="xref" href="ch06.html#fig_mandel" title="Figure 6-1. Mandelbrot set picture generated on the GPU">Figure 6-1</a>.  Generating an image of the Mandelbrot set is a
naturally parallel process—each pixel is independent of the
others—but there are some aspects to this problem that make it an
interesting example to program using Accelerate.  In particular, we’ll
see how to use conditionals and to work with arrays of tuples.</p>
<div class="figure" id="fig_mandel">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0601.png" alt="Mandelbrot set picture generated on the GPU"></div></div>
<div class="figure-title">Figure 6-1. Mandelbrot set picture generated on the GPU</div>
</div>
<p id="the_mandelbrot_">The Mandelbrot set is a mathematical construction over the <span class="emphasis"><em>complex
plane</em></span>, which is the two-dimensional plane of complex numbers.  A
particular point is said to be in the set if, when the following
equation is repeatedly applied, the magnitude of <span class="emphasis"><em>z</em></span> (written as <span class="keep-together">|<span class="emphasis"><em>z</em></span>|</span>) does not diverge to infinity:</p>
<div class="informalequation" id="zn__c__zn"><span class="mathphrase">
    <span class="emphasis"><em>z</em></span><sub>(<span class="emphasis"><em>n</em></span>+1)</sub> =
    <span class="emphasis"><em>c</em></span> +
    <span class="emphasis"><em>z</em></span><sub><span class="emphasis"><em>n</em></span></sub><sup>2</sup></span></div>
<p id="where_c_is_the_">where <span class="emphasis"><em>c</em></span> is the point on the plane (a complex number), and <span class="emphasis"><em>z</em></span><sub>0</sub> = <span class="emphasis"><em>c</em></span>.</p>
<p id="in_practice_we">In practice, we iterate the equation for a fixed number of times, and
if it has not diverged at that point, we declare the point to be
in the set.  Furthermore, to generate a pretty picture, we remember
the iteration at which each point diverged and map the iteration
values to a color gradient.</p>
<p id="we_know_that_z">We know that |<span class="emphasis"><em>z</em></span>| will definitely diverge if it is greater than 2.
The magnitude of a complex number <span class="emphasis"><em>x</em></span> + i<span class="emphasis"><em>y</em></span> is given by
√(x<sup>2</sup> + y<sup>2</sup>), so we can simplify the condition by squaring
both sides, giving us this condition for divergence: x<sup>2</sup> + y<sup>2</sup> &gt; 4.</p>
<p id="lets_express_t">Let’s express this using Accelerate.  First, we want a type for
complex numbers. Accelerate lets us work with tuples, so we can
represent complex numbers as pairs of floating point numbers.  Not all
GPUs can work with <code class="literal">Double</code>s, so for the best compatibility we’ll use
<code class="literal">Float</code>:</p>
<p id="mandelmandelh" class="caption"><span class="emphasis"><em>mandel/mandel.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="type_f__float_"><code class="kr">type</code> <code class="kt">F</code>            <code class="ow">=</code> <code class="kt">Float</code>
<code class="kr">type</code> <code class="kt">Complex</code>      <code class="ow">=</code> <code class="p">(</code><code class="kt">F</code><code class="p">,</code><code class="kt">F</code><code class="p">)</code>
<code class="kr">type</code> <code class="kt">ComplexPlane</code> <code class="ow">=</code> <code class="kt">Array</code> <code class="kt">DIM2</code> <code class="kt">Complex</code></pre>
<p id="well_be_referr">We’ll be referring to <code class="literal">Float</code> a lot, so the <code class="literal">F</code> type synonym helps to
keep things readable.</p>
<p id="the_following_f_id2">The following function, <code class="literal">next</code>, embodies the main Mandelbrot formula:
it computes the next value of <span class="emphasis"><em>z</em></span> for a given point <span class="emphasis"><em>c</em></span>.</p>
<pre class="programlisting" data-language="haskell" id="next__exp_com"><code class="nf">next</code> <code class="ow">::</code> <code class="kt">Exp</code> <code class="kt">Complex</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="kt">Complex</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="kt">Complex</code>
<code class="nf">next</code> <code class="n">c</code> <code class="n">z</code> <code class="ow">=</code> <code class="n">c</code> <code class="p">`</code><code class="n">plus</code><code class="p">`</code> <code class="p">(</code><code class="n">z</code> <code class="p">`</code><code class="n">times</code><code class="p">`</code> <code class="n">z</code><code class="p">)</code></pre>
<p id="multiplication_"><a id="ix_multiplicationinAccelerate" class="indexterm"></a>We can’t use the normal <code class="literal">+</code> and <code class="literal">*</code> operations here, because
there is no instance of <code class="literal">Num</code> for <code class="literal">Exp Complex</code>. In other words, Accelerate doesn’t know
how to <a id="id422582" class="indexterm"></a>add or multiply our complex numbers, so we have to define these
operations ourselves.  First, <code class="literal">plus</code>:</p>
<pre class="programlisting" data-language="haskell" id="plus__exp_com_id1"><code class="nf">plus</code> <code class="ow">::</code> <code class="kt">Exp</code> <code class="kt">Complex</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="kt">Complex</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="kt">Complex</code>
<code class="nf">plus</code> <code class="n">a</code> <code class="n">b</code> <code class="ow">=</code> <code class="o">...</code></pre>
<p id="to_sum_two_comp">To sum two <a id="id422690" class="indexterm"></a><a id="id422698" class="indexterm"></a>complex numbers, we need to sum the components.  But
how can we access the components?  We cannot pattern match on
<code class="literal">Exp Complex</code>.  There are a few different ways to do it, and we’ll
explore them briefly.  Accelerate provides operations for selecting the
components of pairs in <code class="literal">Exp</code>, namely:</p>
<pre class="programlisting" data-language="haskell" id="fst__elt_a_"><code class="nf">fst</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">Elt</code> <code class="n">a</code><code class="p">,</code> <code class="kt">Elt</code> <code class="n">b</code><code class="p">)</code> <code class="ow">=&gt;</code> <code class="kt">Exp</code> <code class="p">(</code><code class="n">a</code><code class="p">,</code> <code class="n">b</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="n">a</code>
<code class="nf">snd</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">Elt</code> <code class="n">a</code><code class="p">,</code> <code class="kt">Elt</code> <code class="n">b</code><code class="p">)</code> <code class="ow">=&gt;</code> <code class="kt">Exp</code> <code class="p">(</code><code class="n">a</code><code class="p">,</code> <code class="n">b</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="n">b</code></pre>
<p id="so_we_could_wri">So we could write <code class="literal">plus</code> like this:</p>
<pre class="programlisting" data-language="haskell" id="plus__exp_com_id2"><code class="nf">plus</code> <code class="ow">::</code> <code class="kt">Exp</code> <code class="kt">Complex</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="kt">Complex</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="kt">Complex</code>
<code class="nf">plus</code> <code class="n">a</code> <code class="n">b</code> <code class="ow">=</code> <code class="o">...</code>
  <code class="kr">where</code>
    <code class="n">ax</code> <code class="ow">=</code> <code class="kt">A</code><code class="o">.</code><code class="n">fst</code> <code class="n">a</code>
    <code class="n">ay</code> <code class="ow">=</code> <code class="kt">A</code><code class="o">.</code><code class="n">snd</code> <code class="n">a</code>
    <code class="n">bx</code> <code class="ow">=</code> <code class="kt">A</code><code class="o">.</code><code class="n">fst</code> <code class="n">b</code>
    <code class="n">by</code> <code class="ow">=</code> <code class="kt">A</code><code class="o">.</code><code class="n">snd</code> <code class="n">b</code></pre>
<p id="but_how_do_we_c">But how do we construct the result?  We want to write something like
<code class="literal">(ax+bx, ay+by)</code>, but this has type <code class="literal">(Exp F, Exp F)</code>, whereas we want
<code class="literal">Exp (F,F)</code>.  Fortunately <a id="id423161" class="indexterm"></a>the <code class="literal">lift</code> function that we saw earlier
performs this transformation, so the result is:</p>
<pre class="programlisting" data-language="haskell" id="plus__exp_com_id3"><code class="nf">plus</code> <code class="ow">::</code> <code class="kt">Exp</code> <code class="kt">Complex</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="kt">Complex</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="kt">Complex</code>
<code class="nf">plus</code> <code class="n">a</code> <code class="n">b</code> <code class="ow">=</code> <code class="n">lift</code> <code class="p">(</code><code class="n">ax</code><code class="o">+</code><code class="n">bx</code><code class="p">,</code> <code class="n">ay</code><code class="o">+</code><code class="n">by</code><code class="p">)</code>
  <code class="kr">where</code>
    <code class="n">ax</code> <code class="ow">=</code> <code class="kt">A</code><code class="o">.</code><code class="n">fst</code> <code class="n">a</code>
    <code class="n">ay</code> <code class="ow">=</code> <code class="kt">A</code><code class="o">.</code><code class="n">snd</code> <code class="n">a</code>
    <code class="n">bx</code> <code class="ow">=</code> <code class="kt">A</code><code class="o">.</code><code class="n">fst</code> <code class="n">b</code>
    <code class="n">by</code> <code class="ow">=</code> <code class="kt">A</code><code class="o">.</code><code class="n">snd</code> <code class="n">b</code></pre>
<p id="in_fact_we_cou">In fact, we could do a little better, since <code class="literal">A.fst</code> and <code class="literal">A.snd</code> are
just instances <a id="id423442" class="indexterm"></a>of <code class="literal">unlift</code>, and we could do them both in one go:</p>
<pre class="programlisting" data-language="haskell" id="plus__exp_com_id4"><code class="nf">plus</code> <code class="ow">::</code> <code class="kt">Exp</code> <code class="kt">Complex</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="kt">Complex</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="kt">Complex</code>
<code class="nf">plus</code> <code class="n">a</code> <code class="n">b</code> <code class="ow">=</code> <code class="n">lift</code> <code class="p">(</code><code class="n">ax</code><code class="o">+</code><code class="n">bx</code><code class="p">,</code> <code class="n">ay</code><code class="o">+</code><code class="n">by</code><code class="p">)</code>
  <code class="kr">where</code>
    <code class="p">(</code><code class="n">ax</code><code class="p">,</code> <code class="n">ay</code><code class="p">)</code> <code class="ow">=</code> <code class="n">unlift</code> <code class="n">a</code>
    <code class="p">(</code><code class="n">bx</code><code class="p">,</code> <code class="n">by</code><code class="p">)</code> <code class="ow">=</code> <code class="n">unlift</code> <code class="n">b</code></pre>
<p id="unfortunately__id1">Unfortunately, if you try this you will find that there isn’t enough
type information for GHC, so we have to help it out a bit:</p>
<pre class="programlisting" data-language="haskell" id="plus__exp_com_id5"><code class="nf">plus</code> <code class="ow">::</code> <code class="kt">Exp</code> <code class="kt">Complex</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="kt">Complex</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="kt">Complex</code>
<code class="nf">plus</code> <code class="n">a</code> <code class="n">b</code> <code class="ow">=</code> <code class="n">lift</code> <code class="p">(</code><code class="n">ax</code><code class="o">+</code><code class="n">bx</code><code class="p">,</code> <code class="n">ay</code><code class="o">+</code><code class="n">by</code><code class="p">)</code>
  <code class="kr">where</code>
    <code class="p">(</code><code class="n">ax</code><code class="p">,</code> <code class="n">ay</code><code class="p">)</code> <code class="ow">=</code> <code class="n">unlift</code> <code class="n">a</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">Exp</code> <code class="kt">F</code><code class="p">,</code> <code class="kt">Exp</code> <code class="kt">F</code><code class="p">)</code>
    <code class="p">(</code><code class="n">bx</code><code class="p">,</code> <code class="n">by</code><code class="p">)</code> <code class="ow">=</code> <code class="n">unlift</code> <code class="n">b</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">Exp</code> <code class="kt">F</code><code class="p">,</code> <code class="kt">Exp</code> <code class="kt">F</code><code class="p">)</code></pre>
<p id="we_can_go_a_lit">We can go a little further because Accelerate provides some utilities
that wrap a function in <code class="literal">lift</code> and <code class="literal">unlift</code>.  For a two-argument
function, the right variant is called <code class="literal">lift2</code>:</p>
<pre class="programlisting" data-language="haskell" id="plus__exp_com_id6"><code class="nf">plus</code> <code class="ow">::</code> <code class="kt">Exp</code> <code class="kt">Complex</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="kt">Complex</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="kt">Complex</code>
<code class="nf">plus</code> <code class="ow">=</code> <code class="n">lift2</code> <code class="n">f</code>
  <code class="kr">where</code> <code class="n">f</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">Exp</code> <code class="kt">F</code><code class="p">,</code> <code class="kt">Exp</code> <code class="kt">F</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="p">(</code><code class="kt">Exp</code> <code class="kt">F</code><code class="p">,</code> <code class="kt">Exp</code> <code class="kt">F</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="p">(</code><code class="kt">Exp</code> <code class="kt">F</code><code class="p">,</code> <code class="kt">Exp</code> <code class="kt">F</code><code class="p">)</code>
        <code class="n">f</code> <code class="p">(</code><code class="n">x1</code><code class="p">,</code><code class="n">y1</code><code class="p">)</code> <code class="p">(</code><code class="n">x2</code><code class="p">,</code><code class="n">y2</code><code class="p">)</code> <code class="ow">=</code> <code class="p">(</code><code class="n">x1</code><code class="o">+</code><code class="n">x2</code><code class="p">,</code><code class="n">y1</code><code class="o">+</code><code class="n">y2</code><code class="p">)</code></pre>
<p id="unfortunately__id2">Unfortunately, again we had to add the type signature to get
it to typecheck, but it does aid readability.  This is perhaps as
close to “natural” as we can get for this definition: the necessary
lifting and unlifting are confined to just one place.</p>
<p id="we_also_need_to">We also need to define <code class="literal">times</code>, <a id="id424315" class="indexterm"></a>which follows the same pattern as
<code class="literal">plus</code>, although of course this time we are multiplying the two
complex numbers <a id="id424331" class="indexterm"></a>together:</p>
<pre class="programlisting" data-language="haskell" id="times__exp_co"><code class="nf">times</code> <code class="ow">::</code> <code class="kt">Exp</code> <code class="kt">Complex</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="kt">Complex</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="kt">Complex</code>
<code class="nf">times</code> <code class="ow">=</code> <code class="n">lift2</code> <code class="n">f</code>
  <code class="kr">where</code> <code class="n">f</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">Exp</code> <code class="kt">F</code><code class="p">,</code> <code class="kt">Exp</code> <code class="kt">F</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="p">(</code><code class="kt">Exp</code> <code class="kt">F</code><code class="p">,</code> <code class="kt">Exp</code> <code class="kt">F</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="p">(</code><code class="kt">Exp</code> <code class="kt">F</code><code class="p">,</code> <code class="kt">Exp</code> <code class="kt">F</code><code class="p">)</code>
        <code class="n">f</code> <code class="p">(</code><code class="n">ax</code><code class="p">,</code><code class="n">ay</code><code class="p">)</code> <code class="p">(</code><code class="n">bx</code><code class="p">,</code><code class="n">by</code><code class="p">)</code>   <code class="ow">=</code>  <code class="p">(</code><code class="n">ax</code><code class="o">*</code><code class="n">bx</code><code class="o">-</code><code class="n">ay</code><code class="o">*</code><code class="n">by</code><code class="p">,</code> <code class="n">ax</code><code class="o">*</code><code class="n">by</code><code class="o">+</code><code class="n">ay</code><code class="o">*</code><code class="n">bx</code><code class="p">)</code></pre>
<p id="so_now_we_can_c">So now we can compute <span class="emphasis"><em>z</em></span><sub><span class="emphasis"><em>n</em></span>+1</sub> given <span class="emphasis"><em>z</em></span> and <span class="emphasis"><em>c</em></span>.  But we need to
think about the program as a whole. For each point, we need to iterate
this process until divergence, and then remember the number of
iterations at which divergence happened.  This creates a small
problem: GPUs are designed to do the <span class="emphasis"><em>same thing</em></span> to lots of
different data at the same time, whereas we want to do something
different depending on whether or not a particular point has diverged.  So in practice, we can’t do what we would normally do in a
single-threaded language and iterate each point until divergence.
Instead, we must find a way to apply the same operation to every
element of the array for a fixed number of iterations.</p>
<p id="there_is_a_cond">There is a <a id="id424723" class="indexterm"></a>conditional operation in Accelerate, with this type:</p>
<pre class="screen" id="_elt_t_"><code class="p">(</code><code class="nf">?</code><code class="p">)</code> <code class="ow">::</code> <code class="kt">Elt</code> <code class="n">t</code> <code class="ow">=&gt;</code> <code class="kt">Exp</code> <code class="kt">Bool</code> <code class="ow">-&gt;</code> <code class="p">(</code><code class="kt">Exp</code> <code class="n">t</code><code class="p">,</code> <code class="kt">Exp</code> <code class="n">t</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="n">t</code></pre>
<p id="the_first_argum_id5">The first argument is an <code class="literal">Exp Bool</code>, and the second argument is a pair
of expressions.  If the Boolean evaluates to true, the result is
the first component of the pair; otherwise it is the second.</p>
<p id="however_as_a_r">However, as a rule of thumb, using conditionals in GPU code is
considered “bad” because conditionals <a id="id424857" class="indexterm"></a>cause <span class="emphasis"><em>SIMD divergence</em></span>.
This means that when the GPU hits a conditional instruction, it first
runs all the threads that take the true branch and then runs the
threads that take the false branch.  Of course if you have nested
conditionals, the amount of parallelism rapidly disappears.</p>
<p id="we_cant_avoid_">We can’t avoid <span class="emphasis"><em>some</em></span> kind of conditional in the Mandelbrot
example, but we can make sure there is only a bounded amount of
divergence by having just one conditional per iteration and a fixed
number of iterations.  The trick we’ll use is to keep a pair <code class="literal">(z,i)</code> for
every array element, where <code class="literal">i</code> is the iteration at which that point
diverged.  So at each iteration, we do the following:</p>
<div class="itemizedlist" id="compute_z__ne_id1"><ul class="itemizedlist">
<li class="listitem">
Compute <code class="literal">z' = next c z</code>.
</li>
<li class="listitem">
If it is greater than four, the result is <code class="literal">(z,i)</code>.
</li>
<li class="listitem">
Otherwise, the result is <code class="literal">(z',i+1)</code>
</li>
</ul></div>
<p id="the_implementat_id3">The implementation of this sequence is the <code class="literal">iter</code> function, defined as
follows:</p>
<pre class="programlisting" data-language="haskell" id="iter__exp_com"><code class="nf">iter</code> <code class="ow">::</code> <code class="kt">Exp</code> <code class="kt">Complex</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="p">(</code><code class="kt">Complex</code><code class="p">,</code><code class="kt">Int</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">Exp</code> <code class="p">(</code><code class="kt">Complex</code><code class="p">,</code><code class="kt">Int</code><code class="p">)</code>
<code class="nf">iter</code> <code class="n">c</code> <code class="n">p</code> <code class="ow">=</code>
  <code class="kr">let</code>
     <code class="p">(</code><code class="n">z</code><code class="p">,</code><code class="n">i</code><code class="p">)</code> <code class="ow">=</code> <code class="n">unlift</code> <code class="n">p</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">Exp</code> <code class="kt">Complex</code><code class="p">,</code> <code class="kt">Exp</code> <code class="kt">Int</code><code class="p">)</code>    <code class="c1">-- </code><span id="CO24-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
     <code class="n">z'</code> <code class="ow">=</code> <code class="n">next</code> <code class="n">c</code> <code class="n">z</code>                                 <code class="c1">-- </code><span id="CO24-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>
  <code class="kr">in</code>
  <code class="p">(</code><code class="n">dot</code> <code class="n">z'</code> <code class="o">&gt;*</code> <code class="mf">4.0</code><code class="p">)</code> <code class="o">?</code>                                <code class="c1">-- </code><span id="CO24-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span>
     <code class="p">(</code> <code class="n">p</code>                                           <code class="c1">-- </code><span id="CO24-4"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span>
     <code class="p">,</code> <code class="n">lift</code> <code class="p">(</code><code class="n">z'</code><code class="p">,</code> <code class="n">i</code><code class="o">+</code><code class="mi">1</code><code class="p">)</code>                              <code class="c1">-- </code><span id="CO24-5"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/5.png" alt="5"></span>
     <code class="p">)</code></pre>
<div class="calloutlist"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO24-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_first_thing_id1">
The first thing to do is <code class="literal">unlift p</code> so we can access the
components of the pair.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO24-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="next_we_comput">
Next, we compute <code class="literal">z'</code> by calling <code class="literal">next</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO24-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="now_that_we_hav_id3">
Now that we have <code class="literal">z'</code> we can do the conditional test using the <code class="literal">?</code>
operator.  The <code class="literal">dot</code> function computes <code class="literal">x</code><sup>2</sup> + <code class="literal">y</code><sup>2</sup> where <code class="literal">x</code>
and <code class="literal">y</code> are the components of <code class="literal">z</code>; it follows the same pattern as
<code class="literal">plus</code> and <code class="literal">times</code> so I’ve omitted its definition.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO24-4"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="if_the_conditio">
If the condition evaluates to true, we just return the original
<code class="literal">p</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO24-5"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/5.png" alt="5"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="in_the_false_ca">
In the false case, then we return the new <code class="literal">z'</code> and <code class="literal">i+1</code>.
</p></td>
</tr>
</table></div>
<p id="the_algorithm_n">The algorithm needs two arrays: one array of <code class="literal">c</code> values that will
be constant throughout the computation, and a second array of <code class="literal">(z,i)</code>
values that will be recomputed by each iteration.  Our arrays are
two-dimensional arrays indexed by pixel coordinates because the aim is to
generate a picture from the iteration values at each pixel.</p>
<p id="the_initial_com">The initial complex plane of <code class="literal">c</code> values is generated by a function
<code class="literal">genPlane</code>:</p>
<pre class="programlisting" data-language="haskell" id="genplane__f_"><code class="nf">genPlane</code> <code class="ow">::</code> <code class="kt">F</code> <code class="ow">-&gt;</code> <code class="kt">F</code>
         <code class="ow">-&gt;</code> <code class="kt">F</code> <code class="ow">-&gt;</code> <code class="kt">F</code>
         <code class="ow">-&gt;</code> <code class="kt">Int</code>
         <code class="ow">-&gt;</code> <code class="kt">Int</code>
         <code class="ow">-&gt;</code> <code class="kt">Acc</code> <code class="kt">ComplexPlane</code></pre>
<p id="its_definition_">Its definition is rather long so I’ve omitted it here, but
essentially it is a call to <code class="literal">generate</code>
(<a class="xref" href="ch06.html#sec_par-accel-creating-arrays" title="Creating Arrays Inside Acc">“Creating Arrays Inside Acc”</a>).</p>
<p id="from_the_initia">From the initial complex plane we can generate the initial array of
<code class="literal">(z,i)</code> values, which is done by initializing each <code class="literal">z</code> to the
corresponding <code class="literal">c</code> value and <code class="literal">i</code> to zero.  In the code, this can be
found in the <code class="literal">mkinit</code> function.</p>
<p id="now_we_can_put_">Now we can put the pieces together and write the code for the complete
algorithm:</p>
<pre class="programlisting" data-language="haskell" id="mandelbrot__f"><code class="nf">mandelbrot</code> <code class="ow">::</code> <code class="kt">F</code> <code class="ow">-&gt;</code> <code class="kt">F</code> <code class="ow">-&gt;</code> <code class="kt">F</code> <code class="ow">-&gt;</code> <code class="kt">F</code> <code class="ow">-&gt;</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="kt">Int</code>
           <code class="ow">-&gt;</code> <code class="kt">Acc</code> <code class="p">(</code><code class="kt">Array</code> <code class="kt">DIM2</code> <code class="p">(</code><code class="kt">Complex</code><code class="p">,</code><code class="kt">Int</code><code class="p">))</code>

<code class="nf">mandelbrot</code> <code class="n">x</code> <code class="n">y</code> <code class="n">x'</code> <code class="n">y'</code> <code class="n">screenX</code> <code class="n">screenY</code> <code class="n">max_depth</code>
  <code class="ow">=</code> <code class="n">iterate</code> <code class="n">go</code> <code class="n">zs0</code> <code class="o">!!</code> <code class="n">max_depth</code>              <code class="c1">-- </code><span id="CO25-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
  <code class="kr">where</code>
    <code class="n">cs</code>  <code class="ow">=</code> <code class="n">genPlane</code> <code class="n">x</code> <code class="n">y</code> <code class="n">x'</code> <code class="n">y'</code> <code class="n">screenX</code> <code class="n">screenY</code> <code class="c1">-- </code><span id="CO25-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>
    <code class="n">zs0</code> <code class="ow">=</code> <code class="n">mkinit</code> <code class="n">cs</code>                          <code class="c1">-- </code><span id="CO25-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span>

    <code class="n">go</code> <code class="ow">::</code> <code class="kt">Acc</code> <code class="p">(</code><code class="kt">Array</code> <code class="kt">DIM2</code> <code class="p">(</code><code class="kt">Complex</code><code class="p">,</code><code class="kt">Int</code><code class="p">))</code>
       <code class="ow">-&gt;</code> <code class="kt">Acc</code> <code class="p">(</code><code class="kt">Array</code> <code class="kt">DIM2</code> <code class="p">(</code><code class="kt">Complex</code><code class="p">,</code><code class="kt">Int</code><code class="p">))</code>
    <code class="n">go</code> <code class="ow">=</code> <code class="kt">A</code><code class="o">.</code><code class="n">zipWith</code> <code class="n">iter</code> <code class="n">cs</code>                   <code class="c1">-- </code><span id="CO25-4"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span></pre>
<div class="calloutlist"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO25-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="cs_is_our_stati">
<code class="literal">cs</code> is our static complex plane generated by <code class="literal">genPlane</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO25-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="zs_is_the_init">
<code class="literal">zs0</code> is the initial array of <code class="literal">(z,i)</code> values.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO25-4"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_function_go">
The function <code class="literal">go</code> performs one iteration, producing a new array of
<code class="literal">(z,i)</code>, and it is expressed by zipping <code class="literal">iter</code> over both <code class="literal">cs</code> and the
current array of <code class="literal">(z,i)</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO25-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; ">
<p id="to_perform_all_">
To perform all the iterations, we simply call the ordinary list
function <code class="literal">iterate</code>:
</p>
<pre class="programlisting" data-language="haskell" id="iterate__a_"><code class="nf">iterate</code> <code class="ow">::</code> <code class="p">(</code><code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="n">a</code><code class="p">]</code></pre>
<p id="and_take_the_el">and take the element at position <code class="literal">depth</code>, which corresponds to the
<code class="literal">go</code> function having been applied <code class="literal">depth</code> times.  Note that in this
case, we don’t want to use the pipeline operator <code class="literal">&gt;-&gt;</code> because the
iterations share the array <code class="literal">cs</code>.</p>
</td>
</tr>
</table></div>
<p id="the_complete_pr">The complete program has code to produce an output file in PNG format,
by turning the Accelerate array into a Repa array and then using
the <code class="literal">repa-devil</code> library that we saw in
<a class="xref" href="ch05.html#sec_par-repa-image-rotation" title="Example: Image Rotation">“Example: Image Rotation”</a>.  To compile the program, install the
<code class="literal">accelerate</code> and <code class="literal">accelerate-cuda</code> packages as before, and then:</p>
<pre class="screen" id="ghc_o_thre">$ ghc -O2 -threaded mandel.hs</pre>
<p id="then_generate_a">Then generate a nice big image (again, this is running on an
Amazon EC2 Cluster GPU instance): <a id="id426410" class="indexterm"></a><a id="id426419" class="indexterm"></a><a id="id426429" class="indexterm"></a></p>
<pre class="screen" id="rm_outpng_">$ rm out.png; ./mandel --size=4000 +RTS -s
...
  Total   time    8.40s  ( 10.56s elapsed)</pre>
</div>
<div class="footnotes">
<br><hr style="width: 100; align: left;">
<div id="ftn.id416657" class="footnote"><p><a href="#id416657" class="simpara"><sup class="simpara">[22] </sup></a>This comes with a couple of extra constraints,
which we won’t go into here.</p></div>
<div id="ftn.id418525" class="footnote"><p><a href="#id418525" class="simpara"><sup class="simpara">[23] </sup></a>The <code class="literal">unlift</code> function is
actually a method of <a id="id418535" class="indexterm"></a>the <code class="literal">Unlift</code> class, which has instances for
indices (of any dimensionality) and various sizes of tuples.  See the
Accelerate documentation for details.</p></div>
<div id="ftn.id421665" class="footnote"><p><a href="#id421665" class="simpara"><sup class="simpara">[24] </sup></a>These results were obtained on an Amazon EC2 Cluster GPU instance that had an NVidia Tesla card. I used CUDA version 4.</p></div>
<div id="ftn.id421695" class="footnote"><p><a href="#id421695" class="simpara"><sup class="simpara">[25] </sup></a>Using all eight cores was slower than using seven.</p></div>
</div></section><footer><div class="navfooter">
<hr>
<table style="width: 100%; ">
<tr>
<td style="width: 40%; text-align: left; ">
<a accesskey="p" href="ch05.html">Prev</a> </td>
<td style="width: 20%; text-align: center; "><a accesskey="u" href="pt01.html">Up</a></td>
<td style="width: 40%; text-align: right; "> <a accesskey="n" href="pt02.html">Next</a>
</td>
</tr>
<tr>
<td style="width: 40%; text-align: left; vertical-align: top; ">Chapter 5. Data Parallel Programming with Repa </td>
<td style="width: 20%; text-align: center; "><a accesskey="h" href="index.html">Home</a></td>
<td style="width: 40%; text-align: right; vertical-align: top; "> Part II. Concurrent Haskell</td>
</tr>
</table>
</div></footer>


	<div class="extra-footer">
		<p>© 2013, O’Reilly Media, Inc.</p>
		<ul>
			<li><a href="http://oreilly.com/terms/">Terms of Service</a></li>
			<li><a href="http://oreilly.com/oreilly/privacy.csp">Privacy Policy</a></li>
			<li>Interested in <a href="mailto:scordesse@oreilly.com">sponsoring content?</a></li>
		</ul>
	</div>
<script type="text/javascript">if (!NREUMQ.f) { NREUMQ.f=function() {
NREUMQ.push(["load",new Date().getTime()]);
var e=document.createElement("script");
e.type="text/javascript";
e.src=(("http:"===document.location.protocol)?"http:":"https:") + "//" +
  "js-agent.newrelic.com/nr-100.js";
document.body.appendChild(e);
if(NREUMQ.a)NREUMQ.a();
};
NREUMQ.a=window.onload;window.onload=NREUMQ.f;
};
NREUMQ.push(["nrfj","bam.nr-data.net","3e361aebcf","2194180","IApbRUBZXg1WEEoHDAwORh5aQl8N",68,237,new Date().getTime(),"","","","",""]);</script></body>

<!-- Mirrored from chimera.labs.oreilly.com/books/1230000000929/ch06.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 18 Dec 2016 20:55:07 GMT -->
</html>