<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<!-- Mirrored from chimera.labs.oreilly.com/books/1230000000929/ch07.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 19 Dec 2016 21:57:12 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head><script type="text/javascript">var NREUMQ=NREUMQ||[];NREUMQ.push(["mark","firstbyte",new Date().getTime()]);</script>
	<title>Parallel and Concurrent Programming in Haskell</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link href="http://dwn0odqttrkhc.cloudfront.net/assets/book-f1caceafd9c9f3a6ff72d40c54d173ab.css" media="screen" rel="stylesheet" type="text/css" />
	<link href="http://dwn0odqttrkhc.cloudfront.net/assets/default-24583441b4f47382b8932338cd56ed23.css" media="screen" rel="stylesheet" type="text/css" />
	<script src="http://dwn0odqttrkhc.cloudfront.net/assets/application-47d6ffb0c77b868d29a43eb65e940505.js" type="text/javascript"></script>
	<script src="http://dwn0odqttrkhc.cloudfront.net/assets/book-756862b9ed04d945ca53de5b8f106a83.js" type="text/javascript"></script>
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	<link href="http://dwn0odqttrkhc.cloudfront.net/assets/janrain-53eb5abed55992e21943b9d3373923e8.css" media="all" rel="stylesheet" type="text/css" />
	<meta content="authenticity_token" name="csrf-param" />
<meta content="WQ02oEFDbvBG99rmf8rwvGssMqcy27cCD64yZVVTcMY=" name="csrf-token" />
	<script type="text/javascript" charset="utf-8">
  	
		app.data = new classes.Data({"controller":{"controller":"books","action":"html"},"capturable":{"capture_server":"https://oreilly.janraincapture.com","client_id":"6n5q2k9vesqgn93k3mhevka6c3c3rsre","app_url":"https://login.oreilly.com","app_id":"xsnca5wmqe9vxv97ygh5vfejkd","load_js":"d16s8pqtk4uodx.cloudfront.net/login.oreilly.com/load.js"},"user":{"id":null,"account":"LoggedOutAccount","email":"","name":null,"gravatar_url":"http://www.gravatar.com/avatar/d41d8cd98f00b204e9800998ecf8427e?s=40&d=identicon"},"book":{"isbn":"1230000000929","chapter":"ch07.html","toc_url":"/books/1230000000929/toc_html","metadata_url":"http://d4bb7yl96lyl1.cloudfront.net/1230000000929/metadata/metadata_9b2ac4d71a3220a7d463d8d4c80f9113048bb194.json"},"abilities":{"can_destroy_all_comments":false,"can_create_comments":false},"advertisement":{"body":"<style>      \r\n.ad-profile-image {\r\n  padding: 0;\r\n  margin: 0;\r\n  max-height: 30px;\r\n }\r\n\r\n.top-banner {\r\n  position: absolute;\r\n  right: 0;\r\n  top: 34px;\r\n  z-index: 99999;\r\n}\r\n\r\np.banner-text {\r\n  margin: 0;\r\n  text-align: center;\r\n  padding-right: 10px;\r\n  width: 450px;\r\n}\r\n\r\n@media screen and (max-width: 600px) {\r\n   p.banner-text {\r\n     width: 100%;\r\n     text-align: center;\r\n  }\r\n}\r\n\r\nspan.ebook-advantage {\r\n  font-size: smaller;\r\n  display: block;\r\n}\r\n\r\ndiv.banner-container {\r\n  margin: 0 auto;\r\n}\r\n\r\ndiv.banner-container ul {\r\n  margin: 0 auto;\r\n}\r\n\r\ndiv.topad { padding-bottom: 5px; }\r\n\r\ndiv.banner-container ul li {\r\n  display: inline-block;\r\n  vertical-align: middle;\r\n}\r\n\r\ndiv.banner-container li p {\r\n  padding-top: 0;\r\n  margin-top: 0;\r\n}\r\n\r\ndiv.banner-container li.sponsor {\r\n  border-right: 1px solid rgb(125, 154, 180);\r\n  margin-right: 5px;\r\n  padding-right: 10px;\r\n}\r\n\r\ndiv.banner-container .webbutton {\r\n  background-color: #3994b6;\r\n  display: inline-block;\r\n  padding: 10px;\r\n  -webkit-border-radius: 5px;\r\n  -moz-border-radius: 5px;\r\n  border-radius: 5px;\r\n  color: #FFF;\r\n  text-align: center;\r\n  text-decoration: none;\r\n  font-size: 12px;\r\n  font-weight: bold;\r\n}\r\n\r\n</style>\r\n   \r\n<div style=\"color: rgb(125, 154, 180);\">\r\n\r\n<div class=\"banner-container\">\r\n\r\n<ul>\r\n\r\n<li class=\"sponsor\">\r\n<!--CONFERENCE SPONSOR IMAGE-->\r\n<a href=\"http://www.oscon.com/oscon2013\">\r\n<!--<img src=\"http://orm-other.s3.amazonaws.com/fluent_logo.png\" class=\"ad-profile-image\"/>-->\r\n<img src=\"http://orm-other.s3.amazonaws.com/oscon_logo.png\" class=\"ad-profile-image\"/>\r\n<!--<img src=\"http://orm-other.s3.amazonaws.com/strata_logo.png\" class=\"ad-profile-image\"/>\r\n<img src=\"http://orm-other.s3.amazonaws.com/StrataRx_logo.png\" class=\"ad-profile-image\"/>\r\n<img src=\"http://orm-other.s3.amazonaws.com/velocity_logo.png\" class=\"ad-profile-image\"/>-->\r\n</a>\r\n</li>\r\n\r\n<li>\r\n<!--AD TEXT, 2 LINES, REPLACE LINK URL AS WELL-->\r\n<p class=\"banner-text\">Enjoy this online version of <em>Parallel and Concurrent Programming in Haskell</em>. Purchase and download the DRM-free ebook on <a href=\"http://shop.oreilly.com/product/0636920026365.do\">oreilly.com</a>.<span class=\"ebook-advantage\">Learn more about the O’Reilly <a href=\"http://shop.oreilly.com/category/ebooks.do\">Ebook Advantage</a>.</span></p>\r\n</li>\r\n\r\n<li>\r\n<!--BUY BUTTON-->\r\n<a class=\"webbutton\" href=\"http://shop.oreilly.com/product/0636920026365.do\">Buy the Ebook</a>\r\n</li> \r\n\r\n</ul>\r\n\r\n</div>\r\n\r\n<!--CORNER BANNER (IF NEEDED)-->\r\n<!--<a href=\"http://shop.oreilly.com/product/0636920026365.do\" class=\"top-banner\"><img src=\"http://orm-other.s3.amazonaws.com/banner.png\" /></a>-->\r\n\r\n</div>"}});

		/* Janrain setup */
  	var janrainModal = new JanrainView();
  	$("head").append(janrainModal.render().el);

  	/* segment.io setup */
  	var analytics=analytics||[];analytics.load=function(e){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src=("https:"===document.location.protocol?"https://":"http://")+"d2dq2ahtl5zl1z.cloudfront.net/analytics.js/v1/"+e+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(t,n);var r=function(e){return function(){analytics.push([e].concat(Array.prototype.slice.call(arguments,0)))}},i=["identify","track","trackLink","trackForm","trackClick","trackSubmit","pageview","ab","alias","ready"];for(var s=0;s<i.length;s++)analytics[i[s]]=r(i[s])};
  	
  	analytics.load("hg9h6b9pae");

  	$(function() {
			app.bookapp = new BookApp();
		});
	
	</script>
</head>
<body>
	<div id="menu">
	
		<ul id="menu-left">
			<li id="home-link"><a href="http://chimera.labs.oreilly.com/"><i class="icon-house"></i></a></li>
			<li><a href="http://chimera.labs.oreilly.com/books/1230000000929">Parallel and Concurrent Programming in Haskell</a></li>
			<div class="clear"></div>
		</ul>
	
		<ul id="menu-right">
			<li id="comments-link"><a>&nbsp;</a></li>
			<li>
				<a href="#" class="dropdown-toggle" data-toggle="dropdown">Chapters</a>
				<div id="toc-popup" class="dropdown-menu"></div>
			</li>
				<li><a href="#" class="capture_modal_open" id="capture_signin_link">Log In / Sign Up</a></li>
			<li id="search-li">
				<form accept-charset="UTF-8" action="http://chimera.labs.oreilly.com/searches" id="search-form" method="get"><div style="margin:0;padding:0;display:inline"><input name="utf8" type="hidden" value="&#x2713;" /></div>
	<input name='search[q]' type="text" placeholder="Search book..." id="book-search" />

	<input id="search_bookId" name="search[bookId]" type="hidden" value="1230000000929" />
	
	<div style='display:none'>
		sorted by: 
		<select name='search[sort]' >
			<option value='relevance'>Relevance</option>
			<option value='authors'>Author(s)</option>
			<option value='title'>Title</option>
		</select>
		returning
		<select name='search[limit]' >
			<option value='5'>5</option>
			<option value='10'>10</option>
			<option value='20'>20</option>
			<option selected="selected" value='50'>50</option>
			<option value='100'>100</option>
		</select>
		values at a time.
	</div>
</form>
			</li>
			<div class="clear"></div>
		</ul>
		<div class="clear"></div>
	
</div>
	<header><div class="navheader">
<table style="width: 100%; ">
<tr><td style="text-align: center; " colspan="3">Chapter 7. Basic Concurrency: Threads and MVars</td></tr>
<tr>
<td style="width: 20%; text-align: left; ">
<a accesskey="p" href="pt02.html">Prev</a> </td>
<td style="width: 60%; text-align: center; ">Part II. Concurrent Haskell</td>
<td style="width: 20%; text-align: right; "> <a accesskey="n" href="ch08.html">Next</a>
</td>
</tr>
</table>
<hr>
</div></header><section class="chapter" data-original-filename="ch07_conc-fork-mvar.asciidoc" id="sec_forking"><div class="titlepage"><div><div><h2 class="title">Chapter 7. Basic Concurrency: Threads and MVars</h2></div></div></div>
<p id="the_fundamental">The fundamental action in concurrency is forking a new
thread of control.  In Concurrent Haskell, this is achieved<a id="id426613" class="indexterm"></a> with the
<code class="literal">forkIO</code> operation:</p>
<pre class="programlisting" data-language="haskell" id="forkio__io_"><code class="nf">forkIO</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="nb">()</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="kt">ThreadId</code></pre>
<p id="conc-fork_00000001"><a id="ix_ch07_conc-fork-mvar-txt0" class="indexterm"></a>The <code class="literal">forkIO</code> operation takes a computation of type <code class="literal">IO ()</code> as its
argument; that is, a computation in the <code class="literal">IO</code> monad that eventually
delivers a value of type <code class="literal">()</code>.  The computation passed to <code class="literal">forkIO</code> is
executed in a new thread that runs concurrently with the other
threads in the system.  If the thread has <a id="id426723" class="indexterm"></a><a id="id426729" class="indexterm"></a>effects, those effects will
be interleaved in an indeterminate fashion with the effects from other
threads.</p>
<p id="conc-fork_00000002">To illustrate the interleaving of effects, let’s try a simple example
with two threads, one that repeatedly prints the letter <code class="literal">A</code> while
the other repeatedly prints <code class="literal">B</code>:</p>
<p id="conc-fork_00000003"><span class="emphasis"><em>fork.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="import_control_id2"><code class="kr">import</code> <code class="nn">Control.Concurrent</code>
<code class="kr">import</code> <code class="nn">Control.Monad</code>
<code class="kr">import</code> <code class="nn">System.IO</code>

<code class="nf">main</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">hSetBuffering</code> <code class="n">stdout</code> <code class="kt">NoBuffering</code>            <code class="c1">-- </code><span id="CO26-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
  <code class="n">forkIO</code> <code class="p">(</code><code class="n">replicateM_</code> <code class="mi">100000</code> <code class="p">(</code><code class="n">putChar</code> <code class="sc">'A'</code><code class="p">))</code>   <code class="c1">-- </code><span id="CO26-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>
  <code class="n">replicateM_</code> <code class="mi">100000</code> <code class="p">(</code><code class="n">putChar</code> <code class="sc">'B'</code><code class="p">)</code>            <code class="c1">-- </code><span id="CO26-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></pre>
<div class="calloutlist" id="conc-fork_00000005"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO26-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="put_the_output_">
Put the output <code class="literal">Handle</code> into nonbuffered mode, so
that we can see the interleaving more clearly.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO26-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="create_a_thread">
Create a thread to print the character <code class="literal">A</code> 100,000 times.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO26-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="in_the_main_thr_id1">
In the main thread, print <code class="literal">B</code> 100,000 times.
</p></td>
</tr>
</table></div>
<p id="conc-fork_00000006">Try running the program; it should produce output similar to this:</p>
<pre class="screen" id="conc-fork_00000007">AAAAAAAAABABABABABABABABABABABABABABABABABABABABABABAB
ABABABABABABABABABABABABABABABABABABABABABABABABABABAB
ABABABABABABABABABABABABABABABABABABABABABABABABABABAB
ABABABABABABABABABABABABABABABABABABABABABABABABABABAB</pre>
<p id="conc-fork_00000008">The output might have a different pattern, depending on the particular
version of GHC that you use to run the test.  In this case, we sometimes
see strings of a single letter and sometimes a regular alternation
between the two letters.  Strings of a single letter are to be
expected; the runtime system runs one thread for a "time slice" and
then switches to the other thread.<a href="#ftn.id427024" class="footnote"><sup class="footnote" id="id427024">[26]</sup></a> But why do we see sequences where each thread
only gets a chance to output a single letter before switching?  The
threads in this example are contending for a single resource, the
<code class="literal">stdout</code> Handle, so the behavior is affected by how contention for
this resource is managed by the runtime system.  We’ll see later how
GHC’s <a id="id427046" class="indexterm"></a>fairness policy gives rise to the <code class="literal">ABABABA</code> behavior seen here.</p>
<div class="sect1" data-original-filename="ch07_conc-fork-mvar.asciidoc" id="sec_reminders">
<div class="titlepage"><div><div><h2 class="title">A Simple Example: Reminders</h2></div></div></div>
<p id="conc-fork_00000009"><a id="ix_ch07_conc-fork-mvar-txt2" class="indexterm"></a>The following program illustrates the <a id="id427089" class="indexterm"></a><a id="id427094" class="indexterm"></a><a id="id427103" class="indexterm"></a>creation of threads in a program
that implements timed reminders.  The user enters a number of seconds,
and after the specified time has elapsed, the program prints a message
and emits a beep.<a href="#ftn.id427111" class="footnote"><sup class="footnote" id="id427111">[27]</sup></a>  Any number of reminders can
be active simultaneously.</p>
<p id="conc-fork_00000010">We’ll need an operation that waits for some time to <a id="id427124" class="indexterm"></a>elapse:</p>
<pre class="programlisting" data-language="haskell" id="threaddelay__"><code class="nf">threadDelay</code> <code class="ow">::</code> <code class="kt">Int</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code></pre>
<p id="conc-fork_00000012">The function <code class="literal">threadDelay</code> takes an argument representing a number of
microseconds and waits for that amount of time before returning.</p>
<p id="conc-fork_00000013" class="caption"><span class="emphasis"><em>reminders.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="import_control_id3"><code class="kr">import</code> <code class="nn">Control.Concurrent</code>
<code class="kr">import</code> <code class="nn">Text.Printf</code>
<code class="kr">import</code> <code class="nn">Control.Monad</code>

<code class="nf">main</code> <code class="ow">=</code>
  <code class="n">forever</code> <code class="o">$</code> <code class="kr">do</code>
    <code class="n">s</code> <code class="ow">&lt;-</code> <code class="n">getLine</code>           <code class="c1">-- </code><span id="CO27-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
    <code class="n">forkIO</code> <code class="o">$</code> <code class="n">setReminder</code> <code class="n">s</code> <code class="c1">-- </code><span id="CO27-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>

<code class="nf">setReminder</code> <code class="ow">::</code> <code class="kt">String</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">setReminder</code> <code class="n">s</code>  <code class="ow">=</code> <code class="kr">do</code>
  <code class="kr">let</code> <code class="n">t</code> <code class="ow">=</code> <code class="n">read</code> <code class="n">s</code> <code class="ow">::</code> <code class="kt">Int</code>
  <code class="n">printf</code> <code class="s">"Ok, I'll remind you in %d seconds</code><code class="se">\n</code><code class="s">"</code> <code class="n">t</code>
  <code class="n">threadDelay</code> <code class="p">(</code><code class="mi">10</code><code class="o">^</code><code class="mi">6</code> <code class="o">*</code> <code class="n">t</code><code class="p">)</code>                   <code class="c1">-- </code><span id="CO27-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span>
  <code class="n">printf</code> <code class="s">"%d seconds is up! BING!</code><code class="se">\BEL\n</code><code class="s">"</code> <code class="n">t</code> <code class="c1">-- </code><span id="CO27-4"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span></pre>
<p id="conc-fork_00000016">The program works by creating a thread for each new request for a
reminder:</p>
<div class="calloutlist" id="conc-fork_00000018"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO27-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="waits_for_input">
Waits for input from the user.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO27-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="creates_a_new_t">
Creates a new thread to handle this reminder.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO27-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_new_thread">
The new thread, after printing a confirmation message, waits for the specified number of seconds using <code class="literal">threadDelay</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO27-4"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="finally_when_t">
Finally, when <code class="literal">threadDelay</code> returns, the reminder message is printed.
</p></td>
</tr>
</table></div>
<p id="conc-fork_00000020">For example:</p>
<pre class="screen" id="conc-fork_00000021">$ ./reminders
2
Ok, I'll remind you in 2 seconds
3
Ok, I'll remind you in 3 seconds
4
Ok, I'll remind you in 4 seconds
2 seconds is up! BING!
3 seconds is up! BING!
4 seconds is up! BING!</pre>
<p id="conc-fork_00000022">Let’s extend this example to allow the user to <a id="id427615" class="indexterm"></a><a id="id427621" class="indexterm"></a>terminate the program
by entering <code class="literal">exit</code> instead of a number.  We need to modify only the <code class="literal">main</code> function:</p>
<p id="conc-fork_00000024" class="caption"><span class="emphasis"><em>reminders2.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="main__loop_whe"><code class="nf">main</code> <code class="ow">=</code> <code class="n">loop</code>
 <code class="kr">where</code>
  <code class="n">loop</code> <code class="ow">=</code> <code class="kr">do</code>
    <code class="n">s</code> <code class="ow">&lt;-</code> <code class="n">getLine</code>
    <code class="kr">if</code> <code class="n">s</code> <code class="o">==</code> <code class="s">"exit"</code>
       <code class="kr">then</code> <code class="n">return</code> <code class="nb">()</code>
       <code class="kr">else</code> <code class="kr">do</code> <code class="n">forkIO</code> <code class="o">$</code> <code class="n">setReminder</code> <code class="n">s</code>
               <code class="n">loop</code></pre>
<p id="conc-fork_00000025">Instead of <code class="literal">forever</code>, we now use a recursive loop, and we choose to
return from the loop if the string entered was <code class="literal">"exit"</code>; otherwise, we
create a new thread as before and loop again.  Returning from the loop
causes <code class="literal">main</code> itself to return, which ends the program.</p>
<p id="conc-fork_00000026">Now we can terminate the program, even if there are outstanding
reminders:</p>
<pre class="screen" id="conc-fork_00000027">$ ./reminders2
2
Ok, I'll remind you in 2 seconds
3
Ok, I'll remind you in 3 seconds
2 seconds is up! BING!
exit
$</pre>
<p id="conc-fork_00000028">This tells us something important about how threads work in Haskell: <span class="emphasis"><em>the program terminates when <code class="literal">main</code> returns, even if there are other threads still running</em></span>.  The other threads simply stop running and
cease to exist after <code class="literal">main</code> returns.</p>
<p id="conc-fork_00000029">Why does Haskell make this design decision, when in many cases it
would be more useful to wait for all the concurrent threads to finish
before terminating the program?  Haskell’s approach is to give you the
simplest possible interface that allows you to program whatever
behavior you need, and waiting for threads is an additional service
that can be implemented using the facilities provided by Concurrent
Haskell.  Higher-level interfaces can be provided by libraries. If
you don’t like the behavior provided by a certain library, you can
always modify it or write your own.</p>
<p id="conc-fork_00000030">In <a class="xref" href="ch07.html#sec_conc-logger" title="MVar as a Simple Channel: A Logging Service">“MVar as a Simple Channel: A Logging Service”</a>, we’ll see one way to wait for a thread to
terminate. In <a class="xref" href="ch08.html" title="Chapter 8. Overlapping Input/Output">Chapter 8</a>, we will build a more
general interface for waiting for threads, which will be developed
further in the following chapters.<a id="id427893" class="indexterm"></a></p>
</div>
<div class="sect1" data-original-filename="ch07_conc-fork-mvar.asciidoc" id="sec_mvars">
<div class="titlepage"><div><div><h2 class="title">Communication: MVars</h2></div></div></div>
<p id="conc-mvar_00000000"><a id="ix_ch07_conc-fork-mvar-txt3" class="indexterm"></a><a id="ix_ch07_conc-fork-mvar-txt4" class="indexterm"></a><a id="ix_ch07_conc-fork-mvar-txt5" class="indexterm"></a>So far, we have learned how to create threads, but they can’t talk to
each other.  In this section we’ll introduce <code class="literal">MVar</code>, the <a id="ix_ch07_conc-fork-mvar-txt6" class="indexterm"></a><a id="ix_ch07_conc-fork-mvar-txt7" class="indexterm"></a>basic
communication mechanism provided by Concurrent Haskell.</p>
<p id="conc-mvar_00000001">The API for <code class="literal">MVar</code> is as follows:</p>
<pre class="programlisting" data-language="haskell" id="data_mvar_a__"><code class="kr">data</code> <code class="kt">MVar</code> <code class="n">a</code>  <code class="c1">-- abstract</code>

<code class="nf">newEmptyMVar</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">MVar</code> <code class="n">a</code><code class="p">)</code>
<code class="nf">newMVar</code>      <code class="ow">::</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">MVar</code> <code class="n">a</code><code class="p">)</code>
<code class="nf">takeMVar</code>     <code class="ow">::</code> <code class="kt">MVar</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">a</code>
<code class="nf">putMVar</code>      <code class="ow">::</code> <code class="kt">MVar</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code></pre>
<p id="conc-mvar_00000004">An <code class="literal">MVar</code> can be thought of as a box that is either empty or full. The<a id="id428223" class="indexterm"></a><a id="id428229" class="indexterm"></a><a id="id428235" class="indexterm"></a>
<code class="literal">newEmptyMVar</code> operation creates a new empty box, and <code class="literal">newMVar</code>
creates a new full box containing the value passed as its argument.
The <code class="literal">takeMVar</code> operation removes the value from a full <code class="literal">MVar</code> and
returns it, but waits (or <span class="emphasis"><em>blocks</em></span>) if the <code class="literal">MVar</code> is currently empty.
Symmetrically, the <code class="literal">putMVar</code> operation puts a value into the <code class="literal">MVar</code>
but blocks if the <code class="literal">MVar</code> is already full.</p>
<p id="conc-mvar_00000005">The following sequence of small examples should help to illustrate how
<code class="literal">MVar</code>s work.  First, this program passes a single value from one
thread to another:</p>
<p id="conc-mvar_00000006"><span class="emphasis"><em>mvar1.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="main__do_m___id1"><code class="nf">main</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">m</code> <code class="ow">&lt;-</code> <code class="n">newEmptyMVar</code>
  <code class="n">forkIO</code> <code class="o">$</code> <code class="n">putMVar</code> <code class="n">m</code> <code class="sc">'x'</code>
  <code class="n">r</code> <code class="ow">&lt;-</code> <code class="n">takeMVar</code> <code class="n">m</code>
  <code class="n">print</code> <code class="n">r</code></pre>
<p id="conc-mvar_00000007">The <code class="literal">MVar</code> is empty when it is created, the child thread puts the
value <code class="literal">x</code> into it, and the main thread takes the value and prints
it.  If the main thread calls <code class="literal">takeMVar</code> before the child
thread has put the value, no problem: <code class="literal">takeMVar</code> blocks
until the value is available.</p>
<p id="conc-mvar_00000008">This second example passes <span class="emphasis"><em>two</em></span> values from the child thread to the
main thread:</p>
<p id="conc-mvar_00000009"><span class="emphasis"><em>mvar2.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="main__do_m___id2"><code class="nf">main</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">m</code> <code class="ow">&lt;-</code> <code class="n">newEmptyMVar</code>
  <code class="n">forkIO</code> <code class="o">$</code> <code class="kr">do</code> <code class="n">putMVar</code> <code class="n">m</code> <code class="sc">'x'</code><code class="p">;</code> <code class="n">putMVar</code> <code class="n">m</code> <code class="sc">'y'</code>
  <code class="n">r</code> <code class="ow">&lt;-</code> <code class="n">takeMVar</code> <code class="n">m</code>
  <code class="n">print</code> <code class="n">r</code>
  <code class="n">r</code> <code class="ow">&lt;-</code> <code class="n">takeMVar</code> <code class="n">m</code>
  <code class="n">print</code> <code class="n">r</code></pre>
<p id="conc-mvar_00000010">The output when we run the program will be <code class="literal">'x'</code> followed by <code class="literal">'y'</code>.
An <code class="literal">MVar</code> can be used in this way as a simple channel between two
threads, or even between many writers and a single reader.  We will
see a realistic example of this use case shortly.</p>
<p id="conc-mvar_00000011">What happens if a thread blocks in <code class="literal">takeMVar</code> but there is no other
thread to perform the corresponding <code class="literal">putMVar</code>?  For example:</p>
<p id="conc-mvar_00000012" class="caption"><span class="emphasis"><em>mvar3.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="main__do_m___id3"><code class="nf">main</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">m</code> <code class="ow">&lt;-</code> <code class="n">newEmptyMVar</code>
  <code class="n">takeMVar</code> <code class="n">m</code></pre>
<p id="conc-mvar_00000013">If we run the program, we should see this:</p>
<pre class="screen" id="conc-mvar_00000014">$ ./mvar3
mvar3: thread blocked indefinitely in an MVar operation</pre>
<p id="conc-mvar_00000015">The runtime system detects that the <code class="literal">takeMVar</code> operation in the main
thread is blocked forever and throws a special <a id="id428769" class="indexterm"></a><a id="id428775" class="indexterm"></a><a id="id428783" class="indexterm"></a>exception called
<code class="literal">BlockedIndefinitelyOnMVar</code>.  In practice, this means that if you
accidentally write a program that contains a deadlock, in many cases
the program will fail with an exception rather than just hanging,
which is useful for debugging.  We’ll return to cover deadlock
detection in more detail in <a class="xref" href="ch15.html#sec_deadlock" title="Detecting Deadlock">“Detecting Deadlock”</a>.</p>
<p id="conc-mvar_00000016">The <code class="literal">MVar</code> is a fundamental building block that generalizes many
different communication and synchronization patterns, and over the
next few sections we shall see examples of these various use cases.
To summarize the main ways in which an <code class="literal">MVar</code> can be used:</p>
<div class="itemizedlist" id="conc-mvar_00000017"><ul class="itemizedlist">
<li class="listitem">
An <code class="literal">MVar</code> <a id="ix_ch07_conc-fork-mvar-txt8" class="indexterm"></a><a id="ix_ch07_conc-fork-mvar-txt9" class="indexterm"></a>is a <span class="emphasis"><em>one-place channel</em></span>, which means that it can be used
  for passing messages between threads, but it can hold at most
  one message at a time.
</li>
<li class="listitem">
<p id="an_mvar_ismutab" class="simpara">
An <code class="literal">MVar</code> is<a id="id428896" class="indexterm"></a><a id="id428902" class="indexterm"></a> a <span class="emphasis"><em>container for shared mutable state</em></span>.  For example, a
  common design pattern in Concurrent Haskell, when several threads
  need read and write access to some state, is to represent the state
  value as an ordinary immutable Haskell data structure stored in an
  <code class="literal">MVar</code>.  Modifying the state consists of taking the current value
  with <code class="literal">takeMVar</code> (which implicitly acquires a lock), and then placing<a id="id428930" class="indexterm"></a><a id="id428938" class="indexterm"></a>
  a new value back in the <code class="literal">MVar</code> with <code class="literal">putMVar</code> (which implicitly
  releases the lock again).



</p>
<p id="conc-mvar_00000018" class="simpara">Sometimes the mutable state is not a Haskell data structure; it
might be stored in C code or on the filesystem, for example.  In
such cases, we can use an <code class="literal">MVar</code> with a dummy value such as <code class="literal">()</code> to
act as a lock on the external state, where <code class="literal">takeMVar</code> acquires the
lock and <code class="literal">putMVar</code> releases it again.<a href="#ftn.id429002" class="footnote"><sup class="footnote" id="id429002">[28]</sup></a></p>
</li>
<li class="listitem">
An <code class="literal">MVar</code> is <a id="id429020" class="indexterm"></a>a <span class="emphasis"><em>building block</em></span> for constructing larger concurrent
  Data<a id="id429033" class="indexterm"></a><a id="id429043" class="indexterm"></a><a id="id429054" class="indexterm"></a><a id="id429064" class="indexterm"></a>structures.
</li>
</ul></div>
<p id="conc-mvar_00000021">The next three sections give examples of each of these use cases in turn.</p>
</div>
<div class="sect1" data-original-filename="ch07_conc-fork-mvar.asciidoc" id="sec_conc-logger">
<div class="titlepage"><div><div><h2 class="title">MVar as a Simple Channel: A Logging Service</h2></div></div></div>
<p id="conc-mvar_00000022"><a id="ix_ch07_conc-fork-mvar-txt10" class="indexterm"></a><a id="ix_ch07_conc-fork-mvar-txt11" class="indexterm"></a><a id="ix_ch07_conc-fork-mvar-txt12" class="indexterm"></a>A <a id="ix_ch07_conc-fork-mvar-txt13" class="indexterm"></a>logging service is a thread to which the rest of the program can
send messages, and it is the job of the logger to record those
messages somewhere.  For example, the logger might just print the
messages to the screen, or store them in a file, or perhaps forward
them over the network to a separate machine that collects logs from
multiple sources.</p>
<p id="conc-mvar_00000023">Logging is usually a fire-and-forget activity. We care that the log
messages from any given thread come out in the right order, but we
don’t need to wait until the logger has actually recorded each message
before we go on to do something else. Therefore, running the logging
service in a separate thread means that logging can take place
concurrently with other activity in the system, which means that we
can overlap the input/output performed by the logger with other
activity in the program.</p>
<p id="conc-mvar_00000024">In this section, we implement a simple logging service in
Concurrent Haskell using an <code class="literal">MVar</code> for communication.  The logging
service will have the following API:</p>
<pre class="programlisting" data-language="haskell" id="data_logger_ini"><code class="kr">data</code> <code class="kt">Logger</code>

<code class="nf">initLogger</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="kt">Logger</code>
<code class="nf">logMessage</code> <code class="ow">::</code> <code class="kt">Logger</code> <code class="ow">-&gt;</code> <code class="kt">String</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">logStop</code>    <code class="ow">::</code> <code class="kt">Logger</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code></pre>
<p id="conc-mvar_00000027">There is an abstract data type <a id="id429305" class="indexterm"></a>called <code class="literal">Logger</code> that represents a handle
to the logging service, and a new logging service is created by
calling <code class="literal">initLogger</code>. The handle is required to perform a logging
action—having <code class="literal">Logger</code> be a value that we pass around rather than a
globally known top-level value is good practice; it means we could
have multiple loggers, for example.</p>
<p id="conc-mvar_00000028">There are two operations that we can <a id="id429339" class="indexterm"></a><a id="id429345" class="indexterm"></a>perform: <code class="literal">logMessage</code> takes a
<code class="literal">String</code> and logs it, and <code class="literal">logStop</code> causes the logging service to
terminate.  The latter operation is important because if we want to
shut down the program, we need to be sure that the logging service has
finished processing any outstanding requests. Recall from
<a class="xref" href="ch07.html#sec_reminders" title="A Simple Example: Reminders">“A Simple Example: Reminders”</a> that when the main thread exits, the program
terminates immediately rather than waiting for other threads to
terminate first.  Hence <code class="literal">logStop</code> has an extra requirement: it must
not return until the logging service has processed all outstanding
requests and stopped.</p>
<p id="conc-mvar_00000029">The implementation is given in the following code fragments.  First,
the data type <code class="literal">Logger</code>:</p>
<p id="conc-mvar_00000030" class="caption"><span class="emphasis"><em>logger.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="data_logger__l"><code class="kr">data</code> <code class="kt">Logger</code> <code class="ow">=</code> <code class="kt">Logger</code> <code class="p">(</code><code class="kt">MVar</code> <code class="kt">LogCommand</code><code class="p">)</code>

<code class="kr">data</code> <code class="kt">LogCommand</code> <code class="ow">=</code> <code class="kt">Message</code> <code class="kt">String</code> <code class="o">|</code> <code class="kt">Stop</code> <code class="p">(</code><code class="kt">MVar</code> <code class="nb">()</code><code class="p">)</code></pre>
<p id="conc-mvar_00000032">The <code class="literal">Logger</code> is just an <code class="literal">MVar</code> that we use as a channel for
communication with the logging thread.  Requests are made by placing a
<code class="literal">LogCommand</code> in the <code class="literal">MVar</code>, and the logging thread will process
requests one at a time by taking them from the <code class="literal">MVar</code>.</p>
<p id="conc-mvar_00000033">There are two kinds of requests that we can make, and<a id="id429564" class="indexterm"></a><a id="id429572" class="indexterm"></a><a id="id429580" class="indexterm"></a><a id="id429586" class="indexterm"></a><a id="id429592" class="indexterm"></a> so <code class="literal">LogCommand</code>
is a data type with two constructors.  The first, <code class="literal">Message</code>, is
straightforward; it simply contains a <code class="literal">String</code> that we want to log.
The second, <code class="literal">Stop</code>, obviously represents the message requesting that
the logging thread terminate, but it contains a field of type <code class="literal">MVar ()</code>. This enables the sender of the <code class="literal">Stop</code> message to wait for a
reply from the logging thread that indicates it has finished.  We’ll
see how this works in a <a id="id429639" class="indexterm"></a>moment.</p>
<p id="conc-mvar_00000034">The <code class="literal">initLogger</code> function creates a new logging service:</p>
<pre class="programlisting" data-language="haskell" id="initlogger__i"><code class="nf">initLogger</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="kt">Logger</code>
<code class="nf">initLogger</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">m</code> <code class="ow">&lt;-</code> <code class="n">newEmptyMVar</code>
  <code class="kr">let</code> <code class="n">l</code> <code class="ow">=</code> <code class="kt">Logger</code> <code class="n">m</code>
  <code class="n">forkIO</code> <code class="p">(</code><code class="n">logger</code> <code class="n">l</code><code class="p">)</code>
  <code class="n">return</code> <code class="n">l</code></pre>
<p id="conc-mvar_00000036">This is straightforward: just create an empty <code class="literal">MVar</code> for the channel
and fork a thread to perform the service.  The thread will run the
function <code class="literal">logger</code>, which is defined as follows:</p>
<pre class="programlisting" data-language="haskell" id="logger__logge"><code class="nf">logger</code> <code class="ow">::</code> <code class="kt">Logger</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">logger</code> <code class="p">(</code><code class="kt">Logger</code> <code class="n">m</code><code class="p">)</code> <code class="ow">=</code> <code class="n">loop</code>
 <code class="kr">where</code>
  <code class="n">loop</code> <code class="ow">=</code> <code class="kr">do</code>
    <code class="n">cmd</code> <code class="ow">&lt;-</code> <code class="n">takeMVar</code> <code class="n">m</code>
    <code class="kr">case</code> <code class="n">cmd</code> <code class="kr">of</code>
      <code class="kt">Message</code> <code class="n">msg</code> <code class="ow">-&gt;</code> <code class="kr">do</code>
        <code class="n">putStrLn</code> <code class="n">msg</code>
        <code class="n">loop</code>
      <code class="kt">Stop</code> <code class="n">s</code> <code class="ow">-&gt;</code> <code class="kr">do</code>
        <code class="n">putStrLn</code> <code class="s">"logger: stop"</code>
        <code class="n">putMVar</code> <code class="n">s</code> <code class="nb">()</code></pre>
<p id="conc-mvar_00000038">The logger is implemented with a recursive <code class="literal">loop</code>.  The <code class="literal">loop</code>
function retrieves the next <code class="literal">LogCommand</code> from the <code class="literal">MVar</code> and inspects
it.  If it is a <code class="literal">Message</code>, this simple logger just prints the message
using <code class="literal">putStrLn</code> and recursively invokes <code class="literal">loop</code>.  If it is a <code class="literal">Stop</code>
command, the logger emits a log message to say that it is stopping,
replies to the initiator of the <code class="literal">Stop</code> by putting the unit value <code class="literal">()</code>
into the <code class="literal">MVar</code> from the <code class="literal">Stop</code> command, and then returns without
calling <code class="literal">loop</code> again, which causes the logger thread to exit.</p>
<p id="conc-mvar_00000039">Next we have the implementation of <code class="literal">logMessage</code>, which is the function that a
client uses to log a message.</p>
<pre class="programlisting" data-language="haskell" id="logmessage__l"><code class="nf">logMessage</code> <code class="ow">::</code> <code class="kt">Logger</code> <code class="ow">-&gt;</code> <code class="kt">String</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">logMessage</code> <code class="p">(</code><code class="kt">Logger</code> <code class="n">m</code><code class="p">)</code> <code class="n">s</code> <code class="ow">=</code> <code class="n">putMVar</code> <code class="n">m</code> <code class="p">(</code><code class="kt">Message</code> <code class="n">s</code><code class="p">)</code></pre>
<p id="conc-mvar_00000041">This is simple. Just put a <code class="literal">Message</code> command in the <code class="literal">MVar</code>. Next up, <code class="literal">logStop</code>:</p>
<pre class="programlisting" data-language="haskell" id="logstop__logg"><code class="nf">logStop</code> <code class="ow">::</code> <code class="kt">Logger</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">logStop</code> <code class="p">(</code><code class="kt">Logger</code> <code class="n">m</code><code class="p">)</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">s</code> <code class="ow">&lt;-</code> <code class="n">newEmptyMVar</code>
  <code class="n">putMVar</code> <code class="n">m</code> <code class="p">(</code><code class="kt">Stop</code> <code class="n">s</code><code class="p">)</code>
  <code class="n">takeMVar</code> <code class="n">s</code></pre>
<p id="conc-mvar_00000043">We have to create an empty <code class="literal">MVar</code> to hold the response and then send
a <code class="literal">Stop</code> command to the logger containing the new empty <code class="literal">MVar</code>.  After
sending the command, we call <code class="literal">takeMVar</code> on the new <code class="literal">MVar</code> to wait for
the response. After the logging thread has processed the <code class="literal">Stop</code>
command, it puts <code class="literal">()</code> into this <code class="literal">MVar</code>, which allows the
<code class="literal">takeMVar</code> to continue and <code class="literal">logStop</code> to return.</p>
<p id="conc-mvar_00000044">We can test our logger with a simple <code class="literal">main</code> function:</p>
<p id="conc-mvar_00000045" class="caption"><span class="emphasis"><em>logger.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="main__io__m_id4"><code class="nf">main</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">main</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">l</code> <code class="ow">&lt;-</code> <code class="n">initLogger</code>
  <code class="n">logMessage</code> <code class="n">l</code> <code class="s">"hello"</code>
  <code class="n">logMessage</code> <code class="n">l</code> <code class="s">"bye"</code>
  <code class="n">logStop</code> <code class="n">l</code></pre>
<p id="conc-mvar_00000046">If we run the program, we should see this:</p>
<pre class="screen" id="conc-mvar_00000047">$ ./logger
hello
bye
logger: stop</pre>
<p id="conc-mvar_00000048">Does this logger achieve what we set out to do?  The <code class="literal">logMessage</code>
function can return immediately provided the <code class="literal">MVar</code> is already empty,
and then the logger will proceed concurrently with the caller of
<code class="literal">logMessage</code>.  However, if there are multiple threads trying to log
messages at the same time, it seems likely that the logging thread
would not be able to process the messages fast enough and most of the
threads would get blocked in <code class="literal">logMessage</code> while waiting for the <code class="literal">MVar</code> to
become empty.  This is because the <code class="literal">MVar</code> is only a one-place channel. If it could hold more messages, we would gain greater concurrency
when multiple threads need to call <code class="literal">logMessage</code> simultaneously.  In
<a class="xref" href="ch07.html#sec_channels" title="MVar as a Building Block: Unbounded Channels">“MVar as a Building Block: Unbounded Channels”</a>, we will see how to use <code class="literal">MVar</code> to build fully
buffered channels<a id="id430691" class="indexterm"></a>.<a id="id430702" class="indexterm"></a><a id="id430712" class="indexterm"></a><a id="id430722" class="indexterm"></a></p>
</div>
<div class="sect1" data-original-filename="ch07_conc-fork-mvar.asciidoc" id="sec_conc-phonebook">
<div class="titlepage"><div><div><h2 class="title">MVar as a Container for Shared State</h2></div></div></div>
<p id="conc-mvar_00000049"><a id="ix_ch07_conc-fork-mvar-txt14" class="indexterm"></a><a id="ix_ch07_conc-fork-mvar-txt15" class="indexterm"></a><a id="ix_ch07_conc-fork-mvar-txt16" class="indexterm"></a><a id="ix_ch07_conc-fork-mvar-txt17" class="indexterm"></a><a id="ix_ch07_conc-fork-mvar-txt18" class="indexterm"></a><a id="ix_ch07_conc-fork-mvar-txt19" class="indexterm"></a><a id="ix_ch07_conc-fork-mvar-txt20" class="indexterm"></a>Concurrent programs often need to share some state between multiple
threads.  Furthermore, we usually need to be able to perform complex
operations on the state, in a way that makes these operations appear
atomic from the point of view of the other threads.  Other threads
should not be able to observe intermediate states during a complex
operation, nor should they be able to initiate their own operations
while another operation is in progress.</p>
<p id="conc-mvar_00000050">Traditional <a id="id430850" class="indexterm"></a><a id="id430858" class="indexterm"></a><a id="id430866" class="indexterm"></a>imperative languages achieve this using "locks," whereby
to operate on the state (including reading it) a thread must
acquire a lock, perform the operation, and then release the lock.
Only one thread is allowed to hold the lock at any given time, so the
acquisition of a lock must block until the lock is available.</p>
<p id="conc-mvar_00000051"><code class="literal">MVar</code> provides the combination of a lock and a mutable variable in
Haskell. To acquire the lock, we take the <code class="literal">MVar</code>, whereas, to update the
variable and release the lock, we put the <code class="literal">MVar</code>.<a href="#ftn.id430902" class="footnote"><sup class="footnote" id="id430902">[29]</sup></a></p>
<p id="conc-mvar_00000052">The following example models a phone book as a piece of mutable state
that may be concurrently modified and inspected by multiple threads.
First, we define the types:</p>
<p id="conc-mvar_00000053" class="caption"><span class="emphasis"><em>phonebook.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="type_name__str"><code class="kr">type</code> <code class="kt">Name</code>        <code class="ow">=</code> <code class="kt">String</code>
<code class="kr">type</code> <code class="kt">PhoneNumber</code> <code class="ow">=</code> <code class="kt">String</code>
<code class="kr">type</code> <code class="kt">PhoneBook</code>   <code class="ow">=</code> <code class="kt">Map</code> <code class="kt">Name</code> <code class="kt">PhoneNumber</code>

<code class="kr">newtype</code> <code class="kt">PhoneBookState</code> <code class="ow">=</code> <code class="kt">PhoneBookState</code> <code class="p">(</code><code class="kt">MVar</code> <code class="kt">PhoneBook</code><code class="p">)</code></pre>
<p id="conc-mvar_00000055">A <code class="literal">PhoneBook</code> is a mapping from names to phone numbers represented by
Haskell’s <code class="literal">Map</code> type from the <code class="literal">Data.Map</code> library.  To make this into a
piece of shared mutable state, all we need to do is wrap it in an
<code class="literal">MVar</code>. Here, we have made a new type called <code class="literal">PhoneBookState</code> to
contain the <code class="literal">MVar</code>.  This is simply good practice. If we were to make
this interface into a library, the <code class="literal">PhoneBookState</code> type could be
exported abstractly so that clients could not see or depend on its
implementation.</p>
<p id="conc-mvar_00000056">Making a new <code class="literal">PhoneBookState</code> is straightforward:</p>
<pre class="programlisting" data-language="haskell" id="new__io_phone"><code class="nf">new</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="kt">PhoneBookState</code>
<code class="nf">new</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">m</code> <code class="ow">&lt;-</code> <code class="n">newMVar</code> <code class="kt">Map</code><code class="o">.</code><code class="n">empty</code>
  <code class="n">return</code> <code class="p">(</code><code class="kt">PhoneBookState</code> <code class="n">m</code><code class="p">)</code></pre>
<p id="conc-mvar_00000058">Now to <a id="id431244" class="indexterm"></a>implement <code class="literal">insert</code>, the operation that allows a thread to
insert a new entry in the phone book:</p>
<pre class="programlisting" data-language="haskell" id="insert__phone"><code class="nf">insert</code> <code class="ow">::</code> <code class="kt">PhoneBookState</code> <code class="ow">-&gt;</code> <code class="kt">Name</code> <code class="ow">-&gt;</code> <code class="kt">PhoneNumber</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">insert</code> <code class="p">(</code><code class="kt">PhoneBookState</code> <code class="n">m</code><code class="p">)</code> <code class="n">name</code> <code class="n">number</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">book</code> <code class="ow">&lt;-</code> <code class="n">takeMVar</code> <code class="n">m</code>
  <code class="n">putMVar</code> <code class="n">m</code> <code class="p">(</code><code class="kt">Map</code><code class="o">.</code><code class="n">insert</code> <code class="n">name</code> <code class="n">number</code> <code class="n">book</code><code class="p">)</code></pre>
<p id="conc-mvar_00000060">We call <code class="literal">takeMVar</code> to get the current <code class="literal">PhoneBook</code>, which has the
effect of locking the state against concurrent updates.  Any other
thread attempting to update the state will now block in <code class="literal">takeMVar</code>.
Then, <code class="literal">putMVar</code> simultaneously unlocks the state and updates it with
the new value, which we construct by calling <code class="literal">Map.insert</code> to insert
the new entry into the phone book.</p>
<p id="conc-mvar_00000061">Next, we’ll create<a id="id431486" class="indexterm"></a> a <code class="literal">lookup</code> operation that allows us to query the
phone book for a particular name:</p>
<pre class="programlisting" data-language="haskell" id="lookup__phone"><code class="nf">lookup</code> <code class="ow">::</code> <code class="kt">PhoneBookState</code> <code class="ow">-&gt;</code> <code class="kt">Name</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">Maybe</code> <code class="kt">PhoneNumber</code><code class="p">)</code>
<code class="nf">lookup</code> <code class="p">(</code><code class="kt">PhoneBookState</code> <code class="n">m</code><code class="p">)</code> <code class="n">name</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">book</code> <code class="ow">&lt;-</code> <code class="n">takeMVar</code> <code class="n">m</code>
  <code class="n">putMVar</code> <code class="n">m</code> <code class="n">book</code>
  <code class="n">return</code> <code class="p">(</code><code class="kt">Map</code><code class="o">.</code><code class="n">lookup</code> <code class="n">name</code> <code class="n">book</code><code class="p">)</code></pre>
<p id="conc-mvar_00000063">Note that we need to put back the state after taking it; otherwise, the
state would remain locked after <code class="literal">lookup</code> returns.</p>
<p id="conc-mvar_00000064">Now we can test our data structure with a simple <code class="literal">main</code> function that
inserts a few entries in a phone book and then does a couple of
<code class="literal">lookup</code>s:</p>
<p id="conc-mvar_00000065" class="caption"><span class="emphasis"><em>phonebook.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="main__do_s__"><code class="nf">main</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">s</code> <code class="ow">&lt;-</code> <code class="n">new</code>
  <code class="n">sequence_</code> <code class="p">[</code> <code class="n">insert</code> <code class="n">s</code> <code class="p">(</code><code class="s">"name"</code> <code class="o">++</code> <code class="n">show</code> <code class="n">n</code><code class="p">)</code> <code class="p">(</code><code class="n">show</code> <code class="n">n</code><code class="p">)</code> <code class="o">|</code> <code class="n">n</code> <code class="ow">&lt;-</code> <code class="p">[</code><code class="mi">1</code><code class="o">..</code><code class="mi">10000</code><code class="p">]</code> <code class="p">]</code>
  <code class="n">lookup</code> <code class="n">s</code> <code class="s">"name999"</code> <code class="o">&gt;&gt;=</code> <code class="n">print</code>
  <code class="n">lookup</code> <code class="n">s</code> <code class="s">"unknown"</code> <code class="o">&gt;&gt;=</code> <code class="n">print</code></pre>
<p id="conc-mvar_00000066">We should see the following:</p>
<pre class="screen" id="conc-mvar_00000067">$ ./phonebook
Just "999"
Nothing</pre>
<p id="conc-mvar_00000068">This example illustrates an important principle for managing state in
Concurrent Haskell programs. We can take <span class="emphasis"><em>any</em></span> pure immutable data
structure such as <code class="literal">Map</code> and turn it into mutable shared state by simply
wrapping it in an <code class="literal">MVar</code>.</p>
<p id="conc-mvar_00000069">Using <a id="id431984" class="indexterm"></a><a id="id431993" class="indexterm"></a>immutable data structures in a mutable wrapper has further
benefits. Note that in the <code class="literal">lookup</code> operation, we simply grabbed the
current value of the state and then the complex <code class="literal">Map.lookup</code>
operation takes place outside of the <code class="literal">takeMVar</code>/<code class="literal">putMVar</code> sequence.
This is good for concurrency, because it means the lock is
held only for a very short time.  This is possible only because the
value of the state is immutable. If the data structure were mutable, we
would have to hold the lock while operating on it.<a href="#ftn.id432027" class="footnote"><sup class="footnote" id="id432027">[30]</sup></a></p>
<p id="conc-mvar_00000070">The effect of <a id="id432037" class="indexterm"></a><a id="id432045" class="indexterm"></a>lazy evaluation here is important to understand.
The <code class="literal">insert</code> operation had this line:</p>
<pre class="programlisting" data-language="haskell" id="putmvar_m_map">  <code class="n">putMVar</code> <code class="n">m</code> <code class="p">(</code><code class="kt">Map</code><code class="o">.</code><code class="n">insert</code> <code class="n">name</code> <code class="n">number</code> <code class="n">book</code><code class="p">)</code></pre>
<p id="conc-mvar_00000072">This places in the <code class="literal">MVar</code> the <span class="emphasis"><em>unevaluated</em></span> expression <code class="literal">Map.insert name
number book</code>.  There are both good and bad consequences to this.  The
benefit is that we don’t have to wait for <code class="literal">Map.insert</code> to finish
before we can unlock the state; as in <code class="literal">lookup</code>, the state is only
locked very briefly.  However, if we were to do many <code class="literal">insert</code>
operations consecutively, the <code class="literal">MVar</code> would build up a large chain of
unevaluated expressions, which could create a space leak. As an alternative, we might try:</p>
<pre class="programlisting" data-language="haskell" id="putmvar_m__ma">  <code class="n">putMVar</code> <code class="n">m</code> <code class="o">$!</code> <code class="kt">Map</code><code class="o">.</code><code class="n">insert</code> <code class="n">name</code> <code class="n">number</code> <code class="n">book</code></pre>
<p id="the__operator">The <code class="literal">$!</code> operator<a id="id432235" class="indexterm"></a><a id="id432241" class="indexterm"></a><a id="id432247" class="indexterm"></a> is like the infix apply operator <code class="literal">$</code>, but it
evaluates the argument strictly before applying the function.  The
effect is to reverse the two consequences of the lazy version noted
previously. Now we hold the lock until <code class="literal">Map.insert</code> has completed, but
there is no risk of a space leak.  To get brief locking <span class="emphasis"><em>and</em></span> no space
leaks, we need to use a trick:</p>
<pre class="programlisting" data-language="haskell" id="let_book__map">  <code class="kr">let</code> <code class="n">book'</code> <code class="ow">=</code> <code class="kt">Map</code><code class="o">.</code><code class="n">insert</code> <code class="n">name</code> <code class="n">number</code> <code class="n">book</code>
  <code class="n">putMVar</code> <code class="n">m</code> <code class="n">book'</code>
  <code class="n">seq</code> <code class="n">book'</code> <code class="p">(</code><code class="n">return</code> <code class="nb">()</code><code class="p">)</code></pre>
<p id="conc-mvar_00000074">With this sequence, we’re storing an unevaluated expression in the
<code class="literal">MVar</code>, but it is evaluated immediately after the <code class="literal">putMVar</code>.  The lock
is held only briefly, but now the thunk is also evaluated so we avoid
building up a long chain of thunks.<a id="id432398" class="indexterm"></a><a id="id432409" class="indexterm"></a><a id="id432419" class="indexterm"></a><a id="id432428" class="indexterm"></a><a id="id432438" class="indexterm"></a><a id="id432448" class="indexterm"></a><a id="id432458" class="indexterm"></a></p>
</div>
<div class="sect1" data-original-filename="ch07_conc-fork-mvar.asciidoc" id="sec_channels">
<div class="titlepage"><div><div><h2 class="title">MVar as a Building Block: Unbounded Channels</h2></div></div></div>
<p id="conc-mvar_00000076"><a id="ix_ch07_conc-fork-mvar-txt21" class="indexterm"></a><a id="ix_Chan" class="indexterm"></a><a id="ix_ch07_conc-fork-mvar-txt22" class="indexterm"></a><a id="ix_ch07_conc-fork-mvar-txt23" class="indexterm"></a><a id="ix_ch07_conc-fork-mvar-txt25" class="indexterm"></a><a id="ix_ch07_conc-fork-mvar-txt26" class="indexterm"></a>One of the strengths of <code class="literal">MVar</code>s is to provide a useful building block from which larger abstractions can be constructed.  Here, we
will use <code class="literal">MVar</code>s to construct an unbounded buffered channel that supports
the following basic interface:</p>
<pre class="programlisting" data-language="haskell" id="data_chan_a_new"><code class="kr">data</code> <code class="kt">Chan</code> <code class="n">a</code>

<code class="nf">newChan</code>   <code class="ow">::</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">Chan</code> <code class="n">a</code><code class="p">)</code>
<code class="nf">readChan</code>  <code class="ow">::</code> <code class="kt">Chan</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">a</code>
<code class="nf">writeChan</code> <code class="ow">::</code> <code class="kt">Chan</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code></pre>
<p id="conc-mvar_00000079">This channel implementation is available in the Haskell module
<code class="literal">Control.Concurrent.Chan</code>.  The structure of the implementation is
represented diagrammatically in <a class="xref" href="ch07.html#fig_channels" title="Figure 7-1. Structure of the buffered channel implementation">Figure 7-1</a>, where each bold box
represents an <code class="literal">MVar</code> and the lighter boxes are ordinary Haskell data
structures.</p>
<div class="figure" id="fig_channels">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0701.png" alt="Structure of the buffered channel implementation"></div></div>
<div class="figure-title">Figure 7-1. Structure of the buffered channel implementation</div>
</div>
<p id="conc-mvar_00000080">The current contents of the channel are represented as a <code class="literal">Stream</code>,
defined like this:</p>
<p id="conc-mvar_00000081" class="caption"><span class="emphasis"><em>chan.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="type_stream_a_"><code class="kr">type</code> <code class="kt">Stream</code> <code class="n">a</code> <code class="ow">=</code> <code class="kt">MVar</code> <code class="p">(</code><code class="kt">Item</code> <code class="n">a</code><code class="p">)</code>
<code class="kr">data</code> <code class="kt">Item</code> <code class="n">a</code>   <code class="ow">=</code> <code class="kt">Item</code> <code class="n">a</code> <code class="p">(</code><code class="kt">Stream</code> <code class="n">a</code><code class="p">)</code></pre>
<p id="conc-mvar_00000082">A <code class="literal">Stream</code> represents<a id="id432916" class="indexterm"></a> the sequence of values currently stored in the
channel.  Each element is an <code class="literal">MVar</code> containing an <code class="literal">Item</code>, which
contains the value and the rest of the <code class="literal">Stream</code>.  The end of the
<code class="literal">Stream</code> is represented by an empty <code class="literal">MVar</code> called the <span class="emphasis"><em>hole</em></span>, into
which the next value to be written to the channel will be placed.</p>
<p id="conc-mvar_00000083">The channel needs to track both ends of the <code class="literal">Stream</code>, because values
read from the channel are taken from the beginning, and values written
are added to the end.  Hence a channel consists of two pointers<a id="id432972" class="indexterm"></a><a id="id432980" class="indexterm"></a><a id="id432986" class="indexterm"></a> called
the <span class="emphasis"><em>read</em></span> and the <span class="emphasis"><em>write</em></span> pointer, respectively, both represented by
<code class="literal">MVar</code>s:</p>
<pre class="programlisting" data-language="haskell" id="data_chan_a__c"><code class="kr">data</code> <code class="kt">Chan</code> <code class="n">a</code>
 <code class="ow">=</code> <code class="kt">Chan</code> <code class="p">(</code><code class="kt">MVar</code> <code class="p">(</code><code class="kt">Stream</code> <code class="n">a</code><code class="p">))</code>
        <code class="p">(</code><code class="kt">MVar</code> <code class="p">(</code><code class="kt">Stream</code> <code class="n">a</code><code class="p">))</code></pre>
<p id="conc-mvar_00000085">The read pointer always points to the next item to be read from the
channel, and the write pointer points to the <span class="emphasis"><em>hole</em></span> into which the
next item written will be placed.</p>
<p id="conc-mvar_00000086">To construct<a id="id433120" class="indexterm"></a> a new channel, we must first create an empty <code class="literal">Stream</code>, which
is just a single empty <code class="literal">MVar</code>, and then the <code class="literal">Chan</code> constructor with
<code class="literal">MVar</code>s for the read and write ends, both pointing to the empty
<code class="literal">Stream</code>:</p>
<pre class="programlisting" data-language="haskell" id="newchan__io_"><code class="nf">newChan</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">Chan</code> <code class="n">a</code><code class="p">)</code>
<code class="nf">newChan</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">hole</code>  <code class="ow">&lt;-</code> <code class="n">newEmptyMVar</code>
  <code class="n">readVar</code>  <code class="ow">&lt;-</code> <code class="n">newMVar</code> <code class="n">hole</code>
  <code class="n">writeVar</code> <code class="ow">&lt;-</code> <code class="n">newMVar</code> <code class="n">hole</code>
  <code class="n">return</code> <code class="p">(</code><code class="kt">Chan</code> <code class="n">readVar</code> <code class="n">writeVar</code><code class="p">)</code></pre>
<p id="conc-mvar_00000088">To add a <a id="id433321" class="indexterm"></a>new element to the channel we must make an <code class="literal">Item</code> with a new
hole, fill in the current hole to point to the new item, and adjust
the write-end of the <code class="literal">Chan</code> to point to the new hole:</p>
<pre class="programlisting" data-language="haskell" id="writechan__ch_id1"><code class="nf">writeChan</code> <code class="ow">::</code> <code class="kt">Chan</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">writeChan</code> <code class="p">(</code><code class="kt">Chan</code> <code class="kr">_</code> <code class="n">writeVar</code><code class="p">)</code> <code class="n">val</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">newHole</code> <code class="ow">&lt;-</code> <code class="n">newEmptyMVar</code>
  <code class="n">oldHole</code> <code class="ow">&lt;-</code> <code class="n">takeMVar</code> <code class="n">writeVar</code>
  <code class="n">putMVar</code> <code class="n">oldHole</code> <code class="p">(</code><code class="kt">Item</code> <code class="n">val</code> <code class="n">newHole</code><code class="p">)</code>
  <code class="n">putMVar</code> <code class="n">writeVar</code> <code class="n">newHole</code></pre>
<p id="conc-mvar_00000090">To remove<a id="id433548" class="indexterm"></a> a value from the channel, we must follow the read end of the
<code class="literal">Chan</code> to the first <code class="literal">MVar</code> of the stream, take that <code class="literal">MVar</code> to get the
<code class="literal">Item</code>, adjust the read end to point to the next <code class="literal">MVar</code> in the stream,
and finally return the value stored in the <code class="literal">Item</code>:</p>
<pre class="programlisting" data-language="haskell" id="readchan__cha_id1"><code class="nf">readChan</code> <code class="ow">::</code> <code class="kt">Chan</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">a</code>
<code class="nf">readChan</code> <code class="p">(</code><code class="kt">Chan</code> <code class="n">readVar</code> <code class="kr">_</code><code class="p">)</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">stream</code> <code class="ow">&lt;-</code> <code class="n">takeMVar</code> <code class="n">readVar</code>            <code class="c1">-- </code><span id="readChan-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
  <code class="kt">Item</code> <code class="n">val</code> <code class="n">tail</code> <code class="ow">&lt;-</code> <code class="n">takeMVar</code> <code class="n">stream</code>      <code class="c1">-- </code><span id="readChan-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>
  <code class="n">putMVar</code> <code class="n">readVar</code> <code class="n">tail</code>                  <code class="c1">-- </code><span id="readChan-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span>
  <code class="n">return</code> <code class="n">val</code>
</pre>
<p id="conc-mvar_00000092">Consider what happens if the <a id="id433806" class="indexterm"></a><a id="id433814" class="indexterm"></a>channel is empty.  The first
<code class="literal">takeMVar</code> (<a class="xref" href="ch07.html#readChan-1"><span><img src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1" border="0"></span></a>) will succeed, but the second <code class="literal">takeMVar</code> (<a class="xref" href="ch07.html#readChan-2"><span><img src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2" border="0"></span></a>)
will find an empty hole, and so will block.  When another thread calls
<code class="literal">writeChan</code>, it will fill the hole, allowing the first thread to
complete its <code class="literal">takeMVar</code>, update the read end (<a class="xref" href="ch07.html#readChan-3"><span><img src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3" border="0"></span></a>) and finally
return.</p>
<p id="conc-mvar_00000093">If multiple threads concurrently <a id="id433871" class="indexterm"></a><a id="id433879" class="indexterm"></a>call <code class="literal">readChan</code>, the first one will
successfully call <code class="literal">takeMVar</code> on the read end, but the subsequent
threads will all block at this point until the first thread completes
the operation and updates the read end.  If multiple threads call
<code class="literal">writeChan</code>, a similar thing happens: the write end of the <code class="literal">Chan</code> is
the synchronization point, allowing only one thread at a time to add
an item to the channel.  However, the read and write ends, being
separate <code class="literal">MVar</code>s, allow concurrent <code class="literal">readChan</code> and <code class="literal">writeChan</code>
operations to proceed without interference.</p>
<p id="conc-mvar_00000094">This implementation allows a nice generalization<a id="id433940" class="indexterm"></a> to <span class="emphasis"><em>multicast</em></span>
channels without changing the underlying structure.  The idea is to
add one more operation:</p>
<pre class="programlisting" data-language="haskell" id="dupchan__chan_id1"><code class="nf">dupChan</code> <code class="ow">::</code> <code class="kt">Chan</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">Chan</code> <code class="n">a</code><code class="p">)</code></pre>
<p id="conc-mvar_00000096">This creates a <a id="id434016" class="indexterm"></a><a id="id434024" class="indexterm"></a>duplicate <code class="literal">Chan</code> with the following
semantics:</p>
<div class="itemizedlist" id="conc-mvar_00000098"><ul class="itemizedlist">
<li class="listitem">
The new <code class="literal">Chan</code> begins empty.
</li>
<li class="listitem">
Subsequent writes to either <code class="literal">Chan</code> are read from both; that is,
  reading an item from one <code class="literal">Chan</code> does not remove it from the other.
</li>
</ul></div>
<p id="conc-mvar_00000100">This implementation<a id="id434083" class="indexterm"></a> seems to fit the bill:</p>
<pre class="programlisting" data-language="haskell" id="dupchan__chan_id2"><code class="nf">dupChan</code> <code class="ow">::</code> <code class="kt">Chan</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="p">(</code><code class="kt">Chan</code> <code class="n">a</code><code class="p">)</code>
<code class="nf">dupChan</code> <code class="p">(</code><code class="kt">Chan</code> <code class="kr">_</code> <code class="n">writeVar</code><code class="p">)</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">hole</code> <code class="ow">&lt;-</code> <code class="n">readMVar</code> <code class="n">writeVar</code>
  <code class="n">newReadVar</code> <code class="ow">&lt;-</code> <code class="n">newMVar</code> <code class="n">hole</code>
  <code class="n">return</code> <code class="p">(</code><code class="kt">Chan</code> <code class="n">newReadVar</code> <code class="n">writeVar</code><code class="p">)</code></pre>
<p id="im_using_readm">I’m using <code class="literal">readMVar</code> here, which is defined thus:<a href="#ftn.id434281" class="footnote"><sup class="footnote" id="id434281">[31]</sup></a></p>
<pre class="programlisting" data-language="haskell" id="readmvar__mva_id1"><code class="nf">readMVar</code> <code class="ow">::</code> <code class="kt">MVar</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">a</code>
<code class="nf">readMVar</code> <code class="n">m</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">a</code> <code class="ow">&lt;-</code> <code class="n">takeMVar</code> <code class="n">m</code>
  <code class="n">putMVar</code> <code class="n">m</code> <code class="n">a</code>
  <code class="n">return</code> <code class="n">a</code></pre>
<p id="conc-mvar_00000102">After a <code class="literal">dupChan</code>, we have two channels that share a single <code class="literal">writeVar</code>, so items written to one
channel will appear in both.  However, the channels have separate
<code class="literal">readVar</code>s, so reading an item from one of the channels will not
cause the item to be removed from the other channel.</p>
<p id="conc-mvar_00000103">Sadly, this implementation of <code class="literal">dupChan</code> does not work.  Can you see
the problem?  The definition of <code class="literal">dupChan</code> itself is not at fault, but
combined with the definition of <code class="literal">readChan</code> given earlier, it does not
implement the required semantics.  The problem is that <code class="literal">readChan</code> does
not replace the contents of a hole after having read it, so if
<code class="literal">readChan</code> is called to read values from both the channel returned by
<code class="literal">dupChan</code> and the original channel, the second call will block.  The fix is to change a
<code class="literal">takeMVar</code> to <code class="literal">readMVar</code> in the implementation of <code class="literal">readChan</code>:</p>
<p id="conc-mvar_00000104" class="caption"><span class="emphasis"><em>chan2.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="readchan__cha_id2"><code class="nf">readChan</code> <code class="ow">::</code> <code class="kt">Chan</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">a</code>
<code class="nf">readChan</code> <code class="p">(</code><code class="kt">Chan</code> <code class="n">readVar</code> <code class="kr">_</code><code class="p">)</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">stream</code> <code class="ow">&lt;-</code> <code class="n">takeMVar</code> <code class="n">readVar</code>
  <code class="kt">Item</code> <code class="n">val</code> <code class="n">tail</code> <code class="ow">&lt;-</code> <code class="n">readMVar</code> <code class="n">stream</code>      <code class="c1">-- </code><span id="CO28-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
  <code class="n">putMVar</code> <code class="n">readVar</code> <code class="n">tail</code>
  <code class="n">return</code> <code class="n">val</code></pre>
<div class="calloutlist" id="conc-mvar_00000105"><table style="border: 0; "><tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO28-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="returns_the_ite">
Returns the <code class="literal">Item</code> back to the <code class="literal">Stream</code>, where it can
be read by any duplicate channels created by <code class="literal">dupChan</code>.
</p></td>
</tr></table></div>
<p id="conc-mvar_00000106">Before we leave the topic of channels, consider one more extension to
the interface that was described as an “easy extension” and left as
an exercise in the original paper on Concurrent Haskell:</p>
<pre class="programlisting" data-language="haskell" id="ungetchan__ch_id1"><code class="nf">unGetChan</code> <code class="ow">::</code> <code class="kt">Chan</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code></pre>
<p id="conc-mvar_00000108">The <a id="id434796" class="indexterm"></a><a id="id434804" class="indexterm"></a>operation <code class="literal">unGetChan</code> pushes a value back on the read
end of the channel.  Leaving aside for a moment the fact that the
interface does not allow the atomic combination of <code class="literal">readChan</code> and
<code class="literal">unGetChan</code> (which would appear to be an important use case), let us
consider how to implement <code class="literal">unGetChan</code>.  The straightforward
implementation is as <span class="keep-together">follows</span>:</p>
<pre class="programlisting" data-language="haskell" id="ungetchan__ch_id2"><code class="nf">unGetChan</code> <code class="ow">::</code> <code class="kt">Chan</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">unGetChan</code> <code class="p">(</code><code class="kt">Chan</code> <code class="n">readVar</code> <code class="kr">_</code><code class="p">)</code> <code class="n">val</code> <code class="ow">=</code> <code class="kr">do</code>
  <code class="n">newReadEnd</code> <code class="ow">&lt;-</code> <code class="n">newEmptyMVar</code>             <code class="c1">-- </code><span id="CO29-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
  <code class="n">readEnd</code> <code class="ow">&lt;-</code> <code class="n">takeMVar</code> <code class="n">readVar</code>            <code class="c1">-- </code><span id="CO29-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>
  <code class="n">putMVar</code> <code class="n">newReadEnd</code> <code class="p">(</code><code class="kt">Item</code> <code class="n">val</code> <code class="n">readEnd</code><code class="p">)</code>  <code class="c1">-- </code><span id="CO29-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span>
  <code class="n">putMVar</code> <code class="n">readVar</code> <code class="n">newReadEnd</code>             <code class="c1">-- </code><span id="CO29-4"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span></pre>
<div class="calloutlist" id="conc-mvar_00000110"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO29-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="creates_a_new_h">
Creates a new hole to place at the front of the <code class="literal">Stream</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO29-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="takes_the_curre">
Takes the current read end, giving us the current front of the stream.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO29-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="places_a_new_it">
Places a new <code class="literal">Item</code> in the new hole.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO29-4"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="replaces_the_re">
Replaces the read end with a pointer to our new item.
</p></td>
</tr>
</table></div>
<p id="conc-mvar_00000111">Simple testing will confirm that the implementation works.  <a id="id435146" class="indexterm"></a><a id="id435154" class="indexterm"></a><a id="id435162" class="indexterm"></a>However, consider what happens when the channel is empty, a <code class="literal">readChan</code> is already waiting in a blocked state, and another thread calls <code class="literal">unGetChan</code>.  The desired
semantics is that <code class="literal">unGetChan</code> succeeds, and <code class="literal">readChan</code> should return
with the new element.  What actually happens in this case is deadlock. The thread blocked in <code class="literal">readChan</code> will be holding the read end <code class="literal">MVar</code>,
and so <code class="literal">unGetChan</code> will also block in <code class="literal">takeMVar</code> trying to take the read
end.  There is no known implementation of <code class="literal">unGetChan</code> based on this representation of <code class="literal">Chan</code> that has the desired semantics.</p>
<p id="conc-mvar_00000112">The lesson here is that programming larger structures with <code class="literal">MVar</code> can
be much trickier than it appears.  As we shall see shortly, life gets
even more difficult when we consider exceptions.  Fortunately there is
an alternative to <code class="literal">MVar</code> that avoids some of these problems, which we
will describe in <a class="xref" href="ch10.html" title="Chapter 10. Software Transactional Memory">Chapter 10</a>.</p>
<p id="conc-mvar_00000113">Despite the difficulties with scaling <code class="literal">MVar</code>s up to larger
abstractions, <code class="literal">MVar</code>s do have some nice properties, as we shall see in
the next section.<a id="id435277" class="indexterm"></a><a id="id435286" class="indexterm"></a><a id="id435297" class="indexterm"></a><a id="id435307" class="indexterm"></a><a id="id435317" class="indexterm"></a><a id="id435327" class="indexterm"></a><a id="id435336" class="indexterm"></a><a id="id435347" class="indexterm"></a><a id="id435357" class="indexterm"></a></p>
</div>
<div class="sect1" data-original-filename="ch07_conc-fork-mvar.asciidoc" id="sec_fairness">
<div class="titlepage"><div><div><h2 class="title">Fairness</h2></div></div></div>
<p id="conc-mvar_00000115"><a id="ix_ch07_conc-fork-mvar-txt27" class="indexterm"></a><a id="ix_ch07_conc-fork-mvar-txt28" class="indexterm"></a><a id="ix_ch07_conc-fork-mvar-txt29" class="indexterm"></a><a id="ix_ch07_conc-fork-mvar-txt30" class="indexterm"></a><a id="ix_ch07_conc-fork-mvar-txt31" class="indexterm"></a>We would like our concurrent programs to be executed with some degree
of <span class="emphasis"><em>fairness</em></span>.  At the very least, no thread should be starved of CPU
time indefinitely, and ideally each thread should be given an equal
share of the CPU.</p>
<p id="ghc_uses_a_simp">GHC uses a simple <a id="id435467" class="indexterm"></a>round-robin scheduler.  It does guarantee that no
thread is starved indefinitely, although it does not ensure that every
thread gets an exactly equal share of the CPU.  In practice, though,
the scheduler is reasonably fair in this respect.  The <code class="literal">MVar</code>
implementation also provides an important fairness guarantee:</p>
<p id="conc-mvar_00000116"><span class="emphasis"><em>No thread can be blocked indefinitely on an <code class="literal">MVar</code> unless another
thread holds that <code class="literal">MVar</code> indefinitely.</em></span></p>
<p id="conc-mvar_00000117">In other words, if a thread <em class="replaceable"><code>T</code></em> is
blocked in <code class="literal">takeMVar</code> and there are regular <code class="literal">putMVar</code> operations on
the same <code class="literal">MVar</code>, it is guaranteed that at some point thread
<em class="replaceable"><code>T</code></em>'s <code class="literal">takeMVar</code> will return.  In GHC,
this guarantee is implemented by keeping blocked threads in a FIFO
queue attached to the <code class="literal">MVar</code>, so eventually every thread in the queue
will get to complete its operation as long as there are other threads
performing regular <code class="literal">putMVar</code> operations (an equivalent guarantee
applies to threads blocked in <code class="literal">putMVar</code> when there are regular
<code class="literal">takeMVar</code>s).  Note <a id="id435567" class="indexterm"></a><a id="id435575" class="indexterm"></a>that it is not enough to merely <span class="emphasis"><em>wake up</em></span> the
blocked thread because another thread might run first and take
(respectively put) the <code class="literal">MVar</code>, causing the newly woken thread to go to
the back of the queue again, which would invalidate the fairness
guarantee.  The implementation must therefore wake up the blocked
thread <span class="emphasis"><em>and</em></span> perform the blocked operation in a single atomic step,
which is exactly what GHC does.</p>
<p id="conc-mvar_00000118">Recall our example from the beginning of <a class="xref" href="ch07.html" title="Chapter 7. Basic Concurrency: Threads and MVars">Chapter 7</a> where we had
two threads, one printing <code class="literal">A</code>s and the other printing <code class="literal">B</code>s, and
the output was sometimes a perfect alternation between the two:
<code class="literal">ABABABABABABABAB</code>.  This is an example of the fairness guarantee in
practice.  The <code class="literal">stdout</code> handle is represented by an <code class="literal">MVar</code>, so when
both threads attempt to call <code class="literal">takeMVar</code> to operate on the handle, one
of them wins and the other becomes blocked.  When the winning thread
completes its operation and calls <code class="literal">putMVar</code>, the scheduler wakes up
the blocked thread <span class="emphasis"><em>and</em></span> completes its blocked <code class="literal">takeMVar</code>, so the
original winning thread will immediately block when it tries to
reacquire the handle.  Hence this leads to perfect alternation
between the two threads.  The only way that the alternation pattern
can be broken is if one thread is descheduled while it is not holding
the <code class="literal">MVar</code>. Indeed, this does happen from time to time as a result of
preemption, and we see the occasional long string of a single letter
in the output. Currently, GHC doesn’t try to avoid getting
into this situation, but it is possible that in the future it might
implement a tweak to the scheduling policy, perhaps by yielding the
CPU immediately after unblocking another thread.</p>
<p id="conc-mvar_00000120">A consequence of the fairness implementation is that, when multiple
threads are blocked in <code class="literal">takeMVar</code> and another thread does a <code class="literal">putMVar</code>,
<span class="emphasis"><em>only one of the blocked threads becomes unblocked</em></span>.  This<a id="id435715" class="indexterm"></a> "single
wakeup" property is a particularly important performance characteristic
when a large number of threads are contending for a single <code class="literal">MVar</code>.  As
we shall see later, it is the fairness guarantee—together with the
single wakeup property—that keeps <code class="literal">MVar</code>s from being completely
subsumed by software transactional memory.<a id="id435737" class="indexterm"></a><a id="id435748" class="indexterm"></a><a id="id435758" class="indexterm"></a><a id="id435768" class="indexterm"></a><a id="id435777" class="indexterm"></a><a id="id435787" class="indexterm"></a></p>
</div>
<div class="footnotes">
<br><hr style="width: 100; align: left;">
<div id="ftn.id427024" class="footnote"><p><a href="#id427024" class="simpara"><sup class="simpara">[26] </sup></a>The length of the time slice is typically 1/50 of a second, but it can be set manually; the options for doing this will be discussed later in <a class="xref" href="ch15.html#sec_rts-options" title="RTS Options to Tweak">“RTS Options to Tweak”</a>.</p></div>
<div id="ftn.id427111" class="footnote"><p><a href="#id427111" class="simpara"><sup class="simpara">[27] </sup></a>We regret that the audio functionality is
available only on certain platforms.</p></div>
<div id="ftn.id429002" class="footnote"><p><a href="#id429002" class="simpara"><sup class="simpara">[28] </sup></a>It works perfectly
well the other way around, too; just be sure to be consistent about
the policy.</p></div>
<div id="ftn.id430902" class="footnote"><p><a href="#id430902" class="simpara"><sup class="simpara">[29] </sup></a>It is worth noting that while <code class="literal">MVar</code> is somewhat easier to use than locks in an imperative language, some of the same problems that plague locks also affect <code class="literal">MVar</code>, such as the potential to cause accidental deadlock by taking locks in the wrong order.  Fortunately, there are solutions to these problems, which we will discuss in <a class="xref" href="ch10.html" title="Chapter 10. Software Transactional Memory">Chapter 10</a>.</p></div>
<div id="ftn.id432027" class="footnote"><p><a href="#id432027" class="simpara"><sup class="simpara">[30] </sup></a>The other option is to use a
lock-free algorithm, which is enormously complex and difficult to get
right.</p></div>
<div id="ftn.id434281" class="footnote"><p><a href="#id434281" class="simpara"><sup class="simpara">[31] </sup></a><code class="literal">readMVar</code>
is a standard operation provided by the <code class="literal">Control.Concurrent</code> module.</p></div>
</div></section><footer><div class="navfooter">
<hr>
<table style="width: 100%; ">
<tr>
<td style="width: 40%; text-align: left; ">
<a accesskey="p" href="pt02.html">Prev</a> </td>
<td style="width: 20%; text-align: center; "><a accesskey="u" href="pt02.html">Up</a></td>
<td style="width: 40%; text-align: right; "> <a accesskey="n" href="ch08.html">Next</a>
</td>
</tr>
<tr>
<td style="width: 40%; text-align: left; vertical-align: top; ">Part II. Concurrent Haskell </td>
<td style="width: 20%; text-align: center; "><a accesskey="h" href="index.html">Home</a></td>
<td style="width: 40%; text-align: right; vertical-align: top; "> Chapter 8. Overlapping Input/Output</td>
</tr>
</table>
</div></footer>


	<div class="extra-footer">
		<p>© 2013, O’Reilly Media, Inc.</p>
		<ul>
			<li><a href="http://oreilly.com/terms/">Terms of Service</a></li>
			<li><a href="http://oreilly.com/oreilly/privacy.csp">Privacy Policy</a></li>
			<li>Interested in <a href="mailto:scordesse@oreilly.com">sponsoring content?</a></li>
		</ul>
	</div>
<script type="text/javascript">if (!NREUMQ.f) { NREUMQ.f=function() {
NREUMQ.push(["load",new Date().getTime()]);
var e=document.createElement("script");
e.type="text/javascript";
e.src=(("http:"===document.location.protocol)?"http:":"https:") + "//" +
  "js-agent.newrelic.com/nr-100.js";
document.body.appendChild(e);
if(NREUMQ.a)NREUMQ.a();
};
NREUMQ.a=window.onload;window.onload=NREUMQ.f;
};
NREUMQ.push(["nrfj","bam.nr-data.net","3e361aebcf","2194180","IApbRUBZXg1WEEoHDAwORh5aQl8N",119,28,new Date().getTime(),"","","","",""]);</script></body>

<!-- Mirrored from chimera.labs.oreilly.com/books/1230000000929/ch07.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 19 Dec 2016 21:57:12 GMT -->
</html>