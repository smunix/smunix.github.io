<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<!-- Mirrored from chimera.labs.oreilly.com/books/1230000000929/ch05.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 18 Dec 2016 14:08:49 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head><script type="text/javascript">var NREUMQ=NREUMQ||[];NREUMQ.push(["mark","firstbyte",new Date().getTime()]);</script>
	<title>Parallel and Concurrent Programming in Haskell</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link href="http://dwn0odqttrkhc.cloudfront.net/assets/book-f1caceafd9c9f3a6ff72d40c54d173ab.css" media="screen" rel="stylesheet" type="text/css" />
	<link href="http://dwn0odqttrkhc.cloudfront.net/assets/default-24583441b4f47382b8932338cd56ed23.css" media="screen" rel="stylesheet" type="text/css" />
	<script src="http://dwn0odqttrkhc.cloudfront.net/assets/application-47d6ffb0c77b868d29a43eb65e940505.js" type="text/javascript"></script>
	<script src="http://dwn0odqttrkhc.cloudfront.net/assets/book-756862b9ed04d945ca53de5b8f106a83.js" type="text/javascript"></script>
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	<link href="http://dwn0odqttrkhc.cloudfront.net/assets/janrain-53eb5abed55992e21943b9d3373923e8.css" media="all" rel="stylesheet" type="text/css" />
	<meta content="authenticity_token" name="csrf-param" />
<meta content="WQ02oEFDbvBG99rmf8rwvGssMqcy27cCD64yZVVTcMY=" name="csrf-token" />
	<script type="text/javascript" charset="utf-8">
  	
		app.data = new classes.Data({"controller":{"controller":"books","action":"html"},"capturable":{"capture_server":"https://oreilly.janraincapture.com","client_id":"6n5q2k9vesqgn93k3mhevka6c3c3rsre","app_url":"https://login.oreilly.com","app_id":"xsnca5wmqe9vxv97ygh5vfejkd","load_js":"d16s8pqtk4uodx.cloudfront.net/login.oreilly.com/load.js"},"user":{"id":null,"account":"LoggedOutAccount","email":"","name":null,"gravatar_url":"http://www.gravatar.com/avatar/d41d8cd98f00b204e9800998ecf8427e?s=40&d=identicon"},"book":{"isbn":"1230000000929","chapter":"ch05.html","toc_url":"/books/1230000000929/toc_html","metadata_url":"http://d4bb7yl96lyl1.cloudfront.net/1230000000929/metadata/metadata_9b2ac4d71a3220a7d463d8d4c80f9113048bb194.json"},"abilities":{"can_destroy_all_comments":false,"can_create_comments":false},"advertisement":{"body":"<style>      \r\n.ad-profile-image {\r\n  padding: 0;\r\n  margin: 0;\r\n  max-height: 30px;\r\n }\r\n\r\n.top-banner {\r\n  position: absolute;\r\n  right: 0;\r\n  top: 34px;\r\n  z-index: 99999;\r\n}\r\n\r\np.banner-text {\r\n  margin: 0;\r\n  text-align: center;\r\n  padding-right: 10px;\r\n  width: 450px;\r\n}\r\n\r\n@media screen and (max-width: 600px) {\r\n   p.banner-text {\r\n     width: 100%;\r\n     text-align: center;\r\n  }\r\n}\r\n\r\nspan.ebook-advantage {\r\n  font-size: smaller;\r\n  display: block;\r\n}\r\n\r\ndiv.banner-container {\r\n  margin: 0 auto;\r\n}\r\n\r\ndiv.banner-container ul {\r\n  margin: 0 auto;\r\n}\r\n\r\ndiv.topad { padding-bottom: 5px; }\r\n\r\ndiv.banner-container ul li {\r\n  display: inline-block;\r\n  vertical-align: middle;\r\n}\r\n\r\ndiv.banner-container li p {\r\n  padding-top: 0;\r\n  margin-top: 0;\r\n}\r\n\r\ndiv.banner-container li.sponsor {\r\n  border-right: 1px solid rgb(125, 154, 180);\r\n  margin-right: 5px;\r\n  padding-right: 10px;\r\n}\r\n\r\ndiv.banner-container .webbutton {\r\n  background-color: #3994b6;\r\n  display: inline-block;\r\n  padding: 10px;\r\n  -webkit-border-radius: 5px;\r\n  -moz-border-radius: 5px;\r\n  border-radius: 5px;\r\n  color: #FFF;\r\n  text-align: center;\r\n  text-decoration: none;\r\n  font-size: 12px;\r\n  font-weight: bold;\r\n}\r\n\r\n</style>\r\n   \r\n<div style=\"color: rgb(125, 154, 180);\">\r\n\r\n<div class=\"banner-container\">\r\n\r\n<ul>\r\n\r\n<li class=\"sponsor\">\r\n<!--CONFERENCE SPONSOR IMAGE-->\r\n<a href=\"http://www.oscon.com/oscon2013\">\r\n<!--<img src=\"http://orm-other.s3.amazonaws.com/fluent_logo.png\" class=\"ad-profile-image\"/>-->\r\n<img src=\"http://orm-other.s3.amazonaws.com/oscon_logo.png\" class=\"ad-profile-image\"/>\r\n<!--<img src=\"http://orm-other.s3.amazonaws.com/strata_logo.png\" class=\"ad-profile-image\"/>\r\n<img src=\"http://orm-other.s3.amazonaws.com/StrataRx_logo.png\" class=\"ad-profile-image\"/>\r\n<img src=\"http://orm-other.s3.amazonaws.com/velocity_logo.png\" class=\"ad-profile-image\"/>-->\r\n</a>\r\n</li>\r\n\r\n<li>\r\n<!--AD TEXT, 2 LINES, REPLACE LINK URL AS WELL-->\r\n<p class=\"banner-text\">Enjoy this online version of <em>Parallel and Concurrent Programming in Haskell</em>. Purchase and download the DRM-free ebook on <a href=\"http://shop.oreilly.com/product/0636920026365.do\">oreilly.com</a>.<span class=\"ebook-advantage\">Learn more about the O’Reilly <a href=\"http://shop.oreilly.com/category/ebooks.do\">Ebook Advantage</a>.</span></p>\r\n</li>\r\n\r\n<li>\r\n<!--BUY BUTTON-->\r\n<a class=\"webbutton\" href=\"http://shop.oreilly.com/product/0636920026365.do\">Buy the Ebook</a>\r\n</li> \r\n\r\n</ul>\r\n\r\n</div>\r\n\r\n<!--CORNER BANNER (IF NEEDED)-->\r\n<!--<a href=\"http://shop.oreilly.com/product/0636920026365.do\" class=\"top-banner\"><img src=\"http://orm-other.s3.amazonaws.com/banner.png\" /></a>-->\r\n\r\n</div>"}});

		/* Janrain setup */
  	var janrainModal = new JanrainView();
  	$("head").append(janrainModal.render().el);

  	/* segment.io setup */
  	var analytics=analytics||[];analytics.load=function(e){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src=("https:"===document.location.protocol?"https://":"http://")+"d2dq2ahtl5zl1z.cloudfront.net/analytics.js/v1/"+e+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(t,n);var r=function(e){return function(){analytics.push([e].concat(Array.prototype.slice.call(arguments,0)))}},i=["identify","track","trackLink","trackForm","trackClick","trackSubmit","pageview","ab","alias","ready"];for(var s=0;s<i.length;s++)analytics[i[s]]=r(i[s])};
  	
  	analytics.load("hg9h6b9pae");

  	$(function() {
			app.bookapp = new BookApp();
		});
	
	</script>
</head>
<body>
	<div id="menu">
	
		<ul id="menu-left">
			<li id="home-link"><a href="http://chimera.labs.oreilly.com/"><i class="icon-house"></i></a></li>
			<li><a href="http://chimera.labs.oreilly.com/books/1230000000929">Parallel and Concurrent Programming in Haskell</a></li>
			<div class="clear"></div>
		</ul>
	
		<ul id="menu-right">
			<li id="comments-link"><a>&nbsp;</a></li>
			<li>
				<a href="#" class="dropdown-toggle" data-toggle="dropdown">Chapters</a>
				<div id="toc-popup" class="dropdown-menu"></div>
			</li>
				<li><a href="#" class="capture_modal_open" id="capture_signin_link">Log In / Sign Up</a></li>
			<li id="search-li">
				<form accept-charset="UTF-8" action="http://chimera.labs.oreilly.com/searches" id="search-form" method="get"><div style="margin:0;padding:0;display:inline"><input name="utf8" type="hidden" value="&#x2713;" /></div>
	<input name='search[q]' type="text" placeholder="Search book..." id="book-search" />

	<input id="search_bookId" name="search[bookId]" type="hidden" value="1230000000929" />
	
	<div style='display:none'>
		sorted by: 
		<select name='search[sort]' >
			<option value='relevance'>Relevance</option>
			<option value='authors'>Author(s)</option>
			<option value='title'>Title</option>
		</select>
		returning
		<select name='search[limit]' >
			<option value='5'>5</option>
			<option value='10'>10</option>
			<option value='20'>20</option>
			<option selected="selected" value='50'>50</option>
			<option value='100'>100</option>
		</select>
		values at a time.
	</div>
</form>
			</li>
			<div class="clear"></div>
		</ul>
		<div class="clear"></div>
	
</div>
	<header><div class="navheader">
<table style="width: 100%; ">
<tr><td style="text-align: center; " colspan="3">Chapter 5. Data Parallel Programming with Repa</td></tr>
<tr>
<td style="width: 20%; text-align: left; ">
<a accesskey="p" href="ch04.html">Prev</a> </td>
<td style="width: 60%; text-align: center; ">Part I. Parallel Haskell</td>
<td style="width: 20%; text-align: right; "> <a accesskey="n" href="ch06.html">Next</a>
</td>
</tr>
</table>
<hr>
</div></header><section class="chapter" data-original-filename="ch05_par-repa.asciidoc" id="sec_par-repa"><div class="titlepage"><div><div><h2 class="title">Chapter 5. Data Parallel Programming with Repa</h2></div></div></div>
<p id="repathe_techniq"><a id="ix_ch05_par-repa-txt0" class="indexterm"></a>The techniques we’ve seen in the previous chapters are great for
parallelizing code that uses ordinary Haskell data structures like
lists and <code class="literal">Map</code>s, but they don’t work as well for data-parallel
algorithms over large arrays.  That’s because <a id="id405719" class="indexterm"></a><a id="id405727" class="indexterm"></a><a id="id405733" class="indexterm"></a><a id="id405741" class="indexterm"></a>large-scale array
computations demand very good raw sequential performance, which we can
get only by operating on arrays of unboxed data.  We can’t use
Strategies to parallelize operations over unboxed arrays, because they
need lazy data structures (boxed arrays would be suitable, but not
unboxed arrays).  Similarly, <code class="literal">Par</code> doesn’t work well here either,
because in <code class="literal">Par</code> the data is passed in <code class="literal">IVar</code>s.</p>
<p id="in_this_chapter_id2">In this chapter, we’re going to see how to write efficient numerical
array computations in Haskell and run them in parallel.  The
library we’re going to use is called <span class="emphasis"><em>Repa</em></span>, which stands for REgular PArallel arrays.<a href="#ftn.id405787" class="footnote"><sup class="footnote" id="id405787">[19]</sup></a>  The library provides a range of efficient operations for creating arrays and operating on
arrays in parallel.</p>
<p id="the_repa_packag">The Repa package is available on Hackage. If you followed the
instructions for installing the sample code dependencies earlier, then
you should already have it, but if not you can install it with <code class="literal">cabal install</code>:</p>
<pre class="screen" id="cabal_install_id1">$ cabal install repa</pre>
<p id="in_this_chapter_id3">In this chapter, I’m going to use GHCi a lot to illustrate the behavior
of Repa; trying things out in GHCi is a great way to become familiar
with the types and operations that Repa provides.  Because Repa
provides many operations with the same names as <code class="literal">Prelude</code> <a id="id405831" class="indexterm"></a>functions
(e.g., <code class="literal">map</code>), we usually import <code class="literal">Data.Array.Repa</code> with a short module
alias:</p>
<pre class="screen" id="import_dataa">&gt; import Data.Array.Repa as Repa</pre>
<p id="this_way_we_ca">This way, we can refer to Repa’s <code class="literal">map</code> function as <code class="literal">Repa.map</code>.</p>
<div class="sect1" data-original-filename="ch05_par-repa.asciidoc" id="sec_par-repa-arrays">
<div class="titlepage"><div><div><h2 class="title">Arrays, Shapes, and Indices</h2></div></div></div>
<p id="arrays_in_repar"><a id="ix_ch05_par-repa-txt1" class="indexterm"></a><a id="ix_ch05_par-repa-txt2" class="indexterm"></a><a id="ix_ch05_par-repa-txt3" class="indexterm"></a><a id="ix_ch05_par-repa-txt4" class="indexterm"></a>Everything in Repa revolves around arrays.  A computation in Repa
typically consists of computing an array in parallel, perhaps using
other arrays as inputs.  So we’ll start by looking at the type of
arrays, how to build them, and how to work with them.</p>
<p id="the_array_type_">The <code class="literal">Array</code> type has three parameters:</p>
<pre class="programlisting" data-language="haskell" id="data_array_r_sh"><code class="kr">data</code> <code class="kt">Array</code> <code class="n">r</code> <code class="n">sh</code> <code class="n">e</code></pre>
<p id="the_e_represent">The <code class="literal">e</code> <a id="id406008" class="indexterm"></a>parameter is the type of the elements, for example <code class="literal">Double</code>, <code class="literal">Int</code>, or
<code class="literal">Word8</code>.  The <code class="literal">r</code> parameter is the <span class="emphasis"><em>representation type</em></span>, which
describes how the array is represented in memory; I’ll come back to
this shortly.  The <code class="literal">sh</code> parameter describes the <span class="emphasis"><em>shape</em></span> of the array;
that is, the number of dimensions it has.</p>
<p id="shapes_are_buil">Shapes are built out of two type <a id="id406063" class="indexterm"></a><a id="id406071" class="indexterm"></a>constructors, <code class="literal">Z</code> and <code class="literal">:.</code>:</p>
<pre class="programlisting" data-language="haskell" id="data_z__z_data_id1"><code class="kr">data</code> <code class="kt">Z</code> <code class="ow">=</code> <code class="kt">Z</code>
<code class="kr">data</code> <code class="n">tail</code> <code class="kt">:.</code> <code class="n">head</code> <code class="ow">=</code> <code class="n">tail</code> <code class="kt">:.</code> <code class="n">head</code></pre>
<p id="the_simplest_sh">The simplest shape, <code class="literal">Z</code>, is the shape of an array with no dimensions (i.e., a
scalar), which has a single element.  If we add a dimension, <code class="literal">Z
:. Int</code>, we get the shape of an array with a single dimension indexed
by <code class="literal">Int</code>, otherwise known as a vector.  Adding another dimension gives
<code class="literal">Z :. Int :. Int</code>, the shape of a two-dimensional array, or matrix.
New dimensions are added on the right, and the <code class="literal">:.</code> operator
associates left, so when we write <code class="literal">Z :. Int :. Int</code>, we really mean
<code class="literal">(Z :. Int) :. Int</code>.</p>
<p id="the_z_and_con">The <code class="literal">Z</code> and<a id="id406223" class="indexterm"></a><a id="id406229" class="indexterm"></a> <code class="literal">:.</code> symbols are both type constructors and value
constructors, which can be a little confusing at times.  For example, the
data value <code class="literal">Z :. 3</code> has type <code class="literal">Z :. Int</code>. The data value form is used
in Repa to mean either “shapes” or "indices." For example, <code class="literal">Z :. 3</code> can be either the shape of three-element vectors, or the index of
the fourth element of a vector (indices count from zero).</p>
<p id="repa_supports_o">Repa supports only <code class="literal">Int</code>-typed indices. A few handy type synonyms are provided for the common shape types:</p>
<pre class="programlisting" data-language="haskell" id="type_dim__z_t_id1"><code class="kr">type</code> <code class="kt">DIM0</code> <code class="ow">=</code> <code class="kt">Z</code>
<code class="kr">type</code> <code class="kt">DIM1</code> <code class="ow">=</code> <code class="kt">DIM0</code> <code class="kt">:.</code> <code class="kt">Int</code>
<code class="kr">type</code> <code class="kt">DIM2</code> <code class="ow">=</code> <code class="kt">DIM1</code> <code class="kt">:.</code> <code class="kt">Int</code></pre>
<p id="lets_try_a_few">Let’s try a few examples.  A simple way to build an array is to use
<code class="literal">fromListUnboxed</code>:</p>
<pre class="programlisting" data-language="haskell" id="fromlistunboxed"><code class="nf">fromListUnboxed</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">Shape</code> <code class="n">sh</code><code class="p">,</code> <code class="kt">Unbox</code> <code class="n">a</code><code class="p">)</code> <code class="ow">=&gt;</code> <code class="n">sh</code> <code class="ow">-&gt;</code> <code class="p">[</code><code class="n">a</code><code class="p">]</code> <code class="ow">-&gt;</code> <code class="kt">Array</code> <code class="kt">U</code> <code class="n">sh</code> <code class="n">a</code></pre>
<p id="the_fromlistunb">The <code class="literal">fromListUnboxed</code> <a id="id406504" class="indexterm"></a><a id="id406510" class="indexterm"></a><a id="id406516" class="indexterm"></a>function takes a shape of type <code class="literal">sh</code> and a list
of elements of type <code class="literal">a</code>, and builds an array of type <code class="literal">Array U sh a</code>.
The <code class="literal">U</code> is the representation and stands for Unboxed: this array will
contain unboxed elements.  Don’t worry about the <code class="literal">Shape</code> and <code class="literal">Unbox</code>
type classes. They are just there to ensure that we use only the
appropriate shape constructors (<code class="literal">Z</code> and <code class="literal">:.</code>) and supported element types, respectively.</p>
<p id="lets_build_a_">Let’s build a 10-element vector of <code class="literal">Int</code> and fill it with the numbers
1…10.  We need to pass a shape argument, which will be <code class="literal">Z:.10</code>
for a 10-element vector:</p>
<pre class="screen" id="fromlistunbox_id1">&gt; fromListUnboxed (Z :. 10) [1..10]

&lt;interactive&gt;:15:1:
    No instance for (Shape (Z :. head0))
      arising from a use of `fromListUnboxed'
    The type variable `head0' is ambiguous
    Possible fix: add a type signature that fixes these type variable(s)
    Note: there is a potential instance available:
      instance Shape sh =&gt; Shape (sh :. Int)
        -- Defined in `Data.Array.Repa.Index'
    Possible fix: add an instance declaration for (Shape (Z :. head0))
    In the expression: fromListUnboxed (Z :. 10) [1 .. 10]
    In an equation for `it': it = fromListUnboxed (Z :. 10) [1 .. 10]</pre>
<p id="oops_this_illu">Oops!  This illustrates something that you will probably encounter a
lot when working with Repa: a type error caused by insufficient type
information.  In this case, the integer <code class="literal">10</code> in <code class="literal">Z :. 10</code> is
overloaded, so we have to say explicitly that we mean <code class="literal">Int</code>.  There
are many ways to give GHC the extra bit of information it needs; one
way is to add a type signature to the whole expression, which has type
<code class="literal">Array U DIM1 Int</code>:</p>
<pre class="screen" id="fromlistunbox_id2">&gt; fromListUnboxed (Z :. 10) [1..10] :: Array U DIM1 Int
AUnboxed (Z :. 10) (fromList [1,2,3,4,5,6,7,8,9,10])</pre>
<p id="similarly_we_c_id1">Similarly, we can make a two-dimensional array, with 3 rows of 5
columns, and fill it with the elements 1 to 15:</p>
<pre class="screen" id="fromlistunbox_id3">&gt; fromListUnboxed (Z :. 3 :. 5) [1..15] :: Array U DIM2 Int
AUnboxed ((Z :. 3) :. 5) (fromList [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15])</pre>
<p id="conceptually_t">Conceptually, the array we created is this:</p>
<div class="informaltable" id="informaltable"><table style="width: 20%; border-collapse: collapse;">
<colgroup>
<col class="col_1">
<col class="col_2">
<col class="col_3">
<col class="col_4">
<col class="col_5">
</colgroup>
<tbody>
<tr>
<td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p id="simpara_id15">1</p></td>
<td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p id="simpara_id16">2</p></td>
<td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p id="simpara_id17">3</p></td>
<td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p id="simpara_id18">4</p></td>
<td style="border-bottom: 0.5pt solid ; "><p id="simpara_id19">5</p></td>
</tr>
<tr>
<td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p id="simpara_id20">6</p></td>
<td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p id="simpara_id21">7</p></td>
<td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p id="simpara_id22">8</p></td>
<td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p id="simpara_id23">9</p></td>
<td style="border-bottom: 0.5pt solid ; "><p id="simpara_id24">10</p></td>
</tr>
<tr>
<td style="border-right: 0.5pt solid ; "><p id="simpara_id25">11</p></td>
<td style="border-right: 0.5pt solid ; "><p id="simpara_id26">12</p></td>
<td style="border-right: 0.5pt solid ; "><p id="simpara_id27">13</p></td>
<td style="border-right: 0.5pt solid ; "><p id="simpara_id28">14</p></td>
<td><p id="simpara_id29">15</p></td>
</tr>
</tbody>
</table></div>
<p id="but_internally">But internally, the array is stored as a single vector (after all,
computer memory is one-dimensional).  We can see the vector in the
result of the call to <code class="literal">fromListUnboxed</code>; it contains the same
elements that we initialized the array with.</p>
<p id="the_shape_of_th">The shape of the array is there to tell Repa how to interpret the
operations on it.  For example, if we ask for the element at index
<code class="literal">Z:.2:.1</code> in an array with shape <code class="literal">Z:.3:.5</code>, we’ll get the element at
position 2 * 5 + 1 in the vector.  We can try it using <a id="id406854" class="indexterm"></a>the <code class="literal">!</code>
operator, which extracts an element from an array.  The type of <code class="literal">!</code>
is:</p>
<pre class="screen" id="_shape_s"><code class="p">(</code><code class="nf">!</code><code class="p">)</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">Shape</code> <code class="n">sh</code><code class="p">,</code> <code class="kt">Source</code> <code class="n">r</code> <code class="n">e</code><code class="p">)</code> <code class="ow">=&gt;</code> <code class="kt">Array</code> <code class="n">r</code> <code class="n">sh</code> <code class="n">e</code> <code class="ow">-&gt;</code> <code class="n">sh</code> <code class="ow">-&gt;</code> <code class="n">e</code></pre>
<p id="lets_get_the_e">Let’s get the element at position <code class="literal">Z:.2:.1</code> from our example matrix:</p>
<pre class="screen" id="let_arr__fro_id1">&gt; let arr = fromListUnboxed (Z :. 3 :. 5) [1..15] :: Array U DIM2 Int
&gt; arr ! (Z:.2:.1)
12</pre>
<p id="the_element__">The element 12 is therefore 2 rows down and 1 column across. As I mentioned earlier, indices count
from zero in Repa.</p>
<p id="internally_rep">Internally, Repa is using the <a id="id407021" class="indexterm"></a>function <code class="literal">toIndex</code> to convert an index
to an <code class="literal">Int</code> offset, given a shape:</p>
<pre class="programlisting" data-language="haskell" id="toindex__shap"><code class="nf">toIndex</code> <code class="ow">::</code> <code class="kt">Shape</code> <code class="n">sh</code> <code class="ow">=&gt;</code> <code class="n">sh</code> <code class="ow">-&gt;</code> <code class="n">sh</code> <code class="ow">-&gt;</code> <code class="kt">Int</code></pre>
<p id="for_example_id1">For example:</p>
<pre class="screen" id="toindex_z">&gt; toIndex (Z:.3:.5 :: DIM2) (Z:.2:.1 :: DIM2)
11</pre>
<p id="because_the_lay">Because the <a id="id407123" class="indexterm"></a>layout of an array in memory is the same regardless of its
shape, we can even change the shape without copying the array:</p>
<pre class="screen" id="reshape_z">&gt; reshape (Z:.5:.3) arr ! (Z:.2:.1 :: DIM2)
8</pre>
<p id="with_the_shape_">With the shape <code class="literal">Z:.5:.3</code>, the index <code class="literal">Z:.2:.1</code> corresponds to the
element at 2 * 3 + 1 = 7, which has value 8.</p>
<p id="here_are_a_coup">Here are a couple of other operations on shapes that often come in handy<a id="id407165" class="indexterm"></a><a id="id407170" class="indexterm"></a><a id="id407176" class="indexterm"></a>:</p>
<pre class="programlisting" data-language="haskell" id="rank__shape_s"><code class="nf">rank</code> <code class="ow">::</code> <code class="kt">Shape</code> <code class="n">sh</code> <code class="ow">=&gt;</code> <code class="n">sh</code> <code class="ow">-&gt;</code> <code class="kt">Int</code>  <code class="c1">-- number of dimensions</code>
<code class="nf">size</code> <code class="ow">::</code> <code class="kt">Shape</code> <code class="n">sh</code> <code class="ow">=&gt;</code> <code class="n">sh</code> <code class="ow">-&gt;</code> <code class="kt">Int</code>  <code class="c1">-- number of elements</code></pre>
<p id="to_retrieve_the">To retrieve the shape of an array, we can use <code class="literal">extent</code>:</p>
<pre class="programlisting" data-language="haskell" id="extent__shap"><code class="nf">extent</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">Shape</code> <code class="n">sh</code><code class="p">,</code> <code class="kt">Source</code> <code class="n">r</code> <code class="n">e</code><code class="p">)</code> <code class="ow">=&gt;</code> <code class="kt">Array</code> <code class="n">r</code> <code class="n">sh</code> <code class="n">e</code> <code class="ow">-&gt;</code> <code class="n">sh</code></pre>
<p id="for_example_id2">For example: <a id="id407400" class="indexterm"></a><a id="id407409" class="indexterm"></a></p>
<pre class="screen" id="extent_arr_z_id2">&gt; extent arr
(Z :. 3) :. 5
&gt; rank (extent arr)
2
&gt; size (extent arr)
15</pre>
</div>
<div class="sect1" data-original-filename="ch05_par-repa.asciidoc" id="sec_par-repa-array-ops">
<div class="titlepage"><div><div><h2 class="title">Operations on Arrays</h2></div></div></div>
<p id="arrays_in_repao"><a id="ix_ch05_par-repa-txt5" class="indexterm"></a>We <a id="ix_ch05_par-repa-txt6" class="indexterm"></a><a id="ix_ch05_par-repa-txt7" class="indexterm"></a>can map a function over an array using Repa’s <code class="literal">map</code> function:</p>
<pre class="screen" id="repamap__sh"><code class="nf">Repa.map</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">Shape</code> <code class="n">sh</code><code class="p">,</code> <code class="kt">Source</code> <code class="n">r</code> <code class="n">a</code><code class="p">)</code>
         <code class="ow">=&gt;</code> <code class="p">(</code><code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">b</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">Array</code> <code class="n">r</code> <code class="n">sh</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">Array</code> <code class="kt">D</code> <code class="n">sh</code> <code class="n">b</code></pre>
<p id="we_can_see_from">We can see from the type that <code class="literal">map</code> returns an array with the
representation <code class="literal">D</code>.  The <code class="literal">D</code> representation stands for Delayed; this
means that the array has not been computed yet.  A <a id="ix_arrays_delayed" class="indexterm"></a><a id="id407668" class="indexterm"></a>delayed array is
represented by a function from indices to elements.</p>
<p id="we_can_apply_ma">We can apply <code class="literal">map</code> to an array, but there’s no way to print out the
result:</p>
<pre class="screen" id="let_a__froml">&gt; let a = fromListUnboxed (Z :. 10) [1..10] :: Array U DIM1 Int
&gt; Repa.map (+1) a

&lt;interactive&gt;:26:1:
    No instance for (Show (Array D DIM1 Int))
      arising from a use of `print'
    Possible fix:
      add an instance declaration for (Show (Array D DIM1 Int))
    In a stmt of an interactive GHCi command: print it</pre>
<p id="as_its_name_sug">As its name suggests, a <a id="id407711" class="indexterm"></a><a id="id407719" class="indexterm"></a>delayed array is not an array <span class="emphasis"><em>yet</em></span>.  To turn
it into an array, we have to call a function that allocates the array
and computes the value of each element.  The <code class="literal">computeS</code> function does
this for us:</p>
<pre class="programlisting" data-language="haskell" id="computes__lo"><code class="nf">computeS</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">Load</code> <code class="n">r1</code> <code class="n">sh</code> <code class="n">e</code><code class="p">,</code> <code class="kt">Target</code> <code class="n">r2</code> <code class="n">e</code><code class="p">)</code> <code class="ow">=&gt;</code> <code class="kt">Array</code> <code class="n">r1</code> <code class="n">sh</code> <code class="n">e</code> <code class="ow">-&gt;</code> <code class="kt">Array</code> <code class="n">r2</code> <code class="n">sh</code> <code class="n">e</code></pre>
<p id="the_argument_to">The argument to <code class="literal">computeS</code> is an array with a representation that is a
member of the <code class="literal">Load</code> class, whereas its result is an array with a
representation that is a member of the <code class="literal">Target</code> class.  The most
important instances of these two classes are <code class="literal">D</code> and <code class="literal">U</code> respectively;
that is, <code class="literal">computeS</code> turns a delayed array into a concrete unboxed
array.<a href="#ftn.id407904" class="footnote"><sup class="footnote" id="id407904">[20]</sup></a>.</p>
<p id="applying_comput">Applying <code class="literal">computeS</code> to the result of <code class="literal">map</code> gives us an <a id="id407933" class="indexterm"></a><a id="id407941" class="indexterm"></a>unboxed array:</p>
<pre class="screen" id="computes_rep_id1">&gt; computeS (Repa.map (+1) a) :: Array U DIM1 Int
AUnboxed (Z :. 10) (fromList [2,3,4,5,6,7,8,9,10,11])</pre>
<p id="you_might_be_wo">You might be wondering why there is this extra complication—why
doesn’t <code class="literal">map</code> just produce a new array?  The answer is that by
representing the result of an array operation as a delayed array, a
sequence of array operations can be performed without ever building
the intermediate arrays; this is an optimization <a id="id407973" class="indexterm"></a>called <span class="emphasis"><em>fusion</em></span>, and
it’s critical to achieving good performance with Repa.  For example,
if we composed two <code class="literal">map</code>s together:</p>
<pre class="screen" id="computes_rep_id2">&gt; computeS (Repa.map (+1) (Repa.map (^2) a)) :: Array U DIM1 Int
AUnboxed (Z :. 10) (fromList [2,5,10,17,26,37,50,65,82,101])</pre>
<p id="the_intermediat">The intermediate array between the two <code class="literal">map</code>s is not built, and in
fact if we compile this rather than running it in GHCi, provided the
optimization option <code class="literal">-O</code> is enabled, it will compile to a single
efficient loop over the input array.</p>
<p id="lets_see_how_i">Let’s see how it works.  The fundamental way to get a <a id="id408027" class="indexterm"></a><a id="id408035" class="indexterm"></a>delayed array is
<code class="literal">fromFunction</code>:</p>
<pre class="programlisting" data-language="haskell" id="fromfunction_"><code class="nf">fromFunction</code> <code class="ow">::</code> <code class="n">sh</code> <code class="ow">-&gt;</code> <code class="p">(</code><code class="n">sh</code> <code class="ow">-&gt;</code> <code class="n">a</code><code class="p">)</code> <code class="ow">-&gt;</code> <code class="kt">Array</code> <code class="kt">D</code> <code class="n">sh</code> <code class="n">a</code></pre>
<p id="the_fromfunctio">The <code class="literal">fromFunction</code> operation creates a delayed array.  It takes the
shape of the array and a function that specifies the elements.  For
example, we can make a delayed array that represents the vector of
integers 0 to 9 like this:</p>
<pre class="screen" id="let_a__fromf">&gt; let a = fromFunction (Z :. 10) (\(Z:.i) -&gt; i :: Int)
&gt; :t a
a :: Array D (Z :. Int) Int</pre>
<p id="delayed_arrays_">Delayed arrays support indexing, just like manifest arrays:</p>
<pre class="screen" id="a__z_">&gt; a ! (Z:.5)
5</pre>
<p id="indexingdelayed">Indexing<a id="id408176" class="indexterm"></a><a id="id408184" class="indexterm"></a> a delayed array works by just calling the function that we
supplied to <code class="literal">fromFunction</code> with the given index.</p>
<p id="we_need_to_appl">We need to apply <code class="literal">computeS</code> to make the delayed array into a <a id="id408212" class="indexterm"></a><a id="id408220" class="indexterm"></a>manifest array:</p>
<pre class="screen" id="computes_a_">&gt; computeS a :: Array U DIM1 Int
AUnboxed (Z :. 10) (fromList [0,1,2,3,4,5,6,7,8,9])</pre>
<p id="the_computes_fu">The <code class="literal">computeS</code> function creates the array and for each of the indices
of the array, it calls the function stored in the delayed array to find
the element at that position.</p>
<p id="the_map_functio">The <code class="literal">map</code> function, along with many other operations on arrays, can be
specified in terms of <code class="literal">fromFunction</code>.  For example, here is a
definition of <code class="literal">map</code>:</p>
<pre class="screen" id="let_mymap_f_a">&gt; let mymap f a = fromFunction (extent a) (\ix -&gt; f (a ! ix))
&gt; :t mymap
mymap
  :: (Shape sh, Source r e) =&gt;
     (e -&gt; a) -&gt; Array r sh e -&gt; Array D sh a</pre>
<p id="it_works_just_l">It works just like the real <code class="literal">map</code>:</p>
<pre class="screen" id="computes_mym">&gt; computeS (mymap (+1) a) :: Array U DIM1 Int
AUnboxed (Z :. 10) (fromList [1,2,3,4,5,6,7,8,9,10])</pre>
<p id="what_happens_if_id1">What happens if we compose two <code class="literal">map</code>s together?  The result would
be a delayed array containing a function that indexes into another
delayed array.  So we’re building up a nested function that defines
the array elements, rather than intermediate arrays.  Furthermore,
Repa is carefully engineered so that at compile time the nested
function call is optimized away as far as possible, yielding very
efficient <a id="id408326" class="indexterm"></a><a id="id408335" class="indexterm"></a><a id="id408345" class="indexterm"></a>code.<a id="id408356" class="indexterm"></a><a id="id408366" class="indexterm"></a><a id="id408376" class="indexterm"></a></p>
</div>
<div class="sect1" data-original-filename="ch05_par-repa.asciidoc" id="sec_par-repa-shortest-paths">
<div class="titlepage"><div><div><h2 class="title">Example: Computing Shortest Paths</h2></div></div></div>
<p id="floydwarshall_"><a id="ix_ch05_par-repa-txt8" class="indexterm"></a><a id="ix_ch05_par-repa-txt9" class="indexterm"></a>In <a class="xref" href="ch04.html#sec_par-monad-shortest-paths" title="Example: Shortest Paths in a Graph">“Example: Shortest Paths in a Graph”</a>, <a id="id408436" class="indexterm"></a><a id="id408443" class="indexterm"></a><a id="id408449" class="indexterm"></a>we looked at an implementation of
the Floyd-Warshall algorithm for computing the lengths of shortest
paths in a sparse weighted directed graph.  Here, we’ll investigate how
to code up the algorithm over <span class="emphasis"><em>dense</em></span> graphs, using Repa.</p>
<p id="for_reference__id1">For reference, here is the <a id="id408472" class="indexterm"></a>pseudocode definition of the algorithm:</p>
<pre class="screen" id="shortestpath__id2">shortestPath :: Graph -&gt; Vertex -&gt; Vertex -&gt; Vertex -&gt; Weight
shortestPath g i j 0 = weight g i j
shortestPath g i j k = min (shortestPath g i j (k-1))
                           (shortestPath g i k (k-1) + shortestPath g k j (k-1))</pre>
<p id="we_implement_th">We implement this by first computing all the shortest paths for <code class="literal">k ==
0</code>, then <code class="literal">k == 1</code>, and so on up to the maximum vertex in the graph.</p>
<p id="for_the_dense_v">For the dense version, we’re going to use an <a id="id408520" class="indexterm"></a>adjacency matrix; that
is, a two-dimensional array indexed by pairs of vertices, where each
element is the length of the path between the two vertices.  Here is
our representation of graphs:</p>
<p id="fwdensehs_co"><span class="emphasis"><em>fwdense.hs</em></span>
</p>
<pre class="programlisting" data-language="haskell" id="type_weight__i_id1"><code class="kr">type</code> <code class="kt">Weight</code> <code class="ow">=</code> <code class="kt">Int</code>
<code class="kr">type</code> <code class="kt">Graph</code> <code class="n">r</code> <code class="ow">=</code> <code class="kt">Array</code> <code class="n">r</code> <code class="kt">DIM2</code> <code class="kt">Weight</code></pre>
<p id="the_implementat_id2">The implementation of the shortest paths algorithm is as follows:</p>
<pre class="programlisting" data-language="haskell" id="shortestpaths__id2"><code class="nf">shortestPaths</code> <code class="ow">::</code> <code class="kt">Graph</code> <code class="kt">U</code> <code class="ow">-&gt;</code> <code class="kt">Graph</code> <code class="kt">U</code>
<code class="nf">shortestPaths</code> <code class="n">g0</code> <code class="ow">=</code> <code class="n">go</code> <code class="n">g0</code> <code class="mi">0</code>                                                <code class="c1">-- </code><span id="CO17-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
  <code class="kr">where</code>
    <code class="kt">Z</code> <code class="kt">:.</code> <code class="kr">_</code> <code class="kt">:.</code> <code class="n">n</code> <code class="ow">=</code> <code class="n">extent</code> <code class="n">g0</code>                                               <code class="c1">-- </code><span id="CO17-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>

    <code class="n">go</code> <code class="o">!</code><code class="n">g</code> <code class="o">!</code><code class="n">k</code> <code class="o">|</code> <code class="n">k</code> <code class="o">==</code> <code class="n">n</code>    <code class="ow">=</code> <code class="n">g</code>                                              <code class="c1">-- </code><span id="CO17-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span>
             <code class="o">|</code> <code class="n">otherwise</code> <code class="ow">=</code>
                 <code class="kr">let</code> <code class="n">g'</code> <code class="ow">=</code> <code class="n">computeS</code> <code class="p">(</code><code class="n">fromFunction</code> <code class="p">(</code><code class="kt">Z:.</code><code class="n">n</code><code class="kt">:.</code><code class="n">n</code><code class="p">)</code> <code class="n">sp</code><code class="p">)</code>            <code class="c1">-- </code><span id="CO17-4"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span>
                 <code class="kr">in</code>  <code class="n">go</code> <code class="n">g'</code> <code class="p">(</code><code class="n">k</code><code class="o">+</code><code class="mi">1</code><code class="p">)</code>                                          <code class="c1">-- </code><span id="CO17-5"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/5.png" alt="5"></span>
     <code class="kr">where</code>
       <code class="n">sp</code> <code class="p">(</code><code class="kt">Z:.</code><code class="n">i</code><code class="kt">:.</code><code class="n">j</code><code class="p">)</code> <code class="ow">=</code> <code class="n">min</code> <code class="p">(</code><code class="n">g</code> <code class="o">!</code> <code class="p">(</code><code class="kt">Z:.</code><code class="n">i</code><code class="kt">:.</code><code class="n">j</code><code class="p">))</code> <code class="p">(</code><code class="n">g</code> <code class="o">!</code> <code class="p">(</code><code class="kt">Z:.</code><code class="n">i</code><code class="kt">:.</code><code class="n">k</code><code class="p">)</code> <code class="o">+</code> <code class="n">g</code> <code class="o">!</code> <code class="p">(</code><code class="kt">Z:.</code><code class="n">k</code><code class="kt">:.</code><code class="n">j</code><code class="p">))</code> <code class="c1">-- </code><span id="CO17-6"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/6.png" alt="6"></span></pre>
<div class="calloutlist"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO17-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_number_of_v">
The number of vertices in the graph, <code class="literal">n</code>, is found by
pattern-matching on the shape of the input graph, which we get by
calling <code class="literal">extent</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO17-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="we_need_to_loop">
We need to loop over the vertices, with <code class="literal">k</code> taking values from 0 up to <code class="literal">n - 1</code>.  This
is done with a local recursive function <code class="literal">go</code>, which takes the current
graph <code class="literal">g</code> and <code class="literal">k</code> as arguments.  The initial value for <code class="literal">g</code> is <code class="literal">g0</code>,
the input graph, and the initial value for <code class="literal">k</code> is 0.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO17-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_first_case_">
The first case in <code class="literal">go</code> applies when we have looped over all the
vertices, and <code class="literal">k == n</code>.  The result is the current graph, <code class="literal">g</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO17-4"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; ">
<p id="here_is_the_int">
Here is the interesting case.  We’re going to build a new adjacency matrix, <code class="literal">g'</code>, for this step <a id="id409286" class="indexterm"></a><a id="id409294" class="indexterm"></a>using <code class="literal">fromFunction</code>.  The shape of the array is <code class="literal">Z:.n:.n</code>, the same as the input, and the function to compute each element is <code class="literal">sp</code> (discussed later).
</p>
<p id="to_manifest_the">To manifest the new graph, we call <code class="literal">computeS</code>.  Do we have to call <code class="literal">computeS</code> for each step, or could we wait until the end?  If we don’t manifest the graph at each step, then we will be calling a nest of <code class="literal">k</code> functions every time we index into the current graph, <code class="literal">g</code>, which is exactly what this dynamic-programming solution seeks to avoid.  So we <span class="emphasis"><em>must</em></span> manifest the graph at each step.</p>
</td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO17-5"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/5.png" alt="5"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="recursively_cal">
Recursively call <code class="literal">go</code> to continue with the next step, passing the
new graph we just computed, <code class="literal">g'</code>, and the next value of <code class="literal">k</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO17-6"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/6.png" alt="6"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_sp_function_id1">
The <code class="literal">sp</code> function computes the value of each element in the new
matrix and is a direct translation of the pseudocode: the shortest
path between <code class="literal">i</code> and <code class="literal">j</code> is the minimum of the current shortest path,
and the shortest path that goes from <code class="literal">i</code> to <code class="literal">k</code> and then to <code class="literal">j</code>, all of
which we get by indexing into the current graph, <code class="literal">g</code>.
</p></td>
</tr>
</table></div>
<p id="the_code_is_qui">The code is quite readable and somewhat shorter than the sparse
version of the algorithm we saw before.  However, there are a couple of subtleties that might not be obvious, but are nevertheless important for making the code run quickly:</p>
<div class="itemizedlist" id="i_deliberately__id1"><ul class="itemizedlist">
<li class="listitem">
I deliberately used an explicit recursive function, <code class="literal">go</code>, rather
  than something like <code class="literal">foldl'</code>, even though the latter would lead to
  shorter code.  The optimizations in Repa work much better when all
  the code is visible to the compiler, and calling out to library
  functions can sometimes hide details from GHC and prevent optimizations.
  There are no hard and fast rules here; I experimented with both the
  explicit version and the <code class="literal">foldl'</code> version, and found the explicit
  loop faster.
</li>
<li class="listitem">
There are bang-patterns on the arguments to <code class="literal">go</code>.  This is good
  practice for iterative loops like this one and helps Repa to
  optimize the loop.
</li>
</ul></div>
<p id="lets_go_ahead_">Let’s go ahead and compile the program and try it out on a 500-vertex
graph:</p>
<pre class="screen" id="ghc_fwdenseh">&gt; ghc fwdense.hs -O2 -fllvm
[1 of 1] Compiling Main             ( fwdense.hs, fwdense.o )
Linking fwdense ...
&gt; ./fwdense 500 +RTS -s
31250125000
   1,077,772,040 bytes allocated in the heap
      31,516,280 bytes copied during GC
      10,334,312 bytes maximum residency (171 sample(s))
       2,079,424 bytes maximum slop
              32 MB total memory in use (3 MB lost due to fragmentation)

                                    Tot time (elapsed)  Avg pause  Max pause
  Gen  0       472 colls,     0 par    0.01s    0.01s     0.0000s    0.0005s
  Gen  1       171 colls,     0 par    0.03s    0.03s     0.0002s    0.0063s

  INIT    time    0.00s  (  0.00s elapsed)
  MUT     time    1.46s  (  1.47s elapsed)
  GC      time    0.04s  (  0.04s elapsed)
  EXIT    time    0.00s  (  0.00s elapsed)
  Total   time    1.50s  (  1.50s elapsed)</pre>
<p id="note_that_i_add">Note that I added a couple of optimization options<a id="id409529" class="indexterm"></a><a id="id409535" class="indexterm"></a><a id="id409541" class="indexterm"></a>: <code class="literal">-O2</code> turns up
GHC’s optimizer, and <code class="literal">-fllvm</code> enables GHC’s LLVM backend, which
significantly improves the performance of Repa code; on my machine
with this particular example, I see a 40% improvement from
<code class="literal">-fllvm</code>.<a href="#ftn.id409568" class="footnote"><sup class="footnote" id="id409568">[21]</sup></a></p>
<div class="sect2" id="sec_par_repa_parallel_sp">
<div class="titlepage"><div><div><h3 class="title">Parallelizing the Program</h3></div></div></div>
<p id="computes_functi"><a id="ix_ch05_par-repa-txt10" class="indexterm"></a><a id="ix_ch05_par-repa-txt12" class="indexterm"></a>Now to make the program run in parallel.  To compute an array in parallel, Repa provides a variant of the <code class="literal">computeS</code> operation, <a id="id409628" class="indexterm"></a>called <code class="literal">computeP</code>:</p>
<pre class="programlisting" data-language="haskell" id="computep__mo"><code class="nf">computeP</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">Monad</code> <code class="n">m</code><code class="p">,</code> <code class="kt">Source</code> <code class="n">r2</code> <code class="n">e</code><code class="p">,</code> <code class="kt">Target</code> <code class="n">r2</code> <code class="n">e</code><code class="p">,</code> <code class="kt">Load</code> <code class="n">r1</code> <code class="n">sh</code> <code class="n">e</code><code class="p">)</code>
         <code class="ow">=&gt;</code> <code class="kt">Array</code> <code class="n">r1</code> <code class="n">sh</code> <code class="n">e</code>
         <code class="ow">-&gt;</code> <code class="n">m</code> <code class="p">(</code><code class="kt">Array</code> <code class="n">r2</code> <code class="n">sh</code> <code class="n">e</code><code class="p">)</code></pre>
<p id="whereas_compute">Whereas <code class="literal">computeS</code> computes an array sequentially, <code class="literal">computeP</code> uses the available cores to compute the array in parallel.  It knows
the size of the array, so it can divide the work equally amongst the
cores.</p>
<p id="the_type_is_alm">The type is almost the same <a id="id409836" class="indexterm"></a>as <code class="literal">computeS</code>, except that <code class="literal">computeP</code>
takes place in a monad. It works with any
monad, and it doesn’t matter which monad is used because the purpose of the monad is only to ensure that <code class="literal">computeP</code>
operations are performed in sequence and not nested.  Hence we need
to modify our code so that the <code class="literal">go</code> function is in a monad, which
entails a few small changes.  Here is the code:</p>
<pre class="programlisting" data-language="haskell" id="shortestpaths__id3"><code class="nf">shortestPaths</code> <code class="ow">::</code> <code class="kt">Graph</code> <code class="kt">U</code> <code class="ow">-&gt;</code> <code class="kt">Graph</code> <code class="kt">U</code>
<code class="nf">shortestPaths</code> <code class="n">g0</code> <code class="ow">=</code> <code class="n">runIdentity</code> <code class="o">$</code> <code class="n">go</code> <code class="n">g0</code> <code class="mi">0</code>                      <code class="c1">-- </code><span id="CO18-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
  <code class="kr">where</code>
    <code class="kt">Z</code> <code class="kt">:.</code> <code class="kr">_</code> <code class="kt">:.</code> <code class="n">n</code> <code class="ow">=</code> <code class="n">extent</code> <code class="n">g0</code>

    <code class="n">go</code> <code class="o">!</code><code class="n">g</code> <code class="o">!</code><code class="n">k</code> <code class="o">|</code> <code class="n">k</code> <code class="o">==</code> <code class="n">n</code>    <code class="ow">=</code> <code class="n">return</code> <code class="n">g</code>                           <code class="c1">-- </code><span id="CO18-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>
             <code class="o">|</code> <code class="n">otherwise</code> <code class="ow">=</code> <code class="kr">do</code>
                 <code class="n">g'</code> <code class="ow">&lt;-</code> <code class="n">computeP</code> <code class="p">(</code><code class="n">fromFunction</code> <code class="p">(</code><code class="kt">Z:.</code><code class="n">n</code><code class="kt">:.</code><code class="n">n</code><code class="p">)</code> <code class="n">sp</code><code class="p">)</code>   <code class="c1">-- </code><span id="CO18-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span>
                 <code class="n">go</code> <code class="n">g'</code> <code class="p">(</code><code class="n">k</code><code class="o">+</code><code class="mi">1</code><code class="p">)</code>
     <code class="kr">where</code>
        <code class="n">sp</code> <code class="p">(</code><code class="kt">Z:.</code><code class="n">i</code><code class="kt">:.</code><code class="n">j</code><code class="p">)</code> <code class="ow">=</code> <code class="n">min</code> <code class="p">(</code><code class="n">g</code> <code class="o">!</code> <code class="p">(</code><code class="kt">Z:.</code><code class="n">i</code><code class="kt">:.</code><code class="n">j</code><code class="p">))</code> <code class="p">(</code><code class="n">g</code> <code class="o">!</code> <code class="p">(</code><code class="kt">Z:.</code><code class="n">i</code><code class="kt">:.</code><code class="n">k</code><code class="p">)</code> <code class="o">+</code> <code class="n">g</code> <code class="o">!</code> <code class="p">(</code><code class="kt">Z:.</code><code class="n">k</code><code class="kt">:.</code><code class="n">j</code><code class="p">))</code></pre>
<div class="calloutlist"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO18-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="we_need_to_use_">
We need to use a monad, so the <code class="literal">Identity</code> monad will do.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO18-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="remember_to_ret">
Remember to <code class="literal">return</code> the result, as we’re now in a monad.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO18-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="instead_of_let_">
Instead of <code class="literal">let</code> to bind <code class="literal">g'</code>, we use <code class="literal">do</code> and monadic bind and
replace <code class="literal">computeS</code> with <code class="literal">computeP</code>.  There are no differences to the
<code class="literal">fromFunction</code> call or the <code class="literal">sp</code> function.
</p></td>
</tr>
</table></div>
<p id="to_run_it_in_pa">To run it in parallel, we’ll need to add <a id="id410482" class="indexterm"></a>the <code class="literal">-threaded</code> option when
compiling.  Let’s see how it performs:</p>
<pre class="screen" id="ghc_o_fwden">&gt; ghc -O2 fwdense1 -threaded -fllvm  -fforce-recomp
[1 of 1] Compiling Main             ( fwdense1.hs, fwdense1.o )
Linking fwdense1 ...
&gt; ./fwdense1 500 +RTS -s
31250125000
...
  Total   time    1.89s  (  1.91s elapsed)</pre>
<p id="theres_some_ov">There’s some overhead for using <code class="literal">computeP</code>, which here seems to be
about 27%.  That’s quite high, but we can recoup it by using more
cores.  With four cores:</p>
<pre class="screen" id="fwdense__id1">&gt; ./fwdense1 500 +RTS -s -N4
31250125000
...
  Total   time    2.15s  (  0.57s elapsed)</pre>
<p id="that_equates_to">That equates to a 2.63 speedup against the sequential version, for
almost zero effort.  Not bad!<a id="id410536" class="indexterm"></a><a id="id410545" class="indexterm"></a><a id="id410555" class="indexterm"></a><a id="id410565" class="indexterm"></a></p>
<div class="sidebar" id="monads_and_computep">
<div class="titlepage"><div><div><div class="sidebar-title">Monads and computeP</div></div></div></div>
<p id="computep_functi"><a id="ix_ch05_par-repa-txt13" class="indexterm"></a><a id="ix_ch05_par-repa-txt14" class="indexterm"></a>Did we really need to thread a monad through the <code class="literal">go</code> function?
Strictly speaking, the answer is no, because you can always replace <code class="literal">computeS</code> with
<code class="literal">(runIdentity . computeP)</code>, but this can lead to trouble.  To
illustrate what can go wrong, let’s compute two arrays with
<code class="literal">computeP</code>, where the second will depend on the first.  The first is
just a vector of <code class="literal">Int</code>:</p>
<pre class="screen" id="let_arr__fro_id2">&gt; let arr = fromFunction (Z:.5) (\(Z:.i) -&gt; i :: Int)
&gt; let parr = runIdentity $ computeP arr :: Array U DIM1 Int</pre>
<p id="and_the_second_">And the second is a copy of the first, using <code class="literal">fromFunction</code> again:</p>
<pre class="screen" id="let_arr__fr">&gt; let arr2 = fromFunction (Z:.5) (\ix -&gt; parr ! ix)</pre>
<p id="now_when_we_tr">Now, when we try to compute the second array using <code class="literal">computeP</code>, we get:</p>
<pre class="screen" id="runidentity_">&gt; runIdentity $ computeP arr2 :: Array U DIM1 Int
Data.Array.Repa: Performing nested parallel computation sequentially.
  You've probably called the 'compute' or 'copy' function while another
  instance was already running. This can happen if the second version
  was suspended due to lazy evaluation. Use 'deepSeqArray' to ensure
  that each array is fully evaluated before you 'compute' the next one.</pre>
<p id="a_call_to_compu">A call to <code class="literal">computeP</code> cannot refer to another array calculated with
<code class="literal">computeP</code>, unless the inner <code class="literal">computeP</code> has already been evaluated.
Here, we didn’t evaluate it; we just bound it with <code class="literal">let</code>, using
<code class="literal">runIdentity</code> to satisfy the <code class="literal">Monad</code> requirement.</p>
<p id="the_monad_requi">The monad requirement in <code class="literal">computeP</code> is there to help us avoid this
problem, because <code class="literal">computeP</code> ensures that the result is fully evaluated
in the monad.  In GHCi, we can use the <code class="literal">IO</code> monad:</p>
<pre class="screen" id="let_arr__fro_id3">&gt; let arr = fromFunction (Z:.5) (\(Z:.i) -&gt; i :: Int)
&gt; parr &lt;- computeP arr :: IO (Array U DIM1 Int)
&gt; let arr2 = fromFunction (Z:.5) (\ix -&gt; parr ! ix)
&gt; computeP arr2 :: IO (Array U DIM1 Int)
AUnboxed (Z :. 5) (fromList [0,1,2,3,4])</pre>
<p id="so_this_is_the_">So this is the rule of thumb: if your program makes multiple calls to
<code class="literal">computeP</code>, try to ensure that they are performed in the same monad.<a id="id410792" class="indexterm"></a><a id="id410802" class="indexterm"></a></p>
</div>
</div>
</div>
<div class="sect1" data-original-filename="ch05_par-repa.asciidoc" id="_folding_and_shape_polymorphism">
<div class="titlepage"><div><div><h2 class="title">Folding and Shape-Polymorphism</h2></div></div></div>
<p id="arrays_in_repaf"><a id="ix_ch05_par-repa-txt15" class="indexterm"></a><a id="ix_ch05_par-repa-txt16" class="indexterm"></a><a id="ix_ch05_par-repa-txt17" class="indexterm"></a><a id="ix_ch05_par-repa-txt18" class="indexterm"></a><a id="ix_ch05_par-repa-txt19" class="indexterm"></a>Folds<a id="ix_ch05_par-repa-txt20" class="indexterm"></a> are an important class of operations over arrays; they are the
operations that perform a collective operation over all the
elements of an array to produce a single result, such as summing the
array or finding its maximum element.  For example, the <a id="id410914" class="indexterm"></a>function
<code class="literal">sumAllS</code> calculates the sum of all the elements in an array:</p>
<pre class="programlisting" data-language="haskell" id="sumalls__num"><code class="nf">sumAllS</code>
  <code class="ow">::</code> <code class="p">(</code><code class="kt">Num</code> <code class="n">a</code><code class="p">,</code> <code class="kt">Shape</code> <code class="n">sh</code><code class="p">,</code> <code class="kt">Source</code> <code class="n">r</code> <code class="n">a</code><code class="p">,</code> <code class="kt">Unbox</code> <code class="n">a</code><code class="p">,</code> <code class="kt">Elt</code> <code class="n">a</code><code class="p">)</code>
  <code class="ow">=&gt;</code> <code class="kt">Array</code> <code class="n">r</code> <code class="n">sh</code> <code class="n">a</code>
  <code class="ow">-&gt;</code> <code class="n">a</code></pre>
<p id="for_an_array_of">For an array of elements of type <code class="literal">a</code> that supports addition (the <code class="literal">Num</code>
constraint), <code class="literal">sumAllS</code> produces a single result that is the sum of all
the elements:</p>
<pre class="screen" id="let_arr__fro_id4">&gt; let arr = fromListUnboxed (Z :. 10) [1..10] :: Array U DIM1 Int
&gt; sumAllS arr
55</pre>
<p id="but_sometimes_w">But sometimes we don’t want to fold over the whole array. There are
occasions where we need to fold over just one dimension.  For example,
in the shortest paths example, suppose we wanted to take the resulting
matrix of path lengths and find for each vertex the furthest distance
we would have to travel from that vertex to any other vertex in the
graph.</p>
<p id="our_graph_may_h">Our graph may have some nodes that are not connected, and in that case
we represent the distance between them by a special large value called
<code class="literal">inf</code> (the value of <code class="literal">inf</code> doesn’t matter as long as it is larger than
all the path lengths in the graph).  For the purposes of finding the
maximum distance to other nodes, we’ll ignore nodes that are not
reachable and hence have path length <code class="literal">inf</code>.  So the function to
compute the maximum of two path lengths is as follows:</p>
<pre class="programlisting" data-language="haskell" id="maxdistance__"><code class="nf">maxDistance</code> <code class="ow">::</code> <code class="kt">Weight</code> <code class="ow">-&gt;</code> <code class="kt">Weight</code> <code class="ow">-&gt;</code> <code class="kt">Weight</code>
<code class="nf">maxDistance</code> <code class="n">x</code> <code class="n">y</code>
  <code class="o">|</code> <code class="n">x</code> <code class="o">==</code> <code class="n">inf</code>  <code class="ow">=</code> <code class="n">y</code>
  <code class="o">|</code> <code class="n">y</code> <code class="o">==</code> <code class="n">inf</code>  <code class="ow">=</code> <code class="n">x</code>
  <code class="o">|</code> <code class="n">otherwise</code> <code class="ow">=</code> <code class="n">max</code> <code class="n">x</code> <code class="n">y</code></pre>
<p id="now_we_want_to_">Now we want to fold <code class="literal">maxDistance</code> over just one dimension of our
two-dimensional adjacency matrix.  There is a function called <code class="literal">foldS</code>
that does just that; here is its <a id="id411320" class="indexterm"></a><a id="id411328" class="indexterm"></a>type:</p>
<pre class="programlisting" data-language="haskell" id="folds__shape"><code class="nf">foldS</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">Shape</code> <code class="n">sh</code><code class="p">,</code> <code class="kt">Source</code> <code class="n">r</code> <code class="n">a</code><code class="p">,</code> <code class="kt">Elt</code> <code class="n">a</code><code class="p">,</code> <code class="kt">Unbox</code> <code class="n">a</code><code class="p">)</code>
      <code class="ow">=&gt;</code> <code class="p">(</code><code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code><code class="p">)</code>                           <code class="c1">-- </code><span id="CO19-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
      <code class="ow">-&gt;</code> <code class="n">a</code>                                       <code class="c1">-- </code><span id="CO19-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>
      <code class="ow">-&gt;</code> <code class="kt">Array</code> <code class="n">r</code> <code class="p">(</code><code class="n">sh</code> <code class="kt">:.</code> <code class="kt">Int</code><code class="p">)</code> <code class="n">a</code>                   <code class="c1">-- </code><span id="CO19-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span>
      <code class="ow">-&gt;</code> <code class="kt">Array</code> <code class="kt">U</code> <code class="n">sh</code> <code class="n">a</code>                            <code class="c1">-- </code><span id="CO19-4"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span></pre>
<div class="calloutlist"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO19-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_function_to">
The function to fold.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO19-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_unitary_val">
The unitary value of type <code class="literal">a</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO19-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_input_array">
The input array.  Note that the shape is <code class="literal">(sh :. Int)</code>, which
means that this is an array of some shape <code class="literal">sh</code> with one more
dimension.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO19-4"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_output_arra">
The output array has shape <code class="literal">sh</code>; that is, one dimension fewer
than the input array.  For example, if we pass in an array of shape
<code class="literal">Z:.Int:.Int</code>, <code class="literal">sh</code> is <code class="literal">Z:.Int</code>.  The fold takes place over the
inner dimension of the array, which we normally think of as the
<span class="emphasis"><em>rows</em></span>. Each row is reduced to a single value.
</p></td>
</tr>
</table></div>
<p id="the_fwdensehs_">The <span class="emphasis"><em>fwdense.hs</em></span> program has a small test graph of six vertices:</p>
<pre class="screen" id="extent_testgr">&gt; extent testGraph
(Z :. 6) :. 6</pre>
<p id="if_we_use_folds">If we use <code class="literal">foldS</code> to fold <code class="literal">maxDistance</code> over the matrix of shortest
paths, we obtain the maximum distance from each vertex to any other
vertex:</p>
<pre class="screen" id="folds_maxdist_id1">&gt; foldS maxDistance inf (shortestPaths testGraph)
AUnboxed (Z :. 6) (fromList [20,19,31,18,15,21])</pre>
<p id="and_if_we_fold_">And if we fold once more, we’ll find the longest distance between any
two nodes (for which a path exists) in the graph:</p>
<pre class="screen" id="folds_maxdist_id2">&gt; foldS maxDistance inf (foldS maxDistance inf (shortestPaths testGraph))
AUnboxed Z (fromList [31])</pre>
<p id="note_that_the_r">Note that the result this time is an array with zero dimensions,
otherwise known as a <a id="id411749" class="indexterm"></a>scalar.</p>
<p id="a_function_fold">A function <a id="id411762" class="indexterm"></a>named <code class="literal">foldP</code> allows us to fold in parallel:</p>
<pre class="programlisting" data-language="haskell" id="foldp__shape"><code class="nf">foldP</code> <code class="ow">::</code> <code class="p">(</code><code class="kt">Shape</code> <code class="n">sh</code><code class="p">,</code> <code class="kt">Source</code> <code class="n">r</code> <code class="n">a</code><code class="p">,</code> <code class="kt">Elt</code> <code class="n">a</code><code class="p">,</code> <code class="kt">Unbox</code> <code class="n">a</code><code class="p">,</code> <code class="kt">Monad</code> <code class="n">m</code><code class="p">)</code>
      <code class="ow">=&gt;</code> <code class="p">(</code><code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="n">a</code><code class="p">)</code>
      <code class="ow">-&gt;</code> <code class="n">a</code>
      <code class="ow">-&gt;</code> <code class="kt">Array</code> <code class="n">r</code> <code class="p">(</code><code class="n">sh</code> <code class="kt">:.</code> <code class="kt">Int</code><code class="p">)</code> <code class="n">a</code>
      <code class="ow">-&gt;</code> <code class="n">m</code> <code class="p">(</code><code class="kt">Array</code> <code class="kt">U</code> <code class="n">sh</code> <code class="n">a</code><code class="p">)</code></pre>
<p id="for_the_same_re">For the same reasons as <code class="literal">computeP</code>, <code class="literal">foldP</code> is performed in an
arbitrary monad.  The arguments are the same as for <code class="literal">foldS</code>.</p>
<div class="caution" id="the_function_ar_id1">
<p id="the_function_ar_id2">The function argument used with <code class="literal">foldP</code> must <a id="id412054" class="indexterm"></a>be <span class="emphasis"><em>associative</em></span>.  That
is, the function <code class="literal">f</code> must satisfy <code class="literal">f x (f y z) == f (f x y) z</code>.  This
is because unlike <code class="literal">foldS</code>, <code class="literal">foldP</code> doesn’t necessarily fold the
function over the array elements in strict left-to-right order; it
folds different parts of the array in parallel and then combines the
results from those parts using the folding function.</p>
<p id="note_that_stric">Note that strictly speaking,
although mathematical addition is associative, <a id="id412098" class="indexterm"></a>floating-point addition
is not, due to rounding errors.  However, we tend to ignore this
detail when using <code class="literal">foldP</code> because a small amount of nondeterminism in
the floating point result is normally <a id="id412113" class="indexterm"></a>acceptable.<a id="id412124" class="indexterm"></a><a id="id412134" class="indexterm"></a><a id="id412144" class="indexterm"></a><a id="id412153" class="indexterm"></a><a id="id412162" class="indexterm"></a></p>
</div>
</div>
<div class="sect1" data-original-filename="ch05_par-repa.asciidoc" id="sec_par-repa-image-rotation">
<div class="titlepage"><div><div><h2 class="title">Example: Image Rotation</h2></div></div></div>
<p id="devil_libraryin"><a id="ix_ch05_par-repa-txt21" class="indexterm"></a><a id="ix_ch05_par-repa-txt22" class="indexterm"></a><a id="ix_ch05_par-repa-txt23" class="indexterm"></a><a id="ix_ch05_par-repa-txt24" class="indexterm"></a><a id="ix_ch05_par-repa-txt25" class="indexterm"></a><a id="ix_ch05_par-repa-txt26" class="indexterm"></a>Repa<a id="ix_ch05_par-repa-txt27" class="indexterm"></a> is a great tool for coding image manipulation algorithms, which
tend to be naturally parallel and involve a lot of data.  In this
section, we’ll write a program to rotate an image about its center by a
specified number of degrees.</p>
<p id="for_reading_and">For reading and writing image data, Repa provides an interface to
the <span class="emphasis"><em>DevIL</em></span> library, which is a cross-platform C library for image
manipulation.  <span class="emphasis"><em>DevIL</em></span> supports reading and writing various common
image formats, including PNG and JPG.  The library is wrapped by the
Haskell package <code class="literal">repa-devil</code>, which provides a convenient Haskell API
to <span class="emphasis"><em>DevIL</em></span>.  The two operations we’ll be using <a id="id412326" class="indexterm"></a><a id="id412331" class="indexterm"></a>are <code class="literal">readImage</code> and
<code class="literal">writeImage</code>:</p>
<pre class="programlisting" data-language="haskell" id="readimage__fi"><code class="nf">readImage</code>  <code class="ow">::</code> <code class="kt">FilePath</code> <code class="ow">-&gt;</code> <code class="kt">IL</code> <code class="kt">Image</code>
<code class="nf">writeImage</code> <code class="ow">::</code> <code class="kt">FilePath</code> <code class="ow">-&gt;</code> <code class="kt">Image</code> <code class="ow">-&gt;</code> <code class="kt">IL</code> <code class="nb">()</code></pre>
<p id="where_the_image">Where the <code class="literal">Image</code> type defines various in-memory image
representations:</p>
<pre class="programlisting" data-language="haskell" id="data_image__rg"><code class="kr">data</code> <code class="kt">Image</code>
  <code class="ow">=</code> <code class="kt">RGBA</code> <code class="p">(</code><code class="kt">Array</code> <code class="kt">F</code> <code class="kt">DIM3</code> <code class="kt">Word8</code><code class="p">)</code>
  <code class="o">|</code> <code class="kt">RGB</code>  <code class="p">(</code><code class="kt">Array</code> <code class="kt">F</code> <code class="kt">DIM3</code> <code class="kt">Word8</code><code class="p">)</code>
  <code class="o">|</code> <code class="kt">BGRA</code> <code class="p">(</code><code class="kt">Array</code> <code class="kt">F</code> <code class="kt">DIM3</code> <code class="kt">Word8</code><code class="p">)</code>
  <code class="o">|</code> <code class="kt">BGR</code>  <code class="p">(</code><code class="kt">Array</code> <code class="kt">F</code> <code class="kt">DIM3</code> <code class="kt">Word8</code><code class="p">)</code>
  <code class="o">|</code> <code class="kt">Grey</code> <code class="p">(</code><code class="kt">Array</code> <code class="kt">F</code> <code class="kt">DIM2</code> <code class="kt">Word8</code><code class="p">)</code></pre>
<p id="a_color_image_i">A color image is represented as a three-dimensional array. The first
two dimensions are the <span class="emphasis"><em>Y</em></span> and <span class="emphasis"><em>X</em></span> axes, and the last dimension contains the
three color channels and optionally an alpha channel.  The first four
constructors of <code class="literal">Image</code> correspond to different orderings of the color
channels and the presence or not of an alpha channel.  The last
option, <code class="literal">Grey</code>, is a grayscale image with one byte per pixel.</p>
<p id="which_one_of_th">Which one of these is returned by <code class="literal">readImage</code> depends on the type of
image file being read. For example, a color JPEG image returns
data in <code class="literal">RGB</code> format, but a PNG image returns in <code class="literal">RGBA</code> format.</p>
<p id="you_may_have_no">You may have noticed one unfamiliar aspect to these array types: <a id="id412727" class="indexterm"></a>the
<code class="literal">F</code> representation type.  This indicates that the array data is held
in foreign memory; that is, it was allocated by C code.  Apart from
being allocated by C rather than Haskell, the <code class="literal">F</code>
representation is identical to <code class="literal">U</code>.</p>
<p id="note_that_readi">Note that <code class="literal">readImage</code> and <code class="literal">writeImage</code> are in <a id="id412769" class="indexterm"></a>the <code class="literal">IL</code> monad.  The
purpose of the <code class="literal">IL</code> monad is to ensure that the <span class="emphasis"><em>DevIL</em></span> library
is initialized properly. This is done by <code class="literal">runIL</code>:</p>
<pre class="programlisting" data-language="haskell" id="runil__il_a_"><code class="nf">runIL</code> <code class="ow">::</code> <code class="kt">IL</code> <code class="n">a</code> <code class="ow">-&gt;</code> <code class="kt">IO</code> <code class="n">a</code></pre>
<p id="its_perfectly_">It’s perfectly fine to have multiple calls <a id="id412850" class="indexterm"></a>to <code class="literal">runIL</code>; the library
will be initialized only once.</p>
<p id="our_program_wil">Our program will take three arguments: the number of degrees to rotate
the image by, the input filename, and the output filename, respectively:</p>
<pre class="programlisting" data-language="haskell" id="main__io__m_id3"><code class="nf">main</code> <code class="ow">::</code> <code class="kt">IO</code> <code class="nb">()</code>
<code class="nf">main</code> <code class="ow">=</code> <code class="kr">do</code>
    <code class="p">[</code><code class="n">n</code><code class="p">,</code> <code class="n">f1</code><code class="p">,</code><code class="n">f2</code><code class="p">]</code> <code class="ow">&lt;-</code> <code class="n">getArgs</code>
    <code class="n">runIL</code> <code class="o">$</code> <code class="kr">do</code>
      <code class="p">(</code><code class="kt">RGB</code> <code class="n">v</code><code class="p">)</code> <code class="ow">&lt;-</code> <code class="n">readImage</code> <code class="n">f1</code>                                            <code class="c1">-- </code><span id="CO20-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
      <code class="n">rotated</code> <code class="ow">&lt;-</code> <code class="n">computeP</code> <code class="o">$</code> <code class="n">rotate</code> <code class="p">(</code><code class="n">read</code> <code class="n">n</code><code class="p">)</code> <code class="n">v</code> <code class="ow">::</code> <code class="kt">IL</code> <code class="p">(</code><code class="kt">Array</code> <code class="kt">F</code> <code class="kt">DIM3</code> <code class="kt">Word8</code><code class="p">)</code> <code class="c1">-- </code><span id="CO20-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>
      <code class="n">writeImage</code> <code class="n">f2</code> <code class="p">(</code><code class="kt">RGB</code> <code class="n">rotated</code><code class="p">)</code>                                        <code class="c1">-- </code><span id="CO20-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></pre>
<div class="calloutlist"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO20-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="read_the_image_">
Read the image data from the file <code class="literal">f1</code> (the second command-line argument).
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO20-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_rotate_func">
The <a id="ix_ch05_par-repa-txt28" class="indexterm"></a>function <code class="literal">rotate</code>, which we will define shortly, returns a
delayed array representing the rotated image.  We call <code class="literal">computeP</code> here
to calculate the new array in parallel.  In the earlier examples, we
used <code class="literal">computeP</code> to produce arrays with <code class="literal">U</code> representation, but here
we’re producing an array with <code class="literal">F</code> representation.  This is possible
because <code class="literal">computeP</code> is overloaded on the desired output representation;
this is the purpose of the <code class="literal">Target</code> type class.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO20-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="finally_write_">
Finally, write the new image to the file <code class="literal">f2</code>.
</p></td>
</tr>
</table></div>
<p id="next_well_writ">Next we’ll write the function <code class="literal">rotate</code>, which actually calculates the
rotated image data.  First, we have a decision to make: what should the
size of the rotated image be?  We have the option of producing a
smaller image than the input, and discarding any pixels that fall
outside the boundaries after rotation, or to adjust the image size to
contain the rotated image, and fill in the empty areas with something
else (e.g., black).  I’ll opt, somewhat arbitrarily, to keep the output
image size the same as the input and fill in the empty areas with
black.  Please feel free to modify the program to do something more
sensible.</p>
<pre class="programlisting" data-language="haskell" id="rotate__doubl"><code class="nf">rotate</code> <code class="ow">::</code> <code class="kt">Double</code> <code class="ow">-&gt;</code> <code class="kt">Array</code> <code class="kt">F</code> <code class="kt">DIM3</code> <code class="kt">Word8</code> <code class="ow">-&gt;</code> <code class="kt">Array</code> <code class="kt">D</code> <code class="kt">DIM3</code> <code class="kt">Word8</code>
<code class="nf">rotate</code> <code class="n">deg</code> <code class="n">g</code> <code class="ow">=</code> <code class="n">fromFunction</code> <code class="p">(</code><code class="kt">Z</code> <code class="kt">:.</code> <code class="n">y</code> <code class="kt">:.</code> <code class="n">x</code> <code class="kt">:.</code> <code class="n">k</code><code class="p">)</code> <code class="n">f</code>      <code class="c1">-- </code><span id="CO21-1"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span>
    <code class="kr">where</code>
        <code class="n">sh</code><code class="o">@</code><code class="p">(</code><code class="kt">Z</code> <code class="kt">:.</code> <code class="n">y</code> <code class="kt">:.</code> <code class="n">x</code> <code class="kt">:.</code> <code class="n">k</code><code class="p">)</code>   <code class="ow">=</code> <code class="n">extent</code> <code class="n">g</code>

        <code class="o">!</code><code class="n">theta</code> <code class="ow">=</code> <code class="n">pi</code><code class="o">/</code><code class="mi">180</code> <code class="o">*</code> <code class="n">deg</code>                         <code class="c1">-- </code><span id="CO21-2"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span>

        <code class="o">!</code><code class="n">st</code> <code class="ow">=</code> <code class="n">sin</code> <code class="n">theta</code>                               <code class="c1">-- </code><span id="CO21-3"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span>
        <code class="o">!</code><code class="n">ct</code> <code class="ow">=</code> <code class="n">cos</code> <code class="n">theta</code>

        <code class="o">!</code><code class="n">cy</code> <code class="ow">=</code> <code class="n">fromIntegral</code> <code class="n">y</code> <code class="o">/</code> <code class="mi">2</code> <code class="ow">::</code> <code class="kt">Double</code>            <code class="c1">-- </code><span id="CO21-4"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span>
        <code class="o">!</code><code class="n">cx</code> <code class="ow">=</code> <code class="n">fromIntegral</code> <code class="n">x</code> <code class="o">/</code> <code class="mi">2</code> <code class="ow">::</code> <code class="kt">Double</code>

        <code class="n">f</code> <code class="p">(</code><code class="kt">Z</code> <code class="kt">:.</code> <code class="n">i</code> <code class="kt">:.</code> <code class="n">j</code> <code class="kt">:.</code> <code class="n">k</code><code class="p">)</code>                          <code class="c1">-- </code><span id="CO21-5"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/5.png" alt="5"></span>
          <code class="o">|</code> <code class="n">inShape</code> <code class="n">sh</code> <code class="n">old</code> <code class="ow">=</code> <code class="n">g</code> <code class="o">!</code> <code class="n">old</code>                  <code class="c1">-- </code><span id="CO21-6"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/6.png" alt="6"></span>
          <code class="o">|</code> <code class="n">otherwise</code>      <code class="ow">=</code> <code class="mi">0</code>                        <code class="c1">-- </code><span id="CO21-7"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/7.png" alt="7"></span>
          <code class="kr">where</code>
            <code class="n">fi</code> <code class="ow">=</code> <code class="n">fromIntegral</code> <code class="n">i</code> <code class="o">-</code> <code class="n">cy</code>                  <code class="c1">-- </code><span id="CO21-8"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/8.png" alt="8"></span>
            <code class="n">fj</code> <code class="ow">=</code> <code class="n">fromIntegral</code> <code class="n">j</code> <code class="o">-</code> <code class="n">cx</code>

            <code class="n">i'</code> <code class="ow">=</code> <code class="n">round</code> <code class="p">(</code><code class="n">st</code> <code class="o">*</code> <code class="n">fj</code> <code class="o">+</code> <code class="n">ct</code> <code class="o">*</code> <code class="n">fi</code> <code class="o">+</code> <code class="n">cy</code><code class="p">)</code>       <code class="c1">-- </code><span id="CO21-9"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/9.png" alt="9"></span>
            <code class="n">j'</code> <code class="ow">=</code> <code class="n">round</code> <code class="p">(</code><code class="n">ct</code> <code class="o">*</code> <code class="n">fj</code> <code class="o">-</code> <code class="n">st</code> <code class="o">*</code> <code class="n">fi</code> <code class="o">+</code> <code class="n">cx</code><code class="p">)</code>

            <code class="n">old</code> <code class="ow">=</code> <code class="kt">Z</code> <code class="kt">:.</code> <code class="n">i'</code> <code class="kt">:.</code> <code class="n">j'</code> <code class="kt">:.</code> <code class="n">k</code>                  <code class="c1">-- </code><span id="CO21-10"></span><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/10.png" alt="10"></span></pre>
<p id="the_formula_to_">The formula to <a id="id414188" class="indexterm"></a>rotate a point (<span class="emphasis"><em>x</em></span>,<span class="emphasis"><em>y</em></span>) by an angle θ about the
origin is given by:</p>
<div class="informalequation" id="x__y_sin___"><span class="mathphrase"><span class="emphasis"><em>x</em></span>′ = <span class="emphasis"><em>y</em></span> sin θ + <span class="emphasis"><em>x</em></span> cos θ</span></div>
<div class="informalequation" id="y__y_cos___"><span class="mathphrase"><span class="emphasis"><em>y</em></span>′ = <span class="emphasis"><em>y</em></span> cos θ + <span class="emphasis"><em>x</em></span> sin θ</span></div>
<p id="however_we_wan">However, we want to rotate our image about the center, but the origin
is the upper-left corner.  Hence we need to adjust the points to be
relative to the center of the image before translation and adjust
them back afterward.</p>
<div class="calloutlist"><table style="border: 0; ">
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO21-1"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/1.png" alt="1"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="were_creating_">
We’re creating a delayed array, represented by the function <code class="literal">f</code>.
The dimensions of the array are the same as the input array, which we
get by calling <code class="literal">extent</code> just below.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO21-2"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/2.png" alt="2"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="convert_the_ang">
Convert the angle by which to rotate the image from degrees to radians.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO21-3"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/3.png" alt="3"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="because_well_n">
Because we’ll need the values of <code class="literal">sin theta</code> and <code class="literal">cos theta</code> twice
each, we defined them once here.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO21-4"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/4.png" alt="4"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="cy_and_cx_are_t">
<code class="literal">cy</code> and <code class="literal">cx</code> are the <span class="emphasis"><em>y</em></span>- and <span class="emphasis"><em>x</em></span>-coordinates, respectively, of the
center of the image.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO21-5"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/5.png" alt="5"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="the_function_f">
The function <code class="literal">f</code>, which gives the value of the new image at
position <code class="literal">i</code>, <code class="literal">j</code>, <code class="literal">k</code> (where <code class="literal">k</code> here is between 0 and 2,
corresponding to the RGB color channels).
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO21-6"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/6.png" alt="6"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; ">
<p id="first_we_need_">
First, we need to check whether the <code class="literal">old</code> pixel (the pixel we are
rotating into this position) is within the bounds of the original
image.  The function <code class="literal">inShape</code> does this check for us:
</p>
<pre class="programlisting" data-language="haskell" id="inshape__shap"><code class="nf">inShape</code> <code class="ow">::</code> <code class="kt">Shape</code> <code class="n">sh</code> <code class="ow">=&gt;</code> <code class="n">sh</code> <code class="ow">-&gt;</code> <code class="n">sh</code> <code class="ow">-&gt;</code> <code class="kt">Bool</code></pre>
<p id="if_the_old_pixe">If the <code class="literal">old</code> pixel is within the image, then we return the value at
that position in the old image.</p>
</td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO21-7"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/7.png" alt="7"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="if_the_rotated_">
If the rotated position in the old image is out of bounds,
then we return zero, giving a black pixel at this position in the new
image.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO21-8"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/8.png" alt="8"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="fi_and_fj_are_t">
<code class="literal">fi</code> and <code class="literal">fj</code> are the <span class="emphasis"><em>y</em></span> and <span class="emphasis"><em>x</em></span> values of this point relative to
the center of the image, respectively.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO21-9"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/9.png" alt="9"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="i_and_j_are_t">
<code class="literal">i'</code> and <code class="literal">j'</code> are the coordinates of the pixel in the old image
that will be rotated to this position in the new image, given by the previous
formulae for <code class="literal">st</code> and <code class="literal">ct</code>.
</p></td>
</tr>
<tr>
<td style="width: 5%; vertical-align: top; text-align: left; "><p><a href="#CO21-10"><span><img style="border: 0; " src="http://orm-chimera-prod.s3.amazonaws.com/assets/callouts/10.png" alt="10"></span></a> </p></td>
<td style="vertical-align: top; text-align: left; "><p id="finally_old_is">
Finally, <code class="literal">old</code> is the index of the pixel in the old image.
</p></td>
</tr>
</table></div>
<p id="to_see_the_prog">To see the program working, we first need an image to rotate:
<a class="xref" href="ch05.html#fig_repa_wonky" title="Figure 5-1. Image in need of rotation">Figure 5-1</a>.</p>
<div class="figure" id="fig_repa_wonky">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0501.png" alt="Image in need of rotation"></div></div>
<div class="figure-title">Figure 5-1. Image in need of rotation</div>
</div>
<p id="running_the_pro">Running the program like so results in the straightened image shown in <a class="xref" href="ch05.html#fig_repa_straight" title="Figure 5-2. Straightened image">Figure 5-2</a>:</p>
<pre class="screen" id="rotateimage_id1">$ ./rotateimage 4 wonky.jpg straight.jpg</pre>
<div class="figure" id="fig_repa_straight">
<div class="figure-contents"><div class="mediaobject"><img src="http://orm-chimera-prod.s3.amazonaws.com/1230000000929/images/pcph_0502.png" alt="Straightened image"></div></div>
<div class="figure-title">Figure 5-2. Straightened image</div>
</div>
<p id="lets_check_the">Let’s check the performance of the program:</p>
<pre class="screen" id="rm_straightj">$ rm straight.jpg
$ ./rotateimage 4 wonky.jpg straight.jpg +RTS -s
...
  Total   time    0.69s  (  0.69s elapsed)</pre>
<p id="and_see_how_muc">And see how much we can gain by running it in parallel, on four cores:</p>
<pre class="screen" id="rotateimage_id2">$ ./rotateimage 4 wonky.jpg straight.jpg +RTS -s -N4
...
  Total   time    0.76s  (  0.24s elapsed)</pre>
<p id="the_result_is_a_id2">The result is a speedup of 2.88.  However, this program spends 0.05s of its time
reading and writing the image file (measured by modifying the program
to omit the rotation step), and if we factor this into the results, we
obtain a speedup for the parallel portion of the <a id="id414673" class="indexterm"></a>program <a id="id414683" class="indexterm"></a>of 3.39.</p>
</div>
<div class="sect1" data-original-filename="ch05_par-repa.asciidoc" id="_summary">
<div class="titlepage"><div><div><h2 class="title">Summary</h2></div></div></div>
<p id="repa_provides_a">Repa provides a convenient framework for describing array
operations and has some significant benefits:</p>
<div class="itemizedlist" id="intermediate_ar_id1"><ul class="itemizedlist">
<li class="listitem">
Intermediate arrays are automatically eliminated when array
   operations are composed (<span class="emphasis"><em>fusion</em></span>).
</li>
<li class="listitem">
Operations like <code class="literal">computeP</code> and <code class="literal">foldP</code> automatically parallelize
   using the available cores.
</li>
</ul></div>
<p id="there_are_a_cou">There are a couple of gotchas to bear in mind:</p>
<div class="itemizedlist" id="repa_relies_hea_id1"><ul class="itemizedlist">
<li class="listitem">
Repa relies heavily on GHC’s optimizer and is quite sensitive to
   things like strictness annotations and <code class="literal">INLINE</code> pragmas.  A good
   rule of thumb is to use both of these liberally.  You might also
   need to use simpler code and fewer library functions so that GHC
   can see all of your code and optimize it.<a id="id414773" class="indexterm"></a><a id="id414782" class="indexterm"></a><a id="id414792" class="indexterm"></a><a id="id414801" class="indexterm"></a><a id="id414811" class="indexterm"></a><a id="id414820" class="indexterm"></a>
</li>
<li class="listitem">
Don’t forget to add the <code class="literal">-fllvm</code> option if your computer supports it.
</li>
</ul></div>
<p id="theres_much_mo">There’s much more to Repa that we haven’t covered.  For example,
Repa has support for <a id="id414851" class="indexterm"></a>stencil convolutions: a common class of image-processing algorithms in which a transformation on each pixel is
calculated as some function of the surrounding pixels.  For certain
kinds of stencil functions that are known at compile time, Repa can
generate specialized code that runs extremely fast.</p>
<p id="to_learn_more_">To learn more, take a look at the full
<a class="ulink" href="http://hackage.haskell.org/package/repa" target="_top">Repa documentation on Hackage</a>. <a id="id414873" class="indexterm"></a></p>
</div>
<div class="footnotes">
<br><hr style="width: 100; align: left;">
<div id="ftn.id405787" class="footnote"><p><a href="#id405787" class="simpara"><sup class="simpara">[19] </sup></a>Note that we’re using Repa version 3.2 here; 3.0 had a somewhat different API.</p></div>
<div id="ftn.id407904" class="footnote"><p><a href="#id407904" class="simpara"><sup class="simpara">[20] </sup></a>There are other array representations that aren’t covered in this chapter; for more details, see the Repa <span class="keep-together">documentation</span></p></div>
<div id="ftn.id409568" class="footnote"><p><a href="#id409568" class="simpara"><sup class="simpara">[21] </sup></a>You might not have LLVM installed on your computer, in which case the <code class="literal">-fllvm</code> option will not work.  Don’t worry: Repa works perfectly well without it. The code will just be slower.</p></div>
</div></section><footer><div class="navfooter">
<hr>
<table style="width: 100%; ">
<tr>
<td style="width: 40%; text-align: left; ">
<a accesskey="p" href="ch04.html">Prev</a> </td>
<td style="width: 20%; text-align: center; "><a accesskey="u" href="pt01.html">Up</a></td>
<td style="width: 40%; text-align: right; "> <a accesskey="n" href="ch06.html">Next</a>
</td>
</tr>
<tr>
<td style="width: 40%; text-align: left; vertical-align: top; ">Chapter 4. Dataflow Parallelism: The Par Monad </td>
<td style="width: 20%; text-align: center; "><a accesskey="h" href="index.html">Home</a></td>
<td style="width: 40%; text-align: right; vertical-align: top; "> Chapter 6. GPU Programming with Accelerate</td>
</tr>
</table>
</div></footer>


	<div class="extra-footer">
		<p>© 2013, O’Reilly Media, Inc.</p>
		<ul>
			<li><a href="http://oreilly.com/terms/">Terms of Service</a></li>
			<li><a href="http://oreilly.com/oreilly/privacy.csp">Privacy Policy</a></li>
			<li>Interested in <a href="mailto:scordesse@oreilly.com">sponsoring content?</a></li>
		</ul>
	</div>
<script type="text/javascript">if (!NREUMQ.f) { NREUMQ.f=function() {
NREUMQ.push(["load",new Date().getTime()]);
var e=document.createElement("script");
e.type="text/javascript";
e.src=(("http:"===document.location.protocol)?"http:":"https:") + "//" +
  "js-agent.newrelic.com/nr-100.js";
document.body.appendChild(e);
if(NREUMQ.a)NREUMQ.a();
};
NREUMQ.a=window.onload;window.onload=NREUMQ.f;
};
NREUMQ.push(["nrfj","bam.nr-data.net","3e361aebcf","2194180","IApbRUBZXg1WEEoHDAwORh5aQl8N",3,43,new Date().getTime(),"","","","",""]);</script></body>

<!-- Mirrored from chimera.labs.oreilly.com/books/1230000000929/ch05.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 18 Dec 2016 14:08:49 GMT -->
</html>