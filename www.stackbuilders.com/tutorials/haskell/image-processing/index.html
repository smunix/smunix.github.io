<!DOCTYPE HTML>
<html>

  
<!-- Mirrored from www.stackbuilders.com/tutorials/haskell/image-processing/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 18 Dec 2016 20:18:11 GMT -->
<head>

    <title>
      Image processing with Juicy Pixels and Repa - Tutorials
    </title>

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">

    <meta name="viewport" content="width=device-width,
                                   initial-scale=1.0,
                                   maximum-scale=5.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="uUpeU0Xsc1oiaKwIVW1RnAbHbKozHBAJdd9XA-fJm-k">

    <link rel="shortcut icon" type="image/png" href="http://www.stackbuilders.com/assets/img/favicon.png">

    <link rel="alternate" hreflang="en" href="https://www.stackbuilders.com/tutorials"> <!-- TODO: make this dynamic -->
    <link rel="stylesheet" type="text/css" href="http://www.stackbuilders.com/assets/stylesheets/application.min.css">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Muli">
    <link rel="stylesheet" type="text/css" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="http://www.stackbuilders.com/assets/css/news-page.css">
    <link rel="stylesheet" type="text/css" href="http://www.stackbuilders.com/assets/css/highlight.style.css">

    <link rel="stylesheet" href="https://www.stackbuilders.com/tutorials/stylesheets/tutorials.css">
    <script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','http://www.google-analytics.com/analytics.js','ga');ga('create', 'UA-17522809-1', 'auto');ga('send', 'pageview');</script>
  </head>

  <body itemscope itemtype="http://schema.org/WebPage">

    <div itemprop="mainEntity">
      <nav class="navbar navbar-default navbar-fixed-top
                  navbar--transparent">
        <div class="navbar__header container">
          <div class="row">
            <div itemscope itemtype="http://schema.org/Organization">
              <div class="navbar__header__logo">
                <a class="img-logo" href="http://www.stackbuilders.com/" title="Stack Builders">
                  <img itemprop="image" src="http://www.stackbuilders.com/assets/images/stack-builders-logo-nav-horizontal.svg" alt="Stack Builders logo">
                  <span class="hidden" itemprop="name">
                    Stack Builders
                  </span>
                </a>
                <button class="navbar-toggle" type="button" data-target="#navbarOptions" data-toggle="collapse">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="icon-bar"></span>
                  <span class="icon-bar"></span>
                  <span class="icon-bar"></span>
                </button>
              </div>
              <div class="nav navbar-nav navbar-right"><div class="navbar__header__contact_info">
                  <div class="navbar__header__contact_info__languages">
                    <!-- <a href="//www.stackbuilders.com/es/news/page/1">Español</a> -->
                  </div>
                  <div class="navbar__header__contact_info__phone"><a href="tel:212-686-5870" itemprop="telephone">212 686-5870</a>&nbsp;
                    <i class="fa fa-phone"></i>
                  </div>
                </div>
              </div>
            </div>
            <div class="navbar__links nav navbar-center collapse navbar-collapse" id="navbarOptions" itemprop="breadcrumb">
              <ul class="list-inline">
                <li><a href="http://www.stackbuilders.com/services">Services</a></li>
                <li><a href="http://www.stackbuilders.com/portfolio">Portfolio</a></li>
                <li><a href="http://www.stackbuilders.com/news/page/1">News</a></li>
                <li><a href="https://www.stackbuilders.com/tutorials">Tutorials</a></li>
                <li><a href="http://www.stackbuilders.com/join">Join Us</a></li>
                <li><a href="http://www.stackbuilders.com/contact">Contact</a></li>
                <!-- <li class="navbar__links__contact_info__languages"><a href="//www.stackbuilders.com/es/news/page/1">Español</a></li> -->
              </ul>
            </div>
          </div>
        </div>
      </nav>
    </div>

    <section class="post__hero">
      <div class="container">
        <h1>
          Stack Builders Tutorials
        </h1>
      </div>
    </section>

    <div class="tutorials container">
        <div class="row">
  <div class="tutorial-content">
    <h2>
      Image processing with Juicy Pixels and Repa
    </h2>

    <p>
      First published: June  7, 2016
      
      <br />
      by Mark Karpov
    </p>

    <p>
      Tested with:
      <ul>
        
        <li>
          Resolver:
          <a href="https://www.stackage.org/lts-5.16">
            LTS Haskell 5.16 (ghc-7.10.3)
          </a>
        </li>
        
        
        
        <li>
          Libraries:
          
          <a href="https://hackage.haskell.org/package/JuicyPixels-3.2.7">
            JuicyPixels-3.2.7
          </a>
          
          <a href="https://hackage.haskell.org/package/repa-3.4.0.2">
            repa-3.4.0.2
          </a>
          
        </li>
        
      </ul>
    </p>

    <hr>

    <p>In this tutorial we will learn how to efficiently generate, transform, and process images in Haskell. This sort of task is interesting to solve in a pure functional language, because it's parallel in nature — processing of images requires performing identical manipulations on many pieces of data (pixels). On the other hand, such manipulation cannot be performed efficiently with the help of familiar primitives for parallel Haskell computing (the <code>Eval</code> monad, evaluation strategies, and the <code>Par</code> monad with <code>IVar</code>s) because these rely on laziness which works with boxed data, while for efficient processing of large arrays of numbers it's desirable to use unboxed data.</p>
<p>This tutorial assumes basic knowledge of Haskell, as after reading <a href="../../../../learnyouahaskell.com/index.html">Learn You a Haskell for Great Good</a> or similar books. You don't need to know much more than that, but some unfamiliar terms will show up unavoidably, so if you don't yet understand underlying concepts, it's OK, you still can use the libraries, get the work done, and return to the subtle topics later (I give links for further reading in this article every time some mysterious Haskell concept shows up).</p>
<h2 id="available-libraries">Available libraries</h2>
<p>There are a number of libraries for image processing available in the Haskell ecosystem. Some make use of external tools written in other languages, others are written entirely in Haskell. First, I would like to list libraries that are conventionally used for image processing and manipulation with short descriptions, because we don't have space to cover them all in this tutorial.</p>
<ul>
<li><p><a href="https://hackage.haskell.org/package/JuicyPixels"><code>JuicyPixels</code></a> is a lightweight library written in Haskell that allows to load and save images in various formats. It can be used to convert, generate, and process images. Pixels are packed in unboxed storable vector — no automatic parallel execution, but quite fast for simple tasks. We cover the library in the tutorial.</p></li>
<li><p><a href="https://hackage.haskell.org/package/repa"><code>repa</code></a> stands for “REgular PArallel arrays” and is not specifically tied to image processing, but it's the standard choice when you want to perform calculations on a large collection of numeric data in parallel in Haskell. We cover how to use it for image processing in this tutorial.</p></li>
<li><p><a href="https://hackage.haskell.org/package/friday"><code>friday</code></a> is a powerful and relatively new package that allows to manipulate images and has a good collection of operations already coded for you (like edge detection, cropping, filtering, etc.). Its principles of operation are very similar to those of Repa, so after reading this tutorial you should have good intuition of how to code with <code>friday</code> too. To load images, <a href="https://hackage.haskell.org/package/friday-devil"><code>friday-devil</code></a> is usually used, but note that it requires external <a href="http://openil.sourceforge.net/">DevIL</a> library.</p></li>
<li><p><a href="https://hackage.haskell.org/package/gloss"><code>gloss</code></a> describes itself as “Painless 2D vector graphics, animations and simulations”. Indeed, it can do more than just image editing and there are some nice demos to get you started creating animations and simulations. Note that <code>gloss</code> uses <a href="https://www.opengl.org/">OpenGL</a> under the hood.</p></li>
</ul>
<p>We will use the lightweight library <code>JuicyPixels</code> for reading and writing image files, and <code>repa</code> for efficient processing of numeric data.</p>
<h2 id="juicy-pixels">Juicy Pixels</h2>
<p><code>JuicyPixels</code> is useful on its own if your task does not require parallel computations. Simple things like badge or identicon generation can be done sequentially (the overhead of scheduling parallel execution for small amounts of data can even make sequential execution preferable) and the <code>JuicyPixels</code> API makes them ridiculously simple.</p>
<h3 id="types-and-data-structures-used-in-juicy-pixels">Types and data structures used in Juicy Pixels</h3>
<p>If we quickly glance through the <a href="https://hackage.haskell.org/package/JuicyPixels-3.2.7/docs/Codec-Picture.html"><code>Codec.Picture</code></a> module, its types and functions look really straightforward. The basic type in the module is <a href="https://hackage.haskell.org/package/JuicyPixels-3.2.7/docs/Codec-Picture.html#t:Image"><code>Image</code></a>, which is parametrized by pixel type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Image</span> a <span class="fu">=</span> <span class="dt">Image</span>
    { <span class="co">-- | Width of the image in pixels.</span>
<span class="ot">      imageWidth  ::</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span>
      <span class="co">-- | Height of the image in pixels.</span>
    ,<span class="ot"> imageHeight ::</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span>
      <span class="co">-- | Image pixel data. To extract pixels at a given position</span>
      <span class="co">-- you should use the helper functions.</span>
      <span class="fu">--</span>
      <span class="co">-- Internally pixel data is stored as consecutively packed</span>
      <span class="co">-- lines from top to bottom, scanned from left to right</span>
      <span class="co">-- within individual lines, from first to last color</span>
      <span class="co">-- component within each pixel.</span>
    ,<span class="ot"> imageData   ::</span> <span class="dt">V.Vector</span> (<span class="dt">PixelBaseComponent</span> a)
    }</code></pre></div>
<p>The definition is simple and intuitive: we have the width and height of image and single vector that contains pixel data.</p>
<p><code>!</code> before <code>Int</code> is called a “strictness annotation”. Haskell, being a lazy language (should I have said “the lazy language”?), does not normally evaluate fields inside of a data structure when data constructor itself is evaluated. When only the constructor is evaluated, data is said to be in “weak head normal form” for some obscure historical reason (fully evaluated data is said to be in “normal form”). The <code>!</code> sign says: “Hey, we are all in one boat now, if you evaluate the constructor, evaluate me too”.</p>
<p>Here is how it works. Suppose we have this data type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">MyData</span> <span class="fu">=</span> <span class="dt">MyData</span> <span class="fu">!</span><span class="dt">Int</span> <span class="dt">Int</span></code></pre></div>
<p>One <code>Int</code> has a strictness annotation while the other does not. Load the definition in GHCi and try for yourself:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span> d <span class="fu">=</span> <span class="dt">MyData</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>) (<span class="dv">3</span> <span class="fu">+</span> <span class="dv">4</span>)
λ<span class="fu">&gt;</span> <span class="fu">:</span>sprint d <span class="co">-- :sprint shows what's evaluated and what's not, unevaluated</span>
<span class="co">-- data is shown as underscore ‘_’</span>
d <span class="fu">=</span> _ <span class="co">-- the whole thing is unevaluated</span>
λ<span class="fu">&gt;</span> d <span class="ot">`seq`</span> () <span class="co">-- seq guarantees that both its arguments will be evaluated</span>
<span class="co">-- before it returns a value (which is equal to the second argument unless</span>
<span class="co">-- the first argument is bottom)</span>
()
λ<span class="fu">&gt;</span> <span class="fu">:</span>sprint d
d <span class="fu">=</span> <span class="dt">MyData</span> <span class="dv">3</span> _ <span class="co">-- strictness annotation in action</span></code></pre></div>
<p>Bear with me because these things are important for understanding performance-related issues and design decisions of tools we are talking about.</p>
<p><code>{-# UNPACK #-}</code> is a different story. To make things lazy, Haskell by default represents everything as “boxed” data, that is, it stores a pointer to <code>Int</code> in <code>MyData</code>, not the <code>Int</code> itself:</p>
<div class="figure">
<img src="boxed-data.png" alt="Boxed data in Haskell" />
<p class="caption">Boxed data in Haskell</p>
</div>
<p><a href="https://wiki.haskell.org/Thunk">Thunk</a> is a name for data that hasn't been evaluated yet. When the <code>{-# UNPACK #-}</code> pragma is used, data becomes part of parent structure:</p>
<div class="figure">
<img src="unboxed-data.png" alt="Unboxed data in Haskell" />
<p class="caption">Unboxed data in Haskell</p>
</div>
<p>To do something with the <code>Int</code>s inside, we don't need to de-reference the pointers, which makes things faster. Of course in this case we cannot retain high level of granularity with respect to lazy evaluation and we have to make unboxed data strict. Interestingly, GHC won't let you use <code>{-# UNPACK #-}</code> without strictness annotation saying that it's a parse error.</p>
<p>I explained this in detail because <code>imageData</code> is a <code>Vector</code> of pixels and this vector is unboxed and thus it's not possible to use <a href="../../../../chimera.labs.oreilly.com/books/1230000000929/ch02.html"><code>Eval</code></a> or <a href="../../../../chimera.labs.oreilly.com/books/1230000000929/ch04.html"><code>Par</code></a> to compute different parts of it in parallel. Also, the <code>Vector</code> of pixels is immutable so every time you change it, you create a new vector copying all the data because normal Haskell's mechanisms for sharing data work well only with boxed data. We will return to this when we start talking about Repa and will see how the problem is solved there.</p>
<p>To give the programmer a single image type that represents “just” an image, abstracted from its representation, <code>Image</code> is put into the <code>DynamicImage</code> wrapper:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">DynamicImage</span> <span class="fu">=</span>
       <span class="co">-- | A greyscale image.</span>
       <span class="dt">ImageY8</span>    (<span class="dt">Image</span> <span class="dt">Pixel8</span>)
       <span class="co">-- | A greyscale image with 16bit components</span>
     <span class="fu">|</span> <span class="dt">ImageY16</span>   (<span class="dt">Image</span> <span class="dt">Pixel16</span>)
       <span class="co">-- | A greyscale HDR image</span>
     <span class="fu">|</span> <span class="dt">ImageYF</span>    (<span class="dt">Image</span> <span class="dt">PixelF</span>)
       <span class="co">-- | An image in greyscale with an alpha channel.</span>
     <span class="fu">|</span> <span class="dt">ImageYA8</span>   (<span class="dt">Image</span> <span class="dt">PixelYA8</span>)
      <span class="co">-- | An image in greyscale with alpha channel on 16 bits.</span>
     <span class="fu">|</span> <span class="dt">ImageYA16</span>  (<span class="dt">Image</span> <span class="dt">PixelYA16</span>)
       <span class="co">-- | An image in true color.</span>
     <span class="fu">|</span> <span class="dt">ImageRGB8</span>  (<span class="dt">Image</span> <span class="dt">PixelRGB8</span>)
       <span class="co">-- | An image in true color with 16bit depth.</span>
     <span class="fu">|</span> <span class="dt">ImageRGB16</span> (<span class="dt">Image</span> <span class="dt">PixelRGB16</span>)
       <span class="co">-- | An image with HDR pixels</span>
     <span class="fu">|</span> <span class="dt">ImageRGBF</span>  (<span class="dt">Image</span> <span class="dt">PixelRGBF</span>)
       <span class="co">-- | An image in true color and an alpha channel.</span>
     <span class="fu">|</span> <span class="dt">ImageRGBA8</span> (<span class="dt">Image</span> <span class="dt">PixelRGBA8</span>)
       <span class="co">-- | A true color image with alpha on 16 bits.</span>
     <span class="fu">|</span> <span class="dt">ImageRGBA16</span> (<span class="dt">Image</span> <span class="dt">PixelRGBA16</span>)
       <span class="co">-- | An image in the colorspace used by Jpeg images.</span>
     <span class="fu">|</span> <span class="dt">ImageYCbCr8</span> (<span class="dt">Image</span> <span class="dt">PixelYCbCr8</span>)
       <span class="co">-- | An image in the colorspace CMYK</span>
     <span class="fu">|</span> <span class="dt">ImageCMYK8</span>  (<span class="dt">Image</span> <span class="dt">PixelCMYK8</span>)
       <span class="co">-- | An image in the colorspace CMYK and 16 bits precision</span>
     <span class="fu">|</span> <span class="dt">ImageCMYK16</span> (<span class="dt">Image</span> <span class="dt">PixelCMYK16</span>)</code></pre></div>
<p>Its data constructors are an enumeration of images that correspond to supported pixel types. The result is that we can use the <code>DynamicImage</code> type without caring much about the concrete underlying representation.</p>
<p>Pixels in turn are just a collection of numeric components, for example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">PixelRGB8</span> <span class="fu">=</span> <span class="dt">PixelRGB8</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Word8</span> <span class="co">-- Red</span>
                           <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Word8</span> <span class="co">-- Green</span>
                           <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Word8</span> <span class="co">-- Blue</span>
               <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</code></pre></div>
<p>Many functions from <code>Codec.Picture</code> take or produce <code>DynamicImage</code>. As an example, look at <code>readImage</code>, <code>savePngImage</code>, <code>saveBmpImage</code> and others:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">readImage ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> <span class="dt">DynamicImage</span>)
<span class="ot">saveBmpImage ::</span>        FilePath <span class="ot">-&gt;</span> <span class="dt">DynamicImage</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">saveJpgImage ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">DynamicImage</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">savePngImage ::</span>        FilePath <span class="ot">-&gt;</span> <span class="dt">DynamicImage</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">saveTiffImage ::</span>       FilePath <span class="ot">-&gt;</span> <span class="dt">DynamicImage</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</code></pre></div>
<p><code>saveJpgImage</code> takes an integer specifying desired quality as well. It's time to use this straightforward API for real work.</p>
<h3 id="format-conversion-program">Format conversion program</h3>
<p>We can put together an utility for image format conversion right now! Let's write a console program that takes the format of resulting image as the first argument and the path to source image as second argument. When the program is run, it converts image and saves it changing its extension appropriately.</p>
<p>Try to do it yourself first. Here are the imports and language extensions you will need:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RecordWildCards #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators   #-}</span>

<span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Codec.Picture</span>
<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Control.Monad.ST</span>
<span class="kw">import </span><span class="dt">Data.Array.Repa</span> (<span class="dt">Array</span>, <span class="dt">DIM1</span>, <span class="dt">DIM2</span>, <span class="dt">U</span>, <span class="dt">D</span>, <span class="dt">Z</span> (..), (:.)(..), (!))
<span class="kw">import </span><span class="dt">System.Environment</span> (getArgs)
<span class="kw">import </span><span class="dt">System.FilePath</span> (replaceExtension)
<span class="kw">import qualified</span> <span class="dt">Codec.Picture.Types</span> <span class="kw">as</span> <span class="dt">M</span>
<span class="kw">import qualified</span> <span class="dt">Data.Array.Repa</span>     <span class="kw">as</span> <span class="dt">R</span> <span class="co">-- for Repa</span></code></pre></div>
<p>OK, now we can compare our code:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ImgFormat</span> <span class="fu">=</span> <span class="dt">Bmp</span> <span class="fu">|</span> <span class="dt">Jpg</span> <span class="fu">|</span> <span class="dt">Png</span> <span class="fu">|</span> <span class="dt">Tiff</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  [ext, path] <span class="ot">&lt;-</span> getArgs
  <span class="kw">case</span> fromExt ext <span class="kw">of</span>
    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;Sorry, I don't know such format!&quot;</span>
    <span class="dt">Just</span> fmt <span class="ot">-&gt;</span> convertImg fmt path

convertImg
<span class="ot">  ::</span> <span class="dt">ImgFormat</span>         <span class="co">-- ^ Format of resulting image</span>
  <span class="ot">-&gt;</span> FilePath          <span class="co">-- ^ Where to get source image</span>
  <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
convertImg fmt path <span class="fu">=</span> <span class="kw">do</span>
  eimg <span class="ot">&lt;-</span> readImage path
  <span class="kw">case</span> eimg <span class="kw">of</span>
    <span class="dt">Left</span> err <span class="ot">-&gt;</span> putStrLn (<span class="st">&quot;Could not read image: &quot;</span> <span class="fu">++</span> err)
    <span class="dt">Right</span> img <span class="ot">-&gt;</span>
      (<span class="kw">case</span> fmt <span class="kw">of</span> <span class="co">-- select saving function</span>
        <span class="dt">Bmp</span>  <span class="ot">-&gt;</span> saveBmpImage
        <span class="dt">Jpg</span>  <span class="ot">-&gt;</span> saveJpgImage <span class="dv">100</span>
        <span class="dt">Png</span>  <span class="ot">-&gt;</span> savePngImage
        <span class="dt">Tiff</span> <span class="ot">-&gt;</span> saveTiffImage)
      (replaceExtension path (toExt fmt)) <span class="co">-- replace file extension</span>
      img <span class="co">-- pass it 'DynamicImage' we've read</span>

<span class="co">-- | Get file extension corresponding to known image format.</span>
<span class="ot">toExt ::</span> <span class="dt">ImgFormat</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
toExt <span class="dt">Bmp</span>      <span class="fu">=</span> <span class="st">&quot;bmp&quot;</span>
toExt <span class="dt">Jpg</span>      <span class="fu">=</span> <span class="st">&quot;jpeg&quot;</span>
toExt <span class="dt">Png</span>      <span class="fu">=</span> <span class="st">&quot;png&quot;</span>
toExt <span class="dt">Tiff</span>     <span class="fu">=</span> <span class="st">&quot;tiff&quot;</span>

<span class="co">-- | Get image format corresponding to given extension or 'Nothing' if we</span>
<span class="co">-- don't support that format.</span>
<span class="ot">fromExt ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">ImgFormat</span>
fromExt <span class="st">&quot;bmp&quot;</span>  <span class="fu">=</span> <span class="dt">Just</span> <span class="dt">Bmp</span>
fromExt <span class="st">&quot;jpeg&quot;</span> <span class="fu">=</span> <span class="dt">Just</span> <span class="dt">Jpg</span>
fromExt <span class="st">&quot;png&quot;</span>  <span class="fu">=</span> <span class="dt">Just</span> <span class="dt">Png</span>
fromExt <span class="st">&quot;tiff&quot;</span> <span class="fu">=</span> <span class="dt">Just</span> <span class="dt">Tiff</span>
fromExt _      <span class="fu">=</span> <span class="dt">Nothing</span></code></pre></div>
<p>We just built something useful with almost no effort, but what are our options if we wish to edit or generate an image?</p>
<h3 id="image-rotation">Image rotation</h3>
<p>For processing existing images the <code>pixelMap</code> function can be used:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">pixelMap ::</span> (<span class="dt">Pixel</span> a, <span class="dt">Pixel</span> b) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Image</span> a <span class="ot">-&gt;</span> <span class="dt">Image</span> b</code></pre></div>
<p>With this function you can do something funny with colors, but let it be an exercise for the reader. How about operations that require random access to image's data? An example of such an operation is rotation.</p>
<p>Since type at the base of <code>Image</code> is a storable <code>Vector</code> (immutable, unboxed vector) and the standard technique for efficient vector generation is using its mutable variant, it's no surprise that <code>JuicyPixels</code> provides <code>MutableImage</code> type.</p>
<p>The basic workflow is the same as with vectors:</p>
<ol style="list-style-type: decimal">
<li><p>Allocate memory for a new mutable image (or create it from an immutable one).</p></li>
<li><p>Populate it with right values using mutability.</p></li>
<li><p>“Freeze” it and get your normal <code>Image</code>.</p></li>
</ol>
<p>Let's do it with <code>JuicyPixels</code>. We create new mutable images using one of the following functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Create a mutable image with garbage as content. All data is</span>
<span class="co">-- uninitialized.</span>
<span class="ot">newMutableImage ::</span> (<span class="dt">Pixel</span> px, <span class="dt">PrimMonad</span> m)
  <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="co">-- Width</span>
  <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="co">-- Height</span>
  <span class="ot">-&gt;</span> m (<span class="dt">MutableImage</span> (<span class="dt">PrimState</span> m) px)

<span class="co">-- | Yield a mutable copy of an image by making a copy of it.</span>
<span class="ot">thawImage ::</span> (<span class="dt">Storable</span> (<span class="dt">PixelBaseComponent</span> px), <span class="dt">PrimMonad</span> m)
  <span class="ot">=&gt;</span> <span class="dt">Image</span> px
  <span class="ot">-&gt;</span> m (<span class="dt">MutableImage</span> (<span class="dt">PrimState</span> m) px)</code></pre></div>
<p>Reading and writing are done via <code>readPixel</code> and <code>writePixel</code> (they have unsafe companions but we won't touch them here). <code>freezeImage</code> helps with freezing. Let's put it all together:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  [path, path'] <span class="ot">&lt;-</span> getArgs
  eimg <span class="ot">&lt;-</span> readImage path
  <span class="kw">case</span> eimg <span class="kw">of</span>
    <span class="dt">Left</span> err <span class="ot">-&gt;</span> putStrLn (<span class="st">&quot;Could not read image: &quot;</span> <span class="fu">++</span> err)
    <span class="dt">Right</span> (<span class="dt">ImageRGB8</span> img) <span class="ot">-&gt;</span>
      (savePngImage path' <span class="fu">.</span> <span class="dt">ImageRGB8</span> <span class="fu">.</span> rotateImg) img
    <span class="dt">Right</span> _ <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;Unexpected pixel format&quot;</span>

<span class="ot">rotateImg ::</span> <span class="dt">Image</span> <span class="dt">PixelRGB8</span> <span class="ot">-&gt;</span> <span class="dt">Image</span> <span class="dt">PixelRGB8</span>
rotateImg img<span class="fu">@</span><span class="dt">Image</span> {<span class="fu">..</span>} <span class="fu">=</span> runST <span class="fu">$</span> <span class="kw">do</span>
  mimg <span class="ot">&lt;-</span> M.newMutableImage imageWidth imageHeight
  <span class="kw">let</span> go x y
        <span class="fu">|</span> x <span class="fu">&gt;=</span> imageWidth  <span class="fu">=</span> go <span class="dv">0</span> (y <span class="fu">+</span> <span class="dv">1</span>)
        <span class="fu">|</span> y <span class="fu">&gt;=</span> imageHeight <span class="fu">=</span> M.unsafeFreezeImage mimg
        <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">do</span>
            writePixel mimg
              (imageWidth <span class="fu">-</span> x <span class="fu">-</span> <span class="dv">1</span>)
              (imageHeight <span class="fu">-</span> y <span class="fu">-</span> <span class="dv">1</span>)
              (pixelAt img x y)
            go (x <span class="fu">+</span> <span class="dv">1</span>) y
  go <span class="dv">0</span> <span class="dv">0</span></code></pre></div>
<p>In <code>rotateImg</code>, we run a stateful computation inside the <code>ST</code> monad. You can think about <code>ST</code> monad as an “escapable” <code>IO</code>. References to mutable data cannot escape the <code>ST</code> monad, but pure data can. The <code>ST</code> monad is often used to write functions that manipulate mutable values as long as the result is referentially transparent.</p>
<p>We use <code>unsafeFreezeImage</code> instead of <code>freezeImage</code> to avoid unnecessary copying of data: <code>unsafeFreezeImage</code> re-uses memory occupied by its argument. Since after “freezing” we don't modify <code>mimg</code>, it's a safe thing to do.</p>
<p>As simple as that, we have rotated an image upside down:</p>
<p><img src="before-rotation.png" alt="Before rotation" /> <img src="after-rotation.png" alt="After rotation" /></p>
<p>Here is how our program performs (<code>image-processing</code> is the name of compiled executable):</p>
<pre><code>$ image-processing before-rotation.png after-rotation.png +RTS -s
…
  Total   time    0.238s  (  0.142s elapsed)
…</code></pre>
<p>More information about subtleties of the <code>vector</code> package can be found <a href="https://www.schoolofhaskell.com/user/commercial/content/vector">here</a>.</p>
<h3 id="image-generation">Image generation</h3>
<p>Juicy Pixels provides a couple of useful functions to generate images:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">generateImage ::</span> <span class="dt">Pixel</span> a
  <span class="ot">=&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a)  <span class="co">-- ^ Generating function, with x and y parameters</span>
  <span class="ot">-&gt;</span> <span class="dt">Int</span>                <span class="co">-- ^ Width in pixels</span>
  <span class="ot">-&gt;</span> <span class="dt">Int</span>                <span class="co">-- ^ Height in pixels</span>
  <span class="ot">-&gt;</span> <span class="dt">Image</span> a

<span class="ot">generateFoldImage ::</span> <span class="dt">Pixel</span> a
  <span class="ot">=&gt;</span> (acc <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (acc, a)) <span class="co">-- ^ Function taking the state, x and y</span>
  <span class="ot">-&gt;</span> acc                <span class="co">-- ^ Initial state</span>
  <span class="ot">-&gt;</span> <span class="dt">Int</span>                <span class="co">-- ^ Width in pixels</span>
  <span class="ot">-&gt;</span> <span class="dt">Int</span>                <span class="co">-- ^ Height in pixels</span>
  <span class="ot">-&gt;</span> (acc, <span class="dt">Image</span> a)

<span class="ot">withImage ::</span> (<span class="dt">Pixel</span> a, <span class="dt">PrimMonad</span> m)
  <span class="ot">=&gt;</span> <span class="dt">Int</span>                <span class="co">-- ^ Image width</span>
  <span class="ot">-&gt;</span> <span class="dt">Int</span>                <span class="co">-- ^ Image height</span>
  <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m a) <span class="co">-- ^ Generating function</span>
  <span class="ot">-&gt;</span> m (<span class="dt">Image</span> a)</code></pre></div>
<p>If your image can be expressed as a function from coordinates to pixels, <code>generateImage</code> looks super-simple and straightforward. <code>generateFoldImage</code> allows to pass around an accumulator (i.e. you can have some sort of state). <code>withImage</code> is more interesting: it allows to use function that returns values inside instances of <code>PrimMonad</code>. <code>PrimMonad</code> is outside of scope of this tutorial, but if you are interested you can read about it <a href="https://www.schoolofhaskell.com/user/commercial/content/primitive-haskell">here</a>. Basically, <code>PrimMonad</code> means <code>IO</code> or <code>ST</code> and monad stacks with one of these monads at the bottom.</p>
<p>Let's generate an image using the <code>generateImage</code> function and save it as a PNG file. Here is my attempt:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  [path] <span class="ot">&lt;-</span> getArgs
  savePngImage path generateImg

<span class="ot">generateImg ::</span> <span class="dt">DynamicImage</span>
generateImg <span class="fu">=</span> <span class="dt">ImageRGB8</span> (generateImage originalFnc <span class="dv">1200</span> <span class="dv">1200</span>)

<span class="ot">originalFnc ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">PixelRGB8</span>
originalFnc x y <span class="fu">=</span>
  <span class="kw">let</span> (q, r) <span class="fu">=</span> x <span class="ot">`quotRem`</span> max <span class="dv">10</span> y
      s      <span class="fu">=</span> fromIntegral <span class="fu">.</span> min <span class="bn">0xff</span>
  <span class="kw">in</span> <span class="dt">PixelRGB8</span> (s q) (s r) (s (q <span class="fu">+</span> r <span class="fu">+</span> <span class="dv">30</span>))</code></pre></div>
<div class="figure">
<img src="juicy-pixels-generated-wonder.png" alt="Juicy Pixels' generated image" />
<p class="caption">Juicy Pixels' generated image</p>
</div>
<p>Quite mysterious. Let's measure how our program performs.</p>
<pre><code>$ image-processing my-image.png +RTS -s
…
  Total   time    0.197s  (  0.104s elapsed)
…</code></pre>
<p>Generation of image is not parallel, the library just repeatedly calls the provided function and builds the resulting image from returned results. The performance is not bad at all, but can we do better using multiple cores?</p>
<h2 id="repa">Repa</h2>
<p>Here's where Repa comes into play. Operations on arrays performed in Repa are parallel by default if you compile your program with multi-thread support (the <code>-threaded</code> flag enables that) and run it with <code>+RTS -N</code>.</p>
<p>Do you remember the problem with large unboxed arrays? We certainly cannot afford the creation of a new big immutable array after each operation, so how can we avoid producing intermediate results?</p>
<p>Well, the answer is rather simple. Following the same approach with a function that takes coordinates as argument and returns a pixel, we can just make that single function more complex with help of primitives from functional programming like <code>map</code> but specialized for our purposes. Then we can call it to build the final result never creating intermediate ones.</p>
<p>The final “real” array is called “manifest array” in Repa's terminology, while the function that can be used to generate such real array is called “delayed array”. The trick of never building intermediate results is called “fusion”. This is a popular technique that is also used in the <code>friday</code> package and in the more mundane <code>text</code>.</p>
<h3 id="repa-arrays">Repa Arrays</h3>
<p>Before we can start hacking with Repa, there is one more concept that needs to be explained: the <code>Array</code> type and its shape. <code>Array r sh e</code> type is parametrized over:</p>
<ul>
<li><p>Representation <code>r</code>: there are <a href="https://hackage.haskell.org/package/repa-3.4.0.2/docs/Data-Array-Repa.html">a few options</a> available for that, but in this tutorial we will work only with <code>U</code> (unboxed vector, manifest array), and <code>D</code> (delayed array, function from indices to elements).</p></li>
<li><p>Shape <code>sh</code>: this describes how many dimensions your array has and sizes of these dimensions. Below I show how to work with shapes.</p></li>
<li><p>Element type <code>e</code>: in our case it will be <code>(Pixel8, Pixel8, Pixel8)</code> where <code>Pixel8</code> is just a synonym for <code>Word8</code>, i.e. a byte.</p></li>
</ul>
<p>Shapes are constructed like this: you append dimensions to <code>Z</code> (zero-dimension shape) using <code>:.</code> type operator. The tricky part is that <code>Z</code> and <code>:.</code> live on both type level and term (value) level. For example:</p>
<ul>
<li><p><code>Z :. 3 :. 3</code> is shape of 3 × 3 matrix (<code>Z :. Int :. Int</code> on type level);</p></li>
<li><p><code>Z :. 0 :. 0</code>, <code>Z :. 0 :. 1</code>, <code>Z :. 2 :. 2</code> are examples of indices that can be used to access data in that matrix.</p></li>
</ul>
<p>Positions are numbered from 0, and so <code>Z :. 2 :. 2</code> is bottom right corner of such matrix. In reality, all elements are stored in a flat, one-dimensional vector and shapes just help access right elements. In fact we can re-shape a Repa array without modifying array itself:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span> arr <span class="fu">=</span> R.fromListUnboxed (<span class="dt">Z</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dv">3</span>) [<span class="dv">1</span><span class="fu">..</span><span class="dv">9</span>]<span class="ot"> ::</span> <span class="dt">Array</span> <span class="dt">U</span> <span class="dt">DIM2</span> <span class="dt">Int</span>
<span class="co">-- the API is quite polymorphic, we need to give explicit type hints</span>
λ<span class="fu">&gt;</span> arr
<span class="dt">AUnboxed</span> ((<span class="dt">Z</span> <span class="fu">:.</span> <span class="dv">3</span>) <span class="fu">:.</span> <span class="dv">3</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>]
λ<span class="fu">&gt;</span> arr <span class="fu">!</span> (<span class="dt">Z</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">2</span>)
<span class="dv">9</span>
λ<span class="fu">&gt;</span> arr <span class="fu">!</span> (<span class="dt">Z</span> <span class="fu">:.</span> <span class="dv">0</span> <span class="fu">:.</span> <span class="dv">0</span>)
<span class="dv">1</span>
λ<span class="fu">&gt;</span> arr <span class="fu">!</span> (<span class="dt">Z</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dv">3</span>) <span class="co">-- hmm, what if…</span>
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> <span class="fu">./</span><span class="dt">Data</span><span class="fu">/</span><span class="dt">Vector</span><span class="fu">/</span>Generic.hs<span class="fu">:</span><span class="dv">235</span> ((<span class="fu">!</span>))<span class="fu">:</span> index out <span class="kw">of</span> bounds (<span class="dv">12</span>,<span class="dv">9</span>)
<span class="co">-- uh, oh</span>
λ<span class="fu">&gt;</span> R.reshape (<span class="dt">Z</span> <span class="fu">:.</span> <span class="dv">9</span>) arr <span class="fu">!</span> (<span class="dt">Z</span> <span class="fu">:.</span> <span class="dv">5</span><span class="ot"> ::</span> <span class="dt">DIM1</span>)
<span class="dv">6</span></code></pre></div>
<p>Take a look at Simon Marlow's <a href="../../../../chimera.labs.oreilly.com/books/1230000000929/ch05.html#sec_par-repa-arrays">explanation of Repa shapes and indices</a> for more information.</p>
<h3 id="bridge-from-juicy-pixels-to-repa">Bridge from Juicy Pixels to Repa</h3>
<p>I will use two simple functions to convert between Juicy Pixels representation of pixels and Repa arrays:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">RGB8</span> <span class="fu">=</span> (<span class="dt">Pixel8</span>, <span class="dt">Pixel8</span>, <span class="dt">Pixel8</span>)

<span class="co">-- | Produce delayed Repa array from image with true color pixels.</span>
<span class="ot">fromImage ::</span> <span class="dt">Image</span> <span class="dt">PixelRGB8</span> <span class="ot">-&gt;</span> <span class="dt">Array</span> <span class="dt">D</span> <span class="dt">DIM2</span> <span class="dt">RGB8</span>
fromImage img<span class="fu">@</span><span class="dt">Image</span> {<span class="fu">..</span>} <span class="fu">=</span>
  R.fromFunction
    (<span class="dt">Z</span> <span class="fu">:.</span> imageWidth <span class="fu">:.</span> imageHeight)
    (\(<span class="dt">Z</span> <span class="fu">:.</span> x <span class="fu">:.</span> y) <span class="ot">-&gt;</span>
       <span class="kw">let</span> (<span class="dt">PixelRGB8</span> r g b) <span class="fu">=</span> pixelAt img x y
       <span class="kw">in</span> (r, g, b))

<span class="co">-- | Get image with true color pixels from manifest Repa array.</span>
<span class="ot">toImage ::</span> <span class="dt">Array</span> <span class="dt">U</span> <span class="dt">DIM2</span> <span class="dt">RGB8</span> <span class="ot">-&gt;</span> <span class="dt">Image</span> <span class="dt">PixelRGB8</span>
toImage a <span class="fu">=</span> generateImage gen width height
  <span class="kw">where</span>
    <span class="dt">Z</span> <span class="fu">:.</span> width <span class="fu">:.</span> height <span class="fu">=</span> R.extent a
    gen x y <span class="fu">=</span>
      <span class="kw">let</span> (r,g,b) <span class="fu">=</span> a <span class="fu">!</span> (<span class="dt">Z</span> <span class="fu">:.</span> x <span class="fu">:.</span> y)
      <span class="kw">in</span> <span class="dt">PixelRGB8</span> r g b</code></pre></div>
<p>The <code>extent</code> function returns the shape of given array. We represent images as two-dimensional matrix of three-tuples holding components of pixel's color: <code>Array D DIM2 RGB8</code> and <code>Array U DIM2 RGB8</code> where <code>DIM2</code> is just built-in alias for <code>Z :. Int :. Int</code>.</p>
<h2 id="image-rotation-revisited">Image rotation revisited</h2>
<p>Let's re-write the code that rotates an image with Repa and see if it's worth it. To use Repa we need to compile our code with the following flags:</p>
<ul>
<li><code>-Odph</code></li>
<li><code>-rtsopts</code></li>
<li><code>-threaded</code></li>
<li><code>-fno-liberate-case</code></li>
<li><code>-funfolding-use-threshold1000</code></li>
<li><code>-funfolding-keeness-factor1000</code></li>
<li><code>-fllvm</code></li>
<li><code>-optlo-O3</code></li>
</ul>
<p>Yes, all of this. Note the use of <a href="https://en.wikipedia.org/wiki/LLVM">LLVM</a> (enabled by <code>-fllvm</code> flag) which means you need to have it installed. When I tried to use version 3.8.0, I got the following:</p>
<pre><code>You are using a new version of LLVM that hasn't been tested yet!
We will try though...
opt: /tmp/ghc13996_0/ghc_2.ll:7:6: error: unexpected type in metadata definition
!0 = metadata !{metadata !&quot;top&quot;, i8* null}
     ^</code></pre>
<p>So I switched to version 3.5 which seems to work with Repa fine:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  [path, path'] <span class="ot">&lt;-</span> getArgs
  eimg <span class="ot">&lt;-</span> readImage path
  <span class="kw">case</span> eimg <span class="kw">of</span>
    <span class="dt">Left</span> err <span class="ot">-&gt;</span> putStrLn (<span class="st">&quot;Could not read image: &quot;</span> <span class="fu">++</span> err)
    <span class="dt">Right</span> (<span class="dt">ImageRGB8</span> img) <span class="ot">-&gt;</span> <span class="kw">do</span>
      computed <span class="ot">&lt;-</span> (R.computeUnboxedP <span class="fu">.</span> rotateImgRepa <span class="fu">.</span> fromImage) img
      (savePngImage path' <span class="fu">.</span> <span class="dt">ImageRGB8</span> <span class="fu">.</span> toImage) computed
    <span class="dt">Right</span> _ <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;Unexpected pixel format&quot;</span>

<span class="ot">rotateImgRepa ::</span> <span class="dt">R.Source</span> r e <span class="ot">=&gt;</span> <span class="dt">Array</span> r <span class="dt">DIM2</span> e <span class="ot">-&gt;</span> <span class="dt">Array</span> <span class="dt">D</span> <span class="dt">DIM2</span> e
rotateImgRepa g <span class="fu">=</span> R.backpermute e remap g
  <span class="kw">where</span>
    e<span class="fu">@</span>(<span class="dt">Z</span> <span class="fu">:.</span> width <span class="fu">:.</span> height) <span class="fu">=</span> R.extent g
    remap (<span class="dt">Z</span> <span class="fu">:.</span> x <span class="fu">:.</span> y) <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">:.</span> width <span class="fu">-</span> x <span class="fu">-</span> <span class="dv">1</span> <span class="fu">:.</span> height <span class="fu">-</span> y <span class="fu">-</span> <span class="dv">1</span>
    <span class="ot">{-# INLINE remap #-}</span></code></pre></div>
<p><code>computeUnboxedP</code> builds manifest unboxed arrays in parallel. It's a type-specialized version of the more general <code>computeP</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">computeP ::</span> (<span class="dt">Load</span> r1 sh e, <span class="dt">Target</span> r2 e, <span class="dt">Source</span> r2 e, <span class="dt">Monad</span> m)
  <span class="ot">=&gt;</span> <span class="dt">Array</span> r1 sh e     <span class="co">-- ^ The delayed array to compute</span>
  <span class="ot">-&gt;</span> m (<span class="dt">Array</span> r2 sh e) <span class="co">-- ^ Manifest array — result</span></code></pre></div>
<p>An interesting thing here is that <code>computeP</code> wants to live in a monad, <em>any monad</em>, why is that? The reason is that <code>computeP</code> can use an array that is produced with another <code>computeP</code> but only when it's already evaluated or else you get a run-time warning and slow code. If you keep all <code>computeP</code> and <code>computeUnboxedP</code> functions in the same monad, you are safe. So the type just helps avoid writing incorrect code (although it's still possible to use something like <code>runIdentity . computeP</code>). For sequential evaluation we have <code>computeS</code>, which may be a better choice for relatively small data-sets.</p>
<p><code>backpermute</code> is “backwards permutation of an array's elements” and it's just the right tool for the job. Let's see what we get:</p>
<pre><code>$ image-processing -- before-rotation.png after-rotation.png +RTS -s -N2
…
  Total   time    0.271s  (  0.156s elapsed)
…</code></pre>
<p>This seems to perform a bit worse, although both Juicy Pixel's and Repa's solutions have varying time of execution every time you run them. We could use a larger picture but then loading, saving, and transformation to JuicyPixels' representation would dominate processing time. We can use more cores though:</p>
<pre><code>$ image-processing -- before-rotation.png after-rotation.png +RTS -s -N4
…
  Total   time    0.131s  (  0.073s elapsed)
…</code></pre>
<p>Doesn't look too bad.</p>
<h2 id="image-generation-revisited">Image generation revisited</h2>
<p>Let's generate the same image with Repa:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  [path] <span class="ot">&lt;-</span> getArgs
  img    <span class="ot">&lt;-</span> R.computeUnboxedP generateImgRepa
  (savePngImage path <span class="fu">.</span> <span class="dt">ImageRGB8</span> <span class="fu">.</span> toImage) img

<span class="ot">generateImgRepa ::</span> <span class="dt">Array</span> <span class="dt">D</span> <span class="dt">DIM2</span> <span class="dt">RGB8</span>
generateImgRepa <span class="fu">=</span> R.fromFunction (<span class="dt">Z</span> <span class="fu">:.</span> <span class="dv">1200</span> <span class="fu">:.</span> <span class="dv">1200</span>) originalFnc'

<span class="ot">originalFnc' ::</span> (<span class="dt">Z</span> <span class="fu">:.</span> <span class="dt">Int</span> <span class="fu">:.</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">RGB8</span>
originalFnc' (<span class="dt">Z</span> <span class="fu">:.</span> x <span class="fu">:.</span> y) <span class="fu">=</span>
  <span class="kw">let</span> (q, r) <span class="fu">=</span> x <span class="ot">`quotRem`</span> max <span class="dv">3</span> y
      s      <span class="fu">=</span> fromIntegral <span class="fu">.</span> min <span class="bn">0xff</span>
  <span class="kw">in</span> (s q, s r, s (q <span class="fu">+</span> r <span class="fu">+</span> <span class="dv">30</span>))</code></pre></div>
<p>Result with two cores is slower than plain Juicy Pixels version:</p>
<pre><code>$ image-processing my-image.png +RTS -s -N2
…
  Total   time    0.276s  (  0.165s elapsed)
…</code></pre>
<p>Four cores improve the result a bit:</p>
<pre><code>$ image-processing my-image.png +RTS -s -N4
…
  Total   time    0.152s  (  0.084s elapsed)
…</code></pre>
<h3 id="conclusion">Conclusion</h3>
<p>Repa is great but watch out for where your bottleneck is. If you're doing a lot of IO in popular formats like JPEG or PNG, you will need Juicy Pixels and it may be worth it just to do the whole thing with Juicy Pixels. Repa has <a href="https://hackage.haskell.org/package/repa-io"><code>repa-io</code></a> which can save in BMP (if that works for you), but for me it performed considerably worse than our <code>toImage</code> function in combination with <code>JuicyPixels</code>. There is also <a href="https://hackage.haskell.org/package/JuicyPixels-repa"><code>JuicyPixels-repa</code></a>, but I got segfaults with it, no idea why.</p>
<p>Please feel free to comment on the tutorial, I'm not an expert of Repa programming, in fact this is one of my first experiences with the library, so maybe you can come up with an idea how to improve the tutorial or maybe make the code faster. Thanks for reading!</p>
<h2 id="see-also">See also</h2>
<p>List of resources that may be of interest:</p>
<ul>
<li><p><a href="../../../../chimera.labs.oreilly.com/books/1230000000929/ch05.html">Data parallel programming with Repa</a> — Chapter 5 from Simon Marlow's “Parallel and Concurrent Programming in Haskell”, highly recommended reading.</p></li>
<li><p><a href="https://wiki.haskell.org/Numeric_Haskell:_A_Repa_Tutorial">Numeric Haskell: A Repa Tutorial</a>.</p></li>
<li><p><a href="https://hackage.haskell.org/package/JuicyPixels"><code>JuicyPixels</code></a> on Hackage.</p></li>
<li><p><a href="https://hackage.haskell.org/package/repa"><code>repa</code></a> on Hackage.</p></li>
<li><p><a href="https://hackage.haskell.org/package/repa-algorithms"><code>repa-algorithms</code></a> on Hackage.</p></li>
<li><p><a href="https://hackage.haskell.org/package/repa-io"><code>repa-io</code></a> on Hackage.</p></li>
<li><p><a href="https://hackage.haskell.org/package/JuicyPixels-repa"><code>JuicyPixels-repa</code></a> on Hackage.</p></li>
</ul>
<h2 id="what-your-fellow-haskellers-did">What your fellow Haskellers did</h2>
<ul>
<li><p><a href="https://github.com/flannelhead/blackstar">Blackstar</a> is a blackhole raytracer that uses Repa under the hood.</p></li>
<li><p><a href="https://hackage.haskell.org/package/curves">Curves</a> is an interesting package that allows to draw curves, textures, and even text. It uses <code>JuicyPixels</code>.</p></li>
<li><p><a href="https://hackage.haskell.org/package/FractalArt">FractalArt</a> uses <code>JuicyPixels</code> to generate wallpappers with an interesting texture.</p></li>
</ul>

    <hr>

    <p>
      Thanks for reading this tutorial! If you have any feedback,
      please join the discussion below, or open issues and pull
      requests
      on <a href="https://github.com/stackbuilders/tutorials">GitHub</href>.
    </p>

    <div id="disqus_thread"></div>
    <script>
      (function() {
      var d = document, s = d.createElement('script');

      s.src = 'http://stackbuilders.disqus.com/embed.js';

      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

  </div>
</div>

    </div>

    <section class="careers__we_are_hiring">
      <div class="container">
        <div class="row">
          <div class="col-sm-12 v-center-container">
            <h2>
              Do You Have What it Takes To Be a Stack Builder?
            </h2>
            <div class="careers__we_are_hiring__cta">
              <a class="btn btn-cta-secondary" href="http://www.stackbuilders.com/join" title="Join Our Team">
                Join Our Team
              </a>
            </div>
          </div>
        </div>
      </div>
    </section>

    <footer class="footer">
      <div class="container">
        <div class="row">
          <div class="col-sm-6 footer__right">
            <a href="http://www.stackbuilders.com/" title="Stack Builders">
              <img class="footer__logo svg-logo" src="http://www.stackbuilders.com/assets/images/stack-builders-logo-blackwhite.svg" alt="Stack Builders logo">
            </a>
          </div>
          <div class="col-sm-6">
            <div class="footer__conversation">
              <h6>
                Join The Conversation
              </h6>
              <div class="footer__conversation__social">
                <a href="https://twitter.com/stackbuilders" target="_blank" rel="nofollow">
                  <i class="fa fa-twitter-square fa-3x" aria-hidden="true"></i>
                </a>
                <a href="https://www.facebook.com/Stack-Builders-207670466070752/" target="_blank" rel="nofollow">
                  <i class="fa fa-facebook-square fa-3x" aria-hidden="true"></i>
                </a>
              </div>
            </div>
          </div>
        </div>
        <div class="row">
          <div class="col-sm-12 footer__copyright">© Stack Builders Inc. 2016</div>
        </div>
      </div>
    </footer>

<script type="text/javascript" src="http://code.jquery.com/jquery-1.12.0.min.js">
</script>
<script type="text/javascript" src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js">
</script>
<script type="text/javascript" src="http://www.stackbuilders.com/assets/javascripts/all.min.js">
</script>
<script type="text/javascript" src="http://platform.twitter.com/widgets.js">
</script>
<!--[if lt IE 9]><script type="text/javascript" src="//oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
<script type="text/javascript" src="//oss.maxcdn.com/respond/1.4.2/respond.min.js"></script><![endif]-->

  </body>

<!-- Mirrored from www.stackbuilders.com/tutorials/haskell/image-processing/ by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 18 Dec 2016 20:18:11 GMT -->
</html>
