<!doctype html>

<html lang="en-us" prefix="og: http://ogp.me/ns#">
    
<!-- Mirrored from taylor.fausak.me/2014/03/04/haskeleton-a-haskell-project-skeleton/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 23 Dec 2016 06:00:38 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
        <meta charset="utf-8">

        <title>Haskeleton: a Haskell project skeleton &#xb7; taylor.fausak.me</title>

        <link href="http://taylor.fausak.me/static/styles/all.css" rel="stylesheet">
        <link href="http://taylor.fausak.me/static/images/favicon.ico" rel="shortcut icon">

        <link href="http://taylor.fausak.me/sitemap.atom" rel="alternate" title="taylor.fausak.me (Atom)" type="application/atom+xml">
        <link href="http://taylor.fausak.me/sitemap.rss" rel="alternate" title="taylor.fausak.me (RSS)" type="application/rss+xml">

        <link href="index.html" rel="canonical">

        <meta
    name="viewport"
    content="initial-scale=1, width=device-width">
<meta
    name="apple-mobile-web-app-title"
    content="taylor.fausak.html">



    <link
        rel="apple-touch-icon-precomposed"
        href="http://taylor.fausak.me/static/images/apple-touch-icon-152x152.png"
        sizes="152x152">

    <link
        rel="apple-touch-icon-precomposed"
        href="http://taylor.fausak.me/static/images/apple-touch-icon-144x144.png"
        sizes="144x144">

    <link
        rel="apple-touch-icon-precomposed"
        href="http://taylor.fausak.me/static/images/apple-touch-icon-120x120.png"
        sizes="120x120">

    <link
        rel="apple-touch-icon-precomposed"
        href="http://taylor.fausak.me/static/images/apple-touch-icon-114x114.png"
        sizes="114x114">

    <link
        rel="apple-touch-icon-precomposed"
        href="http://taylor.fausak.me/static/images/apple-touch-icon-76x76.png"
        sizes="76x76">

    <link
        rel="apple-touch-icon-precomposed"
        href="http://taylor.fausak.me/static/images/apple-touch-icon-72x72.png"
        sizes="72x72">

    <link
        rel="apple-touch-icon-precomposed"
        href="http://taylor.fausak.me/static/images/apple-touch-icon-60x60.png"
        sizes="60x60">

    <link
        rel="apple-touch-icon-precomposed"
        href="http://taylor.fausak.me/static/images/apple-touch-icon-57x57.png"
        sizes="57x57">


        <meta
    property="fb:admins"
    content="100001771158100">

        <meta
    property="og:description"
    content="Haskeleton is now available as a Stack template. Create a new project with stack new haskeleton your-project. I’m new to Haskell. I’ve learned enough to feel comfortable writing programs in it. I c...">
<meta
    property="og:image"
    content="http://taylor.fausak.me/static/images/og-image.png">
<meta
    property="og:locale"
    content="en_US">
<meta
    property="og:site_name"
    content="taylor.fausak.html">
<meta
    property="og:title"
    content="Haskeleton: a Haskell project skeleton">
<meta
    property="og:type"
    content="article">
<meta
    property="og:url"
    content="index.html">

        
    <link
        rel="prev"
        href="http://taylor.fausak.me/2014/01/23/confidently-manage-business-logic-with-active-interaction/">
    <link
        rel="prefetch"
        href="http://taylor.fausak.me/2014/01/23/confidently-manage-business-logic-with-active-interaction/">
    <link
        rel="prerender"
        href="http://taylor.fausak.me/2014/01/23/confidently-manage-business-logic-with-active-interaction/">



    <link
        rel="next"
        href="http://taylor.fausak.me/2014/04/28/cloning-2048-in-haskell/">
    <link
        rel="prefetch"
        href="http://taylor.fausak.me/2014/04/28/cloning-2048-in-haskell/">
    <link
        rel="prerender"
        href="http://taylor.fausak.me/2014/04/28/cloning-2048-in-haskell/">


        <meta
    property="twitter:card"
    content="summary">
<meta
    property="twitter:creator:id"
    content="204457677">
<meta
    property="twitter:site:id"
    content="204457677">

        <meta
    name="application-name"
    content="taylor.fausak.html">
<meta
    name="msapplication-TileColor"
    content="#151515">
<meta
    name="msapplication-TileImage"
    content="http://taylor.fausak.me/static/images/msapplication-TileImage.png">
<meta
    name="msapplication-square70x70logo"
    content="http://taylor.fausak.me/static/images/msapplication-square70x70logo.png">
<meta
    name="msapplication-square150x150logo"
    content="http://taylor.fausak.me/static/images/msapplication-square150x150logo.png">
<meta
    name="msapplication-wide310x150logo"
    content="http://taylor.fausak.me/static/images/msapplication-wide310x150logo.png">
<meta
    name="msapplication-square310x310logo"
    content="http://taylor.fausak.me/static/images/msapplication-square310x310logo.png">
<meta
    name="msapplication-notification"
    content="frequency=60;polling-uri=http://notifications.buildmypinnedsite.com/?feed=http://taylor.fausak.me/sitemap.atom;cycle=0">

    </head>

    <body itemscope itemtype="http://schema.org/Blog">
        <header class="header">
    <div class="wrapper">
        <h1 itemprop="name">
            <a href="http://taylor.fausak.me/" itemprop="url" title="taylor.fausak.me">
              <svg viewBox="0 0 10 10" height="100%" width="100%" xmlns="http://www.w3.org/2000/svg">
  <path fill="#ac4142" d="M4 2h2l-2 2h-2z"/>
  <path fill="#d28445" d="M5 2h2l-2 2h-2z"/>
  <path fill="#6a9fb5" d="M4 4h4l-4 4z"/>
  <path fill="#aa759f" d="M7 4h1l-4 4v-1z"/>
  <path fill="#f4bf75" d="M6 2h2l-4 4v-2z"/>
  <path fill="#90a959" d="M7 2h1l-4 4v-1z"/>
</svg>


                <span>taylor.fausak.me</span>
            </a>
        </h1>
    </div>
</header>


        <div class="content">
            <div class="wrapper">
                <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
    <h1 itemprop="name">Haskeleton: a Haskell project skeleton</h1>

    <p class="meta">
        by <a href="http://taylor.fausak.me/about/">Taylor Fausak</a>
        on <time datetime="2014-03-04" itemprop="datePublished">March 04, 2014</time>
    </p>

    <div itemprop="articleBody">
        <!---->
        <aside>Haskeleton is now available as a <a href="https://docs.haskellstack.org/en/stable/README/">Stack</a> template. Create a new project with
<code>stack new haskeleton your-project</code>.</aside>

<p>I’m new to Haskell. I’ve learned enough to feel comfortable writing programs in
it. I can solve code katas like <a href="https://github.com/tfausak/exercism-solutions/tree/master/haskell">exercism.io</a>, <a href="https://github.com/tfausak/h99">H-99</a>, and <a href="https://github.com/tfausak/project-euler/tree/master/haskell">Project
Euler</a>. Yet I don’t feel comfortable developing software with it. Writing
idiomatic, maintainable and well-tested Haskell code remains a mystery to me.</p>

<p>Cabal, the Haskell build tool, provides little guidance. For instance, <code class="highlighter-rouge">cabal
init</code> asks 11 questions and outputs two files totaling 26 lines. That’s not the
best metric, but it shows that you aren’t getting much out of it. To both
improve on that and educate myself, I built <a href="https://github.com/tfausak/haskeleton">Haskeleton</a>, a Haskell project
skeleton.</p>

<p>I hope it replaces <code class="highlighter-rouge">cabal init</code> someday. For the time being, it’s just an
example project. This post will walk you through setting up a project like
Haskeleton and explain the decisions I made along the way.</p>

<aside>Update: Haskeleton has been implemented as a template for <a href="https://github.com/fujimura/hi">hi</a>.</aside>

<ul>
  <li><a href="#setup">Setup</a></li>
  <li><a href="#library">Library</a></li>
  <li><a href="#executable">Executable</a></li>
  <li><a href="#documentation">Documentation</a></li>
  <li><a href="#tests">Tests</a></li>
  <li><a href="#benchmarks">Benchmarks</a></li>
  <li><a href="#code-quality">Code Quality</a>
    <ul>
      <li><a href="#documentation-tests">Documentation Tests</a></li>
      <li><a href="#documentation-coverage">Documentation Coverage</a></li>
      <li><a href="#test-coverage">Test Coverage</a></li>
      <li><a href="#static-analysis">Static Analysis</a></li>
    </ul>
  </li>
  <li><a href="#continuous-integration">Continuous Integration</a></li>
  <li><a href="#notes">Notes</a></li>
</ul>

<h2 id="setup">Setup</h2>

<p>There’s no reason to make new software with old technology. To get started,
make sure you have GHC 7.6.3 and Cabal 1.18.0.2 installed. You can get GHC
through <a href="http://www.haskell.org/platform/">The Haskell Platform</a> and the latest version of Cabal with <code class="highlighter-rouge">cabal
install cabal-install</code>.</p>

<p>Now for the hardest part: thinking of a name for your package. I went with
“husk”. (If you’re following along, replace that with your package’s name
throughout.) Make a directory for your package to get started.</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="c"># mkdir husk</span>
<span class="c"># cd husk</span>
</code></pre>
</div>

<p>You only need one file to make a package: a Cabal file. It describes the
package and tells Cabal how to build it. It starts off pretty simple.</p>

<div class="language-hs highlighter-rouge"><pre class="highlight"><code><span class="c1">-- husk.cabal</span>
<span class="n">name</span><span class="o">:</span>          <span class="n">husk</span>
<span class="n">version</span><span class="o">:</span>       <span class="mf">0.0</span><span class="o">.</span><span class="mi">0</span>
<span class="n">build</span><span class="o">-</span><span class="kr">type</span><span class="o">:</span>    <span class="kt">Simple</span>
<span class="n">cabal</span><span class="o">-</span><span class="n">version</span><span class="o">:</span> <span class="o">&gt;=</span> <span class="mf">1.18</span>

<span class="n">library</span>
    <span class="kr">default</span><span class="o">-</span><span class="n">language</span><span class="o">:</span> <span class="kt">Haskell2010</span>
</code></pre>
</div>

<p>The syntax is mix between Haskell and YAML. The <a href="http://www.haskell.org/cabal/users-guide/developing-packages.html#package-properties">package properties</a> at the
top describe the package as a whole. In the library section, the <a href="http://www.haskell.org/cabal/users-guide/developing-packages.html#build-information">build
information</a> declares how to build the library. Here’s what they all mean.</p>

<ul>
  <li><code class="highlighter-rouge">name</code>: The package’s name. This should be unique on <a href="http://hackage.haskell.org/">Hackage</a>.</li>
  <li><code class="highlighter-rouge">version</code>: The package’s version number. I recommend using <a href="http://semver.org/">semantic
versioning</a>.</li>
  <li><code class="highlighter-rouge">build-type</code>: The type of build. Cabal provides a setup script if this is
set to <code class="highlighter-rouge">Simple</code>. For some reason the default is <code class="highlighter-rouge">Custom</code>.</li>
  <li><code class="highlighter-rouge">cabal-version</code>: Cabal’s version number. Use the major and minor parts of
the version of Cabal used to build the package.</li>
  <li><code class="highlighter-rouge">default-language</code>: The version of the Haskell language report. The current
state of the art is <a href="http://www.haskell.org/onlinereport/haskell2010/"><code class="highlighter-rouge">Haskell2010</code></a>.</li>
</ul>

<p>With all the boilerplate out of the way, we can build the package. Before we
do, let’s create a sandbox. It sets up a private environment separate from the
rest of your system.</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="c"># cabal sandbox init</span>
Writing a default package environment file to
.../husk/cabal.sandbox.config
Creating a new sandbox at .../husk/.cabal-sandbox
</code></pre>
</div>

<p>Now let’s install the package into the sandbox.</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="c"># cabal install</span>
Resolving dependencies...
Configuring husk-0.0.0...
Building husk-0.0.0...
Preprocessing library husk-0.0.0...
In-place registering husk-0.0.0...
Installing library <span class="k">in</span> .../husk-0.0.0
Registering husk-0.0.0...
Installed husk-0.0.0
</code></pre>
</div>

<p>Alright, it worked! Six lines of code made a valid Cabal package. It doesn’t do
anything yet, though. Let’s fix that.</p>

<h2 id="library">Library</h2>

<p>Your library code shouldn’t live at the top level. Create a <code class="highlighter-rouge">library</code> directory
for it. In there, make a file with the same name as your package. For this
example, it doesn’t have to do anything interesting. We’re going to make it
export a function that returns the unit value.</p>

<div class="language-hs highlighter-rouge"><pre class="highlight"><code><span class="c1">-- library/Husk.hs</span>
<span class="kr">module</span> <span class="nn">Husk</span> <span class="p">(</span><span class="nf">husk</span><span class="p">)</span> <span class="kr">where</span>

<span class="n">husk</span> <span class="o">::</span> <span class="nb">()</span>
<span class="n">husk</span> <span class="o">=</span> <span class="nb">()</span>
</code></pre>
</div>

<p>Just writing the module isn’t enough. You have to let Cabal know about it.</p>

<div class="language-hs highlighter-rouge"><pre class="highlight"><code><span class="c1">-- husk.cabal</span>
<span class="n">library</span>
    <span class="n">exposed</span><span class="o">-</span><span class="n">modules</span><span class="o">:</span> <span class="kt">Husk</span>
    <span class="n">hs</span><span class="o">-</span><span class="n">source</span><span class="o">-</span><span class="n">dirs</span><span class="o">:</span>  <span class="n">library</span>
    <span class="n">build</span><span class="o">-</span><span class="n">depends</span><span class="o">:</span>   <span class="n">base</span>
</code></pre>
</div>

<p>This adds some new build information to the library:</p>

<ul>
  <li><code class="highlighter-rouge">exposed-modules</code>: List of modules exposed by the package.</li>
  <li><code class="highlighter-rouge">hs-source-dirs</code>: List of directories to search for source files in.</li>
  <li><code class="highlighter-rouge">build-depends</code>: A list of needed packages. Every project will depend on
<a href="http://hackage.haskell.org/package/base"><code class="highlighter-rouge">base</code></a>, which provides the Prelude.</li>
</ul>

<p>Now that Cabal’s in the loop, you can fire up a REPL for your package. The
modules exposed by the package are already available. You can play around with
the functions they export.</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="c"># cabal repl</span>
<span class="gp">*Husk&gt; </span>:type Husk.husk
Husk.husk :: <span class="o">()</span>
<span class="gp">*Husk&gt; </span>husk
<span class="o">()</span>
</code></pre>
</div>

<p>Now we’ve got a Cabal package with a library, which is more than <code class="highlighter-rouge">cabal init</code>
provides. And we did it with less code!</p>

<h2 id="executable">Executable</h2>

<p>Let’s provide an executable that uses the library. It shouldn’t live at the top
level either, so create an <code class="highlighter-rouge">executable</code> directory for it. Unlike the library,
don’t name this after your package. Just call it <code class="highlighter-rouge">Main.hs</code> instead.</p>

<div class="language-hs highlighter-rouge"><pre class="highlight"><code><span class="c1">-- executable/Main.hs</span>
<span class="kr">module</span> <span class="nn">Main</span> <span class="p">(</span><span class="nf">main</span><span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Husk</span> <span class="p">(</span><span class="nf">husk</span><span class="p">)</span>

<span class="n">main</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">main</span> <span class="o">=</span> <span class="n">print</span> <span class="n">husk</span>
</code></pre>
</div>

<p>As before, Cabal needs to know about this. Create a new section at the bottom
of the Cabal file.</p>

<div class="language-hs highlighter-rouge"><pre class="highlight"><code><span class="c1">-- husk.cabal</span>
<span class="n">executable</span> <span class="n">husk</span>
    <span class="n">build</span><span class="o">-</span><span class="n">depends</span><span class="o">:</span>    <span class="n">base</span><span class="p">,</span> <span class="n">husk</span>
    <span class="kr">default</span><span class="o">-</span><span class="n">language</span><span class="o">:</span> <span class="kt">Haskell2010</span>
    <span class="n">hs</span><span class="o">-</span><span class="n">source</span><span class="o">-</span><span class="n">dirs</span><span class="o">:</span>   <span class="n">executable</span>
    <span class="n">main</span><span class="o">-</span><span class="n">is</span><span class="o">:</span>          <span class="kt">Main</span><span class="o">.</span><span class="n">hs</span>
</code></pre>
</div>

<p>The only new property is <code class="highlighter-rouge">main-is</code>. It points to the main entry point for the
executable. After adding that, you can run it!</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="c"># cabal run</span>
Preprocessing library husk-0.0.0...
In-place registering husk-0.0.0...
Preprocessing executable <span class="s1">'husk'</span> <span class="k">for </span>husk-0.0.0...
Linking dist/build/husk/husk ...
<span class="o">()</span>
</code></pre>
</div>

<p>That’s all it takes to make an executable with Cabal.</p>

<h2 id="documentation">Documentation</h2>

<p>Now that you’ve got a library and an executable, you should document them.
There are two things that need documentation: the package itself and the source
of the package.</p>

<p>Documenting the package requires adding a few more package properties to the
Cabal file. If you’re not going to distribute your package on Hackage, you can
skip this step.</p>

<div class="language-hs highlighter-rouge"><pre class="highlight"><code><span class="c1">-- husk.cabal</span>
<span class="n">copyright</span><span class="o">:</span> <span class="mi">2014</span> <span class="kt">Taylor</span> <span class="kt">Fausak</span>
<span class="n">license</span><span class="o">:</span>   <span class="kt">MIT</span>
<span class="n">synopsis</span><span class="o">:</span>  <span class="kt">An</span> <span class="n">example</span> <span class="n">package</span><span class="o">.</span>
</code></pre>
</div>

<p>To write documentation for the source, you’ll need to learn <a href="http://www.haskell.org/haddock/">Haddock</a>. It’s
a simple markup language for annotating Haskell source. Here’s how the library
looks with comments:</p>

<div class="language-hs highlighter-rouge"><pre class="highlight"><code><span class="c1">-- library/Husk.hs</span>
<span class="cd">-- | An example module.</span>
<span class="kr">module</span> <span class="nn">Husk</span> <span class="p">(</span><span class="nf">husk</span><span class="p">)</span> <span class="kr">where</span>

<span class="cm">{- |
    An alias for the unit value.

    &gt;&gt;&gt; husk
    ()
-}</span>
<span class="n">husk</span> <span class="o">::</span> <span class="nb">()</span> <span class="c1">-- ^ The unit type.</span>
<span class="n">husk</span> <span class="o">=</span> <span class="nb">()</span>
</code></pre>
</div>

<p>Now that it’s documented, let’s generate the HTML documentation.</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="c"># cabal haddock</span>
Running Haddock <span class="k">for </span>husk-0.0.0...
Preprocessing library husk-0.0.0...
Haddock coverage:
 100% <span class="o">(</span>  2 /  2<span class="o">)</span> <span class="k">in</span> <span class="s1">'Husk'</span>
Documentation created: dist/doc/html/husk/index.html
</code></pre>
</div>

<p>The output is like what you’d see on Hackage. It’s missing one thing: links to
the source. Adding those requires another dependency. It should be optional.
Not everyone who installs the package will generate its documentation.</p>

<div class="language-hs highlighter-rouge"><pre class="highlight"><code><span class="c1">-- husk.cabal</span>
<span class="n">flag</span> <span class="n">documentation</span>
    <span class="kr">default</span><span class="o">:</span> <span class="kt">False</span>

<span class="n">library</span>
    <span class="kr">if</span> <span class="n">flag</span><span class="p">(</span><span class="n">documentation</span><span class="p">)</span>
        <span class="n">build</span><span class="o">-</span><span class="n">depends</span><span class="o">:</span> <span class="n">hscolour</span> <span class="o">==</span> <span class="mf">1.20</span><span class="o">.*</span>
</code></pre>
</div>

<p>Enabling flags for Cabal commands is easy. Add either <code class="highlighter-rouge">-fdocumentation</code> or
<code class="highlighter-rouge">--flags=documentation</code>. Using that flag, let’s regenerate the documentation.</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="c"># cabal install --flags=documentation</span>
<span class="c"># cabal haddock --hyperlink-source</span>
Running Haddock <span class="k">for </span>husk-0.0.0...
Running hscolour <span class="k">for </span>husk-0.0.0...
Preprocessing library husk-0.0.0...
Haddock coverage:
 100% <span class="o">(</span>  2 /  2<span class="o">)</span> <span class="k">in</span> <span class="s1">'Husk'</span>
Documentation created: dist/doc/html/husk/index.html
</code></pre>
</div>

<p>Now it should have source links. If you get a bunch of warnings, you can ignore
them. Haddock is looking for the documentation for the standard library. If you
want to add it, install <code class="highlighter-rouge">haskell-platform-doc</code>.</p>

<h2 id="tests">Tests</h2>

<p>You can test Haskell code in two different ways:</p>

<p>Unit tests using HUnit. Use these to test the behavior of your code. For
example, you could test that <code class="highlighter-rouge">+</code> returns <code class="highlighter-rouge">3</code> when given <code class="highlighter-rouge">1</code> and <code class="highlighter-rouge">2</code>.</p>

<div class="language-hs highlighter-rouge"><pre class="highlight"><code><span class="kt">TestCase</span> <span class="p">(</span><span class="n">assertEqual</span> <span class="s">"1 + 2 = 3"</span> <span class="mi">3</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
</code></pre>
</div>

<p>Property tests using QuickCheck. Use these to test the properties of your code.
For example, you could test that <code class="highlighter-rouge">+</code> always returns an even number when given
even arguments.</p>

<div class="language-hs highlighter-rouge"><pre class="highlight"><code><span class="n">quickCheck</span> <span class="p">(</span><span class="nf">\</span> <span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">even</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">y</span><span class="p">)))</span>
</code></pre>
</div>

<p>We’re going to use <a href="http://hspec.github.io/">HSpec</a> instead of those libraries. It has a nicer
syntax and a uniform interface for both. Create a <code class="highlighter-rouge">test-suite</code> folder for the
tests. In there, create <code class="highlighter-rouge">Spec.hs</code>, the top-level entry point. HSpec discovers
and runs your tests using the <code class="highlighter-rouge">hspec-discover</code> GHC preprocessor.</p>

<div class="language-hs highlighter-rouge"><pre class="highlight"><code><span class="c1">-- test-suite/Spec.hs</span>
<span class="cp">{-# OPTIONS_GHC -F -pgmF hspec-discover #-}</span>
</code></pre>
</div>

<p>It assumes you laid your tests out in the format it expects, so create a spec
file for your library. We don’t have much functionality to test, but we can
write a unit test and a property test for the <code class="highlighter-rouge">husk</code> function.</p>

<div class="language-hs highlighter-rouge"><pre class="highlight"><code><span class="c1">-- test-suite/HuskSpec.hs</span>
<span class="kr">module</span> <span class="nn">HuskSpec</span> <span class="p">(</span><span class="nf">spec</span><span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Husk</span> <span class="p">(</span><span class="nf">husk</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Test.Hspec</span>
<span class="kr">import</span> <span class="nn">Test.Hspec.QuickCheck</span>

<span class="n">spec</span> <span class="o">::</span> <span class="kt">Spec</span>
<span class="n">spec</span> <span class="o">=</span> <span class="kr">do</span>
    <span class="n">describe</span> <span class="s">"husk"</span> <span class="o">$</span> <span class="kr">do</span>
        <span class="n">it</span> <span class="s">"returns the unit value"</span> <span class="o">$</span> <span class="kr">do</span>
            <span class="n">husk</span> <span class="p">`</span><span class="n">shouldBe</span><span class="p">`</span> <span class="nb">()</span>

        <span class="n">prop</span> <span class="s">"equals the unit value"</span> <span class="o">$</span>
            <span class="nf">\</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">husk</span> <span class="o">==</span> <span class="n">x</span>
</code></pre>
</div>

<p>With that done, the only piece left is updating the Cabal file. Add a new
section at the end for the test suite.</p>

<div class="language-hs highlighter-rouge"><pre class="highlight"><code><span class="c1">-- husk.cabal</span>
<span class="n">test</span><span class="o">-</span><span class="n">suite</span> <span class="n">hspec</span>
    <span class="n">build</span><span class="o">-</span><span class="n">depends</span><span class="o">:</span>    <span class="n">base</span><span class="p">,</span> <span class="n">husk</span><span class="p">,</span> <span class="n">hspec</span> <span class="o">==</span> <span class="mf">1.8</span><span class="o">.*</span>
    <span class="kr">default</span><span class="o">-</span><span class="n">language</span><span class="o">:</span> <span class="kt">Haskell2010</span>
    <span class="n">hs</span><span class="o">-</span><span class="n">source</span><span class="o">-</span><span class="n">dirs</span><span class="o">:</span>   <span class="n">test</span><span class="o">-</span><span class="n">suite</span>
    <span class="n">main</span><span class="o">-</span><span class="n">is</span><span class="o">:</span>          <span class="kt">Spec</span><span class="o">.</span><span class="n">hs</span>
    <span class="kr">type</span><span class="o">:</span>             <span class="n">exitcode</span><span class="o">-</span><span class="n">stdio</span><span class="o">-</span><span class="mf">1.0</span>
</code></pre>
</div>

<p>The only new build information here is <code class="highlighter-rouge">type</code>. The Cabal documentation
recommends the non-existent <code class="highlighter-rouge">detailed-1.0</code> type. Ignore that and use
<code class="highlighter-rouge">exitcode-stdio-1.0</code>, which uses the exit code to signify success or failure.</p>

<p>After doing all that, you should be able to run the tests.</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="c"># cabal install --enable-tests</span>
<span class="c"># cabal test</span>
Test suite hspec: RUNNING...
Test suite hspec: PASS
Test suite logged to: dist/test/husk-0.0.0-hspec.log
</code></pre>
</div>

<h2 id="benchmarks">Benchmarks</h2>

<p>Now that we’ve got tests to ensure our code works, let’s write some benchmarks
to make sure it’s fast. We’re going to use <a href="http://hackage.haskell.org/package/criterion">Criterion</a>, an exceptional
benchmarking library. It handles all the setup for you and lets you focus on
writing benchmarks.</p>

<p>So let’s make a new directory, <code class="highlighter-rouge">benchmark</code>, and do just that.</p>

<div class="language-hs highlighter-rouge"><pre class="highlight"><code><span class="c1">-- benchmark/HuskBench.hs</span>
<span class="kr">module</span> <span class="nn">HuskBench</span> <span class="p">(</span><span class="nf">benchmarks</span><span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Criterion</span> <span class="p">(</span><span class="kt">Benchmark</span><span class="p">,</span> <span class="nf">bench</span><span class="p">,</span> <span class="nf">nf</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Husk</span> <span class="p">(</span><span class="nf">husk</span><span class="p">)</span>

<span class="n">benchmarks</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Benchmark</span><span class="p">]</span>
<span class="n">benchmarks</span> <span class="o">=</span>
    <span class="p">[</span> <span class="n">bench</span> <span class="s">"husk"</span> <span class="p">(</span><span class="n">nf</span> <span class="p">(</span><span class="n">const</span> <span class="n">husk</span><span class="p">)</span> <span class="nb">()</span><span class="p">)</span>
    <span class="p">]</span>
</code></pre>
</div>

<p>The only tricky part of this is <code class="highlighter-rouge">nf</code>. It evaluates the result of calling the
function with the given value. This is necessary since Haskell is lazy. If you
didn’t do it, only a part of the result might get evaluated. Then your
benchmark wouldn’t be accurate.</p>

<p>Now that we have a benchmark, we need a runner. Unlike HSpec, Criterion doesn’t
auto-discover benchmarks. We have to wire it up.</p>

<div class="language-hs highlighter-rouge"><pre class="highlight"><code><span class="c1">-- benchmark/Bench.hs</span>
<span class="kr">module</span> <span class="nn">Main</span> <span class="p">(</span><span class="nf">main</span><span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Criterion.Main</span> <span class="p">(</span><span class="nf">bgroup</span><span class="p">,</span> <span class="nf">defaultMain</span><span class="p">)</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">HuskBench</span>

<span class="n">main</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">main</span> <span class="o">=</span> <span class="n">defaultMain</span>
    <span class="p">[</span> <span class="n">bgroup</span> <span class="s">"Husk"</span> <span class="kt">HuskBench</span><span class="o">.</span><span class="n">benchmarks</span>
    <span class="p">]</span>
</code></pre>
</div>

<p>We need to add a new section to the Cabal file for the benchmarks.</p>

<div class="language-hs highlighter-rouge"><pre class="highlight"><code><span class="n">benchmark</span> <span class="n">criterion</span>
    <span class="n">build</span><span class="o">-</span><span class="n">depends</span><span class="o">:</span>    <span class="n">base</span><span class="p">,</span> <span class="n">husk</span><span class="p">,</span> <span class="n">criterion</span> <span class="o">==</span> <span class="mf">0.6</span><span class="o">.*</span>
    <span class="kr">default</span><span class="o">-</span><span class="n">language</span><span class="o">:</span> <span class="kt">Haskell2010</span>
    <span class="n">hs</span><span class="o">-</span><span class="n">source</span><span class="o">-</span><span class="n">dirs</span><span class="o">:</span>   <span class="n">benchmark</span>
    <span class="n">main</span><span class="o">-</span><span class="n">is</span><span class="o">:</span>          <span class="kt">Bench</span><span class="o">.</span><span class="n">hs</span>
    <span class="kr">type</span><span class="o">:</span>             <span class="n">exitcode</span><span class="o">-</span><span class="n">stdio</span><span class="o">-</span><span class="mf">1.0</span>
</code></pre>
</div>

<p>With that in place, we can now run the benchmarks.</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="c"># cabal install --enable-benchmarks</span>
<span class="c"># cabal bench</span>
Benchmark criterion: RUNNING...
benchmarking Husk/husk
mean: 12.15392 ns, lb 11.89230 ns, ub 12.49891 ns, ci 0.950
std dev: 1.529236 ns, lb 1.229199 ns, ub 1.884049 ns, ci 0.950
found 17 outliers among 100 samples <span class="o">(</span>17.0%<span class="o">)</span>
  6 <span class="o">(</span>6.0%<span class="o">)</span> high mild
  11 <span class="o">(</span>11.0%<span class="o">)</span> high severe
variance introduced by outliers: 86.253%
variance is severely inflated by outliers
Benchmark criterion: FINISH
</code></pre>
</div>

<h2 id="code-quality">Code Quality</h2>

<p>That covers the basics for making a library and an executable, along with tests
and benchmarks for them. Another important part of software projects is code
quality. This includes things like code coverage and linting. Focusing on
quality helps you make maintainable and idiomatic software.</p>

<h3 id="documentation-tests">Documentation Tests</h3>

<p>Before we get to all that, there’s one more thing that needs testing. When we
wrote our documentation, we included some example code. We should test that
code to make sure it’s correct. Incorrect examples in documentation are
frustrating.</p>

<p>Thanks to <a href="http://hackage.haskell.org/package/doctest"><code class="highlighter-rouge">doctest</code></a>, testing documentation is a cinch. We just need to
write a new test suite.</p>

<div class="language-hs highlighter-rouge"><pre class="highlight"><code><span class="c1">-- test-suite/DocTest.hs</span>
<span class="kr">module</span> <span class="nn">Main</span> <span class="p">(</span><span class="nf">main</span><span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">System.FilePath.Glob</span> <span class="p">(</span><span class="nf">glob</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Test.DocTest</span> <span class="p">(</span><span class="nf">doctest</span><span class="p">)</span>

<span class="n">main</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">main</span> <span class="o">=</span> <span class="n">glob</span> <span class="s">"library/**/*.hs"</span> <span class="o">&gt;&gt;=</span> <span class="n">doctest</span>
</code></pre>
</div>

<p>This uses globbing to avoid listing all the source files. That means you
shouldn’t ever have to change it.</p>

<p>Next, create a new section in the Cabal file.</p>

<div class="language-hs highlighter-rouge"><pre class="highlight"><code><span class="c1">-- husk.cabal</span>
<span class="n">test</span><span class="o">-</span><span class="n">suite</span> <span class="n">doctest</span>
    <span class="n">build</span><span class="o">-</span><span class="n">depends</span><span class="o">:</span>    <span class="n">base</span><span class="p">,</span> <span class="n">doctest</span> <span class="o">==</span> <span class="mf">0.9</span><span class="o">.*</span><span class="p">,</span> <span class="kt">Glob</span> <span class="o">==</span> <span class="mf">0.7</span><span class="o">.*</span>
    <span class="kr">default</span><span class="o">-</span><span class="n">language</span><span class="o">:</span> <span class="kt">Haskell2010</span>
    <span class="n">hs</span><span class="o">-</span><span class="n">source</span><span class="o">-</span><span class="n">dirs</span><span class="o">:</span>   <span class="n">test</span><span class="o">-</span><span class="n">suite</span>
    <span class="n">main</span><span class="o">-</span><span class="n">is</span><span class="o">:</span>          <span class="kt">DocTest</span><span class="o">.</span><span class="n">hs</span>
    <span class="kr">type</span><span class="o">:</span>             <span class="n">exitcode</span><span class="o">-</span><span class="n">stdio</span><span class="o">-</span><span class="mf">1.0</span>
</code></pre>
</div>

<p>You can now run it along with the other test suites.</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="c"># cabal install --enable-tests</span>
<span class="c"># cabal test</span>
Test suite doctest: RUNNING...
Test suite doctest: PASS
Test suite logged to: dist/test/husk-0.0.0-doctest.log
</code></pre>
</div>

<h3 id="documentation-coverage">Documentation Coverage</h3>

<p>After checking our documentation for correctness, we should make sure that we
documented everything. Unfortunately there’s no turnkey solution for this.
Making one isn’t too hard since Haddock outputs coverage information already.
We just need a script for running it and parsing the results. So create a new
test suite for that.</p>

<div class="language-hs highlighter-rouge"><pre class="highlight"><code><span class="c1">-- test-suite/Haddock.hs</span>
<span class="kr">module</span> <span class="nn">Main</span> <span class="p">(</span><span class="nf">main</span><span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Data.List</span> <span class="p">(</span><span class="nf">genericLength</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Maybe</span> <span class="p">(</span><span class="nf">catMaybes</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">System.Exit</span> <span class="p">(</span><span class="nf">exitFailure</span><span class="p">,</span> <span class="nf">exitSuccess</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">System.Process</span> <span class="p">(</span><span class="nf">readProcess</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Text.Regex</span> <span class="p">(</span><span class="nf">matchRegex</span><span class="p">,</span> <span class="nf">mkRegex</span><span class="p">)</span>

<span class="n">average</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Fractional</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Real</span> <span class="n">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">average</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">realToFrac</span> <span class="p">(</span><span class="n">sum</span> <span class="n">xs</span><span class="p">)</span> <span class="o">/</span> <span class="n">genericLength</span> <span class="n">xs</span>

<span class="n">expected</span> <span class="o">::</span> <span class="kt">Fractional</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">a</span>
<span class="n">expected</span> <span class="o">=</span> <span class="mi">90</span>

<span class="n">main</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">main</span> <span class="o">=</span> <span class="kr">do</span>
    <span class="n">output</span> <span class="o">&lt;-</span> <span class="n">readProcess</span> <span class="s">"cabal"</span> <span class="p">[</span><span class="s">"haddock"</span><span class="p">]</span> <span class="s">""</span>
    <span class="kr">if</span> <span class="n">average</span> <span class="p">(</span><span class="n">match</span> <span class="n">output</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">expected</span>
        <span class="kr">then</span> <span class="n">exitSuccess</span>
        <span class="kr">else</span> <span class="n">putStr</span> <span class="n">output</span> <span class="o">&gt;&gt;</span> <span class="n">exitFailure</span>

<span class="n">match</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="n">match</span> <span class="o">=</span> <span class="n">fmap</span> <span class="n">read</span> <span class="o">.</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">catMaybes</span> <span class="o">.</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">matchRegex</span> <span class="n">pattern</span><span class="p">)</span> <span class="o">.</span> <span class="n">lines</span>
  <span class="kr">where</span>
    <span class="n">pattern</span> <span class="o">=</span> <span class="n">mkRegex</span> <span class="s">"^ *([0-9]*)% "</span>
</code></pre>
</div>

<p>This is the most complex code so far. Matching regular expressions in Haskell
isn’t as easy as in scripting languages like Perl. But this code does what we
want and the only part that might change is the <code class="highlighter-rouge">expected</code> value.</p>

<p>To make this a bona fide test suite, we need to tell Cabal.</p>

<div class="language-hs highlighter-rouge"><pre class="highlight"><code><span class="c1">-- husk.cabal</span>
<span class="n">test</span><span class="o">-</span><span class="n">suite</span> <span class="n">haddock</span>
    <span class="n">build</span><span class="o">-</span><span class="n">depends</span><span class="o">:</span>    <span class="n">base</span><span class="p">,</span> <span class="n">process</span> <span class="o">==</span> <span class="mf">1.1</span><span class="o">.*</span><span class="p">,</span> <span class="n">regex</span><span class="o">-</span><span class="n">compat</span> <span class="o">==</span> <span class="mf">0.95</span><span class="o">.*</span>
    <span class="kr">default</span><span class="o">-</span><span class="n">language</span><span class="o">:</span> <span class="kt">Haskell2010</span>
    <span class="n">hs</span><span class="o">-</span><span class="n">source</span><span class="o">-</span><span class="n">dirs</span><span class="o">:</span>   <span class="n">test</span><span class="o">-</span><span class="n">suite</span>
    <span class="n">main</span><span class="o">-</span><span class="n">is</span><span class="o">:</span>          <span class="kt">Haddock</span><span class="o">.</span><span class="n">hs</span>
    <span class="kr">type</span><span class="o">:</span>             <span class="n">exitcode</span><span class="o">-</span><span class="n">stdio</span><span class="o">-</span><span class="mf">1.0</span>
</code></pre>
</div>

<p>Finally we can run it.</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="c"># cabal install --enable-tests</span>
<span class="c"># cabal test</span>
Test suite haddock: RUNNING...
Test suite haddock: PASS
Test suite logged to: dist/test/husk-0.0.0-haddock.log
</code></pre>
</div>

<h3 id="test-coverage">Test Coverage</h3>

<p>We know how much of our code we documented, but we don’t know how much of it we
tested. Let’s fix that by modifying our <code class="highlighter-rouge">hspec</code> test suite to use <a href="http://www.haskell.org/haskellwiki/Haskell_program_coverage">HPC</a>.</p>

<div class="language-hs highlighter-rouge"><pre class="highlight"><code><span class="c1">-- husk.cabal</span>
<span class="n">test</span><span class="o">-</span><span class="n">suite</span> <span class="n">hspec</span>
    <span class="n">ghc</span><span class="o">-</span><span class="n">options</span><span class="o">:</span>    <span class="o">-</span><span class="n">fhpc</span>
    <span class="n">hs</span><span class="o">-</span><span class="n">source</span><span class="o">-</span><span class="n">dirs</span><span class="o">:</span> <span class="n">test</span><span class="o">-</span><span class="n">suite</span> <span class="n">library</span>
    <span class="n">other</span><span class="o">-</span><span class="n">modules</span><span class="o">:</span>  <span class="kt">Husk</span><span class="p">,</span> <span class="kt">HuskSpec</span>
</code></pre>
</div>

<p>What we’re doing here is telling GHC to enable HPC. We also have to add all the
source and test files to <code class="highlighter-rouge">other-modules</code> so HPC can analyze them. This is kind
of annoying, especially since HSpec discovers our tests. But it’s not too bad
because if you forget a file, HPC will yell at you and your test will fail.</p>

<p>Before it can fail, though, we need to write it. This new test suite looks a
lot like the last one.</p>

<div class="language-hs highlighter-rouge"><pre class="highlight"><code><span class="c1">-- test-suite/HPC.hs</span>
<span class="kr">module</span> <span class="nn">Main</span> <span class="p">(</span><span class="nf">main</span><span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Data.List</span> <span class="p">(</span><span class="nf">genericLength</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Maybe</span> <span class="p">(</span><span class="nf">catMaybes</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">System.Exit</span> <span class="p">(</span><span class="nf">exitFailure</span><span class="p">,</span> <span class="nf">exitSuccess</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">System.Process</span> <span class="p">(</span><span class="nf">readProcess</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Text.Regex</span> <span class="p">(</span><span class="nf">matchRegex</span><span class="p">,</span> <span class="nf">mkRegex</span><span class="p">)</span>

<span class="n">average</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Fractional</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Real</span> <span class="n">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">average</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">realToFrac</span> <span class="p">(</span><span class="n">sum</span> <span class="n">xs</span><span class="p">)</span> <span class="o">/</span> <span class="n">genericLength</span> <span class="n">xs</span>

<span class="n">expected</span> <span class="o">::</span> <span class="kt">Fractional</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">a</span>
<span class="n">expected</span> <span class="o">=</span> <span class="mi">90</span>

<span class="n">main</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">main</span> <span class="o">=</span> <span class="kr">do</span>
    <span class="n">output</span> <span class="o">&lt;-</span> <span class="n">readProcess</span> <span class="s">"hpc"</span> <span class="p">[</span><span class="s">"report"</span><span class="p">,</span> <span class="s">"dist/hpc/tix/hspec/hspec.tix"</span><span class="p">]</span> <span class="s">""</span>
    <span class="kr">if</span> <span class="n">average</span> <span class="p">(</span><span class="n">match</span> <span class="n">output</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">expected</span>
        <span class="kr">then</span> <span class="n">exitSuccess</span>
        <span class="kr">else</span> <span class="n">putStr</span> <span class="n">output</span> <span class="o">&gt;&gt;</span> <span class="n">exitFailure</span>

<span class="n">match</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="n">match</span> <span class="o">=</span> <span class="n">fmap</span> <span class="n">read</span> <span class="o">.</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">catMaybes</span> <span class="o">.</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">matchRegex</span> <span class="n">pattern</span><span class="p">)</span> <span class="o">.</span> <span class="n">lines</span>
  <span class="kr">where</span>
    <span class="n">pattern</span> <span class="o">=</span> <span class="n">mkRegex</span> <span class="s">"^ *([0-9]*)% "</span>
</code></pre>
</div>

<p>Just like the last one, we have to add it to the Cabal file.</p>

<div class="language-hs highlighter-rouge"><pre class="highlight"><code><span class="c1">-- husk.cabal</span>
<span class="n">test</span><span class="o">-</span><span class="n">suite</span> <span class="n">hpc</span>
    <span class="n">build</span><span class="o">-</span><span class="n">depends</span><span class="o">:</span>    <span class="n">base</span><span class="p">,</span> <span class="n">process</span> <span class="o">==</span> <span class="mf">1.1</span><span class="o">.*</span><span class="p">,</span> <span class="n">regex</span><span class="o">-</span><span class="n">compat</span> <span class="o">==</span> <span class="mf">0.95</span><span class="o">.*</span>
    <span class="kr">default</span><span class="o">-</span><span class="n">language</span><span class="o">:</span> <span class="kt">Haskell2010</span>
    <span class="n">hs</span><span class="o">-</span><span class="n">source</span><span class="o">-</span><span class="n">dirs</span><span class="o">:</span>   <span class="n">test</span><span class="o">-</span><span class="n">suite</span>
    <span class="n">main</span><span class="o">-</span><span class="n">is</span><span class="o">:</span>          <span class="kt">HPC</span><span class="o">.</span><span class="n">hs</span>
    <span class="kr">type</span><span class="o">:</span>             <span class="n">exitcode</span><span class="o">-</span><span class="n">stdio</span><span class="o">-</span><span class="mf">1.0</span>
</code></pre>
</div>

<p>The order of things in the Cabal file doesn’t matter. But it runs the test
suites in order of appearance. Since this test uses the output of the HSpec
suite, make sure it comes after that one. If it doesn’t, it’ll either run with
old data or no data.</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="c"># cabal install --enable-tests</span>
<span class="c"># cabal test</span>
Test suite hspec: RUNNING...
Test suite hspec: PASS
Test suite logged to: dist/test/husk-0.0.0-hspec.log
Warning: Your version of HPC <span class="o">(</span>0.6<span class="o">)</span> does not properly handle multiple search
paths. Coverage report generation may fail unexpectedly. These issues are
addressed <span class="k">in </span>version 0.7 or later <span class="o">(</span>GHC 7.8 or later<span class="o">)</span>. The following search
paths have been abandoned: <span class="o">[</span><span class="s2">"dist/hpc/mix/husk-0.0.0"</span><span class="o">]</span>
Writing: hpc_index.html
Writing: hpc_index_fun.html
Writing: hpc_index_alt.html
Writing: hpc_index_exp.html
Test coverage report written to dist/hpc/html/hspec/hpc_index.html
Test suite hpc: RUNNING...
Test suite hpc: PASS
Test suite logged to: dist/test/husk-0.0.0-hpc.log
</code></pre>
</div>

<p>You can ignore HPC’s warning about search paths. Everything works fine in spite
of it.</p>

<h3 id="static-analysis">Static Analysis</h3>

<p>You might think we’ve got enough tests, but there’s still one last suite to
write. It’s going to enforce code conventions with <a href="http://community.haskell.org/~ndm/hlint/">HLint</a>.</p>

<div class="language-hs highlighter-rouge"><pre class="highlight"><code><span class="c1">-- test-suite/HLint.hs</span>
<span class="kr">module</span> <span class="nn">Main</span> <span class="p">(</span><span class="nf">main</span><span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Language.Haskell.HLint</span> <span class="p">(</span><span class="nf">hlint</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">System.Exit</span> <span class="p">(</span><span class="nf">exitFailure</span><span class="p">,</span> <span class="nf">exitSuccess</span><span class="p">)</span>

<span class="n">arguments</span> <span class="o">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
<span class="n">arguments</span> <span class="o">=</span>
    <span class="p">[</span> <span class="s">"benchmark"</span>
    <span class="p">,</span> <span class="s">"executable"</span>
    <span class="p">,</span> <span class="s">"library"</span>
    <span class="p">,</span> <span class="s">"test-suite"</span>
    <span class="p">]</span>

<span class="n">main</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">main</span> <span class="o">=</span> <span class="kr">do</span>
    <span class="n">hints</span> <span class="o">&lt;-</span> <span class="n">hlint</span> <span class="n">arguments</span>
    <span class="kr">if</span> <span class="n">null</span> <span class="n">hints</span> <span class="kr">then</span> <span class="n">exitSuccess</span> <span class="kr">else</span> <span class="n">exitFailure</span>
</code></pre>
</div>

<p>Thanks to HLint’s excellent interface, there’s nothing too interesting going on
here. Let’s tell Cabal about it.</p>

<div class="language-hs highlighter-rouge"><pre class="highlight"><code><span class="c1">-- husk.cabal</span>
<span class="n">test</span><span class="o">-</span><span class="n">suite</span> <span class="n">hlint</span>
    <span class="n">build</span><span class="o">-</span><span class="n">depends</span><span class="o">:</span>    <span class="n">base</span><span class="p">,</span> <span class="n">hlint</span> <span class="o">==</span> <span class="mf">1.8</span><span class="o">.*</span>
    <span class="kr">default</span><span class="o">-</span><span class="n">language</span><span class="o">:</span> <span class="kt">Haskell2010</span>
    <span class="n">hs</span><span class="o">-</span><span class="n">source</span><span class="o">-</span><span class="n">dirs</span><span class="o">:</span>   <span class="n">test</span><span class="o">-</span><span class="n">suite</span>
    <span class="n">main</span><span class="o">-</span><span class="n">is</span><span class="o">:</span>          <span class="kt">HLint</span><span class="o">.</span><span class="n">hs</span>
    <span class="kr">type</span><span class="o">:</span>             <span class="n">exitcode</span><span class="o">-</span><span class="n">stdio</span><span class="o">-</span><span class="mf">1.0</span>
</code></pre>
</div>

<p>All that’s left to do now is run it!</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="c"># cabal install --enable-tests</span>
<span class="c"># cabal test</span>
Test suite hlint: RUNNING...
Test suite hlint: PASS
Test suite logged to: dist/test/husk-0.0.0-hlint.log
</code></pre>
</div>

<h2 id="continuous-integration">Continuous Integration</h2>

<p>We’ve got all these tests now. They don’t do us any good if nobody ever runs
them. Since it’s all too easy to forget to run the tests when you’re
developing, let’s make a computer do it!</p>

<p><a href="https://travis-ci.org/">Travis CI</a> makes continuous integration a cinch. Assuming your code is on
GitHub, all you have to do is make one file and add one line to it.</p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="c1"># .travis.yml</span>
<span class="s">language</span><span class="pi">:</span> <span class="s">haskell</span>
</code></pre>
</div>

<p>Now every time you push to GitHub, Travis will run your tests. You’ll get an
email if they aren’t green.</p>

<h2 id="notes">Notes</h2>

<p>This turned out to be much bigger than I anticipated. And I had to leave some
stuff out! For more details, check out <a href="https://github.com/tfausak/haskeleton">Haskeleton</a>. Hopefully some day it
will make this post obsolete.</p>

<p>In the meantime, <a href="&#109;&#097;&#105;&#108;&#116;&#111;:&#116;&#097;&#121;&#108;&#111;&#114;&#043;&#104;&#111;&#110;&#101;&#121;&#112;&#111;&#116;&#064;&#102;&#097;&#117;&#115;&#097;&#107;&#046;&#109;&#101;">email me</a> if you have any questions. I’m happy to help!</p>

<p>I used a number of invaluable resources while writing this post, including:</p>

<ul>
  <li>The <a href="http://www.haskell.org/haskellwiki/Category:Haskell">Haskell wiki</a>. It contains a staggering amount of useful
information and links. Sometimes the information is out of date, but it’s
helpful nonetheless.</li>
  <li>Sebastiaan Visser’s post, <a href="http://fvisser.nl/post/2013/may/28/towards-a-better-haskell-package.html">“Towards a better Haskell package”</a>. It
provides reasoned arguments for a number of subjective points about package
development.</li>
  <li>Kazu Yamamoto’s <a href="https://github.com/kazu-yamamoto/unit-test-example/blob/master/markdown/en/tutorial.md">unit testing guide</a>. It helped me wrap my head around
HUnit, QuickCheck, HSpec, and DocTest.</li>
  <li><a href="https://github.com/fujimura/hi">hi</a>, a Haskell package generator by Fujimura Daisuke. Haskeleton could
end up as a template for this excellent utility.</li>
</ul>


    </div>
</article>


    <hr>

    <table class="pagination">
        <tr>
            
                <td class="prev-icon">&#x2190;</td>
                <td class="prev">
                    <a href="http://taylor.fausak.me/2014/01/23/confidently-manage-business-logic-with-active-interaction/" rel="prev" title="Confidently manage business logic with Active­Interaction">Confidently manage business logic with Active­Interaction</a>
                </td>
            

            
                <td class="next">
                    <a href="http://taylor.fausak.me/2014/04/28/cloning-2048-in-haskell/" rel="next" title="Cloning 2048 in Haskell">Cloning 2048 in Haskell</a>
                </td>
                <td class="next-icon">&#x2192;</td>
            
        </tr>
    </table>


            </div>
        </div>

        <footer class="footer">
    <div class="wrapper">
        <p>
            Content on this site is licensed under a
            <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International license</a>.

            The source for this page is available
            <a href="https://github.com/tfausak/tfausak.github.io/blob/master/_posts/2014-03-04-haskeleton-a-haskell-project-skeleton.md">on GitHub</a>.
        </p>

        <svg viewBox="0 0 10 10" height="100%" width="100%" xmlns="http://www.w3.org/2000/svg">
  <path fill="#ac4142" d="M4 2h2l-2 2h-2z"/>
  <path fill="#d28445" d="M5 2h2l-2 2h-2z"/>
  <path fill="#6a9fb5" d="M4 4h4l-4 4z"/>
  <path fill="#aa759f" d="M7 4h1l-4 4v-1z"/>
  <path fill="#f4bf75" d="M6 2h2l-4 4v-2z"/>
  <path fill="#90a959" d="M7 2h1l-4 4v-1z"/>
</svg>

    </div>
</footer>

    </body>

<!-- Mirrored from taylor.fausak.me/2014/03/04/haskeleton-a-haskell-project-skeleton/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 23 Dec 2016 06:00:38 GMT -->
</html>
