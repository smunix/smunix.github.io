<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from dev.stephendiehl.com/hask/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 23 Dec 2016 06:18:00 GMT -->
<head>
    <meta charset="utf-8">
    <title>What I Wish I Knew When Learning Haskell 2.3 ( Stephen Diehl )</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
        
    <link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,700|Source+Code+Pro" rel="stylesheet">
    <style type="text/css">
      
    </style>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-49839533-1', 'stephendiehl.com');
      ga('send', 'pageview');
    </script>

          <style type="text/css">
    div.sourceCode { overflow-x: auto; }
    table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
      margin: 0; padding: 0; vertical-align: baseline; border: none; }
    table.sourceCode { width: 100%; line-height: 100%; }
    td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
    td.sourceCode { padding-left: 5px; }
    code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code > span.dt { color: #902000; } /* DataType */
    code > span.dv { color: #40a070; } /* DecVal */
    code > span.bn { color: #40a070; } /* BaseN */
    code > span.fl { color: #40a070; } /* Float */
    code > span.ch { color: #4070a0; } /* Char */
    code > span.st { color: #4070a0; } /* String */
    code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code > span.ot { color: #007020; } /* Other */
    code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code > span.fu { color: #06287e; } /* Function */
    code > span.er { color: #ff0000; font-weight: bold; } /* Error */
    code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    code > span.cn { color: #880000; } /* Constant */
    code > span.sc { color: #4070a0; } /* SpecialChar */
    code > span.vs { color: #4070a0; } /* VerbatimString */
    code > span.ss { color: #bb6688; } /* SpecialString */
    code > span.im { } /* Import */
    code > span.va { color: #19177c; } /* Variable */
    code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code > span.op { color: #666666; } /* Operator */
    code > span.bu { } /* BuiltIn */
    code > span.ex { } /* Extension */
    code > span.pp { color: #bc7a00; } /* Preprocessor */
    code > span.at { color: #7d9029; } /* Attribute */
    code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
      </style>
    
        <link rel="stylesheet" href="css/style.css" type="text/css" />
        <link rel="stylesheet" href="css/layout.css" type="text/css" />
    
          </head>

  <body itemscope itemtype="http://schema.org/TechArticle">
    <div id="sidebar-wrapper">
      <a href="index.html" class="logo">
        <img src="img/haskell_logo.svg" alt="Haskell Logo">
      </a>
      <button id="toggle-sidebar">
        Menu
      </button>
      <ul class="sidebar-nav">
<ul>
<li><a href="#basics">Basics</a><ul>
<li><a href="#cabal">Cabal</a></li>
<li><a href="#stack">Stack</a></li>
<li><a href="#flags">Flags</a></li>
<li><a href="#hackage">Hackage</a></li>
<li><a href="#ghci">GHCi</a></li>
<li><a href="#editor-integration">Editor Integration</a></li>
<li><a href="#bottoms">Bottoms</a></li>
<li><a href="#exhaustiveness">Exhaustiveness</a></li>
<li><a href="#debugger">Debugger</a></li>
<li><a href="#stack-traces">Stack Traces</a></li>
<li><a href="#trace">Trace</a></li>
<li><a href="#type-holes">Type Holes</a></li>
<li><a href="#deferred-type-errors">Deferred Type Errors</a></li>
<li><a href="#ghcid">ghcid</a></li>
<li><a href="#haddock">Haddock</a></li>
</ul></li>
<li><a href="#monads">Monads</a><ul>
<li><a href="#eightfold-path-to-monad-satori">Eightfold Path to Monad Satori</a></li>
<li><a href="#monadic-myths">Monadic Myths</a></li>
<li><a href="#monadic-methods">Monadic Methods</a></li>
<li><a href="#laws">Laws</a></li>
<li><a href="#do-notation">Do Notation</a></li>
<li><a href="#maybe">Maybe</a></li>
<li><a href="#list">List</a></li>
<li><a href="#io">IO</a></li>
<li><a href="#whats-the-point">What's the point?</a></li>
<li><a href="#reader-monad">Reader Monad</a></li>
<li><a href="#writer-monad">Writer Monad</a></li>
<li><a href="#state-monad">State Monad</a></li>
<li><a href="#monad-tutorials">Monad Tutorials</a></li>
</ul></li>
<li><a href="#monad-transformers">Monad Transformers</a><ul>
<li><a href="#mtl-transformers">mtl / transformers</a></li>
<li><a href="#transformers">Transformers</a></li>
<li><a href="#basics-1">Basics</a></li>
<li><a href="#readert">ReaderT</a></li>
<li><a href="#newtype-deriving">Newtype Deriving</a></li>
<li><a href="#efficiency">Efficiency</a></li>
<li><a href="#monad-morphisms">Monad Morphisms</a></li>
</ul></li>
<li><a href="#language-extensions">Language Extensions</a><ul>
<li><a href="#the-benign">The Benign</a></li>
<li><a href="#the-dangerous">The Dangerous</a></li>
<li><a href="#type-inference">Type Inference</a></li>
<li><a href="#monomorphism-restriction">Monomorphism Restriction</a></li>
<li><a href="#extended-defaulting">Extended Defaulting</a></li>
<li><a href="#safe-haskell">Safe Haskell</a></li>
<li><a href="#partial-type-signatures">Partial Type Signatures</a></li>
<li><a href="#recursive-do">Recursive Do</a></li>
<li><a href="#applicative-do">Applicative Do</a></li>
<li><a href="#pattern-guards">Pattern Guards</a></li>
<li><a href="#viewpatterns">ViewPatterns</a></li>
<li><a href="#tuplesections">TupleSections</a></li>
<li><a href="#multiwayif">MultiWayIf</a></li>
<li><a href="#emptycase">EmptyCase</a></li>
<li><a href="#lambdacase">LambdaCase</a></li>
<li><a href="#numdecimals">NumDecimals</a></li>
<li><a href="#packageimports">PackageImports</a></li>
<li><a href="#recordwildcards">RecordWildCards</a></li>
<li><a href="#namedfieldpuns">NamedFieldPuns</a></li>
<li><a href="#patternsynonyms">PatternSynonyms</a></li>
<li><a href="#derivetraversable">DeriveTraversable</a></li>
<li><a href="#derivefoldable">DeriveFoldable</a></li>
<li><a href="#derivefunctor">DeriveFunctor</a></li>
<li><a href="#derivegeneric">DeriveGeneric</a></li>
<li><a href="#deriveanyclass">DeriveAnyClass</a></li>
<li><a href="#staticpointers">StaticPointers</a></li>
<li><a href="#duplicaterecordfields">DuplicateRecordFields</a></li>
<li><a href="#overloadedlabels">OverloadedLabels</a></li>
<li><a href="#cpp">Cpp</a></li>
<li><a href="#historical-extensions">Historical Extensions</a></li>
</ul></li>
<li><a href="#type-classes">Type Classes</a><ul>
<li><a href="#minimal-annotations">Minimal Annotations</a></li>
<li><a href="#flexibleinstances">FlexibleInstances</a></li>
<li><a href="#flexiblecontexts">FlexibleContexts</a></li>
<li><a href="#overlappinginstances">OverlappingInstances</a></li>
<li><a href="#incoherentinstances">IncoherentInstances</a></li>
<li><a href="#typesynonyminstances">TypeSynonymInstances</a></li>
</ul></li>
<li><a href="#laziness">Laziness</a><ul>
<li><a href="#strictness">Strictness</a></li>
<li><a href="#seq-and-whnf">Seq and WHNF</a></li>
<li><a href="#strictness-annotations">Strictness Annotations</a></li>
<li><a href="#strict-haskell">Strict Haskell</a></li>
<li><a href="#deepseq">Deepseq</a></li>
<li><a href="#irrefutable-patterns">Irrefutable Patterns</a></li>
</ul></li>
<li><a href="#prelude">Prelude</a><ul>
<li><a href="#what-to-avoid">What to Avoid?</a></li>
<li><a href="#what-should-be-in-base">What Should be in Base</a></li>
<li><a href="#custom-preludes">Custom Preludes</a></li>
<li><a href="#protolude">Protolude</a></li>
<li><a href="#partial-functions">Partial Functions</a></li>
<li><a href="#safe">Safe</a></li>
<li><a href="#boolean-blindness">Boolean Blindness</a></li>
<li><a href="#foldable-traversable">Foldable / Traversable</a></li>
<li><a href="#corecursion">Corecursion</a></li>
<li><a href="#split">split</a></li>
<li><a href="#monad-loops">monad-loops</a></li>
<li><a href="#foundation">Foundation</a></li>
</ul></li>
<li><a href="#strings">Strings</a><ul>
<li><a href="#string">String</a></li>
<li><a href="#import-conventions">Import Conventions</a></li>
<li><a href="#text">Text</a></li>
<li><a href="#text.builder">Text.Builder</a></li>
<li><a href="#bytestring">ByteString</a></li>
<li><a href="#utf8-string">utf8-string</a></li>
<li><a href="#base64-bytestring">base64-bytestring</a></li>
<li><a href="#printf">Printf</a></li>
<li><a href="#overloaded-lists">Overloaded Lists</a></li>
<li><a href="#string-conversions">String Conversions</a></li>
</ul></li>
<li><a href="#applicatives">Applicatives</a><ul>
<li><a href="#alternative">Alternative</a></li>
<li><a href="#arrows">Arrows</a></li>
<li><a href="#bifunctors">Bifunctors</a></li>
<li><a href="#polyvariadic-functions">Polyvariadic Functions</a></li>
</ul></li>
<li><a href="#error-handling">Error Handling</a><ul>
<li><a href="#control.exception">Control.Exception</a></li>
<li><a href="#exceptions">Exceptions</a></li>
<li><a href="#exceptt">ExceptT</a></li>
<li><a href="#spoon">spoon</a></li>
<li><a href="#safe-exceptions">safe-exceptions</a></li>
</ul></li>
<li><a href="#advanced-monads">Advanced Monads</a><ul>
<li><a href="#function-monad">Function Monad</a></li>
<li><a href="#rws-monad">RWS Monad</a></li>
<li><a href="#cont">Cont</a></li>
<li><a href="#monadplus">MonadPlus</a></li>
<li><a href="#monadfix">MonadFix</a></li>
<li><a href="#st-monad">ST Monad</a></li>
<li><a href="#free-monads">Free Monads</a></li>
<li><a href="#indexed-monads">Indexed Monads</a></li>
<li><a href="#lifted-base">lifted-base</a></li>
</ul></li>
<li><a href="#quantification">Quantification</a><ul>
<li><a href="#universal-quantification">Universal Quantification</a></li>
<li><a href="#free-theorems">Free theorems</a></li>
<li><a href="#type-systems">Type Systems</a></li>
<li><a href="#rank-n-types">Rank-N Types</a></li>
<li><a href="#existential-quantification">Existential Quantification</a></li>
<li><a href="#impredicative-types">Impredicative Types</a></li>
<li><a href="#scoped-type-variables">Scoped Type Variables</a></li>
</ul></li>
<li><a href="#gadts">GADTs</a><ul>
<li><a href="#gadts-1">GADTs</a></li>
<li><a href="#kind-signatures">Kind Signatures</a></li>
<li><a href="#void">Void</a></li>
<li><a href="#phantom-types">Phantom Types</a></li>
<li><a href="#typelevel-operations">Typelevel Operations</a></li>
</ul></li>
<li><a href="#interpreters">Interpreters</a><ul>
<li><a href="#hoas">HOAS</a></li>
<li><a href="#phoas">PHOAS</a></li>
<li><a href="#final-interpreters">Final Interpreters</a></li>
<li><a href="#finally-tagless">Finally Tagless</a></li>
<li><a href="#datatypes">Datatypes</a></li>
<li><a href="#f-algebras">F-Algebras</a></li>
<li><a href="#recursion-schemes">recursion-schemes</a></li>
<li><a href="#data-types-à-la-carte">Data types à la carte</a></li>
<li><a href="#hint-and-mueval">Hint and Mueval</a></li>
</ul></li>
<li><a href="#testing">Testing</a><ul>
<li><a href="#quickcheck">QuickCheck</a></li>
<li><a href="#smallcheck">SmallCheck</a></li>
<li><a href="#quickspec">QuickSpec</a></li>
<li><a href="#criterion">Criterion</a></li>
<li><a href="#tasty">Tasty</a></li>
<li><a href="#silently">silently</a></li>
</ul></li>
<li><a href="#type-families">Type Families</a><ul>
<li><a href="#multiparam-typeclasses">MultiParam Typeclasses</a></li>
<li><a href="#type-families-1">Type Families</a></li>
<li><a href="#injectivity">Injectivity</a></li>
<li><a href="#roles">Roles</a></li>
<li><a href="#monotraversable">Monotraversable</a></li>
<li><a href="#nonempty">NonEmpty</a></li>
<li><a href="#overloaded-lists-1">Overloaded Lists</a></li>
<li><a href="#manual-proofs">Manual Proofs</a></li>
<li><a href="#constraint-kinds">Constraint Kinds</a></li>
<li><a href="#typefamilydependencies">TypeFamilyDependencies</a></li>
</ul></li>
<li><a href="#promotion">Promotion</a><ul>
<li><a href="#higher-kinded-types">Higher Kinded Types</a></li>
<li><a href="#kind-polymorphism">Kind Polymorphism</a></li>
<li><a href="#data-kinds">Data Kinds</a></li>
<li><a href="#size-indexed-vectors">Size-Indexed Vectors</a></li>
<li><a href="#typelevel-numbers">Typelevel Numbers</a></li>
<li><a href="#typelevel-strings">Typelevel Strings</a></li>
<li><a href="#custom-errors">Custom Errors</a></li>
<li><a href="#type-equality">Type Equality</a></li>
<li><a href="#proxies">Proxies</a></li>
<li><a href="#promoted-syntax">Promoted Syntax</a></li>
<li><a href="#singleton-types">Singleton Types</a></li>
<li><a href="#closed-type-families">Closed Type Families</a></li>
<li><a href="#kind-indexed-type-families">Kind Indexed Type Families</a></li>
<li><a href="#promoted-symbols">Promoted Symbols</a></li>
<li><a href="#hlists">HLists</a></li>
<li><a href="#typelevel-dictionaries">Typelevel Dictionaries</a></li>
<li><a href="#advanced-proofs">Advanced Proofs</a></li>
<li><a href="#liquid-haskell">Liquid Haskell</a></li>
</ul></li>
<li><a href="#generics">Generics</a><ul>
<li><a href="#typeable">Typeable</a></li>
<li><a href="#dynamic">Dynamic</a></li>
<li><a href="#data">Data</a></li>
<li><a href="#syb">Syb</a></li>
<li><a href="#generic">Generic</a></li>
<li><a href="#generic-deriving">Generic Deriving</a></li>
<li><a href="#generics-sop">generics-sop</a></li>
<li><a href="#uniplate">Uniplate</a></li>
</ul></li>
<li><a href="#mathematics">Mathematics</a><ul>
<li><a href="#numeric-tower">Numeric Tower</a></li>
<li><a href="#integer">Integer</a></li>
<li><a href="#complex">Complex</a></li>
<li><a href="#scientific">Scientific</a></li>
<li><a href="#statistics">Statistics</a></li>
<li><a href="#constructive-reals">Constructive Reals</a></li>
<li><a href="#sat-solvers">SAT Solvers</a></li>
<li><a href="#smt-solvers">SMT Solvers</a></li>
<li><a href="#z3">Z3</a></li>
</ul></li>
<li><a href="#data-structures">Data Structures</a><ul>
<li><a href="#map">Map</a></li>
<li><a href="#tree">Tree</a></li>
<li><a href="#set">Set</a></li>
<li><a href="#vector">Vector</a></li>
<li><a href="#mutable-vectors">Mutable Vectors</a></li>
<li><a href="#unordered-containers">Unordered-Containers</a></li>
<li><a href="#hashtables">Hashtables</a></li>
<li><a href="#graphs">Graphs</a></li>
<li><a href="#graph-theory">Graph Theory</a></li>
<li><a href="#dlist">DList</a></li>
<li><a href="#sequence">Sequence</a></li>
</ul></li>
<li><a href="#ffi">FFI</a><ul>
<li><a href="#pure-functions">Pure Functions</a></li>
<li><a href="#storable-arrays">Storable Arrays</a></li>
<li><a href="#function-pointers">Function Pointers</a></li>
</ul></li>
<li><a href="#concurrency">Concurrency</a><ul>
<li><a href="#sparks">Sparks</a></li>
<li><a href="#threadscope">Threadscope</a></li>
<li><a href="#strategies">Strategies</a></li>
<li><a href="#stm">STM</a></li>
<li><a href="#monad-par">Monad Par</a></li>
<li><a href="#async">async</a></li>
</ul></li>
<li><a href="#graphics">Graphics</a><ul>
<li><a href="#diagrams">Diagrams</a></li>
</ul></li>
<li><a href="#parsing">Parsing</a><ul>
<li><a href="#parsec">Parsec</a></li>
<li><a href="#custom-lexer">Custom Lexer</a></li>
<li><a href="#simple-parsing">Simple Parsing</a></li>
<li><a href="#generic-parsing">Generic Parsing</a></li>
<li><a href="#attoparsec">Attoparsec</a></li>
<li><a href="#optparse-applicative">Optparse Applicative</a></li>
<li><a href="#happy-alex">Happy &amp; Alex</a></li>
<li><a href="#configurator">Configurator</a></li>
</ul></li>
<li><a href="#streaming">Streaming</a><ul>
<li><a href="#lazy-io">Lazy IO</a></li>
<li><a href="#pipes">Pipes</a></li>
<li><a href="#safe-pipes">Safe Pipes</a></li>
<li><a href="#conduits">Conduits</a></li>
</ul></li>
<li><a href="#cryptography">Cryptography</a><ul>
<li><a href="#cryptonite">cryptonite</a></li>
<li><a href="#entropy">entropy</a></li>
<li><a href="#memory">memory</a></li>
<li><a href="#crypto-pubkey">crypto-pubkey</a></li>
<li><a href="#crypto-api">crypto-api</a></li>
<li><a href="#x509">x509</a></li>
<li><a href="#ed25519">ed25519</a></li>
</ul></li>
<li><a href="#compression">Compression</a><ul>
<li><a href="#lz4">lz4</a></li>
<li><a href="#zlib">zlib</a></li>
</ul></li>
<li><a href="#data-formats">Data Formats</a><ul>
<li><a href="#json">JSON</a></li>
<li><a href="#yaml">Yaml</a></li>
<li><a href="#csv">CSV</a></li>
</ul></li>
<li><a href="#network-web-programming">Network &amp; Web Programming</a><ul>
<li><a href="#http">HTTP</a></li>
<li><a href="#blaze">Blaze</a></li>
<li><a href="#warp">Warp</a></li>
<li><a href="#scotty">Scotty</a></li>
<li><a href="#servant">Servant</a></li>
<li><a href="#hastache">Hastache</a></li>
</ul></li>
<li><a href="#databases">Databases</a><ul>
<li><a href="#postgres">Postgres</a></li>
<li><a href="#redis">Redis</a></li>
<li><a href="#acid-state">Acid State</a></li>
</ul></li>
<li><a href="#ghc">GHC</a><ul>
<li><a href="#block-diagram">Block Diagram</a></li>
<li><a href="#core">Core</a></li>
<li><a href="#inliner">Inliner</a></li>
<li><a href="#dictionaries">Dictionaries</a></li>
<li><a href="#specialization">Specialization</a></li>
<li><a href="#static-compilation">Static Compilation</a></li>
<li><a href="#unboxed-types">Unboxed Types</a></li>
<li><a href="#iost">IO/ST</a></li>
<li><a href="#ghc-heap-view">ghc-heap-view</a></li>
<li><a href="#stg">STG</a></li>
<li><a href="#workerwrapper">Worker/Wrapper</a></li>
<li><a href="#z-encoding">Z-Encoding</a></li>
<li><a href="#cmm">Cmm</a></li>
<li><a href="#optimization-hacks">Optimization Hacks</a></li>
<li><a href="#interface-files">Interface Files</a></li>
</ul></li>
<li><a href="#profiling">Profiling</a><ul>
<li><a href="#ekg">EKG</a></li>
<li><a href="#rts-profiling">RTS Profiling</a></li>
</ul></li>
<li><a href="#languages">Languages</a><ul>
<li><a href="#unbound">unbound</a></li>
<li><a href="#unbound-generics">unbound-generics</a></li>
<li><a href="#llvm-general">llvm-general</a></li>
<li><a href="#pretty">pretty</a></li>
<li><a href="#wl-pprint-text">wl-pprint-text</a></li>
<li><a href="#pretty-show">pretty-show</a></li>
<li><a href="#haskeline">Haskeline</a></li>
<li><a href="#repline">Repline</a></li>
</ul></li>
<li><a href="#template-haskell">Template Haskell</a><ul>
<li><a href="#perils-of-metaprogramming">Perils of Metaprogramming</a></li>
<li><a href="#quasiquotation">Quasiquotation</a></li>
<li><a href="#language-c-quote">language-c-quote</a></li>
<li><a href="#template-haskell-1">Template Haskell</a></li>
<li><a href="#antiquotation">Antiquotation</a></li>
<li><a href="#templated-type-families">Templated Type Families</a></li>
<li><a href="#templated-type-classes">Templated Type Classes</a></li>
<li><a href="#multiline-strings">Multiline Strings</a></li>
<li><a href="#git-embed">git-embed</a></li>
</ul></li>
<li><a href="#categories">Categories</a><ul>
<li><a href="#algebraic-relations">Algebraic Relations</a></li>
<li><a href="#categories-1">Categories</a></li>
<li><a href="#isomorphisms">Isomorphisms</a></li>
<li><a href="#duality">Duality</a></li>
<li><a href="#functors">Functors</a></li>
<li><a href="#natural-transformations">Natural Transformations</a></li>
<li><a href="#adjunctions">Adjunctions</a></li>
<li><a href="#yoneda-lemma">Yoneda Lemma</a></li>
<li><a href="#kleisli-category">Kleisli Category</a></li>
<li><a href="#resources">Resources</a></li>
</ul></li>
<li><a href="#other-languages">Other Languages</a><ul>
<li><a href="#haskell">Haskell</a></li>
<li><a href="#ocaml">OCaml</a></li>
<li><a href="#standard-ml">Standard ML</a></li>
<li><a href="#agda">Agda</a></li>
<li><a href="#coq">Coq</a></li>
<li><a href="#idris">Idris</a></li>
<li><a href="#rust">Rust</a></li>
<li><a href="#purescript">Purescript</a></li>
<li><a href="#elm">Elm</a></li>
<li><a href="#python">Python</a></li>
<li><a href="#r">R</a></li>
<li><a href="#julia">Julia</a></li>
<li><a href="#erlang">Erlang</a></li>
<li><a href="#elixer">Elixer</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#clojure">Clojure</a></li>
<li><a href="#swift">Swift</a></li>
<li><a href="#scheme">Scheme</a></li>
<li><a href="#racket">Racket</a></li>
<li><a href="#c">C#</a></li>
<li><a href="#f">F#</a></li>
<li><a href="#c-1">C++</a></li>
<li><a href="#go">Go</a></li>
<li><a href="#scala">Scala</a></li>
<li><a href="#javascript">Javascript</a></li>
<li><a href="#kotlin">Kotlin</a></li>
<li><a href="#php">PHP</a></li>
<li><a href="#perl">Perl</a></li>
<li><a href="#lua">Lua</a></li>
</ul></li>
<li><a href="#code">Code</a></li>
</ul>
      </ul>
    </div>

    <div id="main-wrapper">
      <div id="main">
        <h1 class="document-title" itemprop="name">
          What I Wish I Knew When Learning Haskell
        </h1>
        <p itemprop="version" class="document-version">
        Version
        <span class="version">2.3</span>
        </p>
<hr />
<p>% Stephen Diehl % March 2016</p>
<p>Stephen Diehl (<a class="author" href="https://twitter.com/smdiehl"><span class="citation">@smdiehl</span></a> )</p>
<p>This is the fourth draft of this document.</p>
<p><strong><a href="tutorial.pdf">PDF Version</a></strong></p>
<h4 id="license">License</h4>
<p>This code and text are dedicated to the public domain. You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.</p>
<p>You may copy and paste any code here verbatim into your codebase, wiki, blog, book or Haskell musical production as you see fit. The Markdown and Haskell source is <a href="https://github.com/sdiehl/wiwinwlh/tree/master/src">available on Github</a>. Pull requests are always accepted for changes and additional content. This is a living document.</p>
<h4 id="changelog">Changelog</h4>
<p><strong>2.4</strong></p>
<p><strong>2.3</strong></p>
<ul>
<li>Stack</li>
<li>Stackage</li>
<li>ghcid</li>
<li>Nix (Removed)</li>
<li>Aeson (Updated)</li>
<li>Language Extensions (Updated)</li>
<li>Type Holes (Updated)</li>
<li>Partial Type Signatures</li>
<li>Pattern Synonyms (Updated)</li>
<li>Unboxed Types ( Updated )</li>
<li>Vim Integration ( Updated )</li>
<li>Emacs Integration ( Updated )</li>
<li>Strict Language Extension</li>
<li>Injective Type Families</li>
<li>Custom Type Errors</li>
<li>Language Comparisons</li>
<li>Recursive Do</li>
<li>Applicative Do</li>
<li>LiquidHaskell</li>
<li>Cpp</li>
<li>Minimal Pragma</li>
<li>Typeclass Extensions</li>
<li>ExtendedDefaultRules</li>
<li>mmorph</li>
<li>integer-gmp</li>
<li>Static Pointers</li>
<li>spoon</li>
<li>monad-control</li>
<li>monad-base</li>
<li>postgresql-simple</li>
<li>hedis</li>
<li>happy/alex</li>
<li>configurator</li>
<li>string-conv</li>
<li>resource-pool</li>
<li>resourcet</li>
<li>optparse-applicative</li>
<li>hastache</li>
<li>silently</li>
<li>Mulitiline Strings</li>
<li>git-embed</li>
<li>Coercible</li>
<li>-fdefer-type-errors</li>
</ul>
<p><strong>2.2</strong></p>
<p>Sections that have had been added or seen large changes:</p>
<ul>
<li>Irrefutable Patterns</li>
<li>Hackage</li>
<li>Exhaustiveness</li>
<li>Stacktraces</li>
<li>Laziness</li>
<li>Skolem Capture</li>
<li>Foreign Function Pointers</li>
<li>Attoparsec Parser</li>
<li>Inline Cmm</li>
<li>PrimMonad</li>
<li>Specialization</li>
<li>unbound-generics</li>
<li>Editor Integration</li>
<li>EKG</li>
<li>Nix</li>
<li>Haddock</li>
<li>Corecursion</li>
<li>Category</li>
<li>Arrows</li>
<li>Bifunctors</li>
<li>ExceptT</li>
<li>hint / mueval</li>
<li>Roles</li>
<li>Higher Kinds</li>
<li>Kind Polymorphism</li>
<li>Numeric Tower</li>
<li>SAT Solvers</li>
<li>Graph</li>
<li>Sparks</li>
<li>Threadscope</li>
<li>Generic Parsers</li>
<li>GHC Block Diagram</li>
<li>GHC Debug Flags</li>
<li>Core</li>
<li>Inliner</li>
<li>Unboxed Types</li>
<li>Runtime Memory Representation</li>
<li>ghc-heapview</li>
<li>STG</li>
<li>Worker/Wrapper</li>
<li>Z-Encoding</li>
<li>Cmm</li>
<li>Runtime Optimizations</li>
<li>RTS Profiling</li>
<li>Algebraic Relations</li>
</ul>
<hr />
<h1 id="basics">Basics</h1>
<h2 id="cabal">Cabal</h2>
<div class="alert alert-success">
<p>Historically Cabal had a component known as <code>cabal-install</code> that has largely been replaced by <a href="#stack">Stack</a>. The following use of Cabal sandboxes is left for historical reasons and can often be replaced by modern tools.</p>
</div>
<p><a href="https://www.haskell.org/cabal/">Cabal</a> is the build system for Haskell.</p>
<p>For example, to install the <a href="http://hackage.haskell.org/package/parsec">parsec</a> package to your system from <a href="#hackage">Hackage</a>, the upstream source of Haskell packages, invoke the <code>install</code> command:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install parsec           <span class="co"># latest version</span>
$ <span class="kw">cabal</span> install parsec==3.1.5    <span class="co"># exact version</span></code></pre></div>
<p>The usual build invocation for Haskell packages is the following:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> get parsec    <span class="co"># fetch source</span>
$ <span class="kw">cd</span> parsec-3.1.5

$ <span class="kw">cabal</span> configure
$ <span class="kw">cabal</span> build
$ <span class="kw">cabal</span> install</code></pre></div>
<p>To update the package index from Hackage, run:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> update</code></pre></div>
<p>To start a new Haskell project, run:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> init
$ <span class="kw">cabal</span> configure</code></pre></div>
<p>A <code>.cabal</code> file will be created with the configuration options for our new project.</p>
<p>The latest feature of <code>cabal</code> is the addition of <a href="http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html">Sandboxes</a>, ( in cabal &gt; 1.18 ) which are self contained environments of Haskell packages separate from the global package index stored in the <code>./.cabal-sandbox</code> of our project's root. To create a new <code>sandbox</code> for our <code>cabal</code> project, run:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> sandbox init</code></pre></div>
<p>Additionally, the <code>sandbox</code> can be torn down:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> sandbox delete</code></pre></div>
<p>When in the working directory of a project with a <code>sandbox</code> that has a configuration already set up, invoking <code>cabal</code> commands alters the behaviour of cabal itself. For instance, the <code>cabal install</code> command will alter only the install to the local package index, not the global configuration.</p>
<p>To install the dependencies from the <code>.cabal</code> file into the newly created <code>sandbox</code>, run:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install --only-dependencies</code></pre></div>
<p>Dependencies can also be built in parallel by passing <code>-j&lt;n&gt;</code> where <code>n</code> is the number of concurrent builds.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install -j4 --only-dependencies</code></pre></div>
<p>Let's look at an example <code>.cabal</code> file. There are two main entry points that any package may provide: a <code>library</code> and an <code>executable</code>. Multiple executables can be defined, but only one library. In addition, there is a special form of executable entry point <code>Test-Suite</code>, which defines an interface for invoking unit tests from <code>cabal</code>.</p>
<p>For a library, the <code>exposed-modules</code> field in the <code>.cabal</code> file indicates which modules within the package structure will be publicly visible when the package is installed. These modules are the user-facing APIs that we wish to expose to downstream consumers.</p>
<p>For an executable, the <code>main-is</code> field indicates the module that exports the <code>main</code> function running the executable logic of the application. Every module in the package must be listed in one of <code>other-modules</code>, <code>exposed-modules</code> or <code>main-is</code> fields.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">name</span>:               mylibrary
<span class="kw">version</span>:            0.1
<span class="kw">cabal-version</span>:      <span class="kw">&gt;</span>= 1.10
<span class="kw">author</span>:             Paul Atreides
<span class="kw">license</span>:            MIT
<span class="kw">license-file</span>:       LICENSE
<span class="kw">synopsis</span>:           The code must flow.
<span class="kw">category</span>:           Math
<span class="kw">tested-with</span>:        GHC
<span class="kw">build-type</span>:         Simple

<span class="kw">library</span>
    <span class="kw">exposed-modules</span>:
      <span class="kw">Library.ExampleModule1</span>
      <span class="kw">Library.ExampleModule2</span>

    <span class="kw">build-depends</span>:
      <span class="kw">base</span> <span class="kw">&gt;</span>= 4 <span class="kw">&amp;&amp;</span> <span class="kw">&lt;</span> <span class="kw">5</span>

    <span class="kw">default-language</span>: Haskell2010

    <span class="kw">ghc-options</span>: -O2 -Wall -fwarn-tabs

<span class="kw">executable</span> <span class="st">&quot;example&quot;</span>
    <span class="kw">build-depends</span>:
        <span class="kw">base</span> <span class="kw">&gt;</span>= 4 <span class="kw">&amp;&amp;</span> <span class="kw">&lt;</span> <span class="kw">5</span>,
        <span class="kw">mylibrary</span> == 0.1
    <span class="kw">default-language</span>: Haskell2010
    <span class="kw">main-is</span>: Main.hs

<span class="kw">Test-Suite</span> test
  <span class="kw">type</span>: exitcode-stdio-1.0
  <span class="kw">main-is</span>: Test.hs
  <span class="kw">default-language</span>: Haskell2010
  <span class="kw">build-depends</span>:
      <span class="kw">base</span> <span class="kw">&gt;</span>= 4 <span class="kw">&amp;&amp;</span> <span class="kw">&lt;</span> <span class="kw">5</span>,
      <span class="kw">mylibrary</span> == 0.1</code></pre></div>
<p>To run an &quot;executable&quot; for a project under the <code>cabal</code> <code>sandbox</code>:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> run
$ <span class="kw">cabal</span> run <span class="kw">&lt;</span>name<span class="kw">&gt;</span> <span class="co"># when there are several executables in a project</span></code></pre></div>
<p>To load the &quot;library&quot; into a <a href="#ghci">GHCi</a> shell under <code>cabal</code> <code>sandbox</code>:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> repl
$ <span class="kw">cabal</span> repl <span class="kw">&lt;</span>name<span class="kw">&gt;</span></code></pre></div>
<p>The <code>&lt;name&gt;</code> metavariable is either one of the executable or library declarations in the <code>.cabal</code> file and can optionally be disambiguated by the prefix <code>exe:&lt;name&gt;</code> or <code>lib:&lt;name&gt;</code> respectively.</p>
<p>To build the package locally into the <code>./dist/build</code> folder, execute the <code>build</code> command:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> build</code></pre></div>
<p>To run the tests, our package must itself be reconfigured with the <code>--enable-tests</code> and the <code>build-depends</code> options. The <code>Test-Suite</code> must be installed manually, if not already present.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install --only-dependencies --enable-tests
$ <span class="kw">cabal</span> configure --enable-tests
$ <span class="kw">cabal</span> test
$ <span class="kw">cabal</span> test <span class="kw">&lt;</span>name<span class="kw">&gt;</span></code></pre></div>
<p>Moreover, arbitrary shell commands can be invoked with the <a href="https://www.haskell.org/ghc/">GHC</a> environmental variables set up for the <code>sandbox</code>. Quite common is to invoke a new shell with this command such that the <code>ghc</code> and <code>ghci</code> commands use the <code>sandbox</code>. ( They don't by default, which is a common source of frustration. ).</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> exec
$ <span class="kw">cabal</span> exec sh <span class="co"># launch a shell with GHC sandbox path set.</span></code></pre></div>
<p>The <a href="#haddock">haddock</a> documentation can be generated for the local project by executing the <code>haddock</code> command. The documentation will be built to the <code>./dist</code> folder.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> haddock</code></pre></div>
<p>When we're finally ready to upload to Hackage ( presuming we have a Hackage account set up ), then we can build the tarball and upload with the following commands:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> sdist
$ <span class="kw">cabal</span> upload dist/mylibrary-0.1.tar.gz</code></pre></div>
<p>Sometimes you'd also like to add a library from a local project into a <code>sandbox</code>. In this case, run the <code>add-source</code> command to bring the library into the <code>sandbox</code> from a local directory:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> sandbox add-source /path/to/project</code></pre></div>
<p>The current state of a <code>sandbox</code> can be frozen with all current package constraints enumerated:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> freeze</code></pre></div>
<p>This will create a file <code>cabal.config</code> with the constraint set.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">constraints<span class="fu">:</span> mtl <span class="fu">==</span><span class="fl">2.2</span><span class="fu">.</span><span class="dv">1</span>,
             text <span class="fu">==</span><span class="fl">1.1</span><span class="fu">.</span><span class="fl">1.3</span>,
             transformers <span class="fu">==</span><span class="fl">0.4</span><span class="fu">.</span><span class="fl">1.0</span></code></pre></div>
<p>Using the <code>cabal repl</code> and <code>cabal run</code> commands is preferable, but sometimes we'd like to manually perform their equivalents at the shell. Several useful aliases rely on shell directory expansion to find the package database in the current working directory and launch GHC with the appropriate flags:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">alias</span> ghc-sandbox=<span class="st">&quot;ghc -no-user-package-db -package-db .cabal-sandbox/*-packages.conf.d&quot;</span>
<span class="kw">alias</span> ghci-sandbox=<span class="st">&quot;ghci -no-user-package-db -package-db .cabal-sandbox/*-packages.conf.d&quot;</span>
<span class="kw">alias</span> runhaskell-sandbox=<span class="st">&quot;runhaskell -no-user-package-db -package-db .cabal-sandbox/*-packages.conf.d&quot;</span></code></pre></div>
<p>There is also a zsh script to show the sandbox status of the current working directory in our shell:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">function</span><span class="fu"> cabal_sandbox_info()</span> <span class="kw">{</span>
    <span class="ot">cabal_files=(</span>*.cabal(N<span class="ot">)</span>)
    <span class="kw">if [</span> <span class="ot">$#</span>cabal_files <span class="ot">-gt</span> 0<span class="kw"> ]</span>; <span class="kw">then</span>
        <span class="kw">if [</span> <span class="ot">-f</span> cabal.sandbox.config<span class="kw"> ]</span>; <span class="kw">then</span>
            <span class="kw">echo</span> <span class="st">&quot;%{</span><span class="ot">$fg[green]</span><span class="st">%}sandboxed%{</span><span class="ot">$reset_color</span><span class="st">%}&quot;</span>
        <span class="kw">else</span>
            <span class="kw">echo</span> <span class="st">&quot;%{</span><span class="ot">$fg[red]</span><span class="st">%}not sandboxed%{</span><span class="ot">$reset_color</span><span class="st">%}&quot;</span>
        <span class="kw">fi</span>
    <span class="kw">fi</span>
<span class="kw">}</span>

<span class="ot">RPROMPT=</span><span class="st">&quot;</span><span class="dt">\$</span><span class="st">(cabal_sandbox_info) </span><span class="ot">$RPROMPT</span><span class="st">&quot;</span></code></pre></div>
<p>The <code>cabal</code> configuration is stored in <code>$HOME/.cabal/config</code> and contains various options including credential information for Hackage upload. One addition to configuration is to completely disallow the installation of packages outside of sandboxes to prevent accidental collisions.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl">-- Don<span class="kw">&#39;</span><span class="st">t allow global install of packages.</span>
<span class="st">require-sandbox: True</span></code></pre></div>
<p>A library can also be compiled with runtime profiling information enabled. More on this is discussed in the section on <a href="#concurrency">Concurrency</a> and <a href="#profiling">Profiling</a>.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl">library-profiling: True</code></pre></div>
<p>Another common flag to enable is <code>documentation</code> which forces the local build of Haddock documentation, which can be useful for offline reference. On a Linux filesystem these are built to the <code>/usr/share/doc/ghc-doc/html/libraries/</code> directory.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl">documentation: True</code></pre></div>
<p>If GHC is currently installed, the documentation for the Prelude and Base libraries should be available at this local link:</p>
<p><a href="file:///usr/share/doc/ghc-doc/html/libraries/index.html">/usr/share/doc/ghc-doc/html/libraries/index.html</a></p>
<p>See:</p>
<ul>
<li><a href="http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html">An Introduction to Cabal Sandboxes</a></li>
<li><a href="http://www.vex.net/~trebla/haskell/sicp.xhtml">Storage and Identification of Cabalized Packages</a></li>
</ul>
<h2 id="stack">Stack</h2>
<p><a href="http://docs.haskellstack.org/en/stable/README/">Stack</a> is a new approach to Haskell package structure that emerged in 2015. Instead of using a rolling build like <code>cabal-install</code>, <code>stack</code> breaks up sets of packages into release blocks that guarantee internal compatibility between sets of packages. The package solver for <code>stack</code> uses a different, more robust strategy for resolving dependencies than <code>cabal-install</code> has historically used.</p>
<div class="alert alert-success">
<p>Contrary to much misinformation, <strong>Stack does not replace <a href="#cabal">Cabal</a> as the build system</strong> and <a href="http://docs.haskellstack.org/en/stable/faq/#what-is-the-relationship-between-stack-and-cabal">uses it under the hood</a>. Stack simply streamlines integration with third-party packages and the resolution of their dependencies.</p>
</div>
</hr>
<h4 id="install">Install</h4>
<p>To install <code>stack</code> on Ubuntu Linux, run:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">sudo</span> apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 575159689BEFB442                             <span class="co"># get fp complete key</span>
<span class="kw">echo</span> <span class="st">&#39;deb http://download.fpcomplete.com/ubuntu trusty main&#39;</span><span class="kw">|sudo</span> tee /etc/apt/sources.list.d/fpco.list    <span class="co"># add appropriate source repo</span>
<span class="kw">sudo</span> apt-get update <span class="kw">&amp;&amp;</span> <span class="kw">sudo</span> apt-get install stack -y</code></pre></div>
<p>For other operating systems, see <a href="http://docs.haskellstack.org/en/stable/install_and_upgrade/">the official install directions</a>.</p>
<h4 id="usage">Usage</h4>
<p>Once <code>stack</code> is installed, it is possible to setup a build environment on top of your existing project's <code>cabal</code> file by running:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">stack</span> init</code></pre></div>
<p>An example <code>stack.yaml</code> file for <a href="https://www.haskell.org/ghc">GHC</a> 7.10.3 would look like:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">resolver</span>: lts-6.4
<span class="kw">flags</span>: <span class="dt">{}</span>
<span class="kw">extra-package-dbs</span>: []
<span class="kw">packages</span>: []
<span class="kw">extra-deps</span>: []</code></pre></div>
<p>Most of the common libraries used in everyday development are already in the <a href="https://www.stackage.org/">Stackage</a> repository. The <code>extra-deps</code> field can be used to add <a href="http://hackage.haskell.org/">Hackage</a> dependencies that are not in the Stackage repository. They are specified by the package and the version key. For instance, the <code>zenc</code> package could be added to the <code>stack</code> build:</p>
<pre><code>extra-deps:
- zenc-0.1.1</code></pre>
<p>The <code>stack</code> command can be used to install packages and executables into either the current build environment or the global environment. For example, the following command installs the executable for <code>hlint</code>, <a href="https://github.com/ndmitchell/hlint">a popular linting tool for Haskell</a>, and places it in the PATH:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">stack</span> install hlint</code></pre></div>
<p>To check the set of dependencies, run:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">stack</span> list-dependencies</code></pre></div>
<p>Just as with <code>cabal</code>, the build and debug process can be orchestrated using <code>stack</code> commands:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">stack</span> build                 <span class="co"># Build a cabal target</span>
$ <span class="kw">stack</span> repl                  <span class="co"># Launch ghci</span>
$ <span class="kw">stack</span> ghc                   <span class="co"># Invoke the standalone compiler in stack environment</span>
$ <span class="kw">stack</span> exec bash             <span class="co"># Execute a shell command with the stack GHC environment variables</span>
$ <span class="kw">stack</span> build --file-watch    <span class="co"># Build on every filesystem change</span></code></pre></div>
<p>To visualize the dependency graph, use the dot command piped first into graphviz, then piped again into your favorite image viewer:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">stack</span> dot --external <span class="kw">|</span> <span class="kw">dot</span> -Tpng <span class="kw">|</span> <span class="kw">feh</span> -</code></pre></div>
<h2 id="flags">Flags</h2>
<p>Enabling <a href="https://www.haskell.org/ghc">GHC</a> <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flag-reference.html">compiler flags</a> grants the user more control in detecting common code errors. The most frequently used flags are:</p>
<table>
<thead>
<tr class="header">
<th align="left">Flag</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">-fwarn-tabs</td>
<td align="left">Emit warnings of tabs instead of spaces in the source code</td>
</tr>
<tr class="even">
<td align="left">-fwarn-unused-imports</td>
<td align="left">Warn about libraries imported without being used</td>
</tr>
<tr class="odd">
<td align="left">-fwarn-name-shadowing</td>
<td align="left">Warn on duplicate names in nested bindings</td>
</tr>
<tr class="even">
<td align="left">-fwarn-incomplete-uni-patterns</td>
<td align="left">Emit warnings for incomplete patterns in lambdas or pattern bindings</td>
</tr>
<tr class="odd">
<td align="left">-fwarn-incomplete-patterns</td>
<td align="left">Warn on non-exhaustive patterns</td>
</tr>
<tr class="even">
<td align="left">-fwarn-overlapping-patterns</td>
<td align="left">Warn on pattern matching branches that overlap</td>
</tr>
<tr class="odd">
<td align="left">-fwarn-incomplete-record-updates</td>
<td align="left">Warn when records are not instantiated with all fields</td>
</tr>
<tr class="even">
<td align="left">-fdefer-type-errors</td>
<td align="left">Turn type errors into warnings</td>
</tr>
<tr class="odd">
<td align="left">-fwarn-missing-signatures</td>
<td align="left">Warn about toplevel missing type signatures</td>
</tr>
<tr class="even">
<td align="left">-fwarn-monomorphism-restriction</td>
<td align="left">Warn when the monomorphism restriction is applied implicitly</td>
</tr>
<tr class="odd">
<td align="left">-fwarn-orphans</td>
<td align="left">Warn on orphan typeclass instances</td>
</tr>
<tr class="even">
<td align="left">-fforce-recomp</td>
<td align="left">Force recompilation regardless of timestamp</td>
</tr>
<tr class="odd">
<td align="left">-fno-code</td>
<td align="left">Omit code generation, just parse and typecheck</td>
</tr>
<tr class="even">
<td align="left">-fobject-code</td>
<td align="left">Generate object code</td>
</tr>
</tbody>
</table>
<p>Like most compilers, GHC takes the <code>-Wall</code> flag to enable all warnings. However, a few of the enabled warnings are highly verbose. For example, <code>-fwarn-unused-do-bind</code> and <code>-fwarn-unused-matches</code> typically would not correspond to errors or failures.</p>
<p>Any of these flags can be added to the <code>ghc-options</code> section of a project's <code>.cabal</code> file. For example:</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl">library mylib

  ghc-options:
    -fwarn-tabs
    -fwarn-unused-imports
    -fwarn-missing-signatures
    -fwarn-name-shadowing
    -fwarn-incomplete-patterns</code></pre></div>
<p>The flags described above are simply the most useful. See the <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flag-reference.html">official reference</a> for the complete set of GHC's supported flags.</p>
<p>For information on debugging GHC internals, see the <a href="#block-diagram">commentary</a> on GHC internals.</p>
<h2 id="hackage">Hackage</h2>
<p><a href="http://hackage.haskell.org/">Hackage</a> is the upstream source of <a href="://www.fsf.org/about/what-is-free-software">Free</a> and/or <a href="https://opensource.org/">Open Source</a> Haskell packages. With Haskell's continuing evolution, Hackage has become many things to developers, but there seem to be two dominant philosophies of uploaded libraries.</p>
<p><strong>Reusable Code / Building Blocks</strong></p>
<p>In the first philosophy, libraries exist as reliable, community-supported building blocks for constructing higher level functionality on top of a common, stable edifice. In development communities where this method is the dominant philosophy, the author(s) of libraries have written them as a means of packaging up their understanding of a problem domain so that others can build on their understanding and expertise.</p>
<p><strong>A Staging Area / Request for Comments</strong></p>
<p>In contrast to the previous method of packaging, a common philosophy in the Haskell community is that Hackage is a place to upload experimental libraries as a means of getting community feedback and making the code publicly available. Library author(s) often rationalize putting these kind of libraries up undocumented, often without indication of what the library actually does, by simply stating that they intend to tear the code down and rewrite it later. This approach unfortunately means a lot of Hackage namespace has become polluted with dead-end, bit-rotting code. Sometimes packages are also uploaded purely for internal use within an organisation, to accompany a paper, or just to integrate with the <code>cabal</code> build system. These packages are often left undocumented as well.</p>
<p>For developers coming to Haskell from other language ecosystems that favor the former philsophy (e.g., Python, Javascript, Ruby), seeing <em>thousands of libraries without the slightest hint of documentation or description of purpose</em> can be unnerving. It is an open question whether the current cultural state of Hackage is sustainable in light of these philsophical differences.</p>
<p>Needless to say, there is a lot of very low-quality Haskell code and documentation out there today, so being conservative in library assessment is a necessary skill. That said, there are also quite a few phenomenal libraries on Hackage that are highly curated by many people.</p>
<p>As a general rule, if the Haddock documentation for the library does not have a <strong>minimal worked example</strong>, it is usually safe to assume that it is an RFC-style library and probably should be avoided in production-grade code.</p>
<p>Similarly, if the library <strong>predates the <a href="http://hackage.haskell.org/package/text">text</a> library</strong> (released circa 2007), it probably should be avoided in production code. The way we write Haskell has changed drastically since the early days.</p>
<h2 id="ghci">GHCi</h2>
<p><a href="https://wiki.haskell.org/GHC/GHCi">GHCi</a> is the interactive shell for the <a href="https://www.haskell.org/GHC">GHC</a> compiler. GHCi is where we will spend most of our time in every day development.</p>
<table>
<thead>
<tr class="header">
<th align="left">Command</th>
<th align="left">Shortcut</th>
<th align="left">Action</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>:reload</code></td>
<td align="left"><code>:r</code></td>
<td align="left">Code reload</td>
</tr>
<tr class="even">
<td align="left"><code>:type</code></td>
<td align="left"><code>:t</code></td>
<td align="left">Type inspection</td>
</tr>
<tr class="odd">
<td align="left"><code>:kind</code></td>
<td align="left"><code>:k</code></td>
<td align="left">Kind inspection</td>
</tr>
<tr class="even">
<td align="left"><code>:info</code></td>
<td align="left"><code>:i</code></td>
<td align="left">Information</td>
</tr>
<tr class="odd">
<td align="left"><code>:print</code></td>
<td align="left"><code>:p</code></td>
<td align="left">Print the expression</td>
</tr>
<tr class="even">
<td align="left"><code>:edit</code></td>
<td align="left"><code>:e</code></td>
<td align="left">Load file in system editor</td>
</tr>
<tr class="odd">
<td align="left"><code>:load</code></td>
<td align="left"><code>:l</code></td>
<td align="left">Set the active Main module in the REPL</td>
</tr>
<tr class="even">
<td align="left"><code>:add</code></td>
<td align="left"><code>:ad</code></td>
<td align="left">Load a file into the REPL namespace</td>
</tr>
<tr class="odd">
<td align="left"><code>:browse</code></td>
<td align="left"><code>:bro</code></td>
<td align="left">Browse all available symbols in the REPL namespace</td>
</tr>
</tbody>
</table>
<p>The introspection commands are an essential part of debugging and interacting with Haskell code:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> <span class="fu">:</span><span class="kw">type</span> <span class="dv">3</span>
<span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> <span class="fu">:</span>kind <span class="dt">Either</span>
<span class="dt">Either</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> <span class="fu">:</span>info <span class="dt">Functor</span>
<span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span>
<span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b
<span class="ot">  (&lt;$) ::</span> a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f a
        <span class="co">-- Defined in `GHC.Base&#39;</span>
  <span class="fu">...</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> <span class="fu">:</span>i (<span class="fu">:</span>)
<span class="kw">data</span> [] a <span class="fu">=</span> <span class="fu">...</span> <span class="fu">|</span> a <span class="fu">:</span> [a]       <span class="co">-- Defined in `GHC.Types&#39;</span>
<span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:</span></code></pre></div>
<p>Querying the current state of the global environment in the shell is also possible. For example, to view module-level bindings and types in GHCi, run:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> <span class="fu">:</span>browse
λ<span class="fu">:</span> <span class="fu">:</span>show bindings</code></pre></div>
<p>Examining module-level imports, execute:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> <span class="fu">:</span>show imports
<span class="kw">import </span><span class="dt">Prelude</span> <span class="co">-- implicit</span>
<span class="kw">import </span><span class="dt">Data.Eq</span>
<span class="kw">import </span><span class="dt">Control.Monad</span></code></pre></div>
<p>To see compiler-level flags and pragmas, use:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> <span class="fu">:</span>set
options currently set<span class="fu">:</span> none<span class="fu">.</span>
base language is<span class="fu">:</span> <span class="dt">Haskell2010</span>
with the following modifiers<span class="fu">:</span>
  <span class="fu">-</span><span class="dt">XNoDatatypeContexts</span>
  <span class="fu">-</span><span class="dt">XNondecreasingIndentation</span>
<span class="dt">GHCi</span><span class="fu">-</span>specific dynamic flag settings<span class="fu">:</span>
other dynamic, non<span class="fu">-</span>language, flag settings<span class="fu">:</span>
  <span class="fu">-</span>fimplicit<span class="fu">-</span>import<span class="fu">-</span>qualified
warning settings<span class="fu">:</span>

λ<span class="fu">:</span> <span class="fu">:</span>showi language
base language is<span class="fu">:</span> <span class="dt">Haskell2010</span>
with the following modifiers<span class="fu">:</span>
  <span class="fu">-</span><span class="dt">XNoDatatypeContexts</span>
  <span class="fu">-</span><span class="dt">XNondecreasingIndentation</span>
  <span class="fu">-</span><span class="dt">XExtendedDefaultRules</span></code></pre></div>
<p>Language extensions and compiler pragmas can be set at the prompt. See the <a href="#flags">Flag Reference</a> for the vast collection of compiler flag options.</p>
<p>Several commands for the interactive shell have shortcuts:</p>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>+t</code></td>
<td align="left">Show types of evaluated expressions</td>
</tr>
<tr class="even">
<td align="left"><code>+s</code></td>
<td align="left">Show timing and memory usage</td>
</tr>
<tr class="odd">
<td align="left"><code>+m</code></td>
<td align="left">Enable multi-line expression delimited by <code>:{</code> and <code>:}</code>.</td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> <span class="fu">:</span>set <span class="fu">+</span>t
λ<span class="fu">:</span> []
[]
<span class="ot">it ::</span> [a]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> <span class="fu">:</span>set <span class="fu">+</span>s
λ<span class="fu">:</span> foldr (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">25</span>]
<span class="dv">325</span>
<span class="ot">it ::</span> <span class="dt">Prelude.Integer</span>
(<span class="fl">0.02</span> secs, <span class="dv">4900952</span> bytes)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> <span class="fu">:</span>{
λ<span class="fu">:|</span> <span class="kw">let</span> foo <span class="fu">=</span> <span class="kw">do</span>
λ<span class="fu">:|</span>           putStrLn <span class="st">&quot;hello ghci&quot;</span>
λ<span class="fu">:|</span> <span class="fu">:</span>}
λ<span class="fu">:</span> foo
<span class="st">&quot;hello ghci&quot;</span></code></pre></div>
<p>The configuration for the GHCi shell can be customized globally by defining a <code>ghci.conf</code> in <code>$HOME/.ghc/</code> or in the current working directory as <code>./.ghci.conf</code>.</p>
<p>For example, we can add a command to use the <a href="https://www.haskell.org/hoogle/">Hoogle</a> type search from within GHCi. First, install <code>hoogle</code>:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">cabal</span> install hoogle</code></pre></div>
<p>Then, we can enable the search functionality by adding a command to our <code>ghci.conf</code>:</p>
<div class="sourceCode" include="src/01-basics/ghci.conf"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">:</span>set prompt <span class="st">&quot;λ: &quot;</span>

<span class="fu">:</span>def hlint const <span class="fu">.</span> return <span class="fu">$</span> <span class="st">&quot;:! hlint \&quot;src\&quot;&quot;</span>
<span class="fu">:</span>def hoogle \s <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="st">&quot;:! hoogle --count=15 \&quot;&quot;</span> <span class="fu">++</span> s <span class="fu">++</span> <span class="st">&quot;\&quot;&quot;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> <span class="fu">:</span>hoogle (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b
<span class="dt">Data.Traversable</span><span class="ot"> fmapDefault ::</span> <span class="dt">Traversable</span> t <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t b
<span class="dt">Prelude</span><span class="ot"> fmap ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre></div>
<p>For reasons of sexiness, it is desirable to set your GHC prompt to a <code>λ</code> or a <code>λΠ</code>. Only if you're into that lifestyle, though.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">:</span>set prompt <span class="st">&quot;λ: &quot;</span>
<span class="fu">:</span>set prompt <span class="st">&quot;ΠΣ: &quot;</span></code></pre></div>
<h4 id="ghci-performance">GHCi Performance</h4>
<p>For large projects, GHCi with the default flags can use quite a bit of memory and take a long time to compile. To speed compilation by keeping artificats for compiled modules around, we can enable object code compilation instead of bytecode.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">:</span>set <span class="fu">-</span>fobject<span class="fu">-</span>code</code></pre></div>
<p>Enabling object code compliation may complicate type inference, since type information provided to the shell can sometimes be less informative than source-loaded code. This under specificity can result in breakage with some langauge extensions. In that case, you can temporarily reenable bytecode compilation on a per module basis with the <code>-fbyte-code</code> flag.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">:</span>set <span class="fu">-</span>fbyte<span class="fu">-</span>code
<span class="fu">:</span>load MyModule.hs</code></pre></div>
<p>If you all you need is to typecheck your code in the interactive shell, then disabling code generation entirely makes reloading code almost instantaneous:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">:</span>set <span class="fu">-</span>fno<span class="fu">-</span>code</code></pre></div>
<h2 id="editor-integration">Editor Integration</h2>
<p>Haskell has a variety of editor tools that can be used to provide interactive development feedback and functionality such as querying types of subexpressions, linting, type checking, and code completion.</p>
<p>Several prepackaged setups exist to expedite the process of setting up many of the programmer editors for Haskell development. In particular, using <code>ghc-mod</code> can remarkably improve programmer efficiency and productivity because <a href="http://www.mew.org/~kazu/proj/ghc-mod/en/">the project</a> attempts to implement features common to modern IDEs.</p>
<p><strong>Vim</strong></p>
<ul>
<li><a href="https://github.com/begriffs/haskell-vim-now">haskell-vim-now</a></li>
<li><a href="../../www.stephendiehl.com/posts/vim_2016.html">Vim and Haskell in 2016</a></li>
</ul>
<p><strong>Emacs</strong></p>
<ul>
<li><a href="https://github.com/chrisdone/emacs-haskell-config">Chris Done's Emacs Config</a></li>
<li><a href="http://tim.dysinger.net/posts/2014-02-18-haskell-with-emacs.html">Haskell Development From Emacs</a></li>
<li><a href="https://github.com/chrisdone/structured-haskell-mode">Structured Haskell Mode</a></li>
</ul>
<p><strong>Atom</strong></p>
<ul>
<li><a href="https://atom.io/packages/language-haskell">language-haskell plugin</a></li>
<li><a href="https://atom.io/packages/ide-haskell">ide-haskell plugin</a></li>
</ul>
<h2 id="bottoms">Bottoms</h2>
<p>The bottom is a singular value that inhabits every type. When this value is evaluated, the semantics of Haskell no longer yield a meaningful value. In other words, further operations on the value cannot be defined in Haskell. A bottom value is usually written as the symbol <a href="../../en.wikipedia.org/wiki/Up_tack.html">⊥</a>, ( i.e. the compiler flipping you off ). Several ways exist to express bottoms in Haskell code.</p>
<p>For instance, <code>undefined</code> is an easily called example of a bottom value. This function has type <code>a</code> but lacks any type constraints in its type signature. Thus, <code>undefined</code> is able to stand in for any type in a function body, allowing type checking to succeed, even if the function is incomplete or lacking a definition entirely. The <code>undefined</code> function is extremely practical for debugging or to accommodate writing incomplete programs.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">undefined<span class="ot"> ::</span> a


<span class="ot">mean ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> a
mean nums <span class="fu">=</span> (total <span class="fu">/</span> count) <span class="kw">where</span>            <span class="co">-- Partially defined function</span>
              total <span class="fu">=</span> undefined
              count <span class="fu">=</span> undefined

<span class="ot">addThreeNums ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
addThreeNums n m j <span class="fu">=</span> undefined               <span class="co">-- No function body declared at all</span>

<span class="ot">f ::</span> a <span class="ot">-&gt;</span> <span class="dt">Complicated</span> <span class="dt">Type</span>
f <span class="fu">=</span> undefined                                <span class="co">-- Write tomorrow, typecheck today!</span>
                                             <span class="co">-- Arbitrarily complicated types</span>
                                             <span class="co">-- welcome!</span></code></pre></div>
<p>Another example of a bottom value comes from the evaluation of the <code>error</code> function, which takes a <code>String</code> and returns something that can be of any type. This property is quite similar to <code>undefined</code>, which also can also stand in for any type.</p>
<p>Calling <code>error</code> in a function causes the compiler to throw an exception, halt the program, and print the specified error message. In the <code>divByY</code> function below, passing the function <code>0</code> as the divisor results in this function results in such an exception.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">error<span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a                       <span class="co">-- Takes an error message of type</span>
                                           <span class="co">-- String and returns whatever type</span>
                                           <span class="co">-- is needed</span></code></pre></div>
<div class="sourceCode" include="src/01-basics/errors.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="co">-- Annotated code that features use of the error function.</span>

<span class="ot">divByY::</span> (<span class="dt">Num</span> a, <span class="dt">Eq</span> a, <span class="dt">Fractional</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
divByY _ <span class="dv">0</span> <span class="fu">=</span> error <span class="st">&quot;Divide by zero error&quot;</span>      <span class="co">-- Dividing by 0 causes an error</span>
divByY dividend divisor <span class="fu">=</span> dividend <span class="fu">/</span> divisor   <span class="co">-- Handles defined division</span>
</code></pre></div>
<p>A third type way to express a bottom is with an infinitely looping term:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> a
f <span class="fu">=</span> <span class="kw">let</span> x <span class="fu">=</span> x <span class="kw">in</span> x</code></pre></div>
<p>Examples of actual Haskell code that use this looping syntax live in the source code of the <a href="https://hackage.haskell.org/package/ghc-prim-0.4.0.0/docs/GHC-Prim.html">GHC.Prim</a> module. These bottoms exist because the operations <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/users_guide/primitives.html">cannot be defined in native Haskell</a>. Such operations are baked into the compiler at a very low level. However, this module exists so that <a href="#haddock">Haddock</a> can generate documentation for these primitive operations, while the looping syntax serves as a placeholder for the actual implementation of the primops.</p>
<p>Perhaps the most common introduction to bottoms is writing a partial function that does not have <a href="#exhaustiveness">exhaustive</a> pattern matching defined. For example, the following code has non-exhaustive pattern matching because the <code>case</code> expression, lacks a definition of what to do with a <code>B</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">F</span> <span class="fu">=</span> <span class="dt">A</span> <span class="fu">|</span> <span class="dt">B</span>
<span class="kw">case</span> x <span class="kw">of</span>
  <span class="dt">A</span> <span class="ot">-&gt;</span> ()</code></pre></div>
<p>The code snippet above is translated into the following <a href="#code">GHC Core</a> output. The compiler inserts an exception to account for the non-exhaustive patterns:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">case</span> x <span class="kw">of</span> _ {
  <span class="dt">A</span> <span class="ot">-&gt;</span> ();
  <span class="dt">B</span> <span class="ot">-&gt;</span> patError <span class="st">&quot;&lt;interactive&gt;:3:11-31|case&quot;</span>
}</code></pre></div>
<p>GHC can be made more vocal about incomplete patterns using the <code>-fwarn-incomplete-patterns</code> and <code>-fwarn-incomplete-uni-patterns</code> flags.</p>
<p>A similar situation can arise with records. Although constructing a record with missing fields is rarely useful, it is still possible.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Foo</span> <span class="fu">=</span> <span class="dt">Foo</span> {<span class="ot"> example1 ::</span> <span class="dt">Int</span> }
f <span class="fu">=</span> <span class="dt">Foo</span> {}     <span class="co">-- Record defined with a missing field</span></code></pre></div>
<p>When the developer omits a field's definition, the compiler inserts an exception in the GHC Core representation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Foo</span> (recConError <span class="st">&quot;&lt;interactive&gt;:4:9-12|a&quot;</span>)</code></pre></div>
<p>Fortunately, GHC will warn us by default about missing record fields.</p>
<p>Bottoms are used extensively throughout <a href="#prelude">the Prelude</a>, although this fact may not be immediately apparent. The reasons for including bottoms are either practical or historical.</p>
<p>The canonical example is the <code>head</code> function which has type <code>[a] -&gt; a</code>. This function could not be well-typed without the bottom.</p>
<div class="sourceCode" include="src/01-basics/bottoms.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">GHC.Err</span>
<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (head, (!!), undefined)

<span class="co">-- degenerate functions</span>

undefined<span class="ot"> ::</span> a
undefined <span class="fu">=</span>  error <span class="st">&quot;Prelude.undefined&quot;</span>

head<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> a
head (x<span class="fu">:</span>_) <span class="fu">=</span>  x
head []    <span class="fu">=</span>  error <span class="st">&quot;Prelude.head: empty list&quot;</span>

<span class="ot">(!!) ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a
xs     <span class="fu">!!</span> n <span class="fu">|</span> n <span class="fu">&lt;</span> <span class="dv">0</span> <span class="fu">=</span>  error <span class="st">&quot;Prelude.!!: negative index&quot;</span>
[]     <span class="fu">!!</span> _         <span class="fu">=</span>  error <span class="st">&quot;Prelude.!!: index too large&quot;</span>
(x<span class="fu">:</span>_)  <span class="fu">!!</span> <span class="dv">0</span>         <span class="fu">=</span>  x
(_<span class="fu">:</span>xs) <span class="fu">!!</span> n         <span class="fu">=</span>  xs <span class="fu">!!</span> (n<span class="fu">-</span><span class="dv">1</span>)</code></pre></div>
<p>It is rare to see these partial functions thrown around carelessly in production code because they cause the program to halt. The preferred method for handling exceptions is to combine the use of safe variants provided in <code>Data.Maybe</code> with the usual fold functions <code>maybe</code> and <code>either</code>.</p>
<p>Another method is to use pattern matching, as shown in <code>listToMaybe</code>, a safer version of <code>head</code> described below:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">listToMaybe ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
listToMaybe []     <span class="fu">=</span>  <span class="dt">Nothing</span>    <span class="co">-- An empty list returns Nothing</span>
listToMaybe (a<span class="fu">:</span>_)  <span class="fu">=</span>  <span class="dt">Just</span> a     <span class="co">-- A non-empty list returns the first element</span>
                                 <span class="co">-- wrapped in the Just context.</span></code></pre></div>
<p>Invoking a bottom defined in terms of <code>error</code> typically will not generate any position information. However, <code>assert</code>, which is used to provide assertions, can be short-circuited to generate position information in the place of either <code>undefined</code> or <code>error</code> calls.</p>
<div class="sourceCode" include="src/01-basics/fail.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">GHC.Base</span>

<span class="ot">foo ::</span> a
foo <span class="fu">=</span> undefined
<span class="co">-- *** Exception: Prelude.undefined</span>

<span class="ot">bar ::</span> a
bar <span class="fu">=</span> assert <span class="dt">False</span> undefined
<span class="co">-- *** Exception: src/fail.hs:8:7-12: Assertion failed</span></code></pre></div>
<p>See: <a href="https://wiki.haskell.org/Avoiding_partial_functions">Avoiding Partial Functions</a></p>
<h2 id="exhaustiveness">Exhaustiveness</h2>
<p>Pattern matching in Haskell allows for the possibility of non-exhaustive patterns. For example, passing Nothing to <code>unsafe</code> will cause the program to crash at runtime. However, this function is an otherwise valid, type-checked program.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">unsafe ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
unsafe (<span class="dt">Just</span> x) <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> x <span class="fu">+</span> <span class="dv">1</span></code></pre></div>
<p>Since <code>unsafe</code> takes a <code>Maybe a</code> value as its argument, two possible values are valid input: <code>Nothing</code> and <code>Just a</code>. Since the case of a <code>Nothing</code> was not defined in <code>unsafe</code>, we say that the pattern matching within that function is <em>non-exhaustive</em>. In other words, the function does not implement appropriate handling of all valid inputs. Instead of yielding a value, such a function will halt from an incomplete match.</p>
<p>Partial functions from non-exhaustivity are a controversial subject, and frequent use of non-exhaustive patterns is considered a dangerous code smell. However, the complete removal of non-exhaustive patterns from the language would itself be too restrictive and forbid too many valid programs.</p>
<p>Several flags exist that we can pass to the compiler to warn us about such patterns or forbid them entirely either locally or globally.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">$</span> ghc <span class="fu">-</span>c <span class="fu">-</span><span class="dt">Wall</span> <span class="fu">-</span><span class="dt">Werror</span> A.hs
A.hs<span class="fu">:</span><span class="dv">3</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span>
    <span class="dt">Warning</span><span class="fu">:</span> <span class="dt">Pattern</span> match(es) are non<span class="fu">-</span>exhaustive
             <span class="dt">In</span> an equation for <span class="ot">`unsafe&#39;: Patterns not matched: Nothing</span></code></pre></div>
<p>The <code>-Wall</code> or <code>-fwarn-incomplete-patterns</code> flag can also be added on a per-module basis by using the <code>OPTIONS_GHC</code> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/users_guide/pragmas.html">pragma</a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# OPTIONS_GHC -Wall #-}</span>
<span class="ot">{-# OPTIONS_GHC -fwarn-incomplete-patterns #-}</span></code></pre></div>
<p>A more subtle case of non-exhaustivity is the use of implicit pattern matching with a single <em>uni-pattern</em> in a lambda expression. In a manner similar to the <code>unsafe</code> function above, a uni-pattern cannot handle all types of valid input. For instance, the function <code>boom</code> will fail when given a Nothing, even though the type of the lambda expression's argument is a <code>Maybe a</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">boom <span class="fu">=</span> \(<span class="dt">Just</span> a) <span class="ot">-&gt;</span> something</code></pre></div>
<p>Non-exhaustivity arising from uni-patterns in lambda expressions occurs frequently in <code>let</code> or <code>do</code>-blocks after desugaring, because such code is translated into lambda expressions similar to <code>boom</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">boom2 <span class="fu">=</span> <span class="kw">let</span>
  <span class="dt">Just</span> a <span class="fu">=</span> something

boom3 <span class="fu">=</span> <span class="kw">do</span>
  <span class="dt">Just</span> a <span class="ot">&lt;-</span> something</code></pre></div>
<p>GHC can warn about these cases of non-exhaustivity with the <code>-fwarn-incomplete-uni-patterns</code> flag.</p>
<p>Grossly speaking, any non-trivial program will use some measure of partial functions. It is simply a fact. Thus, there exist obligations for the programmer than cannot be manifest in the Haskell type system.</p>
<h2 id="debugger">Debugger</h2>
<p>Since <a href="#ghci">GHCi</a> version 6.8.1, a built-in <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-debugger.html">debugger</a> has been available, although its use is somewhat rare. Debugging uncaught exceptions from bottoms or asynchronous exceptions is in similar style to debugging segfaults with gdb.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> <span class="fu">:</span>set <span class="fu">-</span>fbreak<span class="fu">-</span>on<span class="fu">-</span>exception       <span class="co">-- Sets option for evaluation to stop on exception</span>
λ<span class="fu">:</span> <span class="fu">:</span>break <span class="dv">2</span> <span class="dv">15</span>                     <span class="co">-- Sets a break point at line 2, column 15</span>
λ<span class="fu">:</span> <span class="fu">:</span>trace main                     <span class="co">-- Run a function to generate a sequence of evaluation steps</span>
λ<span class="fu">:</span> <span class="fu">:</span>hist                           <span class="co">-- Step backwards from a breakpoint through previous steps of evaluation</span>
λ<span class="fu">:</span> <span class="fu">:</span>back                           <span class="co">-- Step backwards a single step at a time through the history</span>
λ<span class="fu">:</span> <span class="fu">:</span>forward                        <span class="co">-- Step forward a single step at a time through the history</span></code></pre></div>
<h2 id="stack-traces">Stack Traces</h2>
<p>With <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html">runtime profiling enabled</a>, <a href="https://www.haskell.org/ghc/">GHC</a> can also print a stack trace when a diverging bottom term (error, undefined) is hit. This action, though, requires a special flag and profiling to be enabled, both of which are disabled by default. So, for example:</p>
<div class="sourceCode" include="src/01-basics/stacktrace.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Exception</span>

f x <span class="fu">=</span> g x

g x <span class="fu">=</span> error (show x)

main <span class="fu">=</span> try (evaluate (f ()))<span class="ot"> ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">SomeException</span> ())</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">$</span> ghc <span class="fu">-</span><span class="dt">O0</span> <span class="fu">-</span>rtsopts<span class="fu">=</span>all <span class="fu">-</span>prof <span class="fu">-</span>auto<span class="fu">-</span>all <span class="co">--make stacktrace.hs</span>
<span class="fu">./</span>stacktrace <span class="fu">+</span><span class="dt">RTS</span> <span class="fu">-</span>xc</code></pre></div>
<p>And indeed, the runtime tells us that the exception occurred in the function <code>g</code> and enumerates the call stack.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">***</span> <span class="dt">Exception</span> (reporting due to <span class="fu">+</span><span class="dt">RTS</span> <span class="fu">-</span>xc)<span class="fu">:</span> (<span class="dt">THUNK_2_0</span>), stack trace<span class="fu">:</span>
  Main.g,
  called from Main.f,
  called from Main.main,
  called from <span class="dt">Main.CAF</span>
  <span class="fu">--&gt;</span> evaluated by<span class="fu">:</span> Main.main,
  called from <span class="dt">Main.CAF</span></code></pre></div>
<p>It is best to run this code without optimizations applied <code>-O0</code> so as to preserve the original call stack as represented in the source. With optimizations applied, GHC will rearrange the program in rather drastic ways, resulting in what may be an entirely different call stack.</p>
<p>See:</p>
<ul>
<li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime-control.html#idp13041968">xc flag</a></li>
</ul>
<h2 id="trace">Trace</h2>
<p>Since Haskell is a <a href="../fun/000_introduction.html#functional-languages">pure language</a>, it has the unique property that most code is introspectable on its own. As such, using <a href="https://www.codingunit.com/printf-format-specifiers-format-conversions-and-formatted-output">printf</a> to display the state of the program at critical times throughout execution is often unnecessary because we can simply open <a href="#ghci">GHCi</a> and test the function. Nevertheless, Haskell does come with an unsafe <code>trace</code> function which can be used to perform arbitrary print statements outside of the IO monad.</p>
<div class="sourceCode" include="src/01-basics/trace.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Debug.Trace</span>

<span class="ot">example1 ::</span> <span class="dt">Int</span>
example1 <span class="fu">=</span> trace <span class="st">&quot;impure print&quot;</span> <span class="dv">1</span>

<span class="ot">example2 ::</span> <span class="dt">Int</span>
example2 <span class="fu">=</span> traceShow <span class="st">&quot;tracing&quot;</span> <span class="dv">2</span>

<span class="ot">example3 ::</span> [<span class="dt">Int</span>]
example3 <span class="fu">=</span> [trace <span class="st">&quot;will not be called&quot;</span> <span class="dv">3</span>]

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  print example1
  print example2
  print <span class="fu">$</span> length example3
<span class="co">-- impure print</span>
<span class="co">-- 1</span>
<span class="co">-- &quot;tracing&quot;</span>
<span class="co">-- 2</span>
<span class="co">-- 1</span></code></pre></div>
<div class="alert alert-danger">
<p>Trace uses <code>unsafePerformIO</code> under the hood and should <strong>not</strong> be used in stable code.</p>
</div>
<p>In addition to the <code>trace</code> function, several monadic <code>trace</code> variants are quite common.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Text.Printf</span>
<span class="kw">import </span><span class="dt">Debug.Trace</span>

<span class="ot">traceM ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> m ()
traceM string <span class="fu">=</span> trace string <span class="fu">$</span> return ()

<span class="ot">traceShowM ::</span> (<span class="dt">Show</span> a, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> m ()
traceShowM <span class="fu">=</span> traceM <span class="fu">.</span> show

<span class="ot">tracePrintfM ::</span> (<span class="dt">Monad</span> m, <span class="dt">PrintfArg</span> a) <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m ()
tracePrintfM s <span class="fu">=</span> traceM <span class="fu">.</span> printf s</code></pre></div>
<h2 id="type-holes">Type Holes</h2>
<p>Since the release of GHC 7.8, <em>typed holes</em> allow for debugging incomplete programs. By placing an underscore on any value on the right hand-side of a declaration, <a href="https://www.haskell.org/ghc/">GHC</a> will throw an error during type-checking. Such an error reflects what type the value in the position of the type hole could be in order for the program to type-check successfully.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> [] <span class="kw">where</span>
  fmap f (x<span class="fu">:</span>xs) <span class="fu">=</span> f x <span class="fu">:</span> fmap f _</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">[<span class="kw">1</span> of 1] Compiling Main             ( src/typedhole.hs, interpreted )

<span class="kw">src</span>/typedhole.hs:<span class="kw">7</span>:32:
    <span class="kw">Found</span> hole ‘_’ with type: [a]
    <span class="kw">Where</span>: ‘a’ is a rigid type variable bound by
               <span class="kw">the</span> type signature for fmap :: (a -<span class="kw">&gt;</span> b) <span class="kw">-&gt;</span> [a] -<span class="kw">&gt;</span> [b]
               <span class="kw">at</span> src/typedhole.hs:7:3
    <span class="kw">Relevant</span> bindings include
      <span class="kw">xs</span> :: [a] (bound at src/typedhole.hs:7:13)
      <span class="kw">x</span> :: a (bound at src/typedhole.hs:7:11)
      <span class="kw">f</span> :: a -<span class="kw">&gt;</span> b (bound at src/typedhole.hs:7:8)
      <span class="kw">fmap</span> :: (a -<span class="kw">&gt;</span> b) <span class="kw">-&gt;</span> [a] -<span class="kw">&gt;</span> [b] (bound at src/typedhole.hs:7:3)
    <span class="kw">In</span> the second argument of ‘fmap’, namely ‘_’
    <span class="kw">In</span> the second argument of ‘(:)’, <span class="kw">namely</span> ‘fmap f _’
    <span class="kw">In</span> the expression: f x : fmap f _
<span class="kw">Failed</span>, modules loaded: none.</code></pre></div>
<p>GHC has rightly suggested that the expression needed to finish the program is <code>xs :: [a]</code>.</p>
<h2 id="deferred-type-errors">Deferred Type Errors</h2>
<p>Since the release of version 7.8, <a href="https://www.haskell.org/ghc/">GHC</a> supports the option of treating type errors as runtime errors. With this option enabled, programs will run, but they will fail when a mistyped expression is evaluated. This feature is enabled with the <code>-fdefer-type-errors</code> flag in three ways: at the module level, when compiled from the command line, or inside of a <a href="#ghci">GHCi</a> interactive session.</p>
<p>For instance, the program below will compile:</p>
<div class="sourceCode" include="src/01-basics/defer.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# OPTIONS_GHC -fdefer-type-errors #-}</span> <span class="co">-- Enable deferred type</span>
                                        <span class="co">-- errors at module level</span>

<span class="ot">x ::</span> ()
x <span class="fu">=</span> print <span class="dv">3</span>

<span class="ot">y ::</span> <span class="dt">Char</span>
y <span class="fu">=</span> <span class="dv">0</span>

<span class="ot">z ::</span> <span class="dt">Int</span>
z <span class="fu">=</span> <span class="dv">0</span> <span class="fu">+</span> <span class="st">&quot;foo&quot;</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  print x</code></pre></div>
<p>However, when a pathological term is evaluated at runtime, we'll see a message like:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">defer</span>: defer.hs:4:5:
    <span class="kw">Couldn</span><span class="st">&#39;t match expected type ‘()’ with actual type ‘IO ()’</span>
<span class="st">    In the expression: print 3</span>
<span class="st">    In an equation for ‘x’: x = print 3</span>
<span class="st">(deferred type error)</span></code></pre></div>
<p>This error tells us that while <code>x</code> has a declared type of <code>()</code>, the body of the function <code>print 3</code> has a type of <code>IO ()</code>. However, if the term is never evaluated, GHC will not throw an exception.</p>
<h2 id="ghcid">ghcid</h2>
<p><a href="https://github.com/ndmitchell/ghcid">ghcid</a> is a lightweight IDE hook that allows continuous feedback whenever code is updated. It can be run from the command line in the root of the <code>cabal</code> project directory by specifying a command to run (e.g. <code>ghci</code>, <code>cabal repl</code>, or <code>stack repl</code>).</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">ghcid</span> --command=<span class="st">&quot;cabal repl&quot;</span>   <span class="co"># Run cabal repl under ghcid</span>
<span class="kw">ghcid</span> --command=<span class="st">&quot;stack repl&quot;</span>   <span class="co"># Run stack repl under ghcid</span>
<span class="kw">ghcid</span> --command=<span class="st">&quot;ghci baz.hs&quot;</span>  <span class="co"># Open baz.hs under ghcid</span></code></pre></div>
<p>When a Haskell module is loaded into <code>ghcid</code>, the code is evaluated in order to provide the user with any errors or warnings that would happen at compile time. When the developer edits and saves code loaded into <code>ghcid</code>, the program automatically reloads and evaluates the code for errors and warnings.</p>
<h2 id="haddock">Haddock</h2>
<p><a href="haskel://www.haskell.org/haddock/#Overview">Haddock</a> is the automatic documentation generation tool for Haskell source code. It integrates with the usual <code>cabal</code> toolchain. In this section, we will explore how to document code so that Haddock can generate documentation successfully.</p>
<p>Several frequent comment patterns are used to document code for Haddock. The first of these methods uses <code>-- |</code> to delineate the beginning of a comment:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Documentation for f</span>
<span class="ot">f ::</span> a <span class="ot">-&gt;</span> a
f <span class="fu">=</span> <span class="fu">...</span></code></pre></div>
<p>Multiline comments are also possible:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Multiline documentation for the function</span>
<span class="co">-- f with multiple arguments.</span>
fmap<span class="ot"> ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span>
     <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b)  <span class="co">-- ^ function</span>
     <span class="ot">-&gt;</span> f a       <span class="co">-- ^ input</span>
     <span class="ot">-&gt;</span> f b       <span class="co">-- ^ output</span></code></pre></div>
<p><code>-- ^</code> is also used to comment Constructors or Record fields:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">T</span> a b
  <span class="fu">=</span> <span class="dt">A</span> a <span class="co">-- ^ Documentation for A</span>
  <span class="fu">|</span> <span class="dt">B</span> b <span class="co">-- ^ Documentation for B</span>

<span class="kw">data</span> <span class="dt">R</span> a b <span class="fu">=</span> <span class="dt">R</span>
  {<span class="ot"> f1 ::</span> a <span class="co">-- ^ Documentation for the field f1</span>
  ,<span class="ot"> f2 ::</span> b <span class="co">-- ^ Documentation for the field f2</span>
  }</code></pre></div>
<p>Elements within a module (i.e. value, types, classes) can be hyperlinked by enclosing the identifier in single quotes:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">T</span> a b
  <span class="fu">=</span> <span class="dt">A</span> a <span class="co">-- ^ Documentation for &#39;A&#39;</span>
  <span class="fu">|</span> <span class="dt">B</span> b <span class="co">-- ^ Documentation for &#39;B&#39;</span></code></pre></div>
<p>Modules themselves can be referenced by enclosing them in double quotes:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Here we use the &quot;Data.Text&quot; library and import</span>
<span class="co">-- the &#39;Data.Text.pack&#39; function.</span></code></pre></div>
<p><code>haddock</code> also allows the user to include blocks of code within the generated documentation. Two methods of demarcating the code blocks exist in <code>haddock</code>. For example, enclosing a code snippet in <code>@</code> symbols marks it as a code block:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | An example of a code block.</span>
<span class="fu">--</span>
<span class="co">-- @</span>
<span class="co">--    f x = f (f x)</span>
<span class="co">-- @</span></code></pre></div>
<p>Similarly, it's possible to use bird tracks (<code>&gt;</code>) in a comment line to set off a code block. This usage is very similar to <a href="https://wiki.haskell.org/Literate_programming#Bird_Style">Bird style Literate Haskell</a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | A similar code block example that uses bird tracks (i.e. &#39;&gt;&#39;)</span>
<span class="co">-- &gt; f x = f (f x)</span></code></pre></div>
<p>Snippets of interactive shell sessions can also be included in <code>haddock</code> documentation. In order to denote the beginning of code intended to be run in a REPL, the <code>&gt;&gt;&gt;</code> symbol is used:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Example of an interactive shell session embedded within documentation</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; factorial 5</span>
<span class="co">-- 120</span></code></pre></div>
<p>Headers for specific blocks can be added by prefacing the comment in the module block with a <code>*</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Foo</span> (
  <span class="co">-- * My Header</span>
  example1,
  example2
)</code></pre></div>
<p>Sections can also be delineated by <code>$</code> blocks that pertain to references in the body of the module:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Foo</span> (
  <span class="co">-- $section1</span>
  example1,
  example2
)

<span class="co">-- $section1</span>
<span class="co">-- Here is the documentation section that describes the symbols</span>
<span class="co">-- &#39;example1&#39; and &#39;example2&#39;.</span></code></pre></div>
<p>Links can be added with the following syntax:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&lt;</span>url text<span class="fu">&gt;</span></code></pre></div>
<p>Images can also be included, so long as the path is either absolute or relative to the directory in which <code>haddock</code> is run.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&lt;&lt;</span>diagram<span class="fu">.</span>png title<span class="fu">&gt;&gt;</span></code></pre></div>
<p><code>haddock</code> options can also be specified with pragmas in the source, either at the module or project level.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# OPTIONS_HADDOCK show-extensions, ignore-exports #-}</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">Option</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">ignore-exports</td>
<td align="left">Ignores the export list and includes all signatures in scope.</td>
</tr>
<tr class="even">
<td align="left">not-home</td>
<td align="left">Module will not be considered in the root documentation.</td>
</tr>
<tr class="odd">
<td align="left">show-extensions</td>
<td align="left">Annotates the documentation with the language extensions used.</td>
</tr>
<tr class="even">
<td align="left">hide</td>
<td align="left">Forces the module to be hidden from Haddock.</td>
</tr>
<tr class="odd">
<td align="left">prune</td>
<td align="left">Omits definitions with no annotations.</td>
</tr>
</tbody>
</table>
<hr />
<h1 id="monads">Monads</h1>
<h2 id="eightfold-path-to-monad-satori">Eightfold Path to Monad Satori</h2>
<p>Much ink has been spilled waxing lyrical about the supposed mystique of monads. Instead, I suggest a path to enlightenment:</p>
<ol style="list-style-type: decimal">
<li>Don't read the monad tutorials.</li>
<li>No really, don't read the monad tutorials.</li>
<li>Learn about <a href="../../book.realworldhaskell.org/read/types-and-functions.html">Haskell types</a>.</li>
<li>Learn what a typeclass is.</li>
<li>Read the <a href="http://wiki.haskell.org/Typeclassopedia">Typeclassopedia</a>.</li>
<li>Read the monad definitions.</li>
<li>Use monads in real code.</li>
<li>Don't write monad-analogy tutorials.</li>
</ol>
<p>In other words, the only path to understanding monads is to read the fine source, fire up GHC, and write some code. Analogies and metaphors will not lead to understanding.</p>
<h2 id="monadic-myths">Monadic Myths</h2>
<p>The following are all <strong>false</strong>:</p>
<ul>
<li>Monads are impure.</li>
<li>Monads are about effects.</li>
<li>Monads are about state.</li>
<li>Monads are about imperative sequencing.</li>
<li>Monads are about IO.</li>
<li>Monads are dependent on laziness.</li>
<li>Monads are a &quot;back-door&quot; in the language to perform side-effects.</li>
<li>Monads are an embedded imperative language inside Haskell.</li>
<li>Monads require knowing abstract mathematics.</li>
<li>Monads are unique to Haskell.</li>
</ul>
<p>See: <a href="http://wiki.haskell.org/What_a_Monad_is_not">What a Monad Is Not</a></p>
<h2 id="monadic-methods">Monadic Methods</h2>
<p>Monads are not complicated. They are implemented as a typeclass with two methods, <code>return</code> and <code>(&gt;&gt;=)</code> (pronounced &quot;bind&quot;). In order to implement a Monad instance, these two functions must be defined in accordance with the arity described in the typeclass definition:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monad</span> m <span class="kw">where</span>
<span class="ot">  return ::</span> a <span class="ot">-&gt;</span> m a                    <span class="co">-- N.B. &#39;m&#39; refers to a type constructor</span>
                                        <span class="co">-- (e.g., Maybe, Either, etc.) that</span>
                                        <span class="co">-- implements the Monad typeclass</span>

<span class="ot">  (&gt;&gt;=)  ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</code></pre></div>
<p>The first type signature in the Monad class definition is for <code>return</code>. Any preconceptions one might have for the word &quot;return&quot; should be discarded: It has an entirely different meaning in the context of Haskell and acts very differently than in languages like C, Python, or Java. Instead of being the final arbiter of what value a function produces, <code>return</code> in Haskell injects a value of type <code>a</code> into a monadic context (e.g., Maybe, Either, etc.), which is denoted as <code>m a</code>.</p>
<p>The other function essential to implementing a Monad instance is <code>(&gt;&gt;=)</code>. This infix takes two arguments. On its left side is a value with type <code>m a</code>, while on the right side is a function with type <code>(a -&gt; m b)</code>. The bind operation results in a final value of type <code>m b</code>.</p>
<p>A third, auxiliary function (<code>(&gt;&gt;)</code>) is defined in terms of the bind operation that discards its argument.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&gt;&gt;) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m b
m <span class="fu">&gt;&gt;</span> k <span class="fu">=</span> m <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> k</code></pre></div>
<p>This definition says that (&gt;&gt;) has a left and right argument which are monadic with types <code>m a</code> and <code>m b</code> respectively, while the infix returns a value of type <code>m b</code>. The actual implementation of (&gt;&gt;) says that when <code>m</code> is passed to <code>(&gt;&gt;)</code> with <code>k</code> on the right, the value <code>k</code> will always be returned.</p>
<h2 id="laws">Laws</h2>
<p>In addition to specific implementations of <code>(&gt;&gt;=)</code> and <code>return</code>, all monad instances must satisfy three laws.</p>
<p><strong>Law 1</strong></p>
<p>The first law says that when <code>return a</code> is passed through a <code>(&gt;&gt;=)</code> into a function <code>f</code>, this expression is exactly equivalent to <code>f a</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">return a <span class="fu">&gt;&gt;=</span> f ≡ f a    <span class="co">-- N.B. &#39;a&#39; refers to a value, not a type</span></code></pre></div>
<p>In discussing the next two laws, we'll refer to a value <code>m</code>. This notation is shorthand for value wrapped in a monadic context. Such a value has type <code>m a</code>, and could be represented more concretely by values like <code>Nothing</code>, <code>Just x</code>, or <code>Right x</code>. It is important to note that some of these concrete instantiations of the value <code>m</code> have multiple components. In discussing the second and third monad laws, we'll see some examples of how this plays out.</p>
<p><strong>Law 2</strong></p>
<p>The second law states that a monadic value <code>m</code> passed through <code>(&gt;&gt;=)</code> into <code>return</code> is exactly equivalent to itself. In other words, using bind to pass a monadic value to <code>return</code> does not change the initial value.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">m <span class="fu">&gt;&gt;=</span> return ≡ m        <span class="co">-- &#39;m&#39; here refers to a value that has type &#39;m a&#39;</span></code></pre></div>
<p>A more explicit way to write the second Monad law exists. In this following example code, the first expression shows how the second law applies to values represented by <a href="https://wiki.haskell.org/Constructor#Type_constructor">non-nullary</a> type constructors. The second snippet shows how a value represented by a nullary type constructor works within the context of the second law.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="dt">SomeMonad</span> val) <span class="fu">&gt;&gt;=</span> return ≡ <span class="dt">SomeMonad</span> val  <span class="co">-- &#39;SomeMonad val&#39; has type &#39;m a&#39; just</span>
                                            <span class="co">-- like &#39;m&#39; from the first example of the</span>
                                            <span class="co">-- second law</span>

<span class="dt">NullaryMonadType</span> <span class="fu">&gt;&gt;=</span> return ≡ <span class="dt">NullaryMonadType</span></code></pre></div>
<p><strong>Law 3</strong></p>
<p>While the first two laws are relatively clear, the third law may be more difficult to understand. This law states that when a monadic value <code>m</code> is passed through <code>(&gt;&gt;=)</code> to the function <code>f</code> and then the result of that expression is passed to <code>&gt;&gt;= g</code>, the entire expression is exactly equivalent to passing <code>m</code> to a lambda expression that takes one parameter <code>x</code> and outputs the function <code>f</code> applied to <code>x</code>. By the definition of bind, <code>f x</code> <em>must</em> return a value wrapped in the same Monad. Because of this property, the resultant value of that expression can be passed through <code>(&gt;&gt;=)</code> to the function <code>g</code>, which also returns a monadic value.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(m <span class="fu">&gt;&gt;=</span> f) <span class="fu">&gt;&gt;=</span> g ≡ m <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> f x <span class="fu">&gt;&gt;=</span> g)  <span class="co">-- Like in the last law, &#39;m&#39; has</span>
                                           <span class="co">-- has type &#39;m a&#39;. The functions &#39;f&#39;</span>
                                           <span class="co">-- and &#39;g&#39; have types &#39;(a -&gt; m b)&#39;</span>
                                           <span class="co">-- and &#39;(b -&gt; m c)&#39; respectively</span></code></pre></div>
<p>Again, it is possible to write this law with more explicit code. Like in the explicit examples for law 2, <code>m</code> has been replaced by <code>SomeMonad val</code> in order to be very clear that there can be multiple components to a monadic value. Although little has changed in the code, it is easier to see what value--namely, <code>val</code>--corresponds to the <code>x</code> in the lambda expression. After <code>SomeMonad val</code> is passed through <code>(&gt;&gt;=)</code> to <code>f</code>, the function <code>f</code> operates on <code>val</code> and returns a result still wrapped in the <code>SomeMonad</code> type constructor. We can call this new value <code>SomeMonad newVal</code>. Since it is still wrapped in the monadic context, <code>SomeMonad newVal</code> can thus be passed through the bind operation into the function <code>g</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">((<span class="dt">SomeMonad</span> val) <span class="fu">&gt;&gt;=</span> f) <span class="fu">&gt;&gt;=</span> g ≡ (<span class="dt">SomeMonad</span> val) <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> f x <span class="fu">&gt;&gt;=</span> g)</code></pre></div>
<p>See: <a href="http://wiki.haskell.org/Monad_laws">Monad Laws</a></p>
<h2 id="do-notation">Do Notation</h2>
<p>Monadic syntax in Haskell is written in a sugared form, known as <code>do</code> notation. The advantages of this special syntax are that it is easier to write and is entirely equivalent to just applications of the monad operations. The desugaring is defined recursively by the rules:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span> { a <span class="ot">&lt;-</span> f ; m } ≡ f <span class="fu">&gt;&gt;=</span> \a <span class="ot">-&gt;</span> <span class="kw">do</span> { m }  <span class="co">-- bind &#39;f&#39; to a, proceed to desugar</span>
                                          <span class="co">-- &#39;m&#39;</span>

<span class="kw">do</span> { f ; m } ≡ f <span class="fu">&gt;&gt;</span> <span class="kw">do</span> { m }              <span class="co">-- evaluate &#39;f&#39;, then proceed to</span>
                                          <span class="co">-- desugar  m</span>

<span class="kw">do</span> { m } ≡ m</code></pre></div>
<p>Thus, through the application of the desugaring rules, the following expressions are equivalent:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span>
  a <span class="ot">&lt;-</span> f                               <span class="co">-- f, g, and h are bound to the names a,</span>
  b <span class="ot">&lt;-</span> g                               <span class="co">-- b, and c. These names are then passed</span>
  c <span class="ot">&lt;-</span> h                               <span class="co">-- to &#39;return&#39; to ensure that all values</span>
  return (a, b, c)                     <span class="co">-- are wrapped in the appropriate monadic</span>
                                       <span class="co">-- context</span>

<span class="kw">do</span> {                                   <span class="co">-- N.B. &#39;{}&#39;  and &#39;;&#39; characters are</span>
  a <span class="ot">&lt;-</span> f;                              <span class="co">--  rarely used in do-notation</span>
  b <span class="ot">&lt;-</span> g;
  c <span class="ot">&lt;-</span> h;
  return (a, b, c)
  }

f <span class="fu">&gt;&gt;=</span> \a <span class="ot">-&gt;</span>
  g <span class="fu">&gt;&gt;=</span> \b <span class="ot">-&gt;</span>
    h <span class="fu">&gt;&gt;=</span> \c <span class="ot">-&gt;</span>
      return (a, b, c)</code></pre></div>
<p>If one were to write the bind operator as an uncurried function ( this is not how Haskell uses it ) the same desugaring might look something like the following chain of nested binds with lambdas.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">bindMonad(f, lambda a<span class="fu">:</span>
  bindMonad(g, lambda b<span class="fu">:</span>
    bindMonad(h, lambda c<span class="fu">:</span>
      returnMonad (a,b,c))))</code></pre></div>
<p>In the do-notation, the <a href="#laws">monad laws</a> from above are equivalently written:</p>
<p><strong>Law 1</strong></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="kw">do</span> y <span class="ot">&lt;-</span> return x
     f y

<span class="fu">=</span> <span class="kw">do</span> f x</code></pre></div>
<p><strong>Law 2</strong></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="kw">do</span> x <span class="ot">&lt;-</span> m
     return x

<span class="fu">=</span> <span class="kw">do</span> m</code></pre></div>
<p><strong>Law 3</strong></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="kw">do</span> b <span class="ot">&lt;-</span> <span class="kw">do</span> a <span class="ot">&lt;-</span> m
             f a
     g b

<span class="fu">=</span> <span class="kw">do</span> a <span class="ot">&lt;-</span> m
     b <span class="ot">&lt;-</span> f a
     g b

<span class="fu">=</span> <span class="kw">do</span> a <span class="ot">&lt;-</span> m
     <span class="kw">do</span> b <span class="ot">&lt;-</span> f a
        g b</code></pre></div>
<p>See: <a href="http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14">Haskell 2010: Do Expressions</a></p>
<h2 id="maybe">Maybe</h2>
<p>The <em>Maybe</em> monad is the simplest first example of a monad instance. The Maybe monad models computations which fail to yield a value at any point during computation.</p>
<p>The Maybe type has two value constructors. The first, <code>Just</code>, is a unary constructor representing a successful computation, while the second, <code>Nothing</code>, is a nullary constructor that represents failure.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="fu">=</span> <span class="dt">Just</span> a <span class="fu">|</span> <span class="dt">Nothing</span></code></pre></div>
<p>The monad instance describes the implementation of <code>(&gt;&gt;=)</code> for <code>Maybe</code> by pattern matching on the possible inputs that could be passed to the bind operation (i.e., <code>Nothing</code> or <code>Just x</code>). The instance declaration also provides an implementation of <code>return</code>, which in this case is simply <code>Just</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Maybe</span> <span class="kw">where</span>
  (<span class="dt">Just</span> x) <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> k x            <span class="co">-- &#39;k&#39; is a function with type  (a -&gt; Maybe a)</span>
  <span class="dt">Nothing</span>  <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> <span class="dt">Nothing</span>

  return <span class="fu">=</span> <span class="dt">Just</span>                   <span class="co">-- Just&#39;s type signature is (a -&gt; Maybe a), in</span>
                                  <span class="co">-- other words, extremely similar to the</span>
                                  <span class="co">-- type of &#39;return&#39; in the typeclass</span>
                                  <span class="co">-- declaration above.</span></code></pre></div>
<p>The following code shows some simple operations to do within the Maybe monad.</p>
<p>In the first example, The value <code>Just 3</code> is passed via <code>(&gt;&gt;=)</code> to the lambda function <code>\x -&gt; return (x + 1)</code>. <code>x</code> refers to the <code>Int</code> portion of <code>Just 3</code>, and we can use <code>x</code> in the second half of the lambda expression, where <code>return (x + 1)</code> evaluates to <code>Just 4</code>, indicating a successful computation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="dt">Just</span> <span class="dv">3</span>) <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> return (x <span class="fu">+</span> <span class="dv">1</span>))
<span class="co">-- Just 4</span></code></pre></div>
<p>In the second example, the value <code>Nothing</code> is passed via <code>(&gt;&gt;=)</code> to the same lambda function as in the previous example. However, according to the <code>Maybe</code> Monad instance, whenever <code>Nothing</code> is bound to a function, the expression's result will be <code>Nothing</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Nothing</span> <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> return (x <span class="fu">+</span> <span class="dv">1</span>))
<span class="co">-- Nothing</span></code></pre></div>
<p>In the next example, <code>return</code> is applied to <code>4</code> and returns <code>Just 4</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">return <span class="dv">4</span><span class="ot"> ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
<span class="co">-- Just 4</span></code></pre></div>
<p>The next code examples show the use of <code>do</code> notation within the Maybe monad to do addition that might fail. Desugared examples are provided as well.</p>
<div class="sourceCode" include="src/02-monads/maybe.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">example1 ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
example1 <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> <span class="dt">Just</span> <span class="dv">3</span>                <span class="co">-- Bind 3 to name a</span>
  b <span class="ot">&lt;-</span> <span class="dt">Just</span> <span class="dv">4</span>                <span class="co">-- Bind 4 to name b</span>
  return <span class="fu">$</span> a <span class="fu">+</span> b             <span class="co">-- Evaluate (a + b), then use &#39;return&#39; to ensure</span>
                             <span class="co">-- the result is in the Maybe monad in order to</span>
                             <span class="co">-- satisfy the type signature</span>
<span class="co">-- Just 7</span>

<span class="ot">desugared1 ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
desugared1 <span class="fu">=</span> <span class="dt">Just</span> <span class="dv">3</span> <span class="fu">&gt;&gt;=</span> \a <span class="ot">-&gt;</span>    <span class="co">-- This example is the desugared</span>
               <span class="dt">Just</span> <span class="dv">4</span> <span class="fu">&gt;&gt;=</span> \b <span class="ot">-&gt;</span>  <span class="co">-- equivalent to example1</span>
                 return <span class="fu">$</span> a <span class="fu">+</span> b
<span class="co">-- Just 7</span>

<span class="ot">example2 ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
example2 <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> <span class="dt">Just</span> <span class="dv">3</span>                <span class="co">-- Bind 3 to name a</span>
  b <span class="ot">&lt;-</span> <span class="dt">Nothing</span>               <span class="co">-- Bind Nothing to name b</span>
  return <span class="fu">$</span> a <span class="fu">+</span> b
<span class="co">-- Nothing                   -- This result might be somewhat surprising, since</span>
                             <span class="co">-- addition within the Maybe monad can actually</span>
                             <span class="co">-- return &#39;Nothing&#39;. This result occurs because one</span>
                             <span class="co">-- of the values, Nothing, indicates computational</span>
                             <span class="co">-- failure. Since the computation failed at one</span>
                             <span class="co">-- step within the process, the whole computation</span>
                             <span class="co">-- fails, leaving us with &#39;Nothing&#39; as the final</span>
                             <span class="co">-- result.</span>

<span class="ot">desugared2 ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
desugared2 <span class="fu">=</span> <span class="dt">Just</span> <span class="dv">3</span> <span class="fu">&gt;&gt;=</span> \a <span class="ot">-&gt;</span>     <span class="co">-- This example is the desugared</span>
               <span class="dt">Nothing</span> <span class="fu">&gt;&gt;=</span> \b <span class="ot">-&gt;</span>  <span class="co">-- equivalent to example2</span>
                 return <span class="fu">$</span> a <span class="fu">+</span> b
<span class="co">-- Nothing</span></code></pre></div>
<h2 id="list">List</h2>
<p>The <em>List</em> monad is the second simplest example of a monad instance. As always, this monad implements both <code>(&gt;&gt;=)</code> and <code>return</code>. The definition of bind says that when the list <code>m</code> is bound to a function <code>f</code>, the result is a concatenation of <code>map f</code> over the list <code>m</code>. The <code>return</code> method simply takes a single value <code>x</code> and injects into a singleton list <code>[x]</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> [] <span class="kw">where</span>
  m <span class="fu">&gt;&gt;=</span> f   <span class="fu">=</span>  concat (map f m)          <span class="co">-- &#39;m&#39; is a list</span>
  return x  <span class="fu">=</span>  [x]</code></pre></div>
<p>In order to demonstrate the <code>List</code> monad's methods, we will define two functions: <code>m</code> and <code>f</code>. <code>m</code> is a simple list, while <code>f</code> is a function that takes a single <code>Int</code> and returns a two element list <code>[1, 0]</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">m ::</span> [<span class="dt">Int</span>]
m <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]

<span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
f <span class="fu">=</span> \x <span class="ot">-&gt;</span> [<span class="dv">1</span>,<span class="dv">0</span>]               <span class="co">-- &#39;f&#39; always returns [1, 0]</span></code></pre></div>
<p>The evaluation proceeds as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">m <span class="fu">&gt;&gt;=</span> f
<span class="fu">==&gt;</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>] <span class="fu">&gt;&gt;=</span> \x <span class="ot">-&gt;</span> [<span class="dv">1</span>,<span class="dv">0</span>]
<span class="fu">==&gt;</span> concat (map (\x <span class="ot">-&gt;</span> [<span class="dv">1</span>,<span class="dv">0</span>]) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>])
<span class="fu">==&gt;</span> concat ([[<span class="dv">1</span>,<span class="dv">0</span>],[<span class="dv">1</span>,<span class="dv">0</span>],[<span class="dv">1</span>,<span class="dv">0</span>],[<span class="dv">1</span>,<span class="dv">0</span>]])
<span class="fu">==&gt;</span> [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>]</code></pre></div>
<p>The list comprehension syntax in Haskell can be implemented in terms of the list monad. List comprehensions can be considered syntactic sugar for more obviously monadic implementations. Examples <code>a</code> and <code>b</code> illustrate these use cases.</p>
<p>The first example (<code>a</code>) illustrates how to write a list comprehension. Although the syntax looks strange at first, there are elements of it that may look familiar. For instance, the use of <code>&lt;-</code> is just like bind in a <code>do</code> notation: It binds an element of a list to a name. However, one major difference is apparent: <code>a</code> seems to lack a call to <code>return</code>. Not to worry, though, the <code>[]</code> fills this role. This syntax can be easily desugared by the compiler to an explicit invocation of <code>return</code>. Furthermore, it serves to remind the user that the computation takes place in the List monad.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">a <span class="fu">=</span> [
      f x y <span class="fu">|</span>        <span class="co">-- Corresponds to &#39;f x y&#39; in example b</span>
      x <span class="ot">&lt;-</span> xs,
      y <span class="ot">&lt;-</span> ys,
      x <span class="fu">==</span> y         <span class="co">-- Corresponds to &#39;guard $ x == y&#39; in example b</span>
    ]</code></pre></div>
<p>The second example (<code>b</code>) shows the list comprehension above rewritten with <code>do</code> notation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Identical to `a`</span>
b <span class="fu">=</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> xs
  y <span class="ot">&lt;-</span> ys
  guard <span class="fu">$</span> x <span class="fu">==</span> y     <span class="co">-- Corresponds to &#39;x == y&#39; in example a</span>
  return <span class="fu">$</span> f x y     <span class="co">-- Corresponds to the &#39;[]&#39; and &#39;f x y&#39; in example a</span></code></pre></div>
<p>The final examples are further illustrations of the List monad. The functions below each return a list of 3-tuples which contain the possible combinations of the three lists that get bound the names <code>a</code>, <code>b</code>, and <code>c</code>. N.B.: Only values in the list bound to <code>a</code> can be used in <code>a</code> position of the tuple; the same fact holds true for the lists bound to <code>b</code> and <code>c</code>.</p>
<div class="sourceCode" include="src/02-monads/list.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">example ::</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>)]
example <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> [<span class="dv">1</span>,<span class="dv">2</span>]
  b <span class="ot">&lt;-</span> [<span class="dv">10</span>,<span class="dv">20</span>]
  c <span class="ot">&lt;-</span> [<span class="dv">100</span>,<span class="dv">200</span>]
  return (a,b,c)
<span class="co">-- [(1,10,100),(1,10,200),(1,20,100),(1,20,200),(2,10,100),(2,10,200),(2,20,100),(2,20,200)]</span>

<span class="ot">desugared ::</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>)]
desugared <span class="fu">=</span> [<span class="dv">1</span>, <span class="dv">2</span>] <span class="fu">&gt;&gt;=</span> \a <span class="ot">-&gt;</span>
              [<span class="dv">10</span>, <span class="dv">20</span>] <span class="fu">&gt;&gt;=</span> \b <span class="ot">-&gt;</span>
                [<span class="dv">100</span>, <span class="dv">200</span>] <span class="fu">&gt;&gt;=</span> \c <span class="ot">-&gt;</span>
                  return (a, b, c)
<span class="co">-- [(1,10,100),(1,10,200),(1,20,100),(1,20,200),(2,10,100),(2,10,200),(2,20,100),(2,20,200)]</span></code></pre></div>
<h2 id="io">IO</h2>
<p>Perhaps the most (in)famous example in Haskell of a type that forms a monad is <code>IO</code>. A value of type <code>IO a</code> is a computation which, when performed, does some I/O before returning a value of type <code>a</code>. These computations are called <a href="https://wiki.haskell.org/Introduction_to_Haskell_IO/Actions">actions</a>. IO actions executed in <code>main</code> are the means by which a program can operate on or access information in the external world. IO actions allow the program to do many things, including, but not limited to:</p>
<ul>
<li>Print a <code>String</code> to the terminal</li>
<li>Read and parse input from the terminal</li>
<li>Read from or write to a file on the system</li>
<li>Establish an <code>ssh</code> connection to a remote computer</li>
<li>Take input from a radio antenna for singal processing</li>
</ul>
<p>Conceptualizing I/O as a monad enables the developer to access information outside the program, but operate on the data with pure functions. The following examples will show how we can use IO actions and IO values to receive input from stdin and print to stdout.</p>
<p>Perhaps the most immediately useful function for doing I/O in Haskell is <code>putStrLn</code>. This function takes a <code>String</code> and returns an <code>IO ()</code>. Calling it from <code>main</code> will result in the <code>String</code> being printed to stdout followed by a newline character.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">putStrLn<span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</code></pre></div>
<p>Here is some code that prints a couple of lines to the terminal. The first invocation of <code>putStrLn</code> is executed, causing the <code>String</code> to be printed to stdout. The result is bound to a lambda expression that discards its argument, and then the next <code>putStrLn</code> is executed.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> putStrLn <span class="st">&quot;Vesihiisi sihisi hississäään.&quot;</span> <span class="fu">&gt;&gt;=</span>
         \_ <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;Or in English: &#39;The water devil was hissing</span>
<span class="st">                         in her elevator&#39;.&quot;</span>

<span class="co">-- Sugared code, written with do notation</span>
<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span> putStrLn <span class="st">&quot;Vesihiisi sihisi hississäään.&quot;</span>
          putStrLn <span class="st">&quot;Or in English: &#39;The water devil was hissing in her</span>
<span class="st">                    elevator&#39;.&quot;</span></code></pre></div>
<p>Another useful function is <code>getLine</code> which has type <code>IO String</code>. This function gets a line of input from stdin. The developer can then bind this line to a name in order to operate on the value within the program.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">getLine<span class="ot"> ::</span> <span class="dt">IO</span> <span class="dt">String</span></code></pre></div>
<p>The code below demonstrates a simple combination of these two functions as well as desugaring <code>IO</code> code. First, <code>putStrLn</code> prints a <code>String</code> to stdout to ask the user to supply their name, with the result being bound to a lambda that discards it argument. Then, <code>getLine</code> is executed, supplying a prompt to the user for entering their name. Next, the resultant <code>IO String</code> is bound to <code>name</code> and passed to <code>putStrLn</code>. Finally, the program prints the name to the terminal.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span> putStrLn <span class="st">&quot;What is your name: &quot;</span>
          name <span class="ot">&lt;-</span> getLine
          putStrLn name</code></pre></div>
<p>The next code block is the desugared equivalent of the previous example; however, the uses of <code>(&gt;&gt;=)</code> are made explict.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> putStrLn <span class="st">&quot;What is your name:&quot;</span> <span class="fu">&gt;&gt;=</span>
       \_    <span class="ot">-&gt;</span> getLine <span class="fu">&gt;&gt;=</span>
       \name <span class="ot">-&gt;</span> putStrLn name</code></pre></div>
<p>Our final example executes in the same way as the previous two examples. This example, though, uses the special <code>(&gt;&gt;)</code> <a href="#monadic-methods">operator</a> to take the place of binding a result to the lamda that discards its argument.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> putStrLn <span class="st">&quot;What is your name: &quot;</span> <span class="fu">&gt;&gt;</span> (getLine <span class="fu">&gt;&gt;=</span> (\name <span class="ot">-&gt;</span> putStrLn name))</code></pre></div>
<p>See: <a href="http://www.haskell.org/onlinereport/haskell2010/haskellch7.html">Haskell 2010: Basic/Input Output</a></p>
<h2 id="whats-the-point">What's the point?</h2>
<p>Although it is difficult, if not impossible, to touch, see, or otherwise physically interact with a monad, this construct has some very interesting implications for programmers. For instance, consider the non-intuitive fact that we now have a uniform interface for talking about three very different, but foundational ideas for programming: <em>Failure</em>, <em>Collections</em> and <em>Effects</em>.</p>
<p>Let's write down a new function called <code>sequence</code> which folds a function <code>mcons</code> over a list of monadic computations. We can think of <code>mcons</code> as analogous to the list constructor (i.e. <code>(a : b : [])</code>) except it pulls the two list elements out of two monadic values (<code>p</code>,<code>q</code>) by means of bind. The bound values are then joined with the list constructor <code>:</code>, before finally being rewrapped in the appropriate monadic context with <code>return</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">sequence<span class="ot"> ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> [m a] <span class="ot">-&gt;</span> m [a]
sequence <span class="fu">=</span> foldr mcons (return [])

<span class="ot">mcons ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m t <span class="ot">-&gt;</span> m [t] <span class="ot">-&gt;</span> m [t]
mcons p q <span class="fu">=</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> p          <span class="co">-- &#39;x&#39; refers to a singleton value</span>
  y <span class="ot">&lt;-</span> q          <span class="co">-- &#39;y&#39; refers to a list. Because of this fact, &#39;x&#39; can be</span>
  return (x<span class="fu">:</span>y)    <span class="co">--  prepended to it</span></code></pre></div>
<p>What does this function mean in terms of each of the monads discussed above?</p>
<p><strong>Maybe</strong></p>
<p>Sequencing a list of values within the <code>Maybe</code> <a href="#maybe">context</a> allows us to collect the results of a series of computations which can possibly fail. However, <code>sequence</code> yields the aggregated values only if each computation succeeds. In other words, if even one of the <code>Maybe</code> values in the initial list passed to <code>sequence</code>is a <code>Nothing</code>, the result of <code>sequence</code> will also be <code>Nothing</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">sequence<span class="ot"> ::</span> [<span class="dt">Maybe</span> a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [a]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">sequence [<span class="dt">Just</span> <span class="dv">3</span>, <span class="dt">Just</span> <span class="dv">4</span>]
<span class="co">-- Just [3,4]</span>

sequence [<span class="dt">Just</span> <span class="dv">3</span>, <span class="dt">Just</span> <span class="dv">4</span>, <span class="dt">Nothing</span>]     <span class="co">-- Since one of the results is Nothing,</span>
<span class="co">-- Nothing                             -- the whole computation fails</span></code></pre></div>
<p><strong>List</strong></p>
<p>The bind operation for the <a href="#list">list monad</a> forms the pairwise list of elements from the two operands. Thus, folding the binds contained in <code>mcons</code> over a list of lists with <code>sequence</code> implements the general Cartesian product for an arbitrary number of lists.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">sequence<span class="ot"> ::</span> [[a]] <span class="ot">-&gt;</span> [[a]]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">sequence [[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">30</span>]]
<span class="co">-- [[1,10],[1,20],[1,30],[2,10],[2,20],[2,30],[3,10],[3,20],[3,30]]</span></code></pre></div>
<p><strong>IO</strong></p>
<p>Applying <code>sequence</code> within the <a href="#io">IO context</a> results in still a different result. The function takes a list of IO actions, performs them sequentially, and then returns the list of resulting values in the order sequenced.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">sequence<span class="ot"> ::</span> [<span class="dt">IO</span> a] <span class="ot">-&gt;</span> <span class="dt">IO</span> [a]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">sequence [getLine, getLine, getLine]
<span class="co">-- a                                  -- a, b, and 9 are the inputs given by the</span>
<span class="co">-- b                                  -- user at the prompt</span>
<span class="co">-- 9</span>
<span class="co">-- [&quot;a&quot;, &quot;b&quot;, &quot;9&quot;]                    -- All inputs are returned in a list as</span>
                                      <span class="co">-- an IO [String].</span></code></pre></div>
<p>So there we have it, three fundamental concepts of computation that are normally defined independently of each other actually all share this similar structure. This unifying pattern can be abstracted out and reused to build higher abstractions that work for all current and future implementations. If you want a motivating reason for understanding monads, this is it! These insights are the essence of what I wish I knew about monads looking back.</p>
<p>See: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad.html#g:4">Control.Monad</a></p>
<h2 id="reader-monad">Reader Monad</h2>
<p>The reader monad lets us access shared immutable state within a monadic context.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ask ::</span> <span class="dt">Reader</span> r r
<span class="ot">asks ::</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Reader</span> r a
<span class="ot">local ::</span> (r <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">Reader</span> r a <span class="ot">-&gt;</span> <span class="dt">Reader</span> r a
<span class="ot">runReader ::</span> <span class="dt">Reader</span> r a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> a</code></pre></div>
<div class="sourceCode" include="src/02-monads/reader.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Reader</span>

<span class="kw">data</span> <span class="dt">MyContext</span> <span class="fu">=</span> <span class="dt">MyContext</span>
  {<span class="ot"> foo ::</span> <span class="dt">String</span>
  ,<span class="ot"> bar ::</span> <span class="dt">Int</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="ot">computation ::</span> <span class="dt">Reader</span> <span class="dt">MyContext</span> (<span class="dt">Maybe</span> <span class="dt">String</span>)
computation <span class="fu">=</span> <span class="kw">do</span>
  n <span class="ot">&lt;-</span> asks bar
  x <span class="ot">&lt;-</span> asks foo
  <span class="kw">if</span> n <span class="fu">&gt;</span> <span class="dv">0</span>
    <span class="kw">then</span> return (<span class="dt">Just</span> x)
    <span class="kw">else</span> return <span class="dt">Nothing</span>

<span class="ot">ex1 ::</span> <span class="dt">Maybe</span> <span class="dt">String</span>
ex1 <span class="fu">=</span> runReader computation <span class="fu">$</span> <span class="dt">MyContext</span> <span class="st">&quot;hello&quot;</span> <span class="dv">1</span>

<span class="ot">ex2 ::</span> <span class="dt">Maybe</span> <span class="dt">String</span>
ex2 <span class="fu">=</span> runReader computation <span class="fu">$</span> <span class="dt">MyContext</span> <span class="st">&quot;haskell&quot;</span> <span class="dv">0</span></code></pre></div>
<p>A simple implementation of the Reader monad:</p>
<div class="sourceCode" include="src/02-monads/reader_impl.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Reader</span> r a <span class="fu">=</span> <span class="dt">Reader</span> {<span class="ot"> runReader ::</span> r <span class="ot">-&gt;</span> a }

<span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Reader</span> r) <span class="kw">where</span>
  return a <span class="fu">=</span> <span class="dt">Reader</span> <span class="fu">$</span> \_ <span class="ot">-&gt;</span> a
  m <span class="fu">&gt;&gt;=</span> k  <span class="fu">=</span> <span class="dt">Reader</span> <span class="fu">$</span> \r <span class="ot">-&gt;</span> runReader (k (runReader m r)) r

<span class="ot">ask ::</span> <span class="dt">Reader</span> a a
ask <span class="fu">=</span> <span class="dt">Reader</span> id

<span class="ot">asks ::</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Reader</span> r a
asks f <span class="fu">=</span> <span class="dt">Reader</span> f

<span class="ot">local ::</span> (r <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">Reader</span> r a <span class="ot">-&gt;</span> <span class="dt">Reader</span> r a
local f m <span class="fu">=</span> <span class="dt">Reader</span> <span class="fu">$</span> runReader m <span class="fu">.</span> f</code></pre></div>
<h2 id="writer-monad">Writer Monad</h2>
<p>The writer monad lets us emit a lazy stream of values from within a monadic context.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">tell ::</span> w <span class="ot">-&gt;</span> <span class="dt">Writer</span> w ()
<span class="ot">execWriter ::</span> <span class="dt">Writer</span> w a <span class="ot">-&gt;</span> w
<span class="ot">runWriter ::</span> <span class="dt">Writer</span> w a <span class="ot">-&gt;</span> (a, w)</code></pre></div>
<div class="sourceCode" include="src/02-monads/writer.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Writer</span>

<span class="kw">type</span> <span class="dt">MyWriter</span> <span class="fu">=</span> <span class="dt">Writer</span> [<span class="dt">Int</span>] <span class="dt">String</span>

<span class="ot">example ::</span> <span class="dt">MyWriter</span>
example  <span class="fu">=</span> <span class="kw">do</span>
  tell [<span class="dv">1</span><span class="fu">..</span><span class="dv">3</span>]
  tell [<span class="dv">3</span><span class="fu">..</span><span class="dv">5</span>]
  return <span class="st">&quot;foo&quot;</span>

<span class="ot">output ::</span> (<span class="dt">String</span>, [<span class="dt">Int</span>])
output <span class="fu">=</span> runWriter example
<span class="co">-- (&quot;foo&quot;, [1, 2, 3, 3, 4, 5])</span></code></pre></div>
<p>A simple implementation of the Writer monad:</p>
<div class="sourceCode" include="src/02-monads/writer_impl.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Monoid</span>

<span class="kw">newtype</span> <span class="dt">Writer</span> w a <span class="fu">=</span> <span class="dt">Writer</span> {<span class="ot"> runWriter ::</span> (a, w) }

<span class="kw">instance</span> <span class="dt">Monoid</span> w <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Writer</span> w) <span class="kw">where</span>
  return a <span class="fu">=</span> <span class="dt">Writer</span> (a, mempty)
  m <span class="fu">&gt;&gt;=</span> k  <span class="fu">=</span> <span class="dt">Writer</span> <span class="fu">$</span> <span class="kw">let</span>
      (a, w)  <span class="fu">=</span> runWriter m
      (b, w&#39;) <span class="fu">=</span> runWriter (k a)
      <span class="kw">in</span> (b, w <span class="ot">`mappend`</span> w&#39;)

<span class="ot">execWriter ::</span> <span class="dt">Writer</span> w a <span class="ot">-&gt;</span> w
execWriter m <span class="fu">=</span> snd (runWriter m)

<span class="ot">tell ::</span> w <span class="ot">-&gt;</span> <span class="dt">Writer</span> w ()
tell w <span class="fu">=</span> <span class="dt">Writer</span> ((), w)</code></pre></div>
<p>This implementation is lazy, so some care must be taken that one actually wants to only generate a stream of thunks. Most often the lazy writer is not suitable for use, instead implement the equivalent structure by embedding some monomial object inside a StateT monad, or using the strict version.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Writer.Strict</span></code></pre></div>
<h2 id="state-monad">State Monad</h2>
<p>The state monad allows functions within a stateful monadic context to access and modify shared state.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runState  ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, s)
<span class="ot">evalState ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a
<span class="ot">execState ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s</code></pre></div>
<div class="sourceCode" include="src/02-monads/state.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.State</span>

<span class="ot">test ::</span> <span class="dt">State</span> <span class="dt">Int</span> <span class="dt">Int</span>
test <span class="fu">=</span> <span class="kw">do</span>
  put <span class="dv">3</span>
  modify (<span class="fu">+</span><span class="dv">1</span>)
  get

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> print <span class="fu">$</span> execState test <span class="dv">0</span></code></pre></div>
<p>The state monad is often mistakenly described as being impure, but it is in fact entirely pure and the same effect could be achieved by explicitly passing state. A simple implementation of the State monad takes only a few lines:</p>
<div class="sourceCode" include="src/02-monads/state_impl.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="fu">=</span> <span class="dt">State</span> {<span class="ot"> runState ::</span> s <span class="ot">-&gt;</span> (a,s) }

<span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">State</span> s) <span class="kw">where</span>
  return a <span class="fu">=</span> <span class="dt">State</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> (a, s)

  <span class="dt">State</span> act <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> <span class="dt">State</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span>
    <span class="kw">let</span> (a, s&#39;) <span class="fu">=</span> act s
    <span class="kw">in</span> runState (k a) s&#39;

<span class="ot">get ::</span> <span class="dt">State</span> s s
get <span class="fu">=</span> <span class="dt">State</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> (s, s)

<span class="ot">put ::</span> s <span class="ot">-&gt;</span> <span class="dt">State</span> s ()
put s <span class="fu">=</span> <span class="dt">State</span> <span class="fu">$</span> \_ <span class="ot">-&gt;</span> ((), s)

<span class="ot">modify ::</span> (s <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">State</span> s ()
modify f <span class="fu">=</span> get <span class="fu">&gt;&gt;=</span> \x <span class="ot">-&gt;</span> put (f x)

<span class="ot">evalState ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a
evalState act <span class="fu">=</span> fst <span class="fu">.</span> runState act

<span class="ot">execState ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
execState act <span class="fu">=</span> snd <span class="fu">.</span> runState act</code></pre></div>
<h2 id="monad-tutorials">Monad Tutorials</h2>
<p>So many monad tutorials have been written that it begs the question: what makes monads so difficult when first learning Haskell? I hypothesize there are three aspects to why this is so:</p>
<ol style="list-style-type: decimal">
<li><em>There are several levels on indirection with desugaring.</em></li>
</ol>
<p>A lot of the Haskell we write is radically rearranged and transformed into an entirely new form under the hood.</p>
<p>Most monad tutorials will not manually expand out the do-sugar. This leaves the beginner thinking that monads are a way of dropping into a pseudo-imperative language inside of code and further fuels that misconception that specific instances like IO are monads in their full generality.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> getLine
  putStrLn x
  return ()</code></pre></div>
<p>Being able to manually desugar is crucial to understanding.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span>
  getLine <span class="fu">&gt;&gt;=</span> \x <span class="ot">-&gt;</span>
    putStrLn x <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span>
      return ()</code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li><em>Asymmetric binary infix operators for higher order functions are not common in other languages.</em></li>
</ol>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&gt;&gt;=) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</code></pre></div>
<p>On the left hand side of the operator we have an <code>m a</code> and on the right we have <code>a -&gt; m b</code>. Although some languages do have infix operators that are themselves higher order functions, it is still a rather rare occurrence.</p>
<p>So with a function desugared, it can be confusing that <code>(&gt;&gt;=)</code> operator is in fact building up a much larger function by composing functions together.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span>
  getLine <span class="fu">&gt;&gt;=</span> \x <span class="ot">-&gt;</span>
    putStrLn <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span>
      return ()</code></pre></div>
<p>Written in prefix form, it becomes a little bit more digestible.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span>
  (<span class="fu">&gt;&gt;=</span>) getLine (\x <span class="ot">-&gt;</span>
    (<span class="fu">&gt;&gt;=</span>) putStrLn (\_ <span class="ot">-&gt;</span>
          return ()
    )
  )</code></pre></div>
<p>Perhaps even removing the operator entirely might be more intuitive coming from other languages.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> bind getLine (\x <span class="ot">-&gt;</span> bind putStrLn (\_ <span class="ot">-&gt;</span> return ()))
  <span class="kw">where</span>
    bind x y <span class="fu">=</span> x <span class="fu">&gt;&gt;=</span> y</code></pre></div>
<ol start="3" style="list-style-type: decimal">
<li><em>Ad-hoc polymorphism is not commonplace in other languages.</em></li>
</ol>
<p>Haskell's implementation of overloading can be unintuitive if one is not familiar with type inference. It is abstracted away from the user, but the <code>(&gt;&gt;=)</code> or <code>bind</code> function is really a function of 3 arguments with the extra typeclass dictionary argument (<code>$dMonad</code>) implicitly threaded around.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">$</span>dMonad <span class="fu">=</span> bind <span class="fu">$</span>dMonad getLine (\x <span class="ot">-&gt;</span> bind <span class="fu">$</span>dMonad putStrLn (\_ <span class="ot">-&gt;</span> return <span class="fu">$</span>dMonad ()))</code></pre></div>
<p>Except in the case where the parameter of the monad class is unified ( through inference ) with a concrete class instance, in which case the instance dictionary (<code>$dMonadIO</code>) is instead spliced throughout.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> bind <span class="fu">$</span>dMonadIO getLine (\x <span class="ot">-&gt;</span> bind <span class="fu">$</span>dMonadIO putStrLn (\_ <span class="ot">-&gt;</span> return <span class="fu">$</span>dMonadIO ()))</code></pre></div>
<p>Now, all of these transformations are trivial once we understand them, they're just typically not discussed. In my opinion the fundamental fallacy of monad tutorials is not that intuition for monads is hard to convey ( nor are metaphors required! ), but that novices often come to monads with an incomplete understanding of points (1), (2), and (3) and then trip on the simple fact that monads are the first example of a Haskell construct that is the confluence of all three.</p>
<p>See: <a href="http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/">Monad Tutorial Fallacy</a></p>
<hr />
<h1 id="monad-transformers">Monad Transformers</h1>
<h2 id="mtl-transformers">mtl / transformers</h2>
<p>So, the descriptions of Monads in the previous chapter are a bit of a white lie. Modern Haskell monad libraries typically use a more general form of these, written in terms of monad transformers which allow us to compose monads together to form composite monads. The monads mentioned previously are subsumed by the special case of the transformer form composed with the Identity monad.</p>
<table>
<thead>
<tr class="header">
<th align="left">Monad</th>
<th align="left">Transformer</th>
<th align="left">Type</th>
<th align="left">Transformed Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Maybe</td>
<td align="left">MaybeT</td>
<td align="left"><code>Maybe a</code></td>
<td align="left"><code>m (Maybe a)</code></td>
</tr>
<tr class="even">
<td align="left">Reader</td>
<td align="left">ReaderT</td>
<td align="left"><code>r -&gt; a</code></td>
<td align="left"><code>r -&gt; m a</code></td>
</tr>
<tr class="odd">
<td align="left">Writer</td>
<td align="left">WriterT</td>
<td align="left"><code>(a,w)</code></td>
<td align="left"><code>m (a,w)</code></td>
</tr>
<tr class="even">
<td align="left">State</td>
<td align="left">StateT</td>
<td align="left"><code>s -&gt; (a,s)</code></td>
<td align="left"><code>s -&gt; m (a,s)</code></td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">State</span>  s <span class="fu">=</span> <span class="dt">StateT</span>  s <span class="dt">Identity</span>
<span class="kw">type</span> <span class="dt">Writer</span> w <span class="fu">=</span> <span class="dt">WriterT</span> w <span class="dt">Identity</span>
<span class="kw">type</span> <span class="dt">Reader</span> r <span class="fu">=</span> <span class="dt">ReaderT</span> r <span class="dt">Identity</span>

<span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadState</span> s (<span class="dt">StateT</span> s m)
<span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadReader</span> r (<span class="dt">ReaderT</span> r m)
<span class="kw">instance</span> (<span class="dt">Monoid</span> w, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadWriter</span> w (<span class="dt">WriterT</span> w m)</code></pre></div>
<p>In terms of generality the mtl library is the most common general interface for these monads, which itself depends on the transformers library which generalizes the &quot;basic&quot; monads described above into transformers.</p>
<h2 id="transformers">Transformers</h2>
<p>At their core monad transformers allow us to nest monadic computations in a stack with an interface to exchange values between the levels, called <code>lift</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lift ::</span> (<span class="dt">Monad</span> m, <span class="dt">MonadTrans</span> t) <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> t m a
<span class="ot">liftIO ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> m a</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">MonadTrans</span> t <span class="kw">where</span>
<span class="ot">    lift ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> t m a

<span class="kw">class</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadIO</span> m <span class="kw">where</span>
<span class="ot">    liftIO ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> m a

<span class="kw">instance</span> <span class="dt">MonadIO</span> <span class="dt">IO</span> <span class="kw">where</span>
    liftIO <span class="fu">=</span> id</code></pre></div>
<p>Just as the base monad class has laws, monad transformers also have several laws:</p>
<p><strong>Law #1</strong></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">lift <span class="fu">.</span> return <span class="fu">=</span> return</code></pre></div>
<p><strong>Law #2</strong></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">lift (m <span class="fu">&gt;&gt;=</span> f) <span class="fu">=</span> lift m <span class="fu">&gt;&gt;=</span> (lift <span class="fu">.</span> f)</code></pre></div>
<p>Or equivalently:</p>
<p><strong>Law #1</strong></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  lift (return x)

<span class="fu">=</span> return x</code></pre></div>
<p><strong>Law #2</strong></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="kw">do</span> x <span class="ot">&lt;-</span> lift m
     lift (f x)

<span class="fu">=</span> lift <span class="fu">$</span> <span class="kw">do</span> x <span class="ot">&lt;-</span> m
            f x</code></pre></div>
<p>It's useful to remember that transformers compose <em>outside-in</em> but are <em>unrolled inside out</em>.</p>
<p>See: <a href="http://catamorph.de/publications/2004-10-01-monad-transformers.html">Monad Transformers: Step-By-Step</a></p>
<h2 id="basics-1">Basics</h2>
<p>The most basic use requires us to use the T-variants for each of the monad transformers in the outer layers and to explicitly <code>lift</code> and <code>return</code> values between the layers. Monads have kind <code>(* -&gt; *)</code>, so monad transformers which take monads to monads have <code>((* -&gt; *) -&gt; * -&gt; *)</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Monad</span> (<span class="ot">m ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>)
<span class="dt">MonadTrans</span> (<span class="ot">t ::</span> (<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>)</code></pre></div>
<p>So, for example, if we wanted to form a composite computation using both the Reader and Maybe monads we can now put the Maybe inside of a <code>ReaderT</code> to form <code>ReaderT t Maybe a</code>.</p>
<div class="sourceCode" include="src/03-monad-transformers/transformer.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Reader</span>

<span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> [(<span class="dt">String</span>, <span class="dt">Int</span>)]
<span class="kw">type</span> <span class="dt">Eval</span> a <span class="fu">=</span> <span class="dt">ReaderT</span> <span class="dt">Env</span> <span class="dt">Maybe</span> a

<span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="dt">Val</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Var</span> <span class="dt">String</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="ot">eval ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Eval</span> <span class="dt">Int</span>
eval ex <span class="fu">=</span> <span class="kw">case</span> ex <span class="kw">of</span>

  <span class="dt">Val</span> n <span class="ot">-&gt;</span> return n

  <span class="dt">Add</span> x y <span class="ot">-&gt;</span> <span class="kw">do</span>
    a <span class="ot">&lt;-</span> eval x
    b <span class="ot">&lt;-</span> eval y
    return (a<span class="fu">+</span>b)

  <span class="dt">Var</span> x <span class="ot">-&gt;</span> <span class="kw">do</span>
    env <span class="ot">&lt;-</span> ask
    val <span class="ot">&lt;-</span> lift (lookup x env)
    return val

<span class="ot">env ::</span> <span class="dt">Env</span>
env <span class="fu">=</span> [(<span class="st">&quot;x&quot;</span>, <span class="dv">2</span>), (<span class="st">&quot;y&quot;</span>, <span class="dv">5</span>)]

<span class="ot">ex1 ::</span> <span class="dt">Eval</span> <span class="dt">Int</span>
ex1 <span class="fu">=</span> eval (<span class="dt">Add</span> (<span class="dt">Val</span> <span class="dv">2</span>) (<span class="dt">Add</span> (<span class="dt">Val</span> <span class="dv">1</span>) (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>)))

example1,<span class="ot"> example2 ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
example1 <span class="fu">=</span> runReaderT ex1 env
example2 <span class="fu">=</span> runReaderT ex1 []</code></pre></div>
<p>The fundamental limitation of this approach is that we find ourselves <code>lift.lift.lift</code>ing and <code>return.return.return</code>ing a lot.</p>
<h2 id="readert">ReaderT</h2>
<p>For example, there exist three possible forms of the Reader monad. The first is the Haskell 98 version that no longer exists, but is useful for understanding the underlying ideas. The other two are the <em>transformers</em> and <em>mtl</em> variants.</p>
<p><em>Reader</em></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Reader</span> r a <span class="fu">=</span> <span class="dt">Reader</span> {<span class="ot"> runReader ::</span> r <span class="ot">-&gt;</span> a }

<span class="kw">instance</span> <span class="dt">MonadReader</span> r (<span class="dt">Reader</span> r) <span class="kw">where</span>
  ask       <span class="fu">=</span> <span class="dt">Reader</span> id
  local f m <span class="fu">=</span> <span class="dt">Reader</span> (runReader m <span class="fu">.</span> f)</code></pre></div>
<p><em>ReaderT</em></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ReaderT</span> r m a <span class="fu">=</span> <span class="dt">ReaderT</span> {<span class="ot"> runReaderT ::</span> r <span class="ot">-&gt;</span> m a }

<span class="kw">instance</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">ReaderT</span> r m) <span class="kw">where</span>
  return a <span class="fu">=</span> <span class="dt">ReaderT</span> <span class="fu">$</span> \_ <span class="ot">-&gt;</span> return a
  m <span class="fu">&gt;&gt;=</span> k  <span class="fu">=</span> <span class="dt">ReaderT</span> <span class="fu">$</span> \r <span class="ot">-&gt;</span> <span class="kw">do</span>
      a <span class="ot">&lt;-</span> runReaderT m r
      runReaderT (k a) r

<span class="kw">instance</span> <span class="dt">MonadTrans</span> (<span class="dt">ReaderT</span> r) <span class="kw">where</span>
    lift m <span class="fu">=</span> <span class="dt">ReaderT</span> <span class="fu">$</span> \_ <span class="ot">-&gt;</span> m</code></pre></div>
<p><em>MonadReader</em></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadReader</span> r m <span class="fu">|</span> m <span class="ot">-&gt;</span> r <span class="kw">where</span>
<span class="ot">  ask   ::</span> m r
<span class="ot">  local ::</span> (r <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m a

<span class="kw">instance</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadReader</span> r (<span class="dt">ReaderT</span> r m) <span class="kw">where</span>
  ask       <span class="fu">=</span> <span class="dt">ReaderT</span> return
  local f m <span class="fu">=</span> <span class="dt">ReaderT</span> <span class="fu">$</span> \r <span class="ot">-&gt;</span> runReaderT m (f r)</code></pre></div>
<p>So, hypothetically the three variants of ask would be:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ask ::</span> <span class="dt">Reader</span> r r
<span class="ot">ask ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ReaderT</span> r m r
<span class="ot">ask ::</span> <span class="dt">MonadReader</span> r m <span class="ot">=&gt;</span> m r</code></pre></div>
<p>In practice only the last one is used in modern Haskell.</p>
<h2 id="newtype-deriving">Newtype Deriving</h2>
<p>Newtypes let us reference a data type with a single constructor as a new distinct type, with no runtime overhead from boxing, unlike an algebraic datatype with a single constructor. Newtype wrappers around strings and numeric types can often drastically reduce accidental errors.</p>
<p>Consider the case of using a newtype to distinguish between two different text blobs with different semantics. Both have the same runtime representation as a text object, but are distinguished statically, so that plaintext can not be accidentally interchanged with encrypted text.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Plaintext</span> <span class="fu">=</span> <span class="dt">Plaintext</span> <span class="dt">Text</span>
<span class="kw">newtype</span> <span class="dt">Crytpotext</span> <span class="fu">=</span> <span class="dt">Cryptotext</span> <span class="dt">Text</span>

<span class="ot">encrypt ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">Plaintext</span> <span class="ot">-&gt;</span> <span class="dt">Cryptotext</span>
<span class="ot">decrypt ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">Cryptotext</span> <span class="ot">-&gt;</span> <span class="dt">Plaintext</span></code></pre></div>
<p>The other common use case is using newtypes to derive logic for deriving custom monad transformers in our business logic. Using <code>-XGeneralizedNewtypeDeriving</code> we can recover the functionality of instances of the underlying types composed in our transformer stack.</p>
<div class="sourceCode" include="src/03-monad-transformers/newtype.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>

<span class="kw">newtype</span> <span class="dt">Velocity</span> <span class="fu">=</span> <span class="dt">Velocity</span> {<span class="ot"> unVelocity ::</span> <span class="dt">Double</span> }
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)

<span class="ot">v ::</span> <span class="dt">Velocity</span>
v <span class="fu">=</span> <span class="dt">Velocity</span> <span class="fl">2.718</span>

<span class="ot">x ::</span> <span class="dt">Double</span>
x <span class="fu">=</span> <span class="fl">2.718</span>

<span class="co">-- Type error is caught at compile time even though</span>
<span class="co">-- they are the same value at runtime!</span>
err <span class="fu">=</span> v <span class="fu">+</span> x

<span class="kw">newtype</span> <span class="dt">Quantity</span> v a <span class="fu">=</span> <span class="dt">Quantity</span> a
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Num</span>, <span class="dt">Show</span>)

<span class="kw">data</span> <span class="dt">Haskeller</span>
<span class="kw">type</span> <span class="dt">Haskellers</span> <span class="fu">=</span> <span class="dt">Quantity</span> <span class="dt">Haskeller</span> <span class="dt">Int</span>

a <span class="fu">=</span> <span class="dt">Quantity</span> <span class="dv">2</span><span class="ot"> ::</span> <span class="dt">Haskellers</span>
b <span class="fu">=</span> <span class="dt">Quantity</span> <span class="dv">6</span><span class="ot"> ::</span> <span class="dt">Haskellers</span>

<span class="ot">totalHaskellers ::</span> <span class="dt">Haskellers</span>
totalHaskellers <span class="fu">=</span> a <span class="fu">+</span> b</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Couldn&#39;t</span> match <span class="kw">type</span> <span class="ot">`Double&#39; with `</span><span class="dt">Velocity&#39;</span>
<span class="dt">Expected</span> <span class="kw">type</span><span class="fu">:</span> <span class="dt">Velocity</span>
  <span class="dt">Actual</span> <span class="kw">type</span><span class="fu">:</span> <span class="dt">Double</span>
<span class="dt">In</span> the second argument <span class="kw">of</span> <span class="ot">`(+)&#39;, namely `</span>x&#39;
<span class="dt">In</span> the expression<span class="fu">:</span> v <span class="fu">+</span> x</code></pre></div>
<p>Using newtype deriving with the mtl library typeclasses we can produce flattened transformer types that don't require explicit lifting in the transform stack. For example, here is a little stack machine involving the Reader, Writer and State monads.</p>
<div class="sourceCode" include="src/03-monad-transformers/newtype_deriving.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>

<span class="kw">import </span><span class="dt">Control.Monad.Reader</span>
<span class="kw">import </span><span class="dt">Control.Monad.Writer</span>
<span class="kw">import </span><span class="dt">Control.Monad.State</span>

<span class="kw">type</span> <span class="dt">Stack</span>   <span class="fu">=</span> [<span class="dt">Int</span>]
<span class="kw">type</span> <span class="dt">Output</span>  <span class="fu">=</span> [<span class="dt">Int</span>]
<span class="kw">type</span> <span class="dt">Program</span> <span class="fu">=</span> [<span class="dt">Instr</span>]

<span class="kw">type</span> <span class="dt">VM</span> a <span class="fu">=</span> <span class="dt">ReaderT</span> <span class="dt">Program</span> (<span class="dt">WriterT</span> <span class="dt">Output</span> (<span class="dt">State</span> <span class="dt">Stack</span>)) a

<span class="kw">newtype</span> <span class="dt">Comp</span> a <span class="fu">=</span> <span class="dt">Comp</span> {<span class="ot"> unComp ::</span> <span class="dt">VM</span> a }
  <span class="kw">deriving</span> (<span class="dt">Monad</span>, <span class="dt">MonadReader</span> <span class="dt">Program</span>, <span class="dt">MonadWriter</span> <span class="dt">Output</span>, <span class="dt">MonadState</span> <span class="dt">Stack</span>)

<span class="kw">data</span> <span class="dt">Instr</span> <span class="fu">=</span> <span class="dt">Push</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Pop</span> <span class="fu">|</span> <span class="dt">Puts</span>

<span class="ot">evalInstr ::</span> <span class="dt">Instr</span> <span class="ot">-&gt;</span> <span class="dt">Comp</span> ()
evalInstr instr <span class="fu">=</span> <span class="kw">case</span> instr <span class="kw">of</span>
  <span class="dt">Pop</span>    <span class="ot">-&gt;</span> modify tail
  <span class="dt">Push</span> n <span class="ot">-&gt;</span> modify (n<span class="fu">:</span>)
  <span class="dt">Puts</span>   <span class="ot">-&gt;</span> <span class="kw">do</span>
    tos <span class="ot">&lt;-</span> gets head
    tell [tos]

<span class="ot">eval ::</span> <span class="dt">Comp</span> ()
eval <span class="fu">=</span> <span class="kw">do</span>
  instr <span class="ot">&lt;-</span> ask
  <span class="kw">case</span> instr <span class="kw">of</span>
    []     <span class="ot">-&gt;</span> return ()
    (i<span class="fu">:</span>is) <span class="ot">-&gt;</span> evalInstr i <span class="fu">&gt;&gt;</span> local (const is) eval

<span class="ot">execVM ::</span> <span class="dt">Program</span> <span class="ot">-&gt;</span> <span class="dt">Output</span>
execVM <span class="fu">=</span> flip evalState [] <span class="fu">.</span> execWriterT <span class="fu">.</span> runReaderT (unComp eval)

<span class="ot">program ::</span> <span class="dt">Program</span>
program <span class="fu">=</span> [
     <span class="dt">Push</span> <span class="dv">42</span>,
     <span class="dt">Push</span> <span class="dv">27</span>,
     <span class="dt">Puts</span>,
     <span class="dt">Pop</span>,
     <span class="dt">Puts</span>,
     <span class="dt">Pop</span>
  ]

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> mapM_ print <span class="fu">$</span> execVM program</code></pre></div>
<p>Pattern matching on a newtype constructor compiles into nothing. For example the<code>extractB</code> function does not scrutinize the <code>MkB</code> constructor like the <code>extractA</code> does, because <code>MkB</code> does not exist at runtime, it is purely a compile-time construct.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">A</span> <span class="fu">=</span> <span class="dt">MkA</span> <span class="dt">Int</span>
<span class="kw">newtype</span> <span class="dt">B</span> <span class="fu">=</span> <span class="dt">MkB</span> <span class="dt">Int</span>

<span class="ot">extractA ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
extractA (<span class="dt">MkA</span> x) <span class="fu">=</span> x

<span class="ot">extractB ::</span> <span class="dt">B</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
extractB (<span class="dt">MkB</span> x) <span class="fu">=</span> x</code></pre></div>
<h2 id="efficiency">Efficiency</h2>
<p>The second monad transformer law guarantees that sequencing consecutive lift operations is semantically equivalent to lifting the results into the outer monad.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span> x <span class="ot">&lt;-</span> lift m  <span class="fu">==</span>  lift <span class="fu">$</span> <span class="kw">do</span> x <span class="ot">&lt;-</span> m
   lift (f x)                 f x</code></pre></div>
<p>Although they are guaranteed to yield the same result, the operation of lifting the results between the monad levels is not without cost and crops up frequently when working with the monad traversal and looping functions. For example, all three of the functions on the left below are less efficient than the right hand side which performs the bind in the base monad instead of lifting on each iteration.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Less Efficient      More Efficient</span>
forever (lift m)    <span class="fu">==</span> lift (forever m)
mapM_ (lift <span class="fu">.</span> f) xs <span class="fu">==</span> lift (mapM_ f xs)
forM_ xs (lift <span class="fu">.</span> f) <span class="fu">==</span> lift (forM_ xs f)</code></pre></div>
<h2 id="monad-morphisms">Monad Morphisms</h2>
<p>The base monad transformer package provides a <code>MonadTrans</code> class for lifting to another monad:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lift ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> t m a</code></pre></div>
<p>But often times we need to work with and manipulate our monad transformer stack to either produce new transformers, modify existing ones or extend an upstream library with new layers. The <code>mmorph</code> library provides the capacity to compose monad morphism transformation directly on transformer stacks. The equivalent of type transformer type-level map is the <code>hoist</code> function.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">hoist ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (forall a<span class="fu">.</span> m a <span class="ot">-&gt;</span> n a) <span class="ot">-&gt;</span> t m b <span class="ot">-&gt;</span> t n b</code></pre></div>
<p>Hoist takes a <em>monad morphism</em> (a mapping from a <code>m a</code> to a <code>n a</code>) and applies in on the inner value monad of a transformer stack, transforming the value under the outer layer.</p>
<p>The monad morphism <code>generalize</code> takes an Identity monad into any another monad <code>m</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">generalize ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Identity</span> a <span class="ot">-&gt;</span> m a</code></pre></div>
<p>For example, it generalizes <code>State s a</code> (which is <code>StateT s Identity a</code>) to <code>StateT s m a</code>.</p>
<p>So we can generalize an existing transformer to lift an IO layer onto it.</p>
<div class="sourceCode" include="src/10-advanced-monads/mmorph.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.State</span>
<span class="kw">import </span><span class="dt">Control.Monad.Morph</span>

<span class="kw">type</span> <span class="dt">Eval</span> a <span class="fu">=</span> <span class="dt">State</span> [<span class="dt">Int</span>] a

<span class="ot">runEval ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Eval</span> a <span class="ot">-&gt;</span> a
runEval <span class="fu">=</span> flip evalState

<span class="ot">pop ::</span> <span class="dt">Eval</span> <span class="dt">Int</span>
pop <span class="fu">=</span> <span class="kw">do</span>
  top <span class="ot">&lt;-</span> gets head
  modify tail
  return top

<span class="ot">push ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Eval</span> ()
push x <span class="fu">=</span> modify (x<span class="fu">:</span>)

<span class="ot">ev1 ::</span> <span class="dt">Eval</span> <span class="dt">Int</span>
ev1 <span class="fu">=</span> <span class="kw">do</span>
  push <span class="dv">3</span>
  push <span class="dv">4</span>
  pop
  pop

<span class="ot">ev2  ::</span> <span class="dt">StateT</span> [<span class="dt">Int</span>] <span class="dt">IO</span> ()
ev2 <span class="fu">=</span> <span class="kw">do</span>
  result <span class="ot">&lt;-</span> hoist generalize ev1
  liftIO <span class="fu">$</span> putStrLn <span class="fu">$</span> <span class="st">&quot;Result: &quot;</span> <span class="fu">++</span> show result</code></pre></div>
<p>See: <a href="https://hackage.haskell.org/package/mmorph">mmorph</a></p>
<hr />
<h1 id="language-extensions">Language Extensions</h1>
<p>It's important to distinguish between different categories of language extensions <em>general</em> and <em>specialized</em>.</p>
<p>The inherent problem with classifying the extensions into the general and specialized categories is that it's a subjective classification. Haskellers who do type system research will have a very different interpretation of Haskell than people who do web programming. As such this is a conservative assessment, as an arbitrary baseline let's consider <code>FlexibleInstances</code> and <code>OverloadedStrings</code> &quot;everyday&quot; while <code>GADTs</code> and <code>TypeFamilies</code> are &quot;specialized&quot;.</p>
<p><strong>Key</strong></p>
<ul>
<li><em>Benign</em> implies both that importing the extension won't change the semantics of the module if not used and that enabling it makes it no easier to shoot yourself in the foot.</li>
<li><em>Historical</em> implies that one shouldn't use this extension, it's in GHC purely for backwards compatibility. Sometimes these are dangerous to enable.</li>
<li><em>Steals syntax</em> means that enabling this extension means that certain code valid in vanilla Haskell will no longer be accepted. For example, <code>f $(a)</code> is the same as <code>f $ (a)</code> in Haskell98, but <code>TemplateHaskell</code> will interpret <code>$(a)</code> as a splice.</li>
</ul>
<p><extensions></extensions></p>
<table class="table-striped">
  <tr class="striped-header">
    <td></td>
    <td>Benign</td>
    <td>Historical</td>
    <td>Steals Syntax</td>
    <td>Use</td>
    <td>Use</td>
    <td>GHC Reference</td>
    <td>Reference</td>
  </tr>
  <tr>
    <td>AllowAmbiguousTypes</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#ambiguity">
    Ref</a></td>
    <td></td>
  </tr>
  <tr>
    <td>Arrows</td>
    <td></td>
    <td></td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/arrow-notation.html">
    Ref</a></td>
    <td><a href="#arrows">Arrows</a></td>
  </tr>
  <tr>
    <td>AutoDeriveTypeable</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Deriving</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#auto-derive-typeable">
    Ref</a></td>
  </tr>
  <tr>
    <td>BangPatterns</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>General</td>
    <td>Strictness Annotation</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/bang-patterns.html">
    Ref</a></td>
    <td><a href="#strictness-annotations">Strictness Annotations</a></td>
  </tr>
  <tr>
    <td>ApplicativeDo</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>FFI</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/ffi.html#ffi-capi">Ref</a></td>
    <td><a href="#applicative-do">Applicative Do</td>
  </tr>
  <tr>
    <td>CApiFFI</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>FFI</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/ffi.html#ffi-capi">Ref</a></td>
  </tr>
  <tr>
    <td>ConstrainedClassMethods</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#class-method-types">
    Ref</a></td>
  </tr>
  <tr>
    <td>ConstraintKinds</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/constraint-kind.html">
    Ref</a></td>
    <td><a href="#constraint-kinds">Constraint Kinds</a></td>
  </tr>
  <tr>
    <td>CPP</td>
    <td></td>
    <td></td>
    <td>✓</td>
    <td>General</td>
    <td>Preprocessor</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/options-phases.html#c-pre-processor">
    Ref</a></td>
    <td><a href="#cpp">Cpp</a></td>
  </tr>
  <tr>
    <td>DataKinds</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/promotion.html">Ref</a></td>
    <td><a href="#data-kinds">Data Kinds</a></td>
  </tr>
  <tr>
    <td>DatatypeContexts</td>
    <td></td>
    <td>✓</td>
    <td></td>
    <td>Deprecated</td>
    <td>Deprecated</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/data-type-extensions.html#datatype-contexts">
    Ref</a></td>
  </tr>
  <tr>
    <td>DefaultSignatures</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Generic Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#class-default-signatures">
    Ref</a></td>
    <td><a href="#generic">Generic</a></td>
  </tr>
  <tr>
    <td>DeriveAnyClass</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Deriving</td>
    <td><a href=
    "https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/deriving.html#derive-any-class">
    Ref</a></td>
  </tr>
  <tr>
    <td>DeriveDataTypeable</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Deriving</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#deriving-typeable">
    Ref</a></td>
    <td><a href="#typeable">Typeable</a></td>
  </tr>
  <tr>
    <td>DeriveFoldable</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Deriving</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#deriving-typeable">
    Ref</a></td>
    <td><a href="#foldable-traversable">Foldable / Traversable</a></td>
  </tr>
  <tr>
    <td>DeriveFunctor</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Deriving</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#deriving-typeable">
    Ref</a></td>
  </tr>
  <tr>
    <td>DeriveGeneric</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Deriving</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#deriving-typeable">
    Ref</a></td>
    <td><a href="#generic">Generic</a></td>
  </tr>
  <tr>
    <td>DeriveLift</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Deriving</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#deriving-typeable">
    Ref</a></td>
    <td><a href="#template-haskell">Template Haskell</a></td>
  </tr>
  <tr>
    <td>DeriveTraversable</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Deriving</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#deriving-typeable">
    Ref</a></td>
  </tr>
  <tr>
    <td>DisambiguateRecordFields</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#disambiguate-fields">
    Ref</a></td>
  </tr>
  <tr>
    <td>DuplicateRecordFields</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#disambiguate-fields">
    Ref</a></td>
    <td><a href="#duplicaterecordfields">DuplicateRecordFields</a></td>
  </tr>
  <tr>
    <td>DoRec</td>
    <td></td>
    <td>✓</td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#recursive-do-notation">
    Ref</a></td>
    <td><a href="#recursive-do">Recursive Do</a></td>
  </tr>
  <tr>
    <td>EmptyCase</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#empty-case">
    Ref</a></td>
    <td><a href="#emptycase">EmptyCase</a></td>
  </tr>
  <tr>
    <td>EmptyDataDecls</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/data-type-extensions.html#nullary-types">
    Ref</a></td>
    <td><a href="#void">Void</a></td>
  </tr>
  <tr>
    <td>ExistentialQuantification</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/data-type-extensions.html#existential-quantification">
    Ref</a></td>
    <td><a href="#existential-quantification">Existential Quantification</a></td>
  </tr>
  <tr>
    <td>ExplicitForAll</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#explicit-foralls">
    Ref</a></td>
    <td><a href="#universal-quantification">Universal Quantification</a></td>
  </tr>
  <tr>
    <td>ExplicitNamespaces</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Syntax Disambiguation</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#explicit-namespaces">
    Ref</a></td>
  </tr>
  <tr>
    <td>ExtendedDefaultRules</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Type Disambiguation</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/interactive-evaluation.html#extended-default-rules">
    Ref</a></td>
  </tr>
  <tr>
    <td>FlexibleContexts</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Typeclass Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#flexible-contexts">
    Ref</a></td>
    <td><a href="#flexiblecontexts">Flexible Contexts</a></td>
  </tr>
  <tr>
    <td>FlexibleInstances</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Typeclass Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#instance-rules">
    Ref</a></td>
    <td><a href="#flexibleinstances">Flexible Instances</a></td>
  </tr>
  <tr>
    <td>ForeignFunctionInterface</td>
    <td></td>
    <td></td>
    <td>✓</td>
    <td>General</td>
    <td>FFI</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/ffi.html">Ref</a></td>
    <td><a href="#ffi">FFI</a></td>
  </tr>
  <tr>
    <td>FunctionalDependencies</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Typeclass Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#functional-dependencies">
    Ref</a></td>
    <td><a href="#multiparam-typeclasses">Multiparam Typeclasses</a></td>
  </tr>
  <tr>
    <td>GADTs</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/data-type-extensions.html#gadt">
    Ref</a></td>
    <td><a href="#gadts">GADTs</a></td>
  </tr>
  <tr>
    <td>GADTSyntax</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/data-type-extensions.html#gadt-style">
    Ref</a></td>
    <td><a href="#gadts">GADTs</a></td>
  </tr>
  <tr>
    <td>GeneralizedNewtypeDeriving</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Typeclass Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#newtype-deriving">
    Ref</a></td>
    <td><a href="#newtype-deriving">Newtype Deriving</a></td>
  </tr>
  <tr>
    <td>GHCForeignImportPrim</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>FFI</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/ffi.html#ffi-prim">Ref</a></td>
    <td><a href="#cmm">Cmm</a></td>
  </tr>
  <tr>
    <td>ImplicitParams</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#implicit-parameters">
    Ref</a></td>
  </tr>
  <tr>
    <td>ImpredicativeTypes</td>
    <td></td>
    <td>✓</td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#impredicative-polymorphism">
    Ref</a></td>
    <td><a href="#impredicative-types">Impredicative Types</a></td>
  </tr>
  <tr>
    <td>IncoherentInstances</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#instance-overlap">
    Ref</a></td>
    <td><a href="#incoherentinstances">Incoherent Instances</a></td>
  </tr>
  <tr>
    <td>InstanceSigs</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#instance-sigs">
    Ref</a></td>
  </tr>
  <tr>
    <td>InterruptibleFFI</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>FFI</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/ffi.html#ffi-interruptible">
    Ref</a></td>
    <td><a href="#ffi">FFI</td>
  </tr>
  <tr>
    <td>KindSignatures</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#kinding">
    Ref</a></td>
    <td><a href="#kind-signatures">Kind Signatures</td>
  </tr>
  <tr>
    <td>LambdaCase</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#lambda-case">
    Ref</a></td>
    <td><a href="#lambdacase">Lambda Case</a></td>
  </tr>
  <tr>
    <td>LiberalTypeSynonyms</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typeclass Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/data-type-extensions.html#type-synonyms">
    Ref</a></td>
  </tr>
  <tr>
    <td>MagicHash</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>GHC Internals</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#magic-hash">
    Ref</a></td>
    <td><a href="#unboxed-types">Unboxed Types</a></td>
  </tr>
  <tr>
    <td>MonadComprehensions</td>
    <td></td>
    <td></td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#monad-comprehensions">
    Ref</a></td>
  </tr>
  <tr>
    <td>MonoLocalBinds</td>
    <td></td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Type Disambiguation</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#mono-local-binds">
    Ref</a></td>
  </tr>
  <tr>
    <td>MonoPatBinds</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Type Disambiguation</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/monomorphism.html">Ref</a></td>
  </tr>
  <tr>
    <td>MultiParamTypeClasses</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Typeclass Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#multi-param-type-classes">
    Ref</a></td>
    <td><a href="#multiparam-typeclasses">Multiparam Typeclasses</a></td>
  </tr>
  <tr>
    <td>MultiWayIf</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#multi-way-if">
    Ref</a></td>
    <td><a href="#multiwayif">MultiWawyIf</a></td>
  </tr>
  <tr>
    <td>NamedFieldPuns</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#record-puns">
    Ref</a></td>
    <td><a href="#namedfieldpuns">Named Field Puns</a></td>
  </tr>
  <tr>
    <td>NegativeLiterals</td>
    <td></td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Type Disambiguation</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#negative-literals">
    Ref</a></td>
  </tr>
  <tr>
    <td>NoImplicitPrelude</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Import Disambiguation</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#rebindable-syntax">
    Ref</a></td>
    <td><a href="#custom-prelude">Custom Prelude</a></td>
  </tr>
  <tr>
    <td>NoMonomorphismRestriction</td>
    <td></td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Type Disambiguation</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#monomorphism">
    Ref</a></td>
    <td><a href="#monomorphism-restriction">Monomorphism Restriction</a></td>
  </tr>
  <tr>
    <td>NPlusKPatterns</td>
    <td></td>
    <td>✓</td>
    <td>✓</td>
    <td>Deprecated</td>
    <td>Deprecated</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#n-k-patterns">
    Ref</a></td>
  </tr>
  <tr>
    <td>NullaryTypeClasses</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typeclass Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#nullary-type-classes">
    Ref</a></td>
    <td><a href="#multiparam-typeclasses">Multiparam Typeclasses</a></td>
  </tr>
  <tr>
    <td>NumDecimals</td>
    <td></td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Type Disambiguation</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#num-decimals">
    Ref</a></td>
    <td><a href="#numdecimals">NumDecimals</a></td>
  </tr>
  <tr>
    <td>OverlappingInstances</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typeclass Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#instance-overlap">
    Ref</a></td>
    <td><a href="#overlappinginstances">Overlapping Instances</a></td>
  </tr>
  <tr>
    <td>OverloadedLabels</td>
    <td></td>
    <td></td>
    <td>✓</td>
    <td>General</td>
    <td>Type Disambiguation</td>
    <td><a href= "#">
    Ref</a></td>
    <td><a href="#overloadedlabels">Overloaded Labels</a></td>
  </tr>
  <tr>
    <td>OverloadedRecordFields</td>
    <td></td>
    <td></td>
    <td>✓</td>
    <td>General</td>
    <td>Syntax Extension</td>
    <td><a href= "#">
    Ref</a></td>
    <td><a href="#overloadedlabels">Overloaded Labels</a></td>
  </tr>
  <tr>
    <td>OverloadedLists</td>
    <td></td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#overloaded-lists">
    Ref</a></td>
    <td><a href="#overloaded-lists">Overloaded Lists</a></td>
  </tr>
  <tr>
    <td>OverloadedStrings</td>
    <td></td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#overloaded-strings">
    Ref</a></td>
    <td><a href="#string">Overloaded Strings</a></td>
  </tr>
  <tr>
    <td>PackageImports</td>
    <td></td>
    <td></td>
    <td>✓</td>
    <td>General</td>
    <td>Import Disambiguation</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#package-imports">
    Ref</a></td>
    <td><a href="#package-imports">Package Imports</a></td>
  </tr>
  <tr>
    <td>ParallelArrays</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Data Parallel Haskell</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/lang-parallel.html">
    Ref</a></td>
  </tr>
  <tr>
    <td>ParallelListComp</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>General</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#parallel-list-comprehensions">
    Ref</a></td>
  </tr>
  <tr>
    <td>PartialTypeSignatures</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Interactive Typing</td>
    <td><a href=
    "https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/partial-type-signatures.html">Ref
    </a></td>
    <td><a href="#partial-type-signatures">Partial Type Signatures</a></td>
  </tr>
  <tr>
    <td>PatternGuards</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>General</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#pattern-guards">
    Ref</a></td>
    <td><a href="#pattern-guards">Pattern Guards</a></td>
  </tr>
  <tr>
    <td>PatternSynonyms</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>General</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#pattern-synonyms">
    Ref</a></td>
    <td><a href="#patternsynonyms">Pattern Synonyms</a></td>
  </tr>
  <tr>
    <td>PolyKinds</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/kind-polymorphism.html">
    Ref</a></td>
    <td><a href="#kind-polymorphism">Kind Polymorphism</a></td>
  </tr>
  <tr>
    <td>PolymorphicComponents</td>
    <td></td>
    <td>✓</td>
    <td></td>
    <td>Specialized</td>
    <td>Deprecated</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#universal-quantification">
    Ref</a></td>
  </tr>
  <tr>
    <td>PostfixOperators</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#postfix-operators">
    Ref</a></td>
  </tr>
  <tr>
    <td>QuasiQuotes</td>
    <td></td>
    <td></td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Metaprogramming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/template-haskell.html#th-quasiquotation">
    Ref</a></td>
    <td><a href="#quasiquotation">QuasiQuotation</a></td>
  </tr>
  <tr>
    <td>Rank2Types</td>
    <td></td>
    <td>✓</td>
    <td></td>
    <td>Specialized</td>
    <td>Historical Artifact</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#universal-quantification">
    Ref</a></td>
    <td><a href="#rank-n-types">Rank N Types</a></td>
  </tr>
  <tr>
    <td>RankNTypes</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#universal-quantification">
    Ref</a></td>
    <td><a href="#rank-n-types">Rank N Types</a></td>
  </tr>
  <tr>
    <td>RebindableSyntax</td>
    <td></td>
    <td></td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Metaprogramming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#rebindable-syntax">
    Ref</a></td>
    <td><a href="#indexed-monads">Indexed Monads</a></td>
  </tr>
  <tr>
    <td>RecordWildCards</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>General</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#record-wildcards">
    Ref</a></td>
    <td><a href="#recordwildcards">Record Wildcards</a></td>
  </tr>
  <tr>
    <td>RecursiveDo</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#recursive-do-notation">
    Ref</a></td>
    <td><a href="#monadfix">MonadFix</a></td>
  </tr>
  <tr>
    <td>RelaxedPolyRec</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Type Disambiguation</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#typing-binds">
    Ref</a></td>
  </tr>
  <tr>
    <td>RoleAnnotations</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Type Disambiguation</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/roles.html">Ref</a></td>
    <td><a href="#roles">Roles</a></td>
  </tr>
  <tr>
    <td>Safe</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Security Auditing</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/safe-haskell.html">Ref</a></td>
    <td><a href="#safe-haskell">Safe Haskell</a></td>
  </tr>
  <tr>
    <td>SafeImports</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Security Auditing</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/safe-haskell.html">Ref</a></td>
    <td><a href="#safe-haskell">Safe Haskell</a></td>
  </tr>
  <tr>
    <td>ScopedTypeVariables</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#scoped-type-variables">
    Ref</a></td>
    <td><a href="#scoped-type-variables">Scoped Type Variables</a></td>
  </tr>
  <tr>
    <td>StandaloneDeriving</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>General</td>
    <td>Typeclass Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#stand-alone-deriving">
    Ref</a></td>
  </tr>
  <tr>
    <td>StaticPointers</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>General</td>
    <td>Distributed Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#stand-alone-deriving">
    Ref</a></td>
  </tr>
  <tr>
    <td>Strict</td>
    <td></td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Strictness Annotations</td>
    <td><a href=
    "https://downloads.haskell.org/~ghc/master/users-guide//glasgow_exts.html#ghc-flag--XStrict" >
    Ref</a></td>
    <td><a href="#strict-haskell">Strict Haskell</a></td>
  </tr>
  <tr>
    <td>StrictData</td>
    <td></td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Strictness Annotations</td>
    <td><a href=
    "https://downloads.haskell.org/~ghc/master/users-guide//glasgow_exts.html#ghc-flag--XStrict" >
    Ref</a></td>
    <td><a href="#strict-haskell">Strict Haskell</a></td>
  </tr>
  <tr>
    <td>TemplateHaskell</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Metaprogramming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/template-haskell.html">
    Ref</a></td>
    <td><a href="#template-haskell">Template Haskell</a></td>
  </tr>
  <tr>
    <td>TraditionalRecordSyntax</td>
    <td></td>
    <td>✓</td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Historical Artifact</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#traditional-record-syntax">
    Ref</a></td>
    <td><a href="#historical-extensions">Historical Extensions</a></td>
  </tr>
  <tr>
    <td>TransformListComp</td>
    <td></td>
    <td></td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#generalised-list-comprehensions">
    Ref</a></td>
  </tr>
  <tr>
    <td>Trustworthy</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Security Auditing</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/safe-haskell.html">Ref</a></td>
    <td><a href="#safe-haskell">Safe Haskell</a></td>
  </tr>
  <tr>
    <td>TupleSections</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#tuple-sections">
    Ref</a></td>
    <td><a href="#tuplesections">Tuple Sections</a></td>
  </tr>
  <tr>
    <td>TypeApplications</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-families.html">
    Ref</a></td>
  </tr>
  <tr>
    <td>TypeFamilies</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-families.html">
    Ref</a></td>
    <td><a href="#type-families">Type Families</a></td>
  </tr>
  <tr>
    <td>TypeHoles</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Interactive Typing</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/typed-holes.html">Ref</a></td>
    <td><a href="#type-holes">Type Holes</a></td>
  </tr>
  <tr>
    <td>TypeInType</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href="#">Ref</a></td>
  </tr>
  <tr>
    <td>TypeOperators</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/data-type-extensions.html#type-operators">
    Ref</a></td>
    <td><a href="#manual-proofs">Manual Proofs</a></td>
  </tr>
  <tr>
    <td>TypeSynonymInstances</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Typeclass Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#flexible-instance-head">
    Ref</a></td>
    <td><a href="#typesynonyminstances">Type Synonym Instances</a></td>
  </tr>
  <tr>
    <td>UnboxedTuples</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>Specialized</td>
    <td>FFI</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/primitives.html#unboxed-tuples">
    Ref</a></td>
  </tr>
  <tr>
    <td>UndecidableInstances</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#undecidable-instances">
    Ref</a></td>
    <td><a href="#multiparam-typeclasses">Multiparam Typeclasses</a></td>
  </tr>
  <tr>
    <td>UnicodeSyntax</td>
    <td></td>
    <td></td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#unicode-syntax">
    Ref</a></td>
  </tr>
  <tr>
    <td>UnliftedFFITypes</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>FFI</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/primitives.html">Ref</a></td>
    <td><a href="#cmm">Cmm</a></td>
  </tr>
  <tr>
    <td>Unsafe</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Security Auditing</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/safe-haskell.html">Ref</a></td>
    <td><a href="#safe-haskell">Safe Haskell</a></td>
  </tr>
  <tr>
    <td>ViewPatterns</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>General</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#view-patterns">
    Ref</a></td>
    <td><a href="#viewpatterns">View Patterns</a></td>
  </tr>
</table>
<p>See: <a href="http://www.haskell.org/ghc/docs/7.8.2/html/users_guide/flag-reference.html#idp14615552">GHC Extension Reference</a></p>
<h2 id="the-benign">The Benign</h2>
<p>It's not obvious which extensions are the most common but it's fairly safe to say that these extensions are benign and are safely used extensively:</p>
<ul>
<li>OverloadedStrings</li>
<li>FlexibleContexts</li>
<li>FlexibleInstances</li>
<li>GeneralizedNewtypeDeriving</li>
<li>TypeSynonymInstances</li>
<li>MultiParamTypeClasses</li>
<li>FunctionalDependencies</li>
<li>NoMonomorphismRestriction</li>
<li>GADTs</li>
<li>BangPatterns</li>
<li>DeriveGeneric</li>
<li>ScopedTypeVariables</li>
</ul>
<h2 id="the-dangerous">The Dangerous</h2>
<p>GHC's typechecker sometimes just casually tells us to enable language extensions when it can't solve certain problems. These include:</p>
<ul>
<li>DatatypeContexts</li>
<li>OverlappingInstances</li>
<li>IncoherentInstances</li>
<li>ImpredicativeTypes</li>
<li>AllowAmbigiousTypes</li>
</ul>
<p>These almost always indicate a design flaw and shouldn't be turned on to remedy the error at hand, as much as GHC might suggest otherwise!</p>
<h2 id="type-inference">Type Inference</h2>
<p>Inference in Haskell is usually precise, although there are several boundary cases where inference is difficult or impossible to infer a principal type of an expression. There a two common cases:</p>
<h4 id="mutually-recursive-binding-groups">Mutually Recursive Binding Groups</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f x <span class="fu">=</span> const x g
g y <span class="fu">=</span> f <span class="ch">&#39;A&#39;</span></code></pre></div>
<p>The inferred type signatures are correct in their usage, but don't represent the most general signatures. When GHC analyzes the module it analyzes the dependencies of expressions on each other, groups them together, and applies substitutions from unification across mutually defined groups. As such the inferred types may not be the most general types possible, and an explicit signature may be desired.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Inferred types</span>
<span class="ot">f ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
<span class="ot">g ::</span> t <span class="ot">-&gt;</span> <span class="dt">Char</span>

<span class="co">-- Most general types</span>
<span class="ot">f ::</span> a <span class="ot">-&gt;</span> a
<span class="ot">g ::</span> a <span class="ot">-&gt;</span> <span class="dt">Char</span></code></pre></div>
<h4 id="polymorphic-recursion">Polymorphic recursion</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> <span class="fu">|</span> <span class="dt">Bin</span> a (<span class="dt">Tree</span> (a, a))

size <span class="dt">Leaf</span> <span class="fu">=</span> <span class="dv">0</span>
size (<span class="dt">Bin</span> _ t) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span> <span class="fu">*</span> size t</code></pre></div>
<p>The problem with this expression is because the inferred type variable <code>a</code> in <code>size</code> spans two possible types (<code>a</code> and <code>(a,a)</code>), the recursion is polymorphic. These two types won't pass the occurs-check of the typechecker and it yields an incorrect inferred type.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="dt">Occurs</span> check<span class="fu">:</span> cannot construct the infinite <span class="kw">type</span><span class="fu">:</span> t0 <span class="fu">=</span> (t0, t0)
    <span class="dt">Expected</span> <span class="kw">type</span><span class="fu">:</span> <span class="dt">Tree</span> t0
      <span class="dt">Actual</span> <span class="kw">type</span><span class="fu">:</span> <span class="dt">Tree</span> (t0, t0)
    <span class="dt">In</span> the first argument <span class="kw">of</span> <span class="ot">`size&#39;, namely `</span>t&#39;
    <span class="dt">In</span> the second argument <span class="kw">of</span> <span class="ot">`(*)&#39;, namely `</span>size t&#39;
    <span class="dt">In</span> the second argument <span class="kw">of</span> <span class="ot">`(+)&#39;, namely `</span><span class="dv">2</span> <span class="fu">*</span> size t&#39;</code></pre></div>
<p>Simply adding an explicit type signature corrects this. Type inference using polymorphic recursion is undecidable in the general case.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">size ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span>
size <span class="dt">Leaf</span> <span class="fu">=</span> <span class="dv">0</span>
size (<span class="dt">Bin</span> _ t) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span> <span class="fu">*</span> size t</code></pre></div>
<p>See: <a href="https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-880004.5">Static Semantics of Function and Pattern Bindings</a></p>
<h2 id="monomorphism-restriction">Monomorphism Restriction</h2>
<p>The most common edge case of the inference is known as the dreaded <em>monomorphism restriction</em>.</p>
<p>When the toplevel declarations of a module are generalized the monomorphism restricts that toplevel values (i.e. expressions not under a lambda ) whose type contains the subclass of the <code>Num</code> type from the Prelude are not generalized and instead are instantiated with a monotype tried sequentially from the list specified by the <code>default</code> which is normally <code>Integer</code>, then <code>Double</code>.</p>
<div class="sourceCode" include="src/04-extensions/monomorphism.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Double is inferred by type inferencer.</span>
<span class="ot">example1 ::</span> <span class="dt">Double</span>
example1 <span class="fu">=</span> <span class="fl">3.14</span>

<span class="co">-- In the presense of a lambda, a different type is inferred!</span>
<span class="ot">example2 ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> t <span class="ot">-&gt;</span> a
example2 _ <span class="fu">=</span> <span class="fl">3.14</span>

default (<span class="dt">Integer</span>, <span class="dt">Double</span>)</code></pre></div>
<p>As of GHC 7.8, the monomorphism restriction is switched off by default in GHCi.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> set <span class="fu">+</span>t

λ<span class="fu">:</span> <span class="dv">3</span>
<span class="dv">3</span>
<span class="ot">it ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a

λ<span class="fu">:</span> default (<span class="dt">Double</span>)

λ<span class="fu">:</span> <span class="dv">3</span>
<span class="fl">3.0</span>
<span class="ot">it ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a</code></pre></div>
<h2 id="extended-defaulting">Extended Defaulting</h2>
<p>Haskell normally applies several defaulting rules for ambigious literals in the absence of an explicit type signature. When an ambiguous literal is typechecked if at least one of its typeclass constraints is numeric and all of its classes are standard library classes, the module's default list is consulted, and the first type from the list that will satisfy the context of the type variable is instantiated. So for instance given the following default rules.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">default (<span class="dt">C1</span> a,<span class="fu">...</span>,<span class="dt">Cn</span> a)</code></pre></div>
<p>The following set of heuristics is used to determine what to instnatiate the ambiguous type variable to.</p>
<ol style="list-style-type: decimal">
<li>The type variable a appears in no other constraints</li>
<li>All the classes Ci are standard.</li>
<li>At least one of the classes Ci is numeric.</li>
</ol>
<p>The default default is (Integer, Double)</p>
<p>This is normally fine, but sometimes we'd like more granular control over defaulting. The <code>-XExtendedDefaultRules</code> loosens the restriction that we're constrained with working on Numerical typeclasses and the constraint that we can only work with standard library classes. If we'd like to have our string literals (using -XOverlodaedStrings) automatically default to the more efficient <code>Text</code> implementation instead of <code>String</code> we can twiddle the flag and GHC will perform the right substitution without the need for an explicit annotation on every string literal.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="ot">{-# LANGUAGE ExtendedDefaultRules #-}</span>

<span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>

default (<span class="dt">T.Text</span>)

example <span class="fu">=</span> <span class="st">&quot;foo&quot;</span></code></pre></div>
<p>For code typed at the GHCi prompt, the <code>-XExtendedDefaultRules</code> flag is always on, and cannot be switched off.</p>
<p>See: <a href="#monomorphism-restriction">Monomorphism Restriction</a></p>
<h2 id="safe-haskell">Safe Haskell</h2>
<p>As everyone eventually finds out there are several functions within the implementation of GHC ( not the Haskell language ) that can be used to subvert the type-system, they are marked with the prefix <code>unsafe</code>. These functions exist only for when one can manually prove the soundness of an expression but can't express this property in the type-system or externalities to Haskell.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">unsafeCoerce ::</span> a <span class="ot">-&gt;</span> b
<span class="ot">unsafePerformIO ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> a</code></pre></div>
<div class="alert alert-danger">
<p>Using these functions to subvert the Haskell typesystem will cause all measure of undefined behavior with unimaginable pain and suffering, and are <span style="font-weight: bold">strongly discouraged</span>. When initially starting out with Haskell there are no legitimate reason to use these functions at all, period.</p>
</div>
<p>The Safe Haskell language extensions allow us to restrict the use of unsafe language features using <code>-XSafe</code> which restricts the import of modules which are themselves marked as Safe. It also forbids the use of certain language extensions (<code>-XTemplateHaskell</code>) which can be used to produce unsafe code. The primary use case of these extensions is security auditing.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE Safe #-}</span>
<span class="ot">{-# LANGUAGE Trustworthy #-}</span></code></pre></div>
<div class="sourceCode" include="src/04-extensions/safe.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE Safe #-}</span>

<span class="kw">import </span><span class="dt">Unsafe.Coerce</span>
<span class="kw">import </span><span class="dt">System.IO.Unsafe</span>

<span class="ot">bad1 ::</span> <span class="dt">String</span>
bad1 <span class="fu">=</span> unsafePerformIO getLine

<span class="ot">bad2 ::</span> a
bad2 <span class="fu">=</span> unsafeCoerce <span class="fl">3.14</span> ()</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Unsafe.Coerce</span><span class="fu">:</span> <span class="dt">Can&#39;t</span> be safely imported<span class="fu">!</span>
<span class="dt">The</span> <span class="kw">module</span> itself isn&#39;t safe<span class="fu">.</span></code></pre></div>
<p>See: <a href="https://ghc.haskell.org/trac/ghc/wiki/SafeHaskell">Safe Haskell</a></p>
<h2 id="partial-type-signatures">Partial Type Signatures</h2>
<p>The same hole technique can be applied at the toplevel for signatures:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">const&#39; ::</span> _
const&#39; x y <span class="fu">=</span> x</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">[<span class="kw">1</span> of 1] Compiling Main             ( src/typedhole.hs, interpreted )

<span class="kw">typedhole.hs</span>:3:11:
    <span class="kw">Found</span> hole ‘_’ with type: t1 -<span class="kw">&gt;</span> t -<span class="kw">&gt;</span> t1
    <span class="kw">Where</span>: ‘t’ is a rigid type variable bound by
               <span class="kw">the</span> inferred type of const<span class="st">&#39; :: t1 -&gt; t -&gt; t1 at foo.hs:4:1</span>
<span class="st">           ‘t1’ is a rigid type variable bound by</span>
<span class="st">                the inferred type of const&#39;</span> :: t1 -<span class="kw">&gt;</span> t -<span class="kw">&gt;</span> t1 at foo.hs:4:1
    <span class="kw">To</span> use the inferred type, enable PartialTypeSignatures
    <span class="kw">In</span> the type signature for ‘const<span class="st">&#39;’: _</span>
<span class="st">Failed, modules loaded: none.</span></code></pre></div>
<p>Pattern wildcards can also be given explicit names so that GHC will use when reporting the inferred type in the resulting message.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foo ::</span> _a <span class="ot">-&gt;</span> _a
foo _ <span class="fu">=</span> <span class="dt">False</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">typedhole.hs</span>:6:9:
    <span class="kw">Couldn</span><span class="st">&#39;t match expected type ‘_a’ with actual type ‘Bool’</span>
<span class="st">      ‘_a’ is a rigid type variable bound by</span>
<span class="st">           the type signature for foo :: _a -&gt; _a at foo.hs:5:8</span>
<span class="st">    Relevant bindings include foo :: _a -&gt; _a (bound at foo.hs:6:1)</span>
<span class="st">    In the expression: False</span>
<span class="st">    In an equation for ‘foo’: foo _ = False</span>
<span class="st">Failed, modules loaded: none.</span></code></pre></div>
<p>The same wildcards can be used in type contexts to dump out inferred type class constraints:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">succ&#39; ::</span> _ <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a
succ&#39; x <span class="fu">=</span> x <span class="fu">+</span> <span class="dv">1</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">typedhole.hs</span>:3:10:
    <span class="kw">Found</span> hole ‘_’ with inferred constraints: (Num a)
    <span class="kw">To</span> use the inferred type, enable PartialTypeSignatures
    <span class="kw">In</span> the type signature for ‘succ<span class="st">&#39;’: _ =&gt; a -&gt; a</span>
<span class="st">Failed, modules loaded: none.</span></code></pre></div>
<p>When the flag <code>-XPartialTypeSignatures</code> is passed to GHC and the inferred type is unambiguous, GHC will let us leave the holes in place and the compilation will proceed.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">typedhole.hs</span>:3:10: Warning:
    <span class="kw">Found</span> hole ‘_’ with type: w_
    <span class="kw">Where</span>: ‘w_’ is a rigid type variable bound by
                <span class="kw">the</span> inferred type of succ<span class="st">&#39; :: w_ -&gt; w_1 -&gt; w_ at foo.hs:4:1</span>
<span class="st">    In the type signature for ‘succ&#39;</span>’: _ -<span class="kw">&gt;</span> _ -<span class="kw">&gt;</span> _</code></pre></div>
<h2 id="recursive-do">Recursive Do</h2>
<p>Recursive do notation allows to use to self-reference expressions on both sides of a monadic bind. For instance the following uses lazy evaluation to generate a infinite list. This is sometimes used for instantiating cyclic datatypes inside of a monadic context that need to hold a reference to themselves.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RecursiveDo #-}</span>

<span class="ot">justOnes ::</span> <span class="dt">Maybe</span> [<span class="dt">Int</span>]
justOnes <span class="fu">=</span> <span class="kw">do</span>
  rec xs <span class="ot">&lt;-</span> <span class="dt">Just</span> (<span class="dv">1</span><span class="fu">:</span>xs)
  return (map negate xs)</code></pre></div>
<p>See: <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#the-recursive-do-notation">Recursive Do Notation</a></p>
<h2 id="applicative-do">Applicative Do</h2>
<p>By default GHC desugars do-notation to use implicit invocations of bind and return.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">test ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m (a, b, c)
test <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> f
  b <span class="ot">&lt;-</span> g
  c <span class="ot">&lt;-</span> h
  return (a, b, c)</code></pre></div>
<p>Desugars into:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">test ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m (a, b, c)
test <span class="fu">=</span>
f <span class="fu">&gt;&gt;=</span> \a <span class="ot">-&gt;</span>
  g <span class="fu">&gt;&gt;=</span> \b <span class="ot">-&gt;</span>
    h <span class="fu">&gt;&gt;=</span> \c <span class="ot">-&gt;</span>
      return (a, b, c)</code></pre></div>
<p>With <code>ApplicativeDo</code> this instead desugars into use of applicative combinators and a laxer Applicative constraint.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">test ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> m (a, b, c)
test <span class="fu">=</span> (,,) <span class="fu">&lt;$&gt;</span> f <span class="fu">&lt;*&gt;</span> g <span class="fu">&lt;*&gt;</span> h</code></pre></div>
<h2 id="pattern-guards">Pattern Guards</h2>
<p>Pattern guards are an extension to the pattern matching syntax. Given a <code>&lt;-</code> pattern qualifier, the right hand side is evaluated and matched against the pattern on the left. If the match fails then the whole guard fails and the next equation is tried. If it succeeds, then the appropriate binding takes place, and the next qualifier is matched, in the augmented environment.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE PatternGuards #-}</span>

combine env x y
   <span class="fu">|</span> <span class="dt">Just</span> a <span class="ot">&lt;-</span> lookup x env
   , <span class="dt">Just</span> b <span class="ot">&lt;-</span> lookup y env
   <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> a <span class="fu">+</span> b

   <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Nothing</span></code></pre></div>
<h2 id="viewpatterns">ViewPatterns</h2>
<p>View patterns are like pattern guards that can be nested inside of other patterns. They are a convenient way of pattern-matching against values of algebraic data types.</p>
<div class="sourceCode" include="src/04-extensions/views.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ViewPatterns #-}</span>
<span class="ot">{-# LANGUAGE NoMonomorphismRestriction #-}</span>

<span class="kw">import </span><span class="dt">Safe</span>

<span class="ot">lookupDefault ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [(a,b)] <span class="ot">-&gt;</span> b
lookupDefault k _ (lookup k <span class="ot">-&gt;</span> <span class="dt">Just</span> s) <span class="fu">=</span> s
lookupDefault _ d _ <span class="fu">=</span> d

<span class="ot">headTup ::</span> (a, [t]) <span class="ot">-&gt;</span> [t]
headTup (headMay <span class="fu">.</span> snd <span class="ot">-&gt;</span> <span class="dt">Just</span> n) <span class="fu">=</span> [n]
headTup _ <span class="fu">=</span> []

<span class="ot">headNil ::</span> [a] <span class="ot">-&gt;</span> [a]
headNil (headMay <span class="ot">-&gt;</span> <span class="dt">Just</span> x) <span class="fu">=</span> [x]
headNil _ <span class="fu">=</span> []</code></pre></div>
<h2 id="tuplesections">TupleSections</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TupleSections #-}</span>

<span class="ot">first ::</span> a <span class="ot">-&gt;</span> (a, <span class="dt">Bool</span>)
first <span class="fu">=</span> (,<span class="dt">True</span>)

<span class="ot">second ::</span> a <span class="ot">-&gt;</span> (<span class="dt">Bool</span>, a)
second <span class="fu">=</span> (<span class="dt">True</span>,)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> t <span class="ot">-&gt;</span> t1 <span class="ot">-&gt;</span> t2 <span class="ot">-&gt;</span> t3 <span class="ot">-&gt;</span> (t, (), t1, (), (), t2, t3)
f <span class="fu">=</span> (,(),,(),(),,)</code></pre></div>
<h2 id="multiwayif">MultiWayIf</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE MultiWayIf #-}</span>

<span class="ot">bmiTell ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
bmiTell bmi <span class="fu">=</span> <span class="kw">if</span>
  <span class="fu">|</span> bmi <span class="fu">&lt;=</span> <span class="fl">18.5</span> <span class="ot">-&gt;</span> <span class="st">&quot;You&#39;re underweight.&quot;</span>
  <span class="fu">|</span> bmi <span class="fu">&lt;=</span> <span class="fl">25.0</span> <span class="ot">-&gt;</span> <span class="st">&quot;You&#39;re average weight.&quot;</span>
  <span class="fu">|</span> bmi <span class="fu">&lt;=</span> <span class="fl">30.0</span> <span class="ot">-&gt;</span> <span class="st">&quot;You&#39;re overewight.&quot;</span>
  <span class="fu">|</span> otherwise   <span class="ot">-&gt;</span> <span class="st">&quot;You&#39;re a whale.&quot;</span></code></pre></div>
<h2 id="emptycase">EmptyCase</h2>
<p>GHC normally requires at least one pattern branch in case statement this restriction can be relaxed with -XEmptyCase. The case statement then immediately yields a <code>Non-exhaustive patterns in case</code> if evaluated.</p>
<pre><code>test = case of</code></pre>
<h2 id="lambdacase">LambdaCase</h2>
<p>For case statements, LambdaCase allows the elimination of redundant free variables introduced purely for the case of pattern matching on.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">\<span class="kw">case</span>
  p1 <span class="ot">-&gt;</span> <span class="dv">32</span>
  p2 <span class="ot">-&gt;</span> <span class="dv">32</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">\temp <span class="ot">-&gt;</span> <span class="kw">case</span> temp <span class="kw">of</span>
  p1 <span class="ot">-&gt;</span> <span class="dv">32</span>
  p2 <span class="ot">-&gt;</span> <span class="dv">32</span></code></pre></div>
<div class="sourceCode" include="src/04-extensions/lambdacase.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE LambdaCase #-}</span>

<span class="kw">data</span> <span class="dt">Exp</span> a
  <span class="fu">=</span> <span class="dt">Lam</span> a (<span class="dt">Exp</span> a)
  <span class="fu">|</span> <span class="dt">Var</span> a
  <span class="fu">|</span> <span class="dt">App</span> (<span class="dt">Exp</span> a) (<span class="dt">Exp</span> a)

<span class="ot">example ::</span> <span class="dt">Exp</span> a <span class="ot">-&gt;</span> a
example <span class="fu">=</span> \<span class="kw">case</span>
  <span class="dt">Lam</span> a b <span class="ot">-&gt;</span> a
  <span class="dt">Var</span> a   <span class="ot">-&gt;</span> a
  <span class="dt">App</span> a b <span class="ot">-&gt;</span> example a</code></pre></div>
<h2 id="numdecimals">NumDecimals</h2>
<p>NumDecimals allows the use of exponential notation for integral literals that are not necessarily floats. Without it, any use of expontial notation induces a Fractional class constraint.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">googol ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> a
googol <span class="fu">=</span> 1e100</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE NumDecimals #-}</span>
<span class="ot">googol ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a
googol <span class="fu">=</span> 1e100</code></pre></div>
<h2 id="packageimports">PackageImports</h2>
<p>Package imports allows us to disambiguate hierarchical package names by their respective package key. This is useful in the case where you have to imported packages that expose the same module. In practice most of the common libraries have taken care to avoid conflicts in the namespace and this is not usually a problem in most modern Haskell.</p>
<p>For example we could explicitly ask GHC to resolve that <code>Control.Monad.Error</code> package be drawn from the <code>mtl</code> library.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> &quot;mtl&quot; <span class="dt">Control.Monad.Error</span> <span class="kw">as</span> <span class="dt">Error</span>
<span class="kw">import qualified</span> &quot;mtl&quot; <span class="dt">Control.Monad.State</span> <span class="kw">as</span> <span class="dt">State</span>
<span class="kw">import qualified</span> &quot;mtl&quot; <span class="dt">Control.Monad.Reader</span> <span class="kw">as</span> <span class="dt">Reader</span></code></pre></div>
<h2 id="recordwildcards">RecordWildCards</h2>
<p>Record wild cards allow us to expand out the names of a record as variables scoped as the labels of the record implicitly. The extension can be used to extract variables names into a scope or to assign to variables in a record drawing, aligning the record's labels with the variables in scope for the assignment. The syntax introduced is the <code>{..}</code> pattern selector.</p>
<div class="sourceCode" include="src/04-extensions/wildcards_update.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RecordWildCards #-}</span>
<span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Data.Text</span>

<span class="kw">data</span>  <span class="dt">Example</span> <span class="fu">=</span> <span class="dt">Example</span>
  {<span class="ot"> e1 ::</span> <span class="dt">Int</span>
  ,<span class="ot"> e2 ::</span> <span class="dt">Text</span>
  ,<span class="ot"> e3 ::</span> <span class="dt">Text</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="co">-- Extracting from a record using wildcards.</span>
<span class="ot">scope ::</span> <span class="dt">Example</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Text</span>, <span class="dt">Text</span>)
scope <span class="dt">Example</span> {<span class="fu">..</span>} <span class="fu">=</span> (e1, e2, e3)

<span class="co">-- Assign to a record using wildcards.</span>
<span class="ot">assign ::</span> <span class="dt">Example</span>
assign <span class="fu">=</span> <span class="dt">Example</span> {<span class="fu">..</span>}
  <span class="kw">where</span>
    (e1, e2, e3) <span class="fu">=</span> (<span class="dv">1</span>, <span class="st">&quot;Kirk&quot;</span>, <span class="st">&quot;Picard&quot;</span>)</code></pre></div>
<h2 id="namedfieldpuns">NamedFieldPuns</h2>
<p>Provides alternative syntax for accessing record fields in a pattern match.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">D</span> <span class="fu">=</span> <span class="dt">D</span> {<span class="ot">a ::</span> <span class="dt">Int</span>,<span class="ot"> b ::</span> <span class="dt">Int</span>}

<span class="ot">f ::</span> <span class="dt">D</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
f <span class="dt">D</span> {a, b} <span class="fu">=</span> a <span class="fu">-</span> b

<span class="co">-- Order doesn&#39;t matter</span>
<span class="ot">g ::</span> <span class="dt">D</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
g <span class="dt">D</span> {b, a} <span class="fu">=</span> a <span class="fu">-</span> b</code></pre></div>
<h2 id="patternsynonyms">PatternSynonyms</h2>
<p>Suppose we were writing a typechecker, it would be very common to include a distinct <code>TArr</code> term to ease the telescoping of function signatures, this is what GHC does in its Core language. Even though technically it could be written in terms of more basic application of the <code>(-&gt;)</code> constructor.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Type</span>
  <span class="fu">=</span> <span class="dt">TVar</span> <span class="dt">TVar</span>
  <span class="fu">|</span> <span class="dt">TCon</span> <span class="dt">TyCon</span>
  <span class="fu">|</span> <span class="dt">TApp</span> <span class="dt">Type</span> <span class="dt">Type</span>
  <span class="fu">|</span> <span class="dt">TArr</span> <span class="dt">Type</span> <span class="dt">Type</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</code></pre></div>
<p>With pattern synonyms we can eliminate the extraneous constructor without losing the convenience of pattern matching on arrow types.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE PatternSynonyms #-}</span>

pattern <span class="dt">TArr</span> t1 t2 <span class="fu">=</span> <span class="dt">TApp</span> (<span class="dt">TApp</span> (<span class="dt">TCon</span> <span class="st">&quot;(-&gt;)&quot;</span>) t1) t2</code></pre></div>
<p>So now we can write an eliminator and constructor for arrow type very naturally.</p>
<div class="sourceCode" include="src/04-extensions/patterns.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE PatternSynonyms #-}</span>

<span class="kw">import </span><span class="dt">Data.List</span> (foldl1&#39;)

<span class="kw">type</span> <span class="dt">Name</span>  <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">TVar</span>  <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">TyCon</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="kw">data</span> <span class="dt">Type</span>
  <span class="fu">=</span> <span class="dt">TVar</span> <span class="dt">TVar</span>
  <span class="fu">|</span> <span class="dt">TCon</span> <span class="dt">TyCon</span>
  <span class="fu">|</span> <span class="dt">TApp</span> <span class="dt">Type</span> <span class="dt">Type</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)


pattern <span class="dt">TArr</span> t1 t2 <span class="fu">=</span> <span class="dt">TApp</span> (<span class="dt">TApp</span> (<span class="dt">TCon</span> <span class="st">&quot;(-&gt;)&quot;</span>) t1) t2

<span class="ot">tapp ::</span> <span class="dt">TyCon</span> <span class="ot">-&gt;</span> [<span class="dt">Type</span>] <span class="ot">-&gt;</span> <span class="dt">Type</span>
tapp tcon args <span class="fu">=</span> foldl <span class="dt">TApp</span> (<span class="dt">TCon</span> tcon) args

<span class="ot">arr ::</span> [<span class="dt">Type</span>] <span class="ot">-&gt;</span> <span class="dt">Type</span>
arr ts <span class="fu">=</span> foldl1&#39; (\t1 t2 <span class="ot">-&gt;</span> tapp <span class="st">&quot;(-&gt;)&quot;</span> [t1, t2]) ts

<span class="ot">elimTArr ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> [<span class="dt">Type</span>]
elimTArr (<span class="dt">TArr</span> (<span class="dt">TArr</span> t1 t2) t3) <span class="fu">=</span> t1 <span class="fu">:</span> t2 <span class="fu">:</span> elimTArr t3
elimTArr (<span class="dt">TArr</span> t1 t2) <span class="fu">=</span> t1 <span class="fu">:</span> elimTArr t2
elimTArr t <span class="fu">=</span> [t]

<span class="co">-- (-&gt;) a ((-&gt;) b a)</span>
<span class="co">-- a -&gt; b -&gt; a</span>
<span class="ot">to ::</span> <span class="dt">Type</span>
to <span class="fu">=</span> arr [<span class="dt">TVar</span> <span class="st">&quot;a&quot;</span>, <span class="dt">TVar</span> <span class="st">&quot;b&quot;</span>, <span class="dt">TVar</span> <span class="st">&quot;a&quot;</span>]

<span class="ot">from ::</span> [<span class="dt">Type</span>]
from <span class="fu">=</span> elimTArr to</code></pre></div>
<p>Pattern synonyms can be exported from a module like any other definition by prefixing them with the prefix <code>pattern</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">MyModule</span> (
  pattern <span class="dt">Elt</span>
) <span class="kw">where</span>

pattern <span class="dt">Elt</span> <span class="fu">=</span> [a]</code></pre></div>
<ul>
<li><a href="http://mpickering.github.io/posts/2015-12-12-pattern-synonyms-8.html">Pattern Synonyms in GHC 8</a></li>
</ul>
<h2 id="derivetraversable">DeriveTraversable</h2>
<h2 id="derivefoldable">DeriveFoldable</h2>
<h2 id="derivefunctor">DeriveFunctor</h2>
<h2 id="derivegeneric">DeriveGeneric</h2>
<h2 id="deriveanyclass">DeriveAnyClass</h2>
<p>With <code>-XDeriveAnyClass</code> we can derive any class. The deriving logic s generates an instance declaration for the type with no explicitly-defined methods. If the typeclass implements a default for each method then this will be well-defined and give rise to an automatic instances.</p>
<h2 id="staticpointers">StaticPointers</h2>
<h2 id="duplicaterecordfields">DuplicateRecordFields</h2>
<p>GHC 8.0 introduced the DuplicateRecordFields extensions which loosens GHC's restriction on records in the same module with identical accessors. The precise type that is being projected into is now deferred to the callsite.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DuplicateRecordFields #-}</span>

<span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span> {<span class="ot"> id ::</span> <span class="dt">Int</span> }
<span class="kw">data</span> <span class="dt">Animal</span> <span class="fu">=</span> <span class="dt">Animal</span> {<span class="ot"> id ::</span> <span class="dt">Int</span> }
<span class="kw">data</span> <span class="dt">Vegetable</span> <span class="fu">=</span> <span class="dt">Vegetable</span> {<span class="ot"> id ::</span> <span class="dt">Int</span> }

<span class="ot">test ::</span> (<span class="dt">Person</span>, <span class="dt">Animal</span>, <span class="dt">Vegetable</span>)
test <span class="fu">=</span> (<span class="dt">Person</span> {id <span class="fu">=</span> <span class="dv">1</span>}, <span class="dt">Animal</span> {id <span class="fu">=</span> <span class="dv">2</span>}, <span class="dt">Vegetable</span> {id <span class="fu">=</span> <span class="dv">3</span>})</code></pre></div>
<p>Using just DuplicateRecordFields, projection is still not supported so the following will not work. OverloadedLabels fixes this to some extent.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">test ::</span> (<span class="dt">Person</span>, <span class="dt">Animal</span>, <span class="dt">Vegetable</span>)
test <span class="fu">=</span> (id (<span class="dt">Person</span> <span class="dv">1</span>), id (<span class="dt">Animal</span> <span class="dv">2</span>), id (<span class="dt">Animal</span> <span class="dv">3</span>))</code></pre></div>
<h2 id="overloadedlabels">OverloadedLabels</h2>
<p>GHC 8.0 also introduced the OverloadedLabels extension which allows a limited form of polymorphism over labels that share the same name.</p>
<p>To work with overloaded labels types we need to enable several language extensions to work with promoted strings and multiparam typeclasses that underly it's implementation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">extract ::</span> <span class="dt">IsLabel</span> <span class="st">&quot;id&quot;</span> t <span class="ot">=&gt;</span> t
extract <span class="fu">=</span> <span class="fu">#</span>id</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedLabels #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class="ot">{-# LANGUAGE DuplicateRecordFields #-}</span>
<span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span>

<span class="kw">import </span><span class="dt">GHC.Records</span> (<span class="dt">HasField</span>(..))
<span class="kw">import </span><span class="dt">GHC.OverloadedLabels</span> (<span class="dt">IsLabel</span>(..))

<span class="kw">data</span> <span class="dt">S</span> <span class="fu">=</span> <span class="dt">MkS</span> {<span class="ot"> foo ::</span> <span class="dt">Int</span> }
<span class="kw">data</span> <span class="dt">T</span> x y z <span class="fu">=</span> forall b <span class="fu">.</span> <span class="dt">MkT</span> {<span class="ot"> foo ::</span> y,<span class="ot"> bar ::</span> b }

<span class="kw">instance</span> <span class="dt">HasField</span> x r a <span class="ot">=&gt;</span> <span class="dt">IsLabel</span> x (r <span class="ot">-&gt;</span> a) <span class="kw">where</span>
  fromLabel <span class="fu">=</span> getField

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  print (<span class="fu">#</span>foo (<span class="dt">MkS</span> <span class="dv">42</span>))
  print (<span class="fu">#</span>foo (<span class="dt">MkT</span> <span class="dt">True</span> <span class="dt">False</span>))</code></pre></div>
<p>See:</p>
<ul>
<li><a href="http://www.well-typed.com/blog/2015/03/overloadedrecordfields-revived/">OverloadedRecordFields revived</a></li>
</ul>
<h2 id="cpp">Cpp</h2>
<p>The C++ preprocessor is the fallback whenever we really need to separate out logic that has to span multiple versions of GHC and language changes while maintaining backwards compatibility. It can dispatch on the version of GHC being used to compile a module.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE CPP #-}</span>

<span class="st">#if (__GLASGOW_HASKELL__ &gt; 710)</span>
<span class="co">-- Imports for GHC 7.10.x</span>
<span class="st">#else</span>
<span class="co">-- Imports for other GHC</span>
<span class="st">#endif</span></code></pre></div>
<p>To demarcate code based on the operating system compiled on.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE CPP #-}</span>

<span class="st">#ifdef OS_Linux</span>
  <span class="co">-- Linux specific logic</span>
<span class="st">#else</span>
<span class="st"># ifdef OS_Win32</span>
  <span class="co">-- Windows specific logic</span>
<span class="st"># else</span>
<span class="st"># ifdef OS_Mac</span>
  <span class="co">-- Macintosh specific logic</span>
<span class="st"># else</span>
  <span class="co">-- Other operating systems</span>
<span class="st"># endif</span>
<span class="st"># endif</span>
<span class="st">#endif</span></code></pre></div>
<p>Or on the version of the base library used.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="st">#if !MIN_VERSION_base(4,6,0)</span>
  <span class="co">-- Base specific logic</span>
<span class="st">#endif</span></code></pre></div>
<p>It can also be abused to do terrible things like metaprogrammming with strings, but please don't do this.</p>
<h2 id="historical-extensions">Historical Extensions</h2>
<p>Several language extensions have either been absorbed into the core language or become deprecated in favor of others. Others are just considered misfeatures.</p>
<ul>
<li>Rank2Types - Rank2Types has been subsumed by RankNTypes</li>
<li>XPolymorphicComponents - Was an implementation detail of higher-rank polymorphism that no longer exists.</li>
<li>NPlusKPatterns - These were largely considered an ugly edge-case of pattern matching language that was best removed.</li>
<li>TraditionalRecordSyntax - Traditional record syntax was an extension to the Haskell 98 specification for what we now consider standard record syntax.</li>
<li>OverlappingInstances - Subsumed by explicit OVERLAPPING pragmas.</li>
<li>IncoherentInstances - Subsumed by explicit INCOHERENT pragmas.</li>
<li>NullaryTypeClasses - Subsumed by explicit Multiparameter Typeclasses with no parameters.</li>
</ul>
<hr />
<h1 id="type-classes">Type Classes</h1>
<h2 id="minimal-annotations">Minimal Annotations</h2>
<p>In the presence of default implementations of typeclasses methods, there may be several ways to implement a typeclass. For instance Eq is entirely defined by either defining when two values are equal or not equal by implying taking the negation of the other. We can define equality in terms of non-equality and vice-versa.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Eq</span> a <span class="kw">where</span>
  (<span class="fu">==</span>),<span class="ot"> (/=) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
  x <span class="fu">==</span> y <span class="fu">=</span> not (x <span class="fu">/=</span> y)
  x <span class="fu">/=</span> y <span class="fu">=</span> not (x <span class="fu">==</span> y)</code></pre></div>
<p>Before 7.6.1 there was no way to specify what was the &quot;minimal&quot; definition required to implement a typeclass</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Eq</span> a <span class="kw">where</span>
  (<span class="fu">==</span>),<span class="ot"> (/=) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
  x <span class="fu">==</span> y <span class="fu">=</span> not (x <span class="fu">/=</span> y)
  x <span class="fu">/=</span> y <span class="fu">=</span> not (x <span class="fu">==</span> y)
  <span class="ot">{-# MINIMAL (==) #-}</span>
  <span class="ot">{-# MINIMAL (/=) #-}</span></code></pre></div>
<p>Minimal pragmas are boolean expressions, with <code>|</code> as logical <code>OR</code>, <em>either</em> definition must be defined). Comma indicates logical <code>AND</code> where both sides <em>both</em> definitions must be defined.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# MINIMAL (==) | (/=) #-}</span> <span class="co">-- Either (==) or (/=)</span>
<span class="ot">{-# MINIMAL (==) , (/=) #-}</span> <span class="co">-- Both (==) and (/=)</span></code></pre></div>
<p>Compiling the <code>-Wmissing-methods</code> will warn when a instance is defined that does not meet the minimal criterion.</p>
<h2 id="flexibleinstances">FlexibleInstances</h2>
<div class="sourceCode" include="src/04-extensions/flexinstances.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>

<span class="kw">class</span> <span class="dt">MyClass</span> a

<span class="co">-- Without flexible instances, all instance heads must be type variable. The</span>
<span class="co">-- following would be legal.</span>
<span class="kw">instance</span> <span class="dt">MyClass</span> (<span class="dt">Maybe</span> a)

<span class="co">-- With flexible instances, typeclass heads can be arbitrary nested types. The</span>
<span class="co">-- following would be forbidden without it.</span>
<span class="kw">instance</span> <span class="dt">MyClass</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>)</code></pre></div>
<h2 id="flexiblecontexts">FlexibleContexts</h2>
<div class="sourceCode" include="src/04-extensions/flexcontexts.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span>

<span class="kw">class</span> <span class="dt">MyClass</span> a

<span class="co">-- Without flexible contexts, all contexts must be type variable. The</span>
<span class="co">-- following would be legal.</span>
<span class="kw">instance</span> (<span class="dt">MyClass</span> a) <span class="ot">=&gt;</span> <span class="dt">MyClass</span> (<span class="dt">Either</span> a b)

<span class="co">-- With flexible contexts, typeclass contexts can be arbitrary nested types. The</span>
<span class="co">-- following would be forbidden without it.</span>
<span class="kw">instance</span> (<span class="dt">MyClass</span> (<span class="dt">Maybe</span> a)) <span class="ot">=&gt;</span> <span class="dt">MyClass</span> (<span class="dt">Either</span> a b)</code></pre></div>
<h2 id="overlappinginstances">OverlappingInstances</h2>
<p>Typeclasses are normally globally coherent, there is only ever one instance that can be resolved for a type unambiguously for a type at any call site in the program. There are however extensions to loosen this restriction and perform more manual direction of the instance search.</p>
<p>Overlapping instances loosens the coherent condition (there can be multiple instances) but introduces a criterion that it will resolve to the most specific one.</p>
<div class="sourceCode" include="src/04-extensions/overlapping.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE OverlappingInstances #-}</span>
<span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span>

<span class="kw">class</span> <span class="dt">MyClass</span> a b <span class="kw">where</span>
<span class="ot">  fn ::</span> (a,b)

<span class="kw">instance</span> <span class="dt">MyClass</span> <span class="dt">Int</span> b <span class="kw">where</span>
  fn <span class="fu">=</span> error <span class="st">&quot;b&quot;</span>

<span class="kw">instance</span> <span class="dt">MyClass</span> a <span class="dt">Int</span> <span class="kw">where</span>
  fn <span class="fu">=</span> error <span class="st">&quot;a&quot;</span>

<span class="kw">instance</span> <span class="dt">MyClass</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="kw">where</span>
  fn <span class="fu">=</span> error <span class="st">&quot;c&quot;</span>

<span class="ot">example ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
example <span class="fu">=</span> fn</code></pre></div>
<p>Historically enabling this on module-level was not the best idea, since generally we define multiple classes in a module only a subset of which may be incoherent. So as of 7.10 we now have the capacity to just annotate instances with the OVERLAPPING and INCOHERENT pragmas.</p>
<div class="sourceCode" include="src/04-extensions/overlapping_anno.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span>

<span class="kw">class</span> <span class="dt">MyClass</span> a b <span class="kw">where</span>
<span class="ot">  fn ::</span> (a,b)

<span class="kw">instance</span> <span class="ot">{-# OVERLAPPING #-}</span> <span class="dt">MyClass</span> <span class="dt">Int</span> b <span class="kw">where</span>
  fn <span class="fu">=</span> error <span class="st">&quot;b&quot;</span>

<span class="kw">instance</span> <span class="ot">{-# OVERLAPPING #-}</span> <span class="dt">MyClass</span> a <span class="dt">Int</span> <span class="kw">where</span>
  fn <span class="fu">=</span> error <span class="st">&quot;a&quot;</span>

<span class="kw">instance</span> <span class="ot">{-# OVERLAPPING #-}</span> <span class="dt">MyClass</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="kw">where</span>
  fn <span class="fu">=</span> error <span class="st">&quot;c&quot;</span>

<span class="ot">example ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
example <span class="fu">=</span> fn</code></pre></div>
<h2 id="incoherentinstances">IncoherentInstances</h2>
<p>Incoherent instance loosens the restriction that there be only one specific instance, will choose one arbitrarily (based on the arbitrary sorting of it's internal representation ) and the resulting program will typecheck. This is generally pretty crazy and usually a sign of poor design.</p>
<div class="sourceCode" include="src/04-extensions/incoherent.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE IncoherentInstances #-}</span>
<span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span>

<span class="kw">class</span> <span class="dt">MyClass</span> a b <span class="kw">where</span>
<span class="ot">  fn ::</span> (a,b)

<span class="kw">instance</span> <span class="dt">MyClass</span> <span class="dt">Int</span> b <span class="kw">where</span>
  fn <span class="fu">=</span> error <span class="st">&quot;a&quot;</span>

<span class="kw">instance</span> <span class="dt">MyClass</span> a <span class="dt">Int</span> <span class="kw">where</span>
  fn <span class="fu">=</span> error <span class="st">&quot;b&quot;</span>

<span class="ot">example ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
example <span class="fu">=</span> fn</code></pre></div>
<p>There is also an incoherent instance.</p>
<div class="sourceCode" include="src/04-extensions/incoherent_anno.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span>

<span class="kw">class</span> <span class="dt">MyClass</span> a b <span class="kw">where</span>
<span class="ot">  fn ::</span> (a,b)

<span class="kw">instance</span> <span class="ot">{-# INCOHERENT #-}</span> <span class="dt">MyClass</span> a <span class="dt">Int</span> <span class="kw">where</span>
  fn <span class="fu">=</span> error <span class="st">&quot;general&quot;</span>

<span class="kw">instance</span> <span class="ot">{-# INCOHERENT #-}</span> <span class="dt">MyClass</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="kw">where</span>
  fn <span class="fu">=</span> error <span class="st">&quot;specific&quot;</span>

<span class="ot">example ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
example <span class="fu">=</span> fn</code></pre></div>
<h2 id="typesynonyminstances">TypeSynonymInstances</h2>
<div class="sourceCode" include="src/04-extensions/synonym.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeSynonymInstances #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>

<span class="kw">type</span> <span class="dt">IntList</span> <span class="fu">=</span> [<span class="dt">Int</span>]

<span class="kw">class</span> <span class="dt">MyClass</span> a

<span class="co">-- Without type synonym instances, we&#39;re forced to manually expand out type</span>
<span class="co">-- synonyms in the typeclass head.</span>
<span class="kw">instance</span> <span class="dt">MyClass</span> [<span class="dt">Int</span>]

<span class="co">-- With it GHC will do this for us automatically. Type synonyms still need to</span>
<span class="co">-- be fully applied.</span>
<span class="kw">instance</span> <span class="dt">MyClass</span> <span class="dt">IntList</span></code></pre></div>
<hr />
<h1 id="laziness">Laziness</h1>
<p>Again, a subject on which <em>much</em> ink has been spilled. There is an ongoing discussion in the land of Haskell about the compromises between lazy and strict evaluation, and there are nuanced arguments for having either paradigm be the default. Haskell takes a hybrid approach and allows strict evaluation when needed and uses laziness by default. Needless to say, we can always find examples where strict evaluation exhibits worse behavior than lazy evaluation and vice versa.</p>
<p>The primary advantage of lazy evaluation in the large is that algorithms that operate over both unbounded and bounded data structures can inhabit the same type signatures and be composed without additional need to restructure their logic or force intermediate computations. Languages that attempt to bolt laziness on to a strict evaluation model often bifurcate classes of algorithms into ones that are hand-adjusted to consume unbounded structures and those which operate over bounded structures. In strict languages mixing and matching between lazy vs strict processing often necessitates manifesting large intermediate structures in memory when such composition would &quot;just work&quot; in a lazy language.</p>
<p>By virtue of Haskell being the only language to actually explore this point in the design space to the point of being industrial strength; knowledge about lazy evaluation is not widely absorbed into the collective programmer consciousness and can often be non-intuitive to the novice. This doesn't reflect on the model itself, merely on the need for more instruction material and research on optimizing lazy compilers.</p>
<p>The paradox of Haskell is that it explores so many definably unique ideas ( laziness, purity, typeclasses ) that it becomes difficult to separate out the discussion of any one from the gestalt of the whole implementation.</p>
<p>See:</p>
<ul>
<li><a href="http://alpmestan.com/posts/2013-10-02-oh-my-laziness.html">Oh My Laziness!</a></li>
<li><a href="http://www.slideshare.net/tibbe/reasoning-about-laziness">Reasoning about Laziness</a></li>
<li><a href="http://www.vex.net/~trebla/haskell/lazy.xhtml">Lazy Evaluation of Haskell</a></li>
<li><a href="http://augustss.blogspot.hu/2011/05/more-points-for-lazy-evaluation-in.html">More Points For Lazy Evaluation</a></li>
<li><a href="https://hackhands.com/lazy-evaluation-works-haskell/">How Lazy Evaluation Works in Haskell</a></li>
</ul>
<h2 id="strictness">Strictness</h2>
<p>There are several evaluation models for the lambda calculus:</p>
<ul>
<li>Strict - Evaluation is said to be strict if all arguments are evaluated before the body of a function.</li>
<li>Non-strict - Evaluation is non-strict if the arguments are not necessarily evaluated before entering the body of a function.</li>
</ul>
<p>These ideas give rise to several models, Haskell itself use the <em>call-by-need</em> model.</p>
<table>
<thead>
<tr class="header">
<th align="left">Model</th>
<th align="left">Strictness</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Call-by-value</td>
<td align="left">Strict</td>
<td align="left">arguments evaluated before function entered</td>
</tr>
<tr class="even">
<td align="left">Call-by-name</td>
<td align="left">Non-strict</td>
<td align="left">arguments passed unevaluated</td>
</tr>
<tr class="odd">
<td align="left">Call-by-need</td>
<td align="left">Non-strict</td>
<td align="left">arguments passed unevaluated but an expression is only evaluated once (sharing)</td>
</tr>
</tbody>
</table>
<h2 id="seq-and-whnf">Seq and WHNF</h2>
<p>A term is said to be in <em>weak head normal-form</em> if the outermost constructor or lambda cannot be reduced further. A term is said to be in <em>normal form</em> if it is fully evaluated and all sub-expressions and thunks contained within are evaluated.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- In Normal Form</span>
<span class="dv">42</span>
(<span class="dv">2</span>, <span class="st">&quot;foo&quot;</span>)
\x <span class="ot">-&gt;</span> x <span class="fu">+</span> <span class="dv">1</span>

<span class="co">-- Not in Normal Form</span>
<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>
(\x <span class="ot">-&gt;</span> x <span class="fu">+</span> <span class="dv">1</span>) <span class="dv">2</span>
<span class="st">&quot;foo&quot;</span> <span class="fu">++</span> <span class="st">&quot;bar&quot;</span>
(<span class="dv">1</span> <span class="fu">+</span> <span class="dv">1</span>, <span class="st">&quot;foo&quot;</span>)

<span class="co">-- In Weak Head Normal Form</span>
(<span class="dv">1</span> <span class="fu">+</span> <span class="dv">1</span>, <span class="st">&quot;foo&quot;</span>)
\x <span class="ot">-&gt;</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">2</span>
<span class="ch">&#39;f&#39;</span> <span class="fu">:</span> (<span class="st">&quot;oo&quot;</span> <span class="fu">++</span> <span class="st">&quot;bar&quot;</span>)

<span class="co">-- Not In Weak Head Normal Form</span>
<span class="dv">1</span> <span class="fu">+</span> <span class="dv">1</span>
(\x <span class="ot">-&gt;</span> x <span class="fu">+</span> <span class="dv">1</span>) <span class="dv">2</span>
<span class="st">&quot;foo&quot;</span> <span class="fu">++</span> <span class="st">&quot;bar&quot;</span></code></pre></div>
<p>In Haskell normal evaluation only occurs at the outer constructor of case-statements in Core. If we pattern match on a list we don't implicitly force all values in the list. An element in a data structure is only evaluated up to the most outer constructor. For example, to evaluate the length of a list we need only scrutinize the outer Cons constructors without regard for their inner values.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> length [undefined, <span class="dv">1</span>]
<span class="dv">2</span>

λ<span class="fu">:</span> head [undefined, <span class="dv">1</span>]
Prelude.undefined

λ<span class="fu">:</span> snd (undefined, <span class="dv">1</span>)
<span class="dv">1</span>

λ<span class="fu">:</span> fst (undefined, <span class="dv">1</span>)
Prelude.undefined</code></pre></div>
<p>For example, in a lazy language the following program terminates even though it contains diverging terms.</p>
<div class="sourceCode" include="src/05-laziness/nodiverge.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ignore ::</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span>
ignore x <span class="fu">=</span> <span class="dv">0</span>

<span class="ot">loop ::</span> a
loop <span class="fu">=</span> loop

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> print <span class="fu">$</span> ignore loop</code></pre></div>
<p>In a strict language like OCaml ( ignoring its suspensions for the moment ), the same program diverges.</p>
<div class="sourceCode" include="src/05-laziness/diverge.ml"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> ignore x <span class="fu">=</span> <span class="dv">0</span>;; 
<span class="kw">let</span> rec loop a <span class="fu">=</span> loop a;;

print_int (ignore (loop ()));</code></pre></div>
<p>In Haskell a <em>thunk</em> is created to stand for an unevaluated computation. Evaluation of a thunk is called <em>forcing</em> the thunk. The result is an <em>update</em>, a referentially transparent effect, which replaces the memory representation of the thunk with the computed value. The fundamental idea is that a thunk is only updated once ( although it may be forced simultaneously in a multi-threaded environment ) and its resulting value is shared when referenced subsequently.</p>
<p>The command <code>:sprint</code> can be used to introspect the state of unevaluated thunks inside an expression without forcing evaluation. For instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> <span class="kw">let</span> a <span class="fu">=</span> [<span class="dv">1</span><span class="fu">..</span>]<span class="ot"> ::</span> [<span class="dt">Integer</span>]
λ<span class="fu">:</span> <span class="kw">let</span> b <span class="fu">=</span> map (<span class="fu">+</span> <span class="dv">1</span>) a

λ<span class="fu">:</span> <span class="fu">:</span>sprint a
a <span class="fu">=</span> _
λ<span class="fu">:</span> <span class="fu">:</span>sprint b
b <span class="fu">=</span> _
λ<span class="fu">:</span> a <span class="fu">!!</span> <span class="dv">4</span>
<span class="dv">5</span>
λ<span class="fu">:</span> <span class="fu">:</span>sprint a
a <span class="fu">=</span> <span class="dv">1</span> <span class="fu">:</span> <span class="dv">2</span> <span class="fu">:</span> <span class="dv">3</span> <span class="fu">:</span> <span class="dv">4</span> <span class="fu">:</span> <span class="dv">5</span> <span class="fu">:</span> _
λ<span class="fu">:</span> b <span class="fu">!!</span> <span class="dv">10</span>
<span class="dv">12</span>
λ<span class="fu">:</span> <span class="fu">:</span>sprint a
a <span class="fu">=</span> <span class="dv">1</span> <span class="fu">:</span> <span class="dv">2</span> <span class="fu">:</span> <span class="dv">3</span> <span class="fu">:</span> <span class="dv">4</span> <span class="fu">:</span> <span class="dv">5</span> <span class="fu">:</span> <span class="dv">6</span> <span class="fu">:</span> <span class="dv">7</span> <span class="fu">:</span> <span class="dv">8</span> <span class="fu">:</span> <span class="dv">9</span> <span class="fu">:</span> <span class="dv">10</span> <span class="fu">:</span> <span class="dv">11</span> <span class="fu">:</span> _
λ<span class="fu">:</span> <span class="fu">:</span>sprint b
b <span class="fu">=</span> _ <span class="fu">:</span> _ <span class="fu">:</span> _ <span class="fu">:</span> _ <span class="fu">:</span> _ <span class="fu">:</span> _ <span class="fu">:</span> _ <span class="fu">:</span> _ <span class="fu">:</span> _ <span class="fu">:</span> _ <span class="fu">:</span> <span class="dv">12</span> <span class="fu">:</span> _</code></pre></div>
<p>While a thunk is being computed its memory representation is replaced with a special form known as <em>blackhole</em> which indicates that computation is ongoing and allows for a short circuit for when a computation might depend on itself to complete. The implementation of this is some of the more subtle details of the GHC runtime.</p>
<p>The <code>seq</code> function introduces an artificial dependence on the evaluation of order of two terms by requiring that the first argument be evaluated to WHNF before the evaluation of the second. The implementation of the <code>seq</code> function is an implementation detail of GHC.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">seq<span class="ot"> ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b

⊥ <span class="ot">`seq`</span> a <span class="fu">=</span> ⊥
a <span class="ot">`seq`</span> b <span class="fu">=</span> b</code></pre></div>
<p>The infamous <code>foldl</code> is well-known to leak space when used carelessly and without several compiler optimizations applied. The strict <code>foldl'</code> variant uses seq to overcome this.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldl<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> a
foldl f z [] <span class="fu">=</span> z
foldl f z (x<span class="fu">:</span>xs) <span class="fu">=</span> foldl f (f z x) xs</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foldl&#39; ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> a
foldl&#39; _ z [] <span class="fu">=</span> z
foldl&#39; f z (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">let</span> z&#39; <span class="fu">=</span> f z x <span class="kw">in</span> z&#39; <span class="ot">`seq`</span> foldl&#39; f z&#39; xs</code></pre></div>
<p>In practice, a combination between the strictness analyzer and the inliner on <code>-O2</code> will ensure that the strict variant of <code>foldl</code> is used whenever the function is inlinable at call site so manually using <code>foldl'</code> is most often not required.</p>
<p>Of important note is that GHCi runs without any optimizations applied so the same program that performs poorly in GHCi may not have the same performance characteristics when compiled with GHC.</p>
<h2 id="strictness-annotations">Strictness Annotations</h2>
<p>The extension <code>BangPatterns</code> allows an alternative syntax to force arguments to functions to be wrapped in seq. A bang operator on an arguments forces its evaluation to weak head normal form before performing the pattern match. This can be used to keep specific arguments evaluated throughout recursion instead of creating a giant chain of thunks.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE BangPatterns #-}</span>

sum<span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a
sum <span class="fu">=</span> go <span class="dv">0</span>
  <span class="kw">where</span>
    go <span class="fu">!</span>acc (x<span class="fu">:</span>xs) <span class="fu">=</span> go (acc <span class="fu">+</span> x) xs
    go  acc []     <span class="fu">=</span> acc</code></pre></div>
<p>This is desugared into code effectively equivalent to the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">sum<span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a
sum <span class="fu">=</span> go <span class="dv">0</span>
  <span class="kw">where</span>
    go acc _ <span class="fu">|</span> acc <span class="ot">`seq`</span> <span class="dt">False</span> <span class="fu">=</span> undefined
    go acc (x<span class="fu">:</span>xs)              <span class="fu">=</span> go (acc <span class="fu">+</span> x) xs
    go acc []                  <span class="fu">=</span> acc</code></pre></div>
<p>Function application to seq'd arguments is common enough that it has a special operator.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">($!) ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b
f <span class="fu">$!</span> x  <span class="fu">=</span> <span class="kw">let</span> <span class="fu">!</span>vx <span class="fu">=</span> x <span class="kw">in</span> f vx</code></pre></div>
<h2 id="strict-haskell">Strict Haskell</h2>
<p>As of GHC 8.0 strictness annotations can be applied to all definitions in a module automatically. In previous versions it was necessary to definitions via explicit syntactic annotations at all sites.</p>
<h4 id="strictdata">StrictData</h4>
<p>Enabling StrictData makes constructor fields strict by default on any module it is enabled on.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE StrictData #-}</span>

<span class="kw">data</span> <span class="dt">Employee</span> <span class="fu">=</span> <span class="dt">Employee</span>
  {<span class="ot"> name ::</span> <span class="dt">T.Text</span>
  ,<span class="ot"> age ::</span> <span class="dt">Int</span>
  }</code></pre></div>
<p>Is equivalent to:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Employee</span> <span class="fu">=</span> <span class="dt">Employee</span>
  {<span class="ot"> name ::</span> <span class="fu">!</span><span class="dt">T.Text</span>
  ,<span class="ot"> age ::</span> <span class="fu">!</span><span class="dt">Int</span>
  }</code></pre></div>
<h4 id="strict">Strict</h4>
<p>Strict implies <code>-XStrictData</code> and extends strictness annotations to all arguments of functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f x y <span class="fu">=</span> x <span class="fu">+</span> y</code></pre></div>
<p>Is equivalent to the following function declaration with explicit bang patterns:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f <span class="fu">!</span>x <span class="fu">!</span>y <span class="fu">=</span> x <span class="fu">+</span> y</code></pre></div>
<p>On a module-level this effectively makes Haskell a call-by-value language with some caveats. All arguments to functions are now explicitly evaluated and all data in constructors within this module are in head normal form by construction. However there are some subtle points to this that are better explained in the language guide.</p>
<ul>
<li><a href="https://downloads.haskell.org/~ghc/master/users-guide//glasgow_exts.html?highlight=typefamilydependencies#strict-by-default-pattern-bindings">Strict Extensions</a></li>
</ul>
<h2 id="deepseq">Deepseq</h2>
<p>There are often times when for performance reasons we need to deeply evaluate a data structure to normal form leaving no terms unevaluated. The <code>deepseq</code> library performs this task.</p>
<p>The typeclass <code>NFData</code> (Normal Form Data) allows us to seq all elements of a structure across any subtypes which themselves implement NFData.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">NFData</span> a <span class="kw">where</span>
<span class="ot">  rnf ::</span> a <span class="ot">-&gt;</span> ()
  rnf a <span class="fu">=</span> a <span class="ot">`seq`</span> ()

<span class="ot">deepseq ::</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b
<span class="ot">($!!) ::</span> (<span class="dt">NFData</span> a) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">NFData</span> <span class="dt">Int</span>
<span class="kw">instance</span> <span class="dt">NFData</span> (a <span class="ot">-&gt;</span> b)

<span class="kw">instance</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> <span class="dt">NFData</span> (<span class="dt">Maybe</span> a) <span class="kw">where</span>
    rnf <span class="dt">Nothing</span>  <span class="fu">=</span> ()
    rnf (<span class="dt">Just</span> x) <span class="fu">=</span> rnf x

<span class="kw">instance</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> <span class="dt">NFData</span> [a] <span class="kw">where</span>
    rnf [] <span class="fu">=</span> ()
    rnf (x<span class="fu">:</span>xs) <span class="fu">=</span> rnf x <span class="ot">`seq`</span> rnf xs</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[<span class="dv">1</span>, undefined] <span class="ot">`seq`</span> ()
<span class="co">-- ()</span>

[<span class="dv">1</span>, undefined] <span class="ot">`deepseq`</span> ()
<span class="co">-- Prelude.undefined</span></code></pre></div>
<p>To force a data structure itself to be fully evaluated we share the same argument in both positions of deepseq.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">force ::</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a
force x <span class="fu">=</span> x <span class="ot">`deepseq`</span> x</code></pre></div>
<h2 id="irrefutable-patterns">Irrefutable Patterns</h2>
<p>A lazy pattern doesn't require a match on the outer constructor, instead it lazily calls the accessors of the values as needed. In the presence of a bottom, we fail at the usage site instead of the outer pattern match.</p>
<div class="sourceCode" include="src/05-laziness/lazy_patterns.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> (a, b) <span class="ot">-&gt;</span> <span class="dt">Int</span>
f (a,b) <span class="fu">=</span> const <span class="dv">1</span> a

<span class="ot">g ::</span> (a, b) <span class="ot">-&gt;</span> <span class="dt">Int</span>
g <span class="fu">~</span>(a,b) <span class="fu">=</span> const <span class="dv">1</span> a

<span class="co">-- λ: f undefined</span>
<span class="co">-- *** Exception: Prelude.undefined</span>
<span class="co">-- λ: g undefined</span>
<span class="co">-- 1</span>

<span class="ot">j ::</span> <span class="dt">Maybe</span> t <span class="ot">-&gt;</span> t
j <span class="fu">~</span>(<span class="dt">Just</span> x) <span class="fu">=</span> x

<span class="ot">k ::</span> <span class="dt">Maybe</span> t <span class="ot">-&gt;</span> t
k (<span class="dt">Just</span> x) <span class="fu">=</span> x

<span class="co">-- λ: j Nothing</span>
<span class="co">-- *** Exception: src/05-laziness/lazy_patterns.hs:15:1-15: Irrefutable pattern failed for pattern (Just x)</span>
<span class="fu">--</span>
<span class="co">-- λ: k Nothing</span>
<span class="co">-- *** Exception: src/05-laziness/lazy_patterns.hs:18:1-14: Non-exhaustive patterns in function k</span></code></pre></div>
<hr />
<h1 id="prelude">Prelude</h1>
<h2 id="what-to-avoid">What to Avoid?</h2>
<p>Haskell being a 25 year old language has witnessed several revolutions in the way we structure and compose functional programs. Yet as a result several portions of the Prelude still reflect old schools of thought that simply can't be removed without breaking significant parts of the ecosystem.</p>
<p>Currently it really only exists in folklore which parts to use and which not to use, although this is a topic that almost all introductory books don't mention and instead make extensive use of the Prelude for simplicity's sake.</p>
<p>The short version of the advice on the Prelude is:</p>
<div class="alert alert-success">
<ul>
<li>Avoid String.</li>
<li>Use <code>fmap</code> instead of <code>map</code>.</li>
<li>Use Foldable and Traversable instead of the Control.Monad, and Data.List versions of traversals.</li>
<li>Avoid partial functions like <code>head</code> and <code>read</code> or use their total variants.</li>
<li>Avoid exceptions, use ExceptT or Either instead.</li>
<li>Avoid boolean blind functions.</li>
</ul>
</div>
<p>The instances of Foldable for the list type often conflict with the monomorphic versions in the Prelude which are left in for historical reasons. So often times it is desirable to explicitly mask these functions from implicit import and force the use of Foldable and Traversable instead.</p>
<p>Of course often times one wishes only to use the Prelude explicitly and one can explicitly import it qualified and use the pieces as desired without the implicit import of the whole namespace.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Prelude</span> <span class="kw">as</span> <span class="dt">P</span></code></pre></div>
<h2 id="what-should-be-in-base">What Should be in Base</h2>
<p>To get work done you probably need.</p>
<div class="alert alert-success">
<ul>
<li>async</li>
<li>bytestring</li>
<li>containers</li>
<li>mtl</li>
<li>stm</li>
<li>text</li>
<li>transformers</li>
<li>unordered-containers</li>
<li>vector</li>
<li>filepath</li>
<li>directory</li>
<li>process</li>
<li>unix</li>
<li>deepseq</li>
<li>optparse-applicative</li>
</ul>
</div>
<h2 id="custom-preludes">Custom Preludes</h2>
<p>The default Prelude can be disabled in it's entirety by twiddling the <code>-XNoImplicitPrelude</code> flag.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></code></pre></div>
<p>We are then free to build an equivalent Prelude that is more to our liking. Using module reexporting we can pluck the good parts of the prelude and libraries like <code>safe</code> to build up a more industrial focused set of default functions. For example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Custom</span> (
  <span class="kw">module</span> <span class="dt">Exports</span>,
) <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Int</span> <span class="kw">as</span> <span class="dt">Exports</span>
<span class="kw">import </span><span class="dt">Data.Tuple</span> <span class="kw">as</span> <span class="dt">Exports</span>
<span class="kw">import </span><span class="dt">Data.Maybe</span> <span class="kw">as</span> <span class="dt">Exports</span>
<span class="kw">import </span><span class="dt">Data.String</span> <span class="kw">as</span> <span class="dt">Exports</span>
<span class="kw">import </span><span class="dt">Data.Foldable</span> <span class="kw">as</span> <span class="dt">Exports</span>
<span class="kw">import </span><span class="dt">Data.Traversable</span> <span class="kw">as</span> <span class="dt">Exports</span>

<span class="kw">import </span><span class="dt">Control.Monad.Trans.Except</span>
  as <span class="dt">Exports</span>
  (<span class="dt">ExceptT</span>(<span class="dt">ExceptT</span>), <span class="dt">Except</span>, except, runExcept, runExceptT,
   mapExcept, mapExceptT, withExcept, withExceptT)</code></pre></div>
<p>The Prelude itself is entirely replicable as well, presuming that an entire project is compiled without the implicit Prelude. Several packages have arisen that supply much of the same functionality in a way that appeals to more modern design principles.</p>
<h2 id="protolude">Protolude</h2>
<p>Protolude is a minimalist Prelude which provides many sensible defaults for writing modern Haskell and is compatible with existing code.</p>
<ul>
<li><a href="http://hackage.haskell.org/package/protolude">protolude</a></li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span>

<span class="kw">import </span><span class="dt">Protolude</span></code></pre></div>
<p>Other examples for alternative Preludes include (your mileage may vary with these):</p>
<ul>
<li><a href="http://hackage.haskell.org/package/base-prelude">base-prelude</a></li>
<li><a href="http://hackage.haskell.org/package/basic-prelude">basic-prelude</a></li>
<li><a href="http://hackage.haskell.org/package/classy-prelude">classy-prelude</a></li>
<li><a href="https://hackage.haskell.org/packages/#cat:Prelude">Other Preludes</a></li>
</ul>
<h2 id="partial-functions">Partial Functions</h2>
<p>A <em>partial function</em> is a function which doesn't terminate and yield a value for all given inputs. Conversely a <em>total function</em> terminates and is always defined for all inputs. As mentioned previously, certain historical parts of the Prelude are full of partial functions.</p>
<p>The difference between partial and total functions is the compiler can't reason about the runtime safety of partial functions purely from the information specified in the language and as such the proof of safety is left to the user to guarantee. They are safe to use in the case where the user can guarantee that invalid inputs cannot occur, but like any unchecked property its safety or not-safety is going to depend on the diligence of the programmer. This very much goes against the overall philosophy of Haskell and as such they are discouraged when not necessary.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">head<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> a
read<span class="ot"> ::</span> <span class="dt">Read</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a
<span class="ot">(!!) ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a</code></pre></div>
<h2 id="safe">Safe</h2>
<p>The Prelude has total variants of the historical partial functions (i.e. <code>Text.Read.readMaybe</code>)in some cases, but often these are found in the various utility libraries like <code>safe</code>.</p>
<p>The total versions provided fall into three cases:</p>
<ul>
<li><code>May</code> - return Nothing when the function is not defined for the inputs</li>
<li><code>Def</code> - provide a default value when the function is not defined for the inputs</li>
<li><code>Note</code> - call <code>error</code> with a custom error message when the function is not defined for the inputs. This is not safe, but slightly easier to debug!</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Total</span>
<span class="ot">headMay ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
<span class="ot">readMay ::</span> <span class="dt">Read</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
<span class="ot">atMay ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a

<span class="co">-- Total</span>
<span class="ot">headDef ::</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a
<span class="ot">readDef ::</span> <span class="dt">Read</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a
<span class="ot">atDef   ::</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a

<span class="co">-- Partial</span>
<span class="ot">headNote ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a
<span class="ot">readNote ::</span> <span class="dt">Read</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a
<span class="ot">atNote   ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a</code></pre></div>
<h2 id="boolean-blindness">Boolean Blindness</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Bool</span> <span class="fu">=</span> <span class="dt">True</span> <span class="fu">|</span> <span class="dt">False</span>

<span class="ot">isJust ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isJust (<span class="dt">Just</span> x) <span class="fu">=</span> <span class="dt">True</span>
isJust <span class="dt">Nothing</span>  <span class="fu">=</span> <span class="dt">False</span></code></pre></div>
<p>The problem with the boolean type is that there is effectively no difference between True and False at the type level. A proposition taking a value to a Bool takes any information given and destroys it. To reason about the behavior we have to trace the provenance of the proposition we're getting the boolean answer from, and this introduces a whole slew of possibilities for misinterpretation. In the worst case, the only way to reason about safe and unsafe use of a function is by trusting that a predicate's lexical name reflects its provenance!</p>
<p>For instance, testing some proposition over a Bool value representing whether the branch can perform the computation safely in the presence of a null is subject to accidental interchange. Consider that in a language like C or Python testing whether a value is null is indistinguishable to the language from testing whether the value is <em>not null</em>. Which of these programs encodes safe usage and which segfaults?</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># This one?</span>
<span class="cf">if</span> p(x):
    <span class="co"># use x</span>
<span class="cf">elif</span> <span class="op">not</span> p(x):
    <span class="co"># don&#39;t use x</span>

<span class="co"># Or this one?</span>
<span class="cf">if</span> p(x):
    <span class="co"># don&#39;t use x</span>
<span class="cf">elif</span> <span class="op">not</span> p(x):
    <span class="co"># use x</span></code></pre></div>
<p>From inspection we can't tell without knowing how p is defined, the compiler can't distinguish the two either and thus the language won't save us if we happen to mix them up. Instead of making invalid states <em>unrepresentable</em> we've made the invalid state <em>indistinguishable</em> from the valid one!</p>
<p>The more desirable practice is to match on terms which explicitly witness the proposition as a type ( often in a sum type ) and won't typecheck otherwise.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">case</span> x <span class="kw">of</span>
  <span class="dt">Just</span> a  <span class="ot">-&gt;</span> use x
  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> don&#39;t use x

<span class="co">-- not ideal</span>
<span class="kw">case</span> p x <span class="kw">of</span>
  <span class="dt">True</span>  <span class="ot">-&gt;</span> use x
  <span class="dt">False</span> <span class="ot">-&gt;</span> don&#39;t use x

<span class="co">-- not ideal</span>
<span class="kw">if</span> p x
  <span class="kw">then</span> use x
  <span class="kw">else</span> don&#39;t use x</code></pre></div>
<p>To be fair though, many popular languages completely lack the notion of sum types ( the source of many woes in my opinion ) and only have product types, so this type of reasoning sometimes has no direct equivalence for those not familiar with ML family languages.</p>
<p>In Haskell, the Prelude provides functions like <code>isJust</code> and <code>fromJust</code> both of which can be used to subvert this kind of reasoning and make it easy to introduce bugs and should often be avoided.</p>
<h2 id="foldable-traversable">Foldable / Traversable</h2>
<p>If coming from an imperative background retraining one's self to think about iteration over lists in terms of maps, folds, and scans can be challenging.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">Prelude.foldl<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> a
Prelude.foldr<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b

<span class="co">-- pseudocode</span>
foldr f z [a<span class="fu">...</span>] <span class="fu">=</span> f a (f b ( <span class="fu">...</span> (f y z) <span class="fu">...</span> ))
foldl f z [a<span class="fu">...</span>] <span class="fu">=</span> f <span class="fu">...</span> (f (f z a) b) <span class="fu">...</span> y</code></pre></div>
<p>For a concrete consider the simple arithmetic sequence over the binary operator <code>(+)</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- foldr (+) 1 [2..]</span>
(<span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> (<span class="dv">3</span> <span class="fu">+</span> (<span class="dv">4</span> <span class="fu">+</span> <span class="fu">...</span>))))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- foldl (+) 1 [2..]</span>
((((<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">+</span> <span class="dv">3</span>) <span class="fu">+</span> <span class="dv">4</span>) <span class="fu">+</span> <span class="fu">...</span>)</code></pre></div>
<p>Foldable and Traversable are the general interface for all traversals and folds of any data structure which is parameterized over its element type ( List, Map, Set, Maybe, ...). These two classes are used everywhere in modern Haskell and are extremely important.</p>
<p>A foldable instance allows us to apply functions to data types of monoidal values that collapse the structure using some logic over <code>mappend</code>.</p>
<p>A traversable instance allows us to apply functions to data types that walk the structure left-to-right within an applicative context.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Functor</span> f, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> <span class="dt">Traversable</span> f <span class="kw">where</span>
<span class="ot">  traverse ::</span> <span class="dt">Applicative</span> g <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> g b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g (f b)

<span class="kw">class</span> <span class="dt">Foldable</span> f <span class="kw">where</span>
<span class="ot">  foldMap ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> m</code></pre></div>
<p>The <code>foldMap</code> function is extremely general and non-intuitively many of the monomorphic list folds can themselves be written in terms of this single polymorphic function.</p>
<p><code>foldMap</code> takes a function of values to a monoidal quantity, a functor over the values and collapses the functor into the monoid. For instance for the trivial Sum monoid:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> foldMap <span class="dt">Sum</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]
<span class="dt">Sum</span> {getSum <span class="fu">=</span> <span class="dv">55</span>}</code></pre></div>
<p>For instance if we wanted to map a list of some abstract element types into a hashtable of elements based on pattern matching we could use it.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Foldable</span>
<span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span>

<span class="kw">data</span> <span class="dt">Elt</span>
  <span class="fu">=</span> <span class="dt">Elt</span> <span class="dt">Int</span> <span class="dt">Double</span>
  <span class="fu">|</span> <span class="dt">Nil</span>

<span class="ot">foo ::</span> [<span class="dt">Elt</span>] <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> <span class="dt">Int</span> <span class="dt">Double</span>
foo <span class="fu">=</span> foldMap go
  <span class="kw">where</span>
    go (<span class="dt">Elt</span> x y) <span class="fu">=</span> Map.singleton x y
    go <span class="dt">Nil</span> <span class="fu">=</span> Map.empty</code></pre></div>
<p>The full Foldable class (with all default implementations) contains a variety of derived functions which themselves can be written in terms of <code>foldMap</code> and <code>Endo</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Endo</span> a <span class="fu">=</span> <span class="dt">Endo</span> {<span class="ot">appEndo ::</span> a <span class="ot">-&gt;</span> a}

<span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Endo</span> a) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Endo</span> id
  <span class="dt">Endo</span> f <span class="ot">`mappend`</span> <span class="dt">Endo</span> g <span class="fu">=</span> <span class="dt">Endo</span> (f <span class="fu">.</span> g)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Foldable</span> t <span class="kw">where</span>
<span class="ot">    fold    ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> t m <span class="ot">-&gt;</span> m
<span class="ot">    foldMap ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m

<span class="ot">    foldr   ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b
<span class="ot">    foldr&#39;  ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b

<span class="ot">    foldl   ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b
<span class="ot">    foldl&#39;  ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b

<span class="ot">    foldr1  ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> a
<span class="ot">    foldl1  ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> a</code></pre></div>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b
foldr f z t <span class="fu">=</span> appEndo (foldMap (<span class="dt">Endo</span> <span class="fu">.</span> f) t) z</code></pre></div>
<p>Most of the operations over lists can be generalized in terms of combinations of Foldable and Traversable to derive more general functions that work over all data structures implementing Foldable.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">Data.Foldable.elem<span class="ot">    ::</span> (<span class="dt">Eq</span> a, <span class="dt">Foldable</span> t) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
Data.Foldable.sum<span class="ot">     ::</span> (<span class="dt">Num</span> a, <span class="dt">Foldable</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> a
Data.Foldable.minimum<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> a
Data.Traversable.mapM<span class="ot"> ::</span> (<span class="dt">Monad</span> m, <span class="dt">Traversable</span> t) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m (t b)</code></pre></div>
<p>Unfortunately for historical reasons the names exported by foldable quite often conflict with ones defined in the Prelude, either import them qualified or just disable the Prelude. The operations in the Foldable all specialize to the same and behave the same as the ones in Prelude for List types.</p>
<div class="sourceCode" include="src/06-prelude/foldable_traversable.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Monoid</span>
<span class="kw">import </span><span class="dt">Data.Foldable</span>
<span class="kw">import </span><span class="dt">Data.Traversable</span>

<span class="kw">import </span><span class="dt">Control.Applicative</span>
<span class="kw">import </span><span class="dt">Control.Monad.Identity</span> (runIdentity)
<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (mapM_, foldr)

<span class="co">-- Rose Tree</span>
<span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Node</span> a [<span class="dt">Tree</span> a] <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Tree</span> <span class="kw">where</span>
  fmap f (<span class="dt">Node</span> x ts) <span class="fu">=</span> <span class="dt">Node</span> (f x) (fmap (fmap f) ts)

<span class="kw">instance</span> <span class="dt">Traversable</span> <span class="dt">Tree</span> <span class="kw">where</span>
  traverse f (<span class="dt">Node</span> x ts) <span class="fu">=</span> <span class="dt">Node</span> <span class="fu">&lt;$&gt;</span> f x <span class="fu">&lt;*&gt;</span> traverse (traverse f) ts

<span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">Tree</span> <span class="kw">where</span>
  foldMap f (<span class="dt">Node</span> x ts) <span class="fu">=</span> f x <span class="ot">`mappend`</span> foldMap (foldMap f) ts


<span class="ot">tree ::</span> <span class="dt">Tree</span> <span class="dt">Integer</span>
tree <span class="fu">=</span> <span class="dt">Node</span> <span class="dv">1</span> [<span class="dt">Node</span> <span class="dv">1</span> [], <span class="dt">Node</span> <span class="dv">2</span> [] ,<span class="dt">Node</span> <span class="dv">3</span> []]


<span class="ot">example1 ::</span> <span class="dt">IO</span> ()
example1 <span class="fu">=</span> mapM_ print tree

<span class="ot">example2 ::</span> <span class="dt">Integer</span>
example2 <span class="fu">=</span> foldr (<span class="fu">+</span>) <span class="dv">0</span> tree

<span class="ot">example3 ::</span> <span class="dt">Maybe</span> (<span class="dt">Tree</span> <span class="dt">Integer</span>)
example3 <span class="fu">=</span> traverse (\x <span class="ot">-&gt;</span> <span class="kw">if</span> x <span class="fu">&gt;</span> <span class="dv">2</span> <span class="kw">then</span> <span class="dt">Just</span> x <span class="kw">else</span> <span class="dt">Nothing</span>) tree

<span class="ot">example4 ::</span> <span class="dt">Tree</span> <span class="dt">Integer</span>
example4 <span class="fu">=</span> runIdentity <span class="fu">$</span> traverse (\x <span class="ot">-&gt;</span> pure (x<span class="fu">+</span><span class="dv">1</span>)) tree</code></pre></div>
<p>The instances we defined above can also be automatically derived by GHC using several language extensions. The automatic instances are identical to the hand-written versions above.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span>
<span class="ot">{-# LANGUAGE DeriveFoldable #-}</span>
<span class="ot">{-# LANGUAGE DeriveTraversable #-}</span>

<span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Node</span> a [<span class="dt">Tree</span> a]
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Traversable</span>)</code></pre></div>
<p>See: <a href="http://wiki.haskell.org/Typeclassopedia">Typeclassopedia</a></p>
<h2 id="corecursion">Corecursion</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">unfoldr ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, b)) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a]</code></pre></div>
<p>A recursive function consumes data and eventually terminates, a corecursive function generates data and <strong>coterminates</strong>. A corecursive function is said to be <em>productive</em> if it can always evaluate more of the resulting value in bounded time.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List</span>

<span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
f <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Nothing</span>
f x <span class="fu">=</span> <span class="dt">Just</span> (x, x<span class="fu">-</span><span class="dv">1</span>)

<span class="ot">rev ::</span> [<span class="dt">Int</span>]
rev <span class="fu">=</span> unfoldr f <span class="dv">10</span>

<span class="ot">fibs ::</span> [<span class="dt">Int</span>]
fibs <span class="fu">=</span> unfoldr (\(a,b) <span class="ot">-&gt;</span> <span class="dt">Just</span> (a,(b,a<span class="fu">+</span>b))) (<span class="dv">0</span>,<span class="dv">1</span>)</code></pre></div>
<h2 id="split">split</h2>
<p>The <a href="http://hackage.haskell.org/package/split-0.1.1/docs/Data-List-Split.html">split</a> package provides a variety of missing functions for splitting list and string types.</p>
<div class="sourceCode" include="src/06-prelude/split.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List.Split</span>

<span class="ot">example1 ::</span> [<span class="dt">String</span>]
example1 <span class="fu">=</span> splitOn <span class="st">&quot;.&quot;</span> <span class="st">&quot;foo.bar.baz&quot;</span>
<span class="co">-- [&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;]</span>

<span class="ot">example2 ::</span> [<span class="dt">String</span>]
example2 <span class="fu">=</span> chunksOf <span class="dv">10</span> <span class="st">&quot;To be or not to be that is the question.&quot;</span>
<span class="co">-- [&quot;To be or n&quot;,&quot;ot to be t&quot;,&quot;hat is the&quot;,&quot; question.&quot;]</span></code></pre></div>
<h2 id="monad-loops">monad-loops</h2>
<p>The <a href="http://hackage.haskell.org/package/monad-loops-0.4.2/docs/Control-Monad-Loops.html">monad-loops</a> package provides a variety of missing functions for control logic in monadic contexts.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">whileM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m [a]
<span class="ot">untilM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m [a]
<span class="ot">iterateUntilM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m a
<span class="ot">whileJust ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m (<span class="dt">Maybe</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m [b]</code></pre></div>
<h2 id="foundation">Foundation</h2>
<p>TODO</p>
<p>See: <a href="https://github.com/haskell-foundation/foundation">Foundation</a></p>
<hr />
<h1 id="strings">Strings</h1>
<h2 id="string">String</h2>
<div class="alert alert-danger">
<p><b>The default String type is broken and should be avoided whenever possible.</b> Unfortunately for historical reasons large portions of GHC and Base depend on String.</p>
</div>
<p>The default Haskell string type is implemented as a naive linked list of characters, this is terrible for most purposes but no one knows how to fix it without rewriting large portions of all code that exists and nobody can commit the time to fix it. So it remains broken, likely forever.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">String</span> <span class="fu">=</span> [<span class="dt">Char</span>]</code></pre></div>
<p>For more performance sensitive cases there are two libraries for processing textual data: <code>text</code> and <code>bytestring</code>.</p>
<ul>
<li><b>text</b> - Used for handling unicode data.</li>
<li><b>bytestring</b> - Used for handling ASCII data that needs to interchanged with C code or network protocols.</li>
</ul>
<p>For each of these there are two variants for both text and bytestring.</p>
<ul>
<li><b>lazy</b> Lazy text objects are encoded as lazy lists of strict chunks of bytes.</li>
<li><b>strict</b> Byte vectors are encoded as strict Word8 arrays of bytes or code points</li>
</ul>
<p>Giving rise to the four types.</p>
<table>
<thead>
<tr class="header">
<th align="left">Variant</th>
<th align="left">Module</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><b>strict text</b></td>
<td align="left">Data.Text</td>
</tr>
<tr class="even">
<td align="left"><b>lazy text</b></td>
<td align="left">Data.Text.Lazy</td>
</tr>
<tr class="odd">
<td align="left"><b>strict bytestring</b></td>
<td align="left">Data.ByteString</td>
</tr>
<tr class="even">
<td align="left"><b>lazy bytestring</b></td>
<td align="left">Data.ByteString.Lazy</td>
</tr>
</tbody>
</table>
<h4 id="conversions">Conversions</h4>
<p>Conversions between strings types ( from : left column, to : top row ) are done with several functions across the bytestring and text libraries. The mapping between text and bytestring is inherently lossy so there is some degree of freedom in choosing the encoding. We'll just consider utf-8 for simplicity.</p>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">Data.Text</th>
<th align="left">Data.Text.Lazy</th>
<th align="left">Data.ByteString</th>
<th align="left">Data.ByteString.Lazy</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Data.Text</td>
<td align="left">id</td>
<td align="left">fromStrict</td>
<td align="left">encodeUtf8</td>
<td align="left">encodeUtf8</td>
</tr>
<tr class="even">
<td align="left">Data.Text.Lazy</td>
<td align="left">toStrict</td>
<td align="left">id</td>
<td align="left">encodeUtf8</td>
<td align="left">encodeUtf8</td>
</tr>
<tr class="odd">
<td align="left">Data.ByteString</td>
<td align="left">decodeUtf8</td>
<td align="left">decodeUtf8</td>
<td align="left">id</td>
<td align="left">fromStrict</td>
</tr>
<tr class="even">
<td align="left">Data.ByteString.Lazy</td>
<td align="left">decodeUtf8</td>
<td align="left">decodeUtf8</td>
<td align="left">toStrict</td>
<td align="left">id</td>
</tr>
</tbody>
</table>
<h4 id="overloaded-strings">Overloaded Strings</h4>
<p>With the <code>-XOverloadedStrings</code> extension string literals can be overloaded without the need for explicit packing and can be written as string literals in the Haskell source and overloaded via a typeclass <code>IsString</code>. Sometimes this is desirable.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">IsString</span> a <span class="kw">where</span>
<span class="ot">  fromString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</code></pre></div>
<p>For instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> <span class="fu">:</span><span class="kw">type</span> <span class="st">&quot;foo&quot;</span>
<span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> [<span class="dt">Char</span>]

λ<span class="fu">:</span> <span class="fu">:</span>set <span class="fu">-</span><span class="dt">XOverloadedStrings</span>

λ<span class="fu">:</span> <span class="fu">:</span><span class="kw">type</span> <span class="st">&quot;foo&quot;</span>
<span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> <span class="dt">IsString</span> a <span class="ot">=&gt;</span> a</code></pre></div>
<p>We can also derive IsString for newtypes using <code>GeneralizedNewtypeDeriving</code>, although much of the safety of the newtype is then lost if it is interchangeable with other strings.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Cat</span> <span class="fu">=</span> <span class="dt">Cat</span> <span class="dt">Text</span>
  <span class="kw">deriving</span> (<span class="dt">IsString</span>)

<span class="ot">fluffy ::</span> <span class="dt">Cat</span>
fluffy <span class="fu">=</span> <span class="st">&quot;Fluffy&quot;</span></code></pre></div>
<h2 id="import-conventions">Import Conventions</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy</span> <span class="kw">as</span> <span class="dt">TL</span>
<span class="kw">import qualified</span> <span class="dt">Data.ByteString</span> <span class="kw">as</span> <span class="dt">BS</span>
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">BL</span>
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Char8</span> <span class="kw">as</span> <span class="dt">C</span>
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">as</span> <span class="dt">CL</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Text.IO</span> <span class="kw">as</span> <span class="dt">TIO</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy.IO</span> <span class="kw">as</span> <span class="dt">TLIO</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Text.Encoding</span> <span class="kw">as</span> <span class="dt">TE</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy.Encoding</span> <span class="kw">as</span> <span class="dt">TLE</span></code></pre></div>
<h2 id="text">Text</h2>
<p>A <code>Text</code> type is a packed blob of Unicode characters.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pack<span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Text</span>
<span class="ot">unpack ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre></div>
<div class="sourceCode" include="src/07-text-bytestring/text.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>

<span class="co">-- From pack</span>
<span class="ot">myTStr1 ::</span> <span class="dt">T.Text</span>
myTStr1 <span class="fu">=</span> T.pack (<span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> <span class="dt">String</span>)

<span class="co">-- From overloaded string literal.</span>
<span class="ot">myTStr2 ::</span> <span class="dt">T.Text</span>
myTStr2 <span class="fu">=</span> <span class="st">&quot;bar&quot;</span></code></pre></div>
<p>See: <a href="http://hackage.haskell.org/package/text-1.1.0.1/docs/Data-Text.html">Text</a></p>
<h2 id="text.builder">Text.Builder</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toLazyText ::</span> <span class="dt">Builder</span> <span class="ot">-&gt;</span> <span class="dt">Data.Text.Lazy.Internal.Text</span>
<span class="ot">fromLazyText ::</span> <span class="dt">Data.Text.Lazy.Internal.Text</span> <span class="ot">-&gt;</span> <span class="dt">Builder</span></code></pre></div>
<p>The Text.Builder allows the efficient monoidal construction of lazy Text types without having to go through inefficient forms like String or List types as intermediates.</p>
<div class="sourceCode" include="src/07-text-bytestring/builder.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Data.Monoid</span> (mconcat, (&lt;&gt;))

<span class="kw">import </span><span class="dt">Data.Text.Lazy.Builder</span> (<span class="dt">Builder</span>, toLazyText)
<span class="kw">import </span><span class="dt">Data.Text.Lazy.Builder.Int</span> (decimal)
<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy.IO</span> <span class="kw">as</span> <span class="dt">L</span>

<span class="ot">beer ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Builder</span>
beer n <span class="fu">=</span> decimal n <span class="fu">&lt;&gt;</span> <span class="st">&quot; bottles of beer on the wall.\n&quot;</span>

<span class="ot">wall ::</span> <span class="dt">Builder</span>
wall <span class="fu">=</span> mconcat <span class="fu">$</span> fmap beer [<span class="dv">1</span><span class="fu">..</span><span class="dv">1000</span>]

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> L.putStrLn <span class="fu">$</span> toLazyText wall</code></pre></div>
<h2 id="bytestring">ByteString</h2>
<p>ByteStrings are arrays of unboxed characters with either strict or lazy evaluation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pack<span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span>
<span class="ot">unpack ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre></div>
<div class="sourceCode" include="src/07-text-bytestring/bytestring.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import qualified</span> <span class="dt">Data.ByteString</span> <span class="kw">as</span> <span class="dt">S</span>
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Char8</span> <span class="kw">as</span> <span class="dt">S8</span>

<span class="co">-- From pack</span>
<span class="ot">bstr1 ::</span> <span class="dt">S.ByteString</span>
bstr1 <span class="fu">=</span> S.pack (<span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> <span class="dt">String</span>)

<span class="co">-- From overloaded string literal.</span>
<span class="ot">bstr2 ::</span> <span class="dt">S.ByteString</span>
bstr2 <span class="fu">=</span> <span class="st">&quot;bar&quot;</span></code></pre></div>
<p>See:</p>
<ul>
<li><a href="https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/bytestring-bits-and-pieces">Bytestring: Bits and Pieces</a></li>
<li><a href="http://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString.html">ByteString</a></li>
</ul>
<h2 id="utf8-string">utf8-string</h2>
<p>See: <a href="https://hackage.haskell.org/package/utf8-string">utf8-string</a></p>
<h2 id="base64-bytestring">base64-bytestring</h2>
<h2 id="printf">Printf</h2>
<p>Haskell also has a variadic <code>printf</code> function in the style of C.</p>
<div class="sourceCode" include="src/07-text-bytestring/printf.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Text</span>
<span class="kw">import </span><span class="dt">Text.Printf</span>

<span class="ot">a ::</span> <span class="dt">Int</span>
a <span class="fu">=</span> <span class="dv">3</span>

<span class="ot">b ::</span> <span class="dt">Double</span>
b <span class="fu">=</span> <span class="fl">3.14159</span>

<span class="ot">c ::</span> <span class="dt">String</span>
c <span class="fu">=</span> <span class="st">&quot;haskell&quot;</span>

<span class="ot">example ::</span> <span class="dt">String</span>
example <span class="fu">=</span> printf <span class="st">&quot;(%i, %f, %s)&quot;</span> a b c
<span class="co">-- &quot;(3, 3.14159, haskell)&quot;</span></code></pre></div>
<h2 id="overloaded-lists">Overloaded Lists</h2>
<p>It is ubiquitous for data structure libraries to expose <code>toList</code> and <code>fromList</code> functions to construct various structures out of lists. As of GHC 7.8 we now have the ability to overload the list syntax in the surface language with a typeclass <code>IsList</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">IsList</span> l <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Item</span> l
<span class="ot">  fromList  ::</span> [<span class="dt">Item</span> l] <span class="ot">-&gt;</span> l
<span class="ot">  toList    ::</span> l <span class="ot">-&gt;</span> [<span class="dt">Item</span> l]

<span class="kw">instance</span> <span class="dt">IsList</span> [a] <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Item</span> [a] <span class="fu">=</span> a
  fromList <span class="fu">=</span> id
  toList   <span class="fu">=</span> id</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> <span class="fu">:</span><span class="kw">type</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]<span class="ot"> ::</span> (<span class="dt">Num</span> (<span class="dt">Item</span> l), <span class="dt">IsList</span> l) <span class="ot">=&gt;</span> l</code></pre></div>
<div class="sourceCode" include="src/07-text-bytestring/overloadedlist.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedLists #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>

<span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span>
<span class="kw">import </span><span class="dt">GHC.Exts</span> (<span class="dt">IsList</span>(..))

<span class="kw">instance</span> (<span class="dt">Ord</span> k) <span class="ot">=&gt;</span> <span class="dt">IsList</span> (<span class="dt">Map.Map</span> k v) <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Item</span> (<span class="dt">Map.Map</span> k v) <span class="fu">=</span> (k,v)
  fromList <span class="fu">=</span> Map.fromList
  toList <span class="fu">=</span> Map.toList

<span class="ot">example1 ::</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">Int</span>
example1 <span class="fu">=</span> [(<span class="st">&quot;a&quot;</span>, <span class="dv">1</span>), (<span class="st">&quot;b&quot;</span>, <span class="dv">2</span>)]</code></pre></div>
<h2 id="string-conversions">String Conversions</h2>
<p>Playing &quot;type-tetris&quot; to convert between Strings explicitly can be frustrating, fortunately there are several packages that automate the conversion using typeclasses to automatically convert between any two common string representations automatically. We can then write generic comparison and concatenation operators that automatically convert types of operands to a like form.</p>
<div class="sourceCode" include="src/07-text-bytestring/convert.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Data.String.Conv</span>

<span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy.IO</span> <span class="kw">as</span> <span class="dt">TL</span>

<span class="kw">import qualified</span> <span class="dt">Data.ByteString</span> <span class="kw">as</span> <span class="dt">B</span>
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">BL</span>

<span class="kw">import </span><span class="dt">Data.Monoid</span>

<span class="ot">a ::</span> <span class="dt">String</span>
a <span class="fu">=</span> <span class="st">&quot;Gödel&quot;</span>

<span class="ot">b ::</span> <span class="dt">BL.ByteString</span>
b <span class="fu">=</span> <span class="st">&quot;Einstein&quot;</span>

<span class="ot">c ::</span> <span class="dt">T.Text</span>
c <span class="fu">=</span> <span class="st">&quot;Feynmann&quot;</span>

<span class="ot">d ::</span> <span class="dt">B.ByteString</span>
d <span class="fu">=</span> <span class="st">&quot;Schrödinger&quot;</span>

<span class="co">-- Compare unlike strings</span>
<span class="ot">(==~) ::</span> (<span class="dt">Eq</span> a, <span class="dt">StringConv</span> b a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Bool</span>
(<span class="fu">==~</span>) a b <span class="fu">=</span> a <span class="fu">==</span> toS b

<span class="co">-- Concat unlike strings</span>
<span class="ot">(&lt;&gt;~) ::</span> (<span class="dt">Monoid</span> a, <span class="dt">StringConv</span> b a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a
(<span class="fu">&lt;&gt;~</span>) a b <span class="fu">=</span> a <span class="fu">&lt;&gt;</span> toS b

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  putStrLn (toS a)
  TL.putStrLn (toS b)
  print (a <span class="fu">==~</span> b)
  print (c <span class="fu">==~</span> d)
  print (c <span class="fu">==~</span> c)
  print (b <span class="fu">&lt;&gt;~</span> c)</code></pre></div>
<hr />
<h1 id="applicatives">Applicatives</h1>
<p>Like monads Applicatives are an abstract structure for a wide class of computations that sit between functors and monads in terms of generality.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">pure ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> f a
<span class="ot">(&lt;$&gt;) ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b
<span class="ot">(&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre></div>
<p>As of GHC 7.6, Applicative is defined as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span>
<span class="ot">  pure ::</span> a <span class="ot">-&gt;</span> f a
<span class="ot">  (&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b

<span class="ot">(&lt;$&gt;) ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b
(<span class="fu">&lt;$&gt;</span>) <span class="fu">=</span> fmap</code></pre></div>
<p>With the following laws:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pure id <span class="fu">&lt;*&gt;</span> v <span class="fu">=</span> v
pure f <span class="fu">&lt;*&gt;</span> pure x <span class="fu">=</span> pure (f x)
u <span class="fu">&lt;*&gt;</span> pure y <span class="fu">=</span> pure (<span class="fu">$</span> y) <span class="fu">&lt;*&gt;</span> u
u <span class="fu">&lt;*&gt;</span> (v <span class="fu">&lt;*&gt;</span> w) <span class="fu">=</span> pure (<span class="fu">.</span>) <span class="fu">&lt;*&gt;</span> u <span class="fu">&lt;*&gt;</span> v <span class="fu">&lt;*&gt;</span> w</code></pre></div>
<p>As an example, consider the instance for Maybe:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Maybe</span> <span class="kw">where</span>
  pure              <span class="fu">=</span> <span class="dt">Just</span>
  <span class="dt">Nothing</span> <span class="fu">&lt;*&gt;</span> _     <span class="fu">=</span> <span class="dt">Nothing</span>
  _ <span class="fu">&lt;*&gt;</span> <span class="dt">Nothing</span>     <span class="fu">=</span> <span class="dt">Nothing</span>
  <span class="dt">Just</span> f <span class="fu">&lt;*&gt;</span> <span class="dt">Just</span> x <span class="fu">=</span> <span class="dt">Just</span> (f x)</code></pre></div>
<p>As a rule of thumb, whenever we would use <code>m &gt;&gt;= return . f</code> what we probably want is an applicative functor, and not a monad.</p>
<div class="sourceCode" include="src/08-applicatives/applicative.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Network.HTTP</span>
<span class="kw">import </span><span class="dt">Control.Applicative</span> ((&lt;$&gt;),(&lt;*&gt;))

<span class="ot">example1 ::</span> <span class="dt">Maybe</span> <span class="dt">Integer</span>
example1 <span class="fu">=</span> (<span class="fu">+</span>) <span class="fu">&lt;$&gt;</span> m1 <span class="fu">&lt;*&gt;</span> m2
  <span class="kw">where</span>
    m1 <span class="fu">=</span> <span class="dt">Just</span> <span class="dv">3</span>
    m2 <span class="fu">=</span> <span class="dt">Nothing</span>
<span class="co">-- Nothing</span>

<span class="ot">example2 ::</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>)]
example2 <span class="fu">=</span> (,,) <span class="fu">&lt;$&gt;</span> m1 <span class="fu">&lt;*&gt;</span> m2 <span class="fu">&lt;*&gt;</span> m3
  <span class="kw">where</span>
    m1 <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">2</span>]
    m2 <span class="fu">=</span> [<span class="dv">10</span>,<span class="dv">20</span>]
    m3 <span class="fu">=</span> [<span class="dv">100</span>,<span class="dv">200</span>]
<span class="co">-- [(1,10,100),(1,10,200),(1,20,100),(1,20,200),(2,10,100),(2,10,200),(2,20,100),(2,20,200)]</span>

<span class="ot">example3 ::</span> <span class="dt">IO</span> <span class="dt">String</span>
example3 <span class="fu">=</span> (<span class="fu">++</span>) <span class="fu">&lt;$&gt;</span> fetch1 <span class="fu">&lt;*&gt;</span> fetch2
  <span class="kw">where</span>
    fetch1 <span class="fu">=</span> simpleHTTP (getRequest <span class="st">&quot;http://www.fpcomplete.com/&quot;</span>) <span class="fu">&gt;&gt;=</span> getResponseBody
    fetch2 <span class="fu">=</span> simpleHTTP (getRequest <span class="st">&quot;http://www.haskell.org/&quot;</span>) <span class="fu">&gt;&gt;=</span> getResponseBody</code></pre></div>
<p>The pattern <code>f &lt;$&gt; a &lt;*&gt; b ...</code> shows up so frequently that there are a family of functions to lift applicatives of a fixed number arguments. This pattern also shows up frequently with monads (<code>liftM</code>, <code>liftM2</code>, <code>liftM3</code>).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">liftA ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b
liftA f a <span class="fu">=</span> pure f <span class="fu">&lt;*&gt;</span> a

<span class="ot">liftA2 ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c
liftA2 f a b <span class="fu">=</span> f <span class="fu">&lt;$&gt;</span> a <span class="fu">&lt;*&gt;</span> b

<span class="ot">liftA3 ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c <span class="ot">-&gt;</span> f d
liftA3 f a b c <span class="fu">=</span> f <span class="fu">&lt;$&gt;</span> a <span class="fu">&lt;*&gt;</span> b <span class="fu">&lt;*&gt;</span> c</code></pre></div>
<p>Applicative also has functions <code>*&gt;</code> and <code>&lt;*</code> that sequence applicative actions while discarding the value of one of the arguments. The operator <code>*&gt;</code> discard the left while <code>&lt;*</code> discards the right. For example in a monadic parser combinator library the <code>*&gt;</code> would parse with first parser argument but return the second.</p>
<p>The Applicative functions <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> are generalized by <code>liftM</code> and <code>ap</code> for monads.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Control.Applicative</span>

<span class="kw">data</span> <span class="dt">C</span> a b <span class="fu">=</span> <span class="dt">C</span> a b

<span class="ot">mnd ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m (<span class="dt">C</span> a b)
mnd a b <span class="fu">=</span> <span class="dt">C</span> <span class="ot">`liftM`</span> a <span class="ot">`ap`</span> b

<span class="ot">apl ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f (<span class="dt">C</span> a b)
apl a b <span class="fu">=</span> <span class="dt">C</span> <span class="fu">&lt;$&gt;</span> a <span class="fu">&lt;*&gt;</span> b</code></pre></div>
<p>See: <a href="http://www.soi.city.ac.uk/~ross/papers/Applicative.pdf">Applicative Programming with Effects</a></p>
<h2 id="alternative">Alternative</h2>
<p>Alternative is an extension of the Applicative class with a zero element and an associative binary operation respecting the zero.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Alternative</span> f <span class="kw">where</span>
  <span class="co">-- | The identity of &#39;&lt;|&gt;&#39;</span>
<span class="ot">  empty ::</span> f a
  <span class="co">-- | An associative binary operation</span>
<span class="ot">  (&lt;|&gt;) ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a
  <span class="co">-- | One or more.</span>
<span class="ot">  some ::</span> f a <span class="ot">-&gt;</span> f [a]
  <span class="co">-- | Zero or more.</span>
<span class="ot">  many ::</span> f a <span class="ot">-&gt;</span> f [a]

<span class="ot">optional ::</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f (<span class="dt">Maybe</span> a)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Alternative</span> <span class="dt">Maybe</span> <span class="kw">where</span>
    empty <span class="fu">=</span> <span class="dt">Nothing</span>
    <span class="dt">Nothing</span> <span class="fu">&lt;|&gt;</span> r <span class="fu">=</span> r
    l       <span class="fu">&lt;|&gt;</span> _ <span class="fu">=</span> l

<span class="kw">instance</span> <span class="dt">Alternative</span> [] <span class="kw">where</span>
    empty <span class="fu">=</span> []
    (<span class="fu">&lt;|&gt;</span>) <span class="fu">=</span> (<span class="fu">++</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> foldl1 (<span class="fu">&lt;|&gt;</span>) [<span class="dt">Nothing</span>, <span class="dt">Just</span> <span class="dv">5</span>, <span class="dt">Just</span> <span class="dv">3</span>]
<span class="dt">Just</span> <span class="dv">5</span></code></pre></div>
<p>These instances show up very frequently in parsers where the alternative operator can model alternative parse branches.</p>
<h2 id="arrows">Arrows</h2>
<p>A category is an algebraic structure that includes a notion of an identity and a composition operation that is associative and preserves identities.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Category</span> cat <span class="kw">where</span>
<span class="ot">  id ::</span> cat a a
<span class="ot">  (.) ::</span> cat b c <span class="ot">-&gt;</span> cat a b <span class="ot">-&gt;</span> cat a c</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Category</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span>
  id <span class="fu">=</span> Prelude.id
  (<span class="fu">.</span>) <span class="fu">=</span> (<span class="fu">Prelude..</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&lt;&lt;&lt;) ::</span> <span class="dt">Category</span> cat <span class="ot">=&gt;</span> cat b c <span class="ot">-&gt;</span> cat a b <span class="ot">-&gt;</span> cat a c
(<span class="fu">&lt;&lt;&lt;</span>) <span class="fu">=</span> (<span class="fu">.</span>)

<span class="ot">(&gt;&gt;&gt;) ::</span> <span class="dt">Category</span> cat <span class="ot">=&gt;</span> cat a b <span class="ot">-&gt;</span> cat b c <span class="ot">-&gt;</span> cat a c
f <span class="fu">&gt;&gt;&gt;</span> g <span class="fu">=</span> g <span class="fu">.</span> f</code></pre></div>
<p>Arrows are an extension of categories with the notion of products.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Category</span> a <span class="ot">=&gt;</span> <span class="dt">Arrow</span> a <span class="kw">where</span>
<span class="ot">  arr ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> a b c
<span class="ot">  first ::</span> a b c <span class="ot">-&gt;</span> a (b,d) (c,d)
<span class="ot">  second ::</span> a b c <span class="ot">-&gt;</span> a (d,b) (d,c)
<span class="ot">  (***) ::</span> a b c <span class="ot">-&gt;</span> a b&#39; c&#39; <span class="ot">-&gt;</span> a (b,b&#39;) (c,c&#39;)
<span class="ot">  (&amp;&amp;&amp;) ::</span> a b c <span class="ot">-&gt;</span> a b c&#39; <span class="ot">-&gt;</span> a b (c,c&#39;)</code></pre></div>
<p>The canonical example is for functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Arrow</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span>
  arr f <span class="fu">=</span> f
  first f <span class="fu">=</span> f <span class="fu">***</span> id
  second f <span class="fu">=</span> id <span class="fu">***</span> f
  (<span class="fu">***</span>) f g <span class="fu">~</span>(x,y) <span class="fu">=</span> (f x, g y)</code></pre></div>
<p>In this form functions of multiple arguments can be threaded around using the arrow combinators in a much more pointfree form. For instance a histogram function has a nice one-liner.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List</span> (group, sort)

<span class="ot">histogram ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [(a, <span class="dt">Int</span>)]
histogram <span class="fu">=</span> map (head <span class="fu">&amp;&amp;&amp;</span> length) <span class="fu">.</span> group <span class="fu">.</span> sort</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> histogram <span class="st">&quot;Hello world&quot;</span>
[(<span class="ch">&#39; &#39;</span>,<span class="dv">1</span>),(<span class="ch">&#39;H&#39;</span>,<span class="dv">1</span>),(<span class="ch">&#39;d&#39;</span>,<span class="dv">1</span>),(<span class="ch">&#39;e&#39;</span>,<span class="dv">1</span>),(<span class="ch">&#39;l&#39;</span>,<span class="dv">3</span>),(<span class="ch">&#39;o&#39;</span>,<span class="dv">2</span>),(<span class="ch">&#39;r&#39;</span>,<span class="dv">1</span>),(<span class="ch">&#39;w&#39;</span>,<span class="dv">1</span>)]</code></pre></div>
<p><strong>Arrow notation</strong></p>
<p>GHC has builtin syntax for composing arrows using <code>proc</code> notation. The following are equivalent after desugaring:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE Arrows #-}</span>

<span class="ot">addA ::</span> <span class="dt">Arrow</span> a <span class="ot">=&gt;</span> a b <span class="dt">Int</span> <span class="ot">-&gt;</span> a b <span class="dt">Int</span> <span class="ot">-&gt;</span> a b <span class="dt">Int</span>
addA f g <span class="fu">=</span> proc x <span class="ot">-&gt;</span> <span class="kw">do</span>
                y <span class="ot">&lt;-</span> f <span class="fu">-&lt;</span> x
                z <span class="ot">&lt;-</span> g <span class="fu">-&lt;</span> x
                returnA <span class="fu">-&lt;</span> y <span class="fu">+</span> z</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">addA f g <span class="fu">=</span> arr (\ x <span class="ot">-&gt;</span> (x, x)) <span class="fu">&gt;&gt;&gt;</span>
           first f <span class="fu">&gt;&gt;&gt;</span> arr (\ (y, x) <span class="ot">-&gt;</span> (x, y)) <span class="fu">&gt;&gt;&gt;</span>
           first g <span class="fu">&gt;&gt;&gt;</span> arr (\ (z, y) <span class="ot">-&gt;</span> y <span class="fu">+</span> z)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">addA f g <span class="fu">=</span> f <span class="fu">&amp;&amp;&amp;</span> g <span class="fu">&gt;&gt;&gt;</span> arr (\ (y, z) <span class="ot">-&gt;</span> y <span class="fu">+</span> z)</code></pre></div>
<p>In practice this notation is not often used and may become deprecated in the future.</p>
<p>See: <a href="https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/arrow-notation.html">Arrow Notation</a></p>
<h2 id="bifunctors">Bifunctors</h2>
<p>Bifunctors are a generalization of functors to include types parameterized by two parameters and include two map functions for each parameter.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Bifunctor</span> p <span class="kw">where</span>
<span class="ot">  bimap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> p a c <span class="ot">-&gt;</span> p b d
<span class="ot">  first ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> p a c <span class="ot">-&gt;</span> p b c
<span class="ot">  second ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> p a b <span class="ot">-&gt;</span> p a c</code></pre></div>
<p>The bifunctor laws are a natural generalization of the usual functor. Namely they respect identities and composition in the usual way:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">bimap id id ≡ id
first id ≡ id
second id ≡ id</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">bimap f g ≡ first f <span class="fu">.</span> second g</code></pre></div>
<p>The canonical example is for 2-tuples.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> first (<span class="fu">+</span><span class="dv">1</span>) (<span class="dv">1</span>,<span class="dv">2</span>)
(<span class="dv">2</span>,<span class="dv">2</span>)
λ<span class="fu">:</span> second (<span class="fu">+</span><span class="dv">1</span>) (<span class="dv">1</span>,<span class="dv">2</span>)
(<span class="dv">1</span>,<span class="dv">3</span>)
λ<span class="fu">:</span> bimap (<span class="fu">+</span><span class="dv">1</span>) (<span class="fu">+</span><span class="dv">1</span>) (<span class="dv">1</span>,<span class="dv">2</span>)
(<span class="dv">2</span>,<span class="dv">3</span>)

λ<span class="fu">:</span> first (<span class="fu">+</span><span class="dv">1</span>) (<span class="dt">Left</span> <span class="dv">3</span>)
<span class="dt">Left</span> <span class="dv">4</span>
λ<span class="fu">:</span> second (<span class="fu">+</span><span class="dv">1</span>) (<span class="dt">Left</span> <span class="dv">3</span>)
<span class="dt">Left</span> <span class="dv">3</span>
λ<span class="fu">:</span> second (<span class="fu">+</span><span class="dv">1</span>) (<span class="dt">Right</span> <span class="dv">3</span>)
<span class="dt">Right</span> <span class="dv">4</span></code></pre></div>
<h2 id="polyvariadic-functions">Polyvariadic Functions</h2>
<p>One surprising application of typeclasses is the ability to construct functions which take an arbitrary number of arguments by defining instances over function types. The arguments may be of arbitrary type, but the resulting collected arguments must either converted into a single type or unpacked into a sum type.</p>
<div class="sourceCode" include="src/08-applicatives/variadic.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>

<span class="kw">class</span> <span class="dt">Arg</span> a <span class="kw">where</span>
<span class="ot">  collect&#39; ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> a

<span class="co">-- extract to IO</span>
<span class="kw">instance</span> <span class="dt">Arg</span> (<span class="dt">IO</span> ()) <span class="kw">where</span>
  collect&#39; acc <span class="fu">=</span> mapM_ putStrLn acc

<span class="co">-- extract to [String]</span>
<span class="kw">instance</span> <span class="dt">Arg</span> [<span class="dt">String</span>] <span class="kw">where</span>
  collect&#39; acc <span class="fu">=</span> acc

<span class="kw">instance</span> (<span class="dt">Show</span> a, <span class="dt">Arg</span> r) <span class="ot">=&gt;</span> <span class="dt">Arg</span> (a <span class="ot">-&gt;</span> r) <span class="kw">where</span>
  collect&#39; acc <span class="fu">=</span> \x <span class="ot">-&gt;</span> collect&#39; (acc <span class="fu">++</span> [show x])

<span class="ot">collect ::</span> <span class="dt">Arg</span> t <span class="ot">=&gt;</span> t
collect <span class="fu">=</span> collect&#39; []

<span class="ot">example1 ::</span> [<span class="dt">String</span>]
example1 <span class="fu">=</span> collect <span class="ch">&#39;a&#39;</span> <span class="dv">2</span> <span class="fl">3.0</span>

<span class="ot">example2 ::</span> <span class="dt">IO</span> ()
example2 <span class="fu">=</span> collect () <span class="st">&quot;foo&quot;</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</code></pre></div>
<p>See: <a href="http://okmij.org/ftp/Haskell/polyvariadic.html">Polyvariadic functions</a></p>
</hr>
<h1 id="error-handling">Error Handling</h1>
<h2 id="control.exception">Control.Exception</h2>
<p>The low-level (and most dangerous) way to handle errors is to use the <code>throw</code> and <code>catch</code> functions which allow us to throw extensible exceptions in pure code but catch the resulting exception within IO. Of specific note is that return value of the <code>throw</code> inhabits all types. There's no reason to use this for custom code that doesn't use low-level system operations.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">throw ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> a
catch<span class="ot"> ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a
<span class="ot">try ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> e a)
<span class="ot">evaluate ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</code></pre></div>
<div class="sourceCode" include="src/09-errors/ioexception.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveDataTypeable #-}</span>

<span class="kw">import </span><span class="dt">Data.Typeable</span>
<span class="kw">import </span><span class="dt">Control.Exception</span>

<span class="kw">data</span> <span class="dt">MyException</span> <span class="fu">=</span> <span class="dt">MyException</span>
    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Typeable</span>)

<span class="kw">instance</span> <span class="dt">Exception</span> <span class="dt">MyException</span>

<span class="ot">evil ::</span> [<span class="dt">Int</span>]
evil <span class="fu">=</span> [throw <span class="dt">MyException</span>]

<span class="ot">example1 ::</span> <span class="dt">Int</span>
example1 <span class="fu">=</span> head evil

<span class="ot">example2 ::</span> <span class="dt">Int</span>
example2 <span class="fu">=</span> length evil

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> try (evaluate example1)<span class="ot"> ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">MyException</span> <span class="dt">Int</span>)
  print a

  b <span class="ot">&lt;-</span> try (return example2)<span class="ot"> ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">MyException</span> <span class="dt">Int</span>)
  print b</code></pre></div>
<p>Because a value will not be evaluated unless needed, if one desires to know for sure that an exception is either caught or not it can be deeply forced into head normal form before invoking catch. The <code>strictCatch</code> is not provided by standard library but has a simple implementation in terms of <code>deepseq</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">strictCatch ::</span> (<span class="dt">NFData</span> a, <span class="dt">Exception</span> e) <span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a
strictCatch <span class="fu">=</span> catch <span class="fu">.</span> (toNF <span class="fu">=&lt;&lt;</span>)</code></pre></div>
<h2 id="exceptions">Exceptions</h2>
<p>The problem with the previous approach is having to rely on GHC's asynchronous exception handling inside of IO to handle basic operations. The <code>exceptions</code> provides the same API as <code>Control.Exception</code> but loosens the dependency on IO.</p>
<div class="sourceCode" include="src/09-errors/exceptions.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveDataTypeable #-}</span>

<span class="kw">import </span><span class="dt">Data.Typeable</span>
<span class="kw">import </span><span class="dt">Control.Monad.Catch</span>
<span class="kw">import </span><span class="dt">Control.Monad.Identity</span>

<span class="kw">data</span> <span class="dt">MyException</span> <span class="fu">=</span> <span class="dt">MyException</span>
    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Typeable</span>)

<span class="kw">instance</span> <span class="dt">Exception</span> <span class="dt">MyException</span>

<span class="ot">example ::</span> <span class="dt">MonadCatch</span> m <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m <span class="dt">Int</span>
example x y <span class="fu">|</span> y <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> throwM <span class="dt">MyException</span>
            <span class="fu">|</span> otherwise <span class="fu">=</span> return <span class="fu">$</span> x <span class="ot">`div`</span> y

<span class="ot">pure ::</span> <span class="dt">MonadCatch</span> m <span class="ot">=&gt;</span> m (<span class="dt">Either</span> <span class="dt">MyException</span> <span class="dt">Int</span>)
pure <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> try (example <span class="dv">1</span> <span class="dv">2</span>)
  b <span class="ot">&lt;-</span> try (example <span class="dv">1</span> <span class="dv">0</span>)
  return (a <span class="fu">&gt;&gt;</span> b)</code></pre></div>
<p>See: <a href="http://hackage.haskell.org/package/exceptions">exceptions</a></p>
<h2 id="exceptt">ExceptT</h2>
<p>As of mtl 2.2 or higher, the <code>ErrorT</code> class has been replaced by the <code>ExceptT</code>. At transformers level.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ExceptT</span> e m a <span class="fu">=</span> <span class="dt">ExceptT</span> (m (<span class="dt">Either</span> e a))

<span class="ot">runExceptT ::</span> <span class="dt">ExceptT</span> e m a <span class="ot">-&gt;</span> m (<span class="dt">Either</span> e a)
runExceptT (<span class="dt">ExceptT</span> m) <span class="fu">=</span> m

<span class="kw">instance</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">ExceptT</span> e m) <span class="kw">where</span>
    return a <span class="fu">=</span> <span class="dt">ExceptT</span> <span class="fu">$</span> return (<span class="dt">Right</span> a)
    m <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> <span class="dt">ExceptT</span> <span class="fu">$</span> <span class="kw">do</span>
        a <span class="ot">&lt;-</span> runExceptT m
        <span class="kw">case</span> a <span class="kw">of</span>
            <span class="dt">Left</span> e <span class="ot">-&gt;</span> return (<span class="dt">Left</span> e)
            <span class="dt">Right</span> x <span class="ot">-&gt;</span> runExceptT (k x)
    fail <span class="fu">=</span> <span class="dt">ExceptT</span> <span class="fu">.</span> fail

<span class="ot">throwE ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">ExceptT</span> e m a
throwE <span class="fu">=</span> <span class="dt">ExceptT</span> <span class="fu">.</span> return <span class="fu">.</span> <span class="dt">Left</span>

<span class="ot">catchE ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span>
    <span class="dt">ExceptT</span> e m a               <span class="co">-- ^ the inner computation</span>
    <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">ExceptT</span> e&#39; m a)    <span class="co">-- ^ a handler for exceptions in the inner</span>
                                <span class="co">-- computation</span>
    <span class="ot">-&gt;</span> <span class="dt">ExceptT</span> e&#39; m a
m <span class="ot">`catchE`</span> h <span class="fu">=</span> <span class="dt">ExceptT</span> <span class="fu">$</span> <span class="kw">do</span>
    a <span class="ot">&lt;-</span> runExceptT m
    <span class="kw">case</span> a <span class="kw">of</span>
        <span class="dt">Left</span>  l <span class="ot">-&gt;</span> runExceptT (h l)
        <span class="dt">Right</span> r <span class="ot">-&gt;</span> return (<span class="dt">Right</span> r)</code></pre></div>
<p>Using mtl:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">MonadTrans</span> (<span class="dt">ExceptT</span> e) <span class="kw">where</span>
    lift <span class="fu">=</span> <span class="dt">ExceptT</span> <span class="fu">.</span> liftM <span class="dt">Right</span>

<span class="kw">class</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadError</span> e m <span class="fu">|</span> m <span class="ot">-&gt;</span> e <span class="kw">where</span>
<span class="ot">    throwError ::</span> e <span class="ot">-&gt;</span> m a
<span class="ot">    catchError ::</span> m a <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a

<span class="kw">instance</span> <span class="dt">MonadError</span> <span class="dt">IOException</span> <span class="dt">IO</span> <span class="kw">where</span>
    throwError <span class="fu">=</span> ioError
    catchError <span class="fu">=</span> catch

<span class="kw">instance</span> <span class="dt">MonadError</span> e (<span class="dt">Either</span> e) <span class="kw">where</span>
    throwError             <span class="fu">=</span> <span class="dt">Left</span>
    <span class="dt">Left</span>  l <span class="ot">`catchError`</span> h <span class="fu">=</span> h l
    <span class="dt">Right</span> r <span class="ot">`catchError`</span> _ <span class="fu">=</span> <span class="dt">Right</span> r</code></pre></div>
<p>See:</p>
<ul>
<li><a href="https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html">Control.Monad.Except</a></li>
</ul>
<h2 id="spoon">spoon</h2>
<p>Sometimes you'll be forced to deal with seemingly pure functions that can throw up at any point. There are many functions in the standard library like this, and many more on Hackage. You'd like to be handle this logic purely as if it were returning a proper <code>Maybe a</code> but to catch the logic you'd need to install a IO handler inside IO to catch it. Spoon allows us to safely (and &quot;purely&quot;, although it uses a referentially transparent invocation of unsafePerformIO) to catch these exceptions and put them in Maybe where they belong.</p>
<p>The <code>spoon</code> function evaluates its argument to head normal form, while <code>teaspoon</code> evaluates to <a href="#seq-and-whnf">weak head normal form</a>.</p>
<div class="sourceCode" include="src/09-errors/spoon.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Spoon</span>

<span class="ot">goBoom ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
goBoom x y <span class="fu">=</span> x <span class="ot">`div`</span> y

<span class="co">-- evaluate to normal form</span>
<span class="ot">test1 ::</span> <span class="dt">Maybe</span> [<span class="dt">Int</span>]
test1 <span class="fu">=</span> spoon [<span class="dv">1</span>, <span class="dv">2</span>, undefined]

<span class="co">-- evaluate to weak head normal form</span>
<span class="ot">test2 ::</span> <span class="dt">Maybe</span> [<span class="dt">Int</span>]
test2 <span class="fu">=</span> teaspoon [<span class="dv">1</span>, <span class="dv">2</span>, undefined]

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  maybe (putStrLn <span class="st">&quot;Nothing&quot;</span>) (print <span class="fu">.</span> length) test1
  maybe (putStrLn <span class="st">&quot;Nothing&quot;</span>) (print <span class="fu">.</span> length) test2</code></pre></div>
<p>See:</p>
<ul>
<li><a href="https://hackage.haskell.org/package/spoon">Spoon</a></li>
</ul>
</hr>
<h2 id="safe-exceptions">safe-exceptions</h2>
<p>TODO</p>
<h1 id="advanced-monads">Advanced Monads</h1>
<h2 id="function-monad">Function Monad</h2>
<p>If one writes Haskell long enough one might eventually encounter the curious beast that is the <code>((-&gt;) r)</code> monad instance. It generally tends to be non-intuitive to work with, but is quite simple when one considers it as an unwrapped Reader monad.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> ((<span class="ot">-&gt;</span>) r) <span class="kw">where</span>
  fmap <span class="fu">=</span> (<span class="fu">.</span>)

<span class="kw">instance</span> <span class="dt">Monad</span> ((<span class="ot">-&gt;</span>) r) <span class="kw">where</span>
  return <span class="fu">=</span> const
  f <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> \r <span class="ot">-&gt;</span> k (f r) r</code></pre></div>
<p>This just uses a prefix form of the arrow type operator.</p>
<div class="sourceCode" include="src/10-advanced-monads/function.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad</span>

<span class="ot">id&#39; ::</span> (<span class="ot">-&gt;</span>) a a
id&#39; <span class="fu">=</span> id

<span class="ot">const&#39; ::</span> (<span class="ot">-&gt;</span>) a ((<span class="ot">-&gt;</span>) b a)
const&#39; <span class="fu">=</span> const

<span class="co">-- Monad m =&gt; a -&gt; m a</span>
<span class="ot">fret ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a
fret <span class="fu">=</span> return

<span class="co">-- Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</span>
<span class="ot">fbind ::</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> b)) <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> b)
fbind f k <span class="fu">=</span> f <span class="fu">&gt;&gt;=</span> k

<span class="co">-- Monad m =&gt; m (m a) -&gt; m a</span>
<span class="ot">fjoin ::</span> (r <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> a)) <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> a)
fjoin <span class="fu">=</span> join

<span class="ot">fid ::</span> a <span class="ot">-&gt;</span> a
fid <span class="fu">=</span> const <span class="fu">&gt;&gt;=</span> id

<span class="co">-- Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span>
<span class="ot">fcompose ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> b)
fcompose <span class="fu">=</span> (<span class="fu">.</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Reader</span> r <span class="fu">=</span> (<span class="ot">-&gt;</span>) r <span class="co">-- pseudocode</span>

<span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Reader</span> r) <span class="kw">where</span>
  return a <span class="fu">=</span> \_ <span class="ot">-&gt;</span> a
  f <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> \r <span class="ot">-&gt;</span> k (f r) r

<span class="ot">ask&#39; ::</span> r <span class="ot">-&gt;</span> r
ask&#39; <span class="fu">=</span> id

<span class="ot">asks&#39; ::</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> a)
asks&#39; f <span class="fu">=</span> id <span class="fu">.</span> f

<span class="ot">runReader&#39; ::</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> a
runReader&#39; <span class="fu">=</span> id</code></pre></div>
<h2 id="rws-monad">RWS Monad</h2>
<p>The RWS monad combines the functionality of the three monads discussed above, the <strong>R</strong>eader, <strong>W</strong>riter, and <strong>S</strong>tate. There is also a <code>RWST</code> transformer.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runReader ::</span> <span class="dt">Reader</span> r a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> a
<span class="ot">runWriter ::</span> <span class="dt">Writer</span> w a <span class="ot">-&gt;</span> (a, w)
<span class="ot">runState  ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, s)</code></pre></div>
<p>These three eval functions are now combined into the following functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runRWS  ::</span> <span class="dt">RWS</span> r w s a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, s, w)
<span class="ot">execRWS ::</span> <span class="dt">RWS</span> r w s a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (s, w)
<span class="ot">evalRWS ::</span> <span class="dt">RWS</span> r w s a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, w)</code></pre></div>
<div class="sourceCode" include="src/10-advanced-monads/rws.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.RWS</span>

<span class="kw">type</span> <span class="dt">R</span> <span class="fu">=</span> <span class="dt">Int</span>
<span class="kw">type</span> <span class="dt">W</span> <span class="fu">=</span> [<span class="dt">Int</span>]
<span class="kw">type</span> <span class="dt">S</span> <span class="fu">=</span> <span class="dt">Int</span>

<span class="ot">computation ::</span> <span class="dt">RWS</span> <span class="dt">R</span> <span class="dt">W</span> <span class="dt">S</span> ()
computation <span class="fu">=</span> <span class="kw">do</span>
  e <span class="ot">&lt;-</span> ask
  a <span class="ot">&lt;-</span> get
  <span class="kw">let</span> b <span class="fu">=</span> a <span class="fu">+</span> e
  put b
  tell [b]

example <span class="fu">=</span> runRWS computation <span class="dv">2</span> <span class="dv">3</span></code></pre></div>
<p>The usual caveat about Writer laziness also applies to RWS.</p>
<h2 id="cont">Cont</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runCont ::</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r
<span class="ot">callCC ::</span> <span class="dt">MonadCont</span> m <span class="ot">=&gt;</span> ((a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a
<span class="ot">cont ::</span> ((a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a</code></pre></div>
<p>In continuation passing style, composite computations are built up from sequences of nested computations which are terminated by a final continuation which yields the result of the full computation by passing a function into the continuation chain.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
add x y <span class="fu">=</span> x <span class="fu">+</span> y

<span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r
add x y k <span class="fu">=</span> k (x <span class="fu">+</span> y)</code></pre></div>
<div class="sourceCode" include="src/10-advanced-monads/cont.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Control.Monad.Cont</span>

<span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Cont</span> k <span class="dt">Int</span>
add x y <span class="fu">=</span> return <span class="fu">$</span> x <span class="fu">+</span> y

<span class="ot">mult ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Cont</span> k <span class="dt">Int</span>
mult x y <span class="fu">=</span> return <span class="fu">$</span> x <span class="fu">*</span> y

<span class="ot">contt ::</span> <span class="dt">ContT</span> () <span class="dt">IO</span> ()
contt <span class="fu">=</span> <span class="kw">do</span>
    k <span class="ot">&lt;-</span> <span class="kw">do</span>
      callCC <span class="fu">$</span> \exit <span class="ot">-&gt;</span> <span class="kw">do</span>
        lift <span class="fu">$</span> putStrLn <span class="st">&quot;Entry&quot;</span>
        exit <span class="fu">$</span> \_ <span class="ot">-&gt;</span> <span class="kw">do</span>
          putStrLn <span class="st">&quot;Exit&quot;</span>
    lift <span class="fu">$</span> putStrLn <span class="st">&quot;Inside&quot;</span>
    lift <span class="fu">$</span> k ()

<span class="ot">callcc ::</span> <span class="dt">Cont</span> <span class="dt">String</span> <span class="dt">Integer</span>
callcc <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> return <span class="dv">1</span>
  b <span class="ot">&lt;-</span> callCC (\k <span class="ot">-&gt;</span> k <span class="dv">2</span>)
  return <span class="fu">$</span> a<span class="fu">+</span>b

<span class="ot">ex1 ::</span> <span class="dt">IO</span> ()
ex1 <span class="fu">=</span> print <span class="fu">$</span> runCont (f <span class="fu">&gt;&gt;=</span> g) id
  <span class="kw">where</span>
    f <span class="fu">=</span> add <span class="dv">1</span> <span class="dv">2</span>
    g <span class="fu">=</span> mult <span class="dv">3</span>
<span class="co">-- 9</span>

<span class="ot">ex2 ::</span> <span class="dt">IO</span> ()
ex2 <span class="fu">=</span> print <span class="fu">$</span> runCont callcc show
<span class="co">-- &quot;3&quot;</span>

<span class="ot">ex3 ::</span> <span class="dt">IO</span> ()
ex3 <span class="fu">=</span> runContT contt print
<span class="co">-- Entry</span>
<span class="co">-- Inside</span>
<span class="co">-- Exit</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  ex1
  ex2
  ex3</code></pre></div>
<div class="sourceCode" include="src/10-advanced-monads/cont_impl.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Cont</span> r a <span class="fu">=</span> <span class="dt">Cont</span> {<span class="ot"> runCont ::</span> ((a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r) }

<span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Cont</span> r) <span class="kw">where</span>
  return a       <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> k a
  (<span class="dt">Cont</span> c) <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> c (\a <span class="ot">-&gt;</span> runCont (f a) k)

<span class="kw">class</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadCont</span> m <span class="kw">where</span>
<span class="ot">  callCC ::</span> ((a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a

<span class="kw">instance</span> <span class="dt">MonadCont</span> (<span class="dt">Cont</span> r) <span class="kw">where</span>
  callCC f <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> runCont (f (\a <span class="ot">-&gt;</span> <span class="dt">Cont</span> <span class="fu">$</span> \_ <span class="ot">-&gt;</span> k a)) k</code></pre></div>
<ul>
<li><a href="http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style">Wikibooks: Continuation Passing Style</a></li>
<li><a href="https://wiki.haskell.org/MonadCont_under_the_hood">MonadCont Under the Hood</a></li>
</ul>
<h2 id="monadplus">MonadPlus</h2>
<p>Choice and failure.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadPlus</span> m <span class="kw">where</span>
<span class="ot">   mzero ::</span> m a
<span class="ot">   mplus ::</span> m a <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m a

<span class="kw">instance</span> <span class="dt">MonadPlus</span> [] <span class="kw">where</span>
   mzero <span class="fu">=</span> []
   mplus <span class="fu">=</span> (<span class="fu">++</span>)

<span class="kw">instance</span> <span class="dt">MonadPlus</span> <span class="dt">Maybe</span> <span class="kw">where</span>
   mzero <span class="fu">=</span> <span class="dt">Nothing</span>

   <span class="dt">Nothing</span> <span class="ot">`mplus`</span> ys  <span class="fu">=</span> ys
   xs      <span class="ot">`mplus`</span> _ys <span class="fu">=</span> xs</code></pre></div>
<p>MonadPlus forms a monoid with</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">mzero <span class="ot">`mplus`</span> a <span class="fu">=</span> a
a <span class="ot">`mplus`</span> mzero <span class="fu">=</span> a
(a <span class="ot">`mplus`</span> b) <span class="ot">`mplus`</span> c <span class="fu">=</span> a <span class="ot">`mplus`</span> (b <span class="ot">`mplus`</span> c)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">when ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()
when p s <span class="fu">=</span>  <span class="kw">if</span> p <span class="kw">then</span> s <span class="kw">else</span> return ()

<span class="ot">guard ::</span> <span class="dt">MonadPlus</span> m <span class="ot">=&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> m ()
guard <span class="dt">True</span>  <span class="fu">=</span> return ()
guard <span class="dt">False</span> <span class="fu">=</span> mzero

<span class="ot">msum ::</span> <span class="dt">MonadPlus</span> m <span class="ot">=&gt;</span> [m a] <span class="ot">-&gt;</span> m a
msum <span class="fu">=</span>  foldr mplus mzero</code></pre></div>
<div class="sourceCode" include="src/10-advanced-monads/monadplus.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Safe</span>
<span class="kw">import </span><span class="dt">Control.Monad</span>

<span class="ot">list1 ::</span> [(<span class="dt">Int</span>,<span class="dt">Int</span>)]
list1 <span class="fu">=</span> [(a,b) <span class="fu">|</span> a <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">25</span>], b <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">25</span>], a <span class="fu">&lt;</span> b]

<span class="ot">list2 ::</span> [(<span class="dt">Int</span>,<span class="dt">Int</span>)]
list2 <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">25</span>]
  b <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">25</span>]
  guard (a <span class="fu">&lt;</span> b)
  return <span class="fu">$</span> (a,b)

<span class="ot">maybe1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Double</span>
maybe1 a b <span class="fu">=</span> <span class="kw">do</span>
  a&#39; <span class="ot">&lt;-</span> readMay a
  b&#39; <span class="ot">&lt;-</span> readMay b
  guard (b&#39; <span class="fu">/=</span> <span class="fl">0.0</span>)
  return <span class="fu">$</span> a&#39;<span class="fu">/</span>b&#39;

<span class="ot">maybe2 ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
maybe2 <span class="fu">=</span> msum [<span class="dt">Nothing</span>, <span class="dt">Nothing</span>, <span class="dt">Just</span> <span class="dv">3</span>, <span class="dt">Just</span> <span class="dv">4</span>]</code></pre></div>
<div class="sourceCode" include="src/10-advanced-monads/logict.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad</span>

range<span class="ot"> ::</span> <span class="dt">MonadPlus</span> m <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> m a
range [] <span class="fu">=</span> mzero
range (x<span class="fu">:</span>xs) <span class="fu">=</span> range xs <span class="ot">`mplus`</span> return x

<span class="ot">pyth ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> [(<span class="dt">Integer</span>,<span class="dt">Integer</span>,<span class="dt">Integer</span>)]
pyth n <span class="fu">=</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> range [<span class="dv">1</span><span class="fu">..</span>n]
  y <span class="ot">&lt;-</span> range [<span class="dv">1</span><span class="fu">..</span>n]
  z <span class="ot">&lt;-</span> range [<span class="dv">1</span><span class="fu">..</span>n]
  <span class="kw">if</span> x<span class="fu">*</span>x <span class="fu">+</span> y<span class="fu">*</span>y <span class="fu">==</span> z<span class="fu">*</span>z <span class="kw">then</span> return (x,y,z) <span class="kw">else</span> mzero

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> print <span class="fu">$</span> pyth <span class="dv">15</span>
<span class="co">{-</span>
<span class="co">[ ( 12 , 9 , 15 )</span>
<span class="co">, ( 12 , 5 , 13 )</span>
<span class="co">, ( 9 , 12 , 15 )</span>
<span class="co">, ( 8 , 6 , 10 )</span>
<span class="co">, ( 6 , 8 , 10 )</span>
<span class="co">, ( 5 , 12 , 13 )</span>
<span class="co">, ( 4 , 3 , 5 )</span>
<span class="co">, ( 3 , 4 , 5 )</span>
<span class="co">]</span>
<span class="co">-}</span></code></pre></div>
<h2 id="monadfix">MonadFix</h2>
<p>The fixed point of a monadic computation. <code>mfix f</code> executes the action <code>f</code> only once, with the eventual output fed back as the input.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fix ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a
fix f <span class="fu">=</span> <span class="kw">let</span> x <span class="fu">=</span> f x <span class="kw">in</span> x

<span class="ot">mfix ::</span> (a <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadFix</span> m <span class="kw">where</span>
<span class="ot">   mfix ::</span> (a <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a

<span class="kw">instance</span> <span class="dt">MonadFix</span> <span class="dt">Maybe</span> <span class="kw">where</span>
   mfix f <span class="fu">=</span> <span class="kw">let</span> a <span class="fu">=</span> f (unJust a) <span class="kw">in</span> a
            <span class="kw">where</span> unJust (<span class="dt">Just</span> x) <span class="fu">=</span> x
                  unJust <span class="dt">Nothing</span>  <span class="fu">=</span> error <span class="st">&quot;mfix Maybe: Nothing&quot;</span></code></pre></div>
<p>The regular do-notation can also be extended with <code>-XRecursiveDo</code> to accommodate recursive monadic bindings.</p>
<div class="sourceCode" include="src/10-advanced-monads/monadfix.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RecursiveDo #-}</span>

<span class="kw">import </span><span class="dt">Control.Applicative</span>
<span class="kw">import </span><span class="dt">Control.Monad.Fix</span>

<span class="ot">stream1 ::</span> <span class="dt">Maybe</span> [<span class="dt">Int</span>]
stream1 <span class="fu">=</span> <span class="kw">do</span>
  rec xs <span class="ot">&lt;-</span> <span class="dt">Just</span> (<span class="dv">1</span><span class="fu">:</span>xs)
  return (map negate xs)

<span class="ot">stream2 ::</span> <span class="dt">Maybe</span> [<span class="dt">Int</span>]
stream2 <span class="fu">=</span> mfix <span class="fu">$</span> \xs <span class="ot">-&gt;</span> <span class="kw">do</span>
  xs&#39; <span class="ot">&lt;-</span> <span class="dt">Just</span> (<span class="dv">1</span><span class="fu">:</span>xs)
  return (map negate xs&#39;)</code></pre></div>
<h2 id="st-monad">ST Monad</h2>
<p>The ST monad models &quot;threads&quot; of stateful computations which can manipulate mutable references but are restricted to only return pure values when evaluated and are statically confined to the ST monad of a <code>s</code> thread.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runST ::</span> (forall s<span class="fu">.</span> <span class="dt">ST</span> s a) <span class="ot">-&gt;</span> a
<span class="ot">newSTRef ::</span> a <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">STRef</span> s a)
<span class="ot">readSTRef ::</span> <span class="dt">STRef</span> s a <span class="ot">-&gt;</span> <span class="dt">ST</span> s a
<span class="ot">writeSTRef ::</span> <span class="dt">STRef</span> s a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</code></pre></div>
<div class="sourceCode" include="src/10-advanced-monads/st.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.STRef</span>
<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Control.Monad.ST</span>
<span class="kw">import </span><span class="dt">Control.Monad.State.Strict</span>

<span class="ot">example1 ::</span> <span class="dt">Int</span>
example1 <span class="fu">=</span> runST <span class="fu">$</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span>

  forM_ [<span class="dv">1</span><span class="fu">..</span><span class="dv">1000</span>] <span class="fu">$</span> \j <span class="ot">-&gt;</span> <span class="kw">do</span>
    writeSTRef x j

  readSTRef x

<span class="ot">example2 ::</span> <span class="dt">Int</span>
example2 <span class="fu">=</span> runST <span class="fu">$</span> <span class="kw">do</span>
  count <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span>
  replicateM_ (<span class="dv">10</span><span class="fu">^</span><span class="dv">6</span>) <span class="fu">$</span> modifySTRef&#39; count (<span class="fu">+</span><span class="dv">1</span>)
  readSTRef count

<span class="ot">example3 ::</span> <span class="dt">Int</span>
example3 <span class="fu">=</span> flip evalState <span class="dv">0</span> <span class="fu">$</span> <span class="kw">do</span>
  replicateM_ (<span class="dv">10</span><span class="fu">^</span><span class="dv">6</span>) <span class="fu">$</span> modify&#39; (<span class="fu">+</span><span class="dv">1</span>)
  get

<span class="ot">modify&#39; ::</span> <span class="dt">MonadState</span> a m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> m ()
modify&#39; f <span class="fu">=</span> get <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> put <span class="fu">$!</span> f x)</code></pre></div>
<p>Using the ST monad we can create a class of efficient purely functional data structures that use mutable references in a referentially transparent way.</p>
<h2 id="free-monads">Free Monads</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Pure</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Free</span> f a
<span class="dt">Free</span><span class="ot"> ::</span> f (<span class="dt">Free</span> f a) <span class="ot">-&gt;</span> <span class="dt">Free</span> f a

<span class="ot">liftF ::</span> (<span class="dt">Functor</span> f, <span class="dt">MonadFree</span> f m) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> m a
<span class="ot">retract ::</span> <span class="dt">Monad</span> f <span class="ot">=&gt;</span> <span class="dt">Free</span> f a <span class="ot">-&gt;</span> f a</code></pre></div>
<p>Free monads are monads which instead of having a <code>join</code> operation that combines computations, instead forms composite computations from application of a functor.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">join ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m (m a) <span class="ot">-&gt;</span> m a
<span class="ot">wrap ::</span> <span class="dt">MonadFree</span> f m <span class="ot">=&gt;</span> f (m a) <span class="ot">-&gt;</span> m a</code></pre></div>
<p>One of the best examples is the Partiality monad which models computations which can diverge. Haskell allows unbounded recursion, but for example we can create a free monad from the <code>Maybe</code> functor which can be used to fix the call-depth of, for example the <a href="../../en.wikipedia.org/wiki/Ackermann_function.html">Ackermann function</a>.</p>
<div class="sourceCode" include="src/10-advanced-monads/partiality.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Fix</span>
<span class="kw">import </span><span class="dt">Control.Monad.Free</span>

<span class="kw">type</span> <span class="dt">Partiality</span> a <span class="fu">=</span> <span class="dt">Free</span> <span class="dt">Maybe</span> a

<span class="co">-- Non-termination.</span>
<span class="ot">never ::</span> <span class="dt">Partiality</span> a
never <span class="fu">=</span> fix (<span class="dt">Free</span> <span class="fu">.</span> <span class="dt">Just</span>)

<span class="ot">fromMaybe ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Partiality</span> a
fromMaybe (<span class="dt">Just</span> x) <span class="fu">=</span> <span class="dt">Pure</span> x
fromMaybe <span class="dt">Nothing</span> <span class="fu">=</span> <span class="dt">Free</span> <span class="dt">Nothing</span>

<span class="ot">runPartiality ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Partiality</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
runPartiality <span class="dv">0</span> _ <span class="fu">=</span> <span class="dt">Nothing</span>
runPartiality _ (<span class="dt">Pure</span> a) <span class="fu">=</span> <span class="dt">Just</span> a
runPartiality _ (<span class="dt">Free</span> <span class="dt">Nothing</span>) <span class="fu">=</span> <span class="dt">Nothing</span>
runPartiality n (<span class="dt">Free</span> (<span class="dt">Just</span> a)) <span class="fu">=</span> runPartiality (n<span class="fu">-</span><span class="dv">1</span>) a

<span class="ot">ack ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Partiality</span> <span class="dt">Int</span>
ack <span class="dv">0</span> n <span class="fu">=</span> <span class="dt">Pure</span> <span class="fu">$</span> n <span class="fu">+</span> <span class="dv">1</span>
ack m <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Free</span> <span class="fu">$</span> <span class="dt">Just</span> <span class="fu">$</span> ack (m<span class="fu">-</span><span class="dv">1</span>) <span class="dv">1</span>
ack m n <span class="fu">=</span> <span class="dt">Free</span> <span class="fu">$</span> <span class="dt">Just</span> <span class="fu">$</span> ack m (n<span class="fu">-</span><span class="dv">1</span>) <span class="fu">&gt;&gt;=</span> ack (m<span class="fu">-</span><span class="dv">1</span>)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> diverge <span class="fu">=</span><span class="ot"> never ::</span> <span class="dt">Partiality</span> ()
  print <span class="fu">$</span> runPartiality <span class="dv">1000</span> diverge
  print <span class="fu">$</span> runPartiality <span class="dv">1000</span> (ack <span class="dv">3</span> <span class="dv">4</span>)
  print <span class="fu">$</span> runPartiality <span class="dv">5500</span> (ack <span class="dv">3</span> <span class="dv">4</span>)</code></pre></div>
<p>The other common use for free monads is to build embedded domain-specific languages to describe computations. We can model a subset of the IO monad by building up a pure description of the computation inside of the IOFree monad and then using the free monad to encode the translation to an effectful IO computation.</p>
<div class="sourceCode" include="src/10-advanced-monads/free_dsl.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span>

<span class="kw">import </span><span class="dt">System.Exit</span>
<span class="kw">import </span><span class="dt">Control.Monad.Free</span>

<span class="kw">data</span> <span class="dt">Interaction</span> x
  <span class="fu">=</span> <span class="dt">Puts</span> <span class="dt">String</span> x
  <span class="fu">|</span> <span class="dt">Gets</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> x)
  <span class="fu">|</span> <span class="dt">Exit</span>
  <span class="kw">deriving</span> <span class="dt">Functor</span>

<span class="kw">type</span> <span class="dt">IOFree</span> a <span class="fu">=</span> <span class="dt">Free</span> <span class="dt">Interaction</span> a

<span class="ot">puts ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IOFree</span> ()
puts s <span class="fu">=</span> liftF <span class="fu">$</span> <span class="dt">Puts</span> s ()

<span class="ot">get ::</span> <span class="dt">IOFree</span> <span class="dt">Char</span>
get <span class="fu">=</span> liftF <span class="fu">$</span> <span class="dt">Gets</span> id

<span class="ot">exit ::</span> <span class="dt">IOFree</span> r
exit <span class="fu">=</span> liftF <span class="dt">Exit</span>

<span class="ot">gets ::</span> <span class="dt">IOFree</span> <span class="dt">String</span>
gets <span class="fu">=</span> <span class="kw">do</span>
  c <span class="ot">&lt;-</span> get
  <span class="kw">if</span> c <span class="fu">==</span> <span class="ch">&#39;\n&#39;</span>
    <span class="kw">then</span> return <span class="st">&quot;&quot;</span>
    <span class="kw">else</span> gets <span class="fu">&gt;&gt;=</span> \line <span class="ot">-&gt;</span> return (c <span class="fu">:</span> line)

<span class="co">-- Collapse our IOFree DSL into IO monad actions.</span>
<span class="ot">interp ::</span> <span class="dt">IOFree</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
interp (<span class="dt">Pure</span> r) <span class="fu">=</span> return r
interp (<span class="dt">Free</span> x) <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span>
  <span class="dt">Puts</span> s t <span class="ot">-&gt;</span> putStrLn s <span class="fu">&gt;&gt;</span> interp t
  <span class="dt">Gets</span> f   <span class="ot">-&gt;</span> getChar <span class="fu">&gt;&gt;=</span> interp <span class="fu">.</span> f
  <span class="dt">Exit</span>     <span class="ot">-&gt;</span> exitSuccess

<span class="ot">echo ::</span> <span class="dt">IOFree</span> ()
echo <span class="fu">=</span> <span class="kw">do</span>
  puts <span class="st">&quot;Enter your name:&quot;</span>
  str <span class="ot">&lt;-</span> gets
  puts str
  <span class="kw">if</span> length str <span class="fu">&gt;</span> <span class="dv">10</span>
    <span class="kw">then</span> puts <span class="st">&quot;You have a long name.&quot;</span>
    <span class="kw">else</span> puts <span class="st">&quot;You have a short name.&quot;</span>
  exit

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> interp echo</code></pre></div>
<p>An implementation such as the one found in <a href="http://hackage.haskell.org/package/free">free</a> might look like the following:</p>
<div class="sourceCode" include="src/10-advanced-monads/free_impl.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span>

<span class="kw">import </span><span class="dt">Control.Applicative</span>

<span class="kw">data</span> <span class="dt">Free</span> f a
  <span class="fu">=</span> <span class="dt">Pure</span> a
  <span class="fu">|</span> <span class="dt">Free</span> (f (<span class="dt">Free</span> f a))

<span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Free</span> f) <span class="kw">where</span>
  return a     <span class="fu">=</span> <span class="dt">Pure</span> a
  <span class="dt">Pure</span> a <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f a
  <span class="dt">Free</span> f <span class="fu">&gt;&gt;=</span> g <span class="fu">=</span> <span class="dt">Free</span> (fmap (<span class="fu">&gt;&gt;=</span> g) f)

<span class="kw">class</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadFree</span> f m  <span class="kw">where</span>
<span class="ot">  wrap ::</span> f (m a) <span class="ot">-&gt;</span> m a

<span class="ot">liftF ::</span> (<span class="dt">Functor</span> f, <span class="dt">MonadFree</span> f m) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> m a
liftF <span class="fu">=</span> wrap <span class="fu">.</span> fmap return

<span class="ot">iter ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Free</span> f a <span class="ot">-&gt;</span> a
iter _ (<span class="dt">Pure</span> a) <span class="fu">=</span> a
iter phi (<span class="dt">Free</span> m) <span class="fu">=</span> phi (iter phi <span class="fu">&lt;$&gt;</span> m)

<span class="ot">retract ::</span> <span class="dt">Monad</span> f <span class="ot">=&gt;</span> <span class="dt">Free</span> f a <span class="ot">-&gt;</span> f a
retract (<span class="dt">Pure</span> a) <span class="fu">=</span> return a
retract (<span class="dt">Free</span> as) <span class="fu">=</span> as <span class="fu">&gt;&gt;=</span> retract</code></pre></div>
<p>See:</p>
<ul>
<li><a href="http://www.andres-loeh.de/Free.pdf">Monads for Free!</a></li>
<li><a href="http://r6.ca/blog/20110520T220201Z.html">I/O is not a Monad</a></li>
</ul>
<h2 id="indexed-monads">Indexed Monads</h2>
<p>Indexed monads are a generalisation of monads that adds an additional type parameter to the class that carries information about the computation or structure of the monadic implementation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">IxMonad</span> md <span class="kw">where</span>
<span class="ot">  return ::</span> a <span class="ot">-&gt;</span> md i i a
<span class="ot">  (&gt;&gt;=) ::</span> md i m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> md m o b) <span class="ot">-&gt;</span> md i o b</code></pre></div>
<p>The canonical use-case is a variant of the vanilla State which allows type-changing on the state for intermediate steps inside of the monad. This indeed turns out to be very useful for handling a class of problems involving resource management since the extra index parameter gives us space to statically enforce the sequence of monadic actions by allowing and restricting certain state transitions on the index parameter at compile-time.</p>
<p>To make this more usable we'll use the somewhat esoteric <code>-XRebindableSyntax</code> allowing us to overload the do-notation and if-then-else syntax by providing alternative definitions local to the module.</p>
<div class="sourceCode" include="src/10-advanced-monads/indexed.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RebindableSyntax #-}</span>
<span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span>
<span class="ot">{-# LANGUAGE NoMonomorphismRestriction #-}</span>

<span class="kw">import </span><span class="dt">Data.IORef</span>
<span class="kw">import </span><span class="dt">Data.Char</span>
<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (fmap, (&gt;&gt;=), (&gt;&gt;), return)
<span class="kw">import </span><span class="dt">Control.Applicative</span>

<span class="kw">newtype</span> <span class="dt">IState</span> i o a <span class="fu">=</span> <span class="dt">IState</span> {<span class="ot"> runIState ::</span> i <span class="ot">-&gt;</span> (a, o) }

<span class="ot">evalIState ::</span> <span class="dt">IState</span> i o a <span class="ot">-&gt;</span> i <span class="ot">-&gt;</span> a
evalIState st i <span class="fu">=</span> fst <span class="fu">$</span> runIState st i

<span class="ot">execIState ::</span> <span class="dt">IState</span> i o a <span class="ot">-&gt;</span> i <span class="ot">-&gt;</span> o
execIState st i <span class="fu">=</span> snd <span class="fu">$</span> runIState st i

<span class="ot">ifThenElse ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
ifThenElse b i j <span class="fu">=</span> <span class="kw">case</span> b <span class="kw">of</span>
  <span class="dt">True</span> <span class="ot">-&gt;</span> i
  <span class="dt">False</span> <span class="ot">-&gt;</span> j

return<span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">IState</span> s s a
return a <span class="fu">=</span> <span class="dt">IState</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> (a, s)

fmap<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">IState</span> i o a <span class="ot">-&gt;</span> <span class="dt">IState</span> i o b
fmap f v <span class="fu">=</span> <span class="dt">IState</span> <span class="fu">$</span> \i <span class="ot">-&gt;</span> <span class="kw">let</span> (a, o) <span class="fu">=</span> runIState v i
                          <span class="kw">in</span> (f a, o)

<span class="ot">join ::</span> <span class="dt">IState</span> i m (<span class="dt">IState</span> m o a) <span class="ot">-&gt;</span> <span class="dt">IState</span> i o a
join v <span class="fu">=</span> <span class="dt">IState</span> <span class="fu">$</span> \i <span class="ot">-&gt;</span> <span class="kw">let</span> (w, m) <span class="fu">=</span> runIState v i
                        <span class="kw">in</span> runIState w m

<span class="ot">(&gt;&gt;=) ::</span> <span class="dt">IState</span> i m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IState</span> m o b) <span class="ot">-&gt;</span> <span class="dt">IState</span> i o b
v <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">IState</span> <span class="fu">$</span> \i <span class="ot">-&gt;</span> <span class="kw">let</span> (a, m) <span class="fu">=</span> runIState v i
                         <span class="kw">in</span> runIState (f a) m

<span class="ot">(&gt;&gt;) ::</span> <span class="dt">IState</span> i m a <span class="ot">-&gt;</span> <span class="dt">IState</span> m o b <span class="ot">-&gt;</span> <span class="dt">IState</span> i o b
v <span class="fu">&gt;&gt;</span> w <span class="fu">=</span> v <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> w

<span class="ot">get ::</span> <span class="dt">IState</span> s s s
get <span class="fu">=</span> <span class="dt">IState</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> (s, s)

<span class="ot">gets ::</span> (a <span class="ot">-&gt;</span> o) <span class="ot">-&gt;</span> <span class="dt">IState</span> a o a
gets f <span class="fu">=</span> <span class="dt">IState</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> (s, f s)

<span class="ot">put ::</span> o <span class="ot">-&gt;</span> <span class="dt">IState</span> i o ()
put o <span class="fu">=</span> <span class="dt">IState</span> <span class="fu">$</span> \_ <span class="ot">-&gt;</span> ((), o)

<span class="ot">modify ::</span> (i <span class="ot">-&gt;</span> o) <span class="ot">-&gt;</span> <span class="dt">IState</span> i o ()
modify f <span class="fu">=</span> <span class="dt">IState</span> <span class="fu">$</span> \i <span class="ot">-&gt;</span> ((), f i)



<span class="kw">data</span> <span class="dt">Locked</span> <span class="fu">=</span> <span class="dt">Locked</span>
<span class="kw">data</span> <span class="dt">Unlocked</span> <span class="fu">=</span> <span class="dt">Unlocked</span>

<span class="kw">type</span> <span class="dt">Stateful</span> a <span class="fu">=</span> <span class="dt">IState</span> a <span class="dt">Unlocked</span> a

<span class="ot">acquire ::</span> <span class="dt">IState</span> i <span class="dt">Locked</span> ()
acquire <span class="fu">=</span> put <span class="dt">Locked</span>

<span class="co">-- Can only release the lock if it&#39;s held, try release the lock</span>
<span class="co">-- that&#39;s not held is a now a type error.</span>
<span class="ot">release ::</span> <span class="dt">IState</span> <span class="dt">Locked</span> <span class="dt">Unlocked</span> ()
release <span class="fu">=</span> put <span class="dt">Unlocked</span>

<span class="co">-- Statically forbids improper handling of resources.</span>
<span class="ot">lockExample ::</span> <span class="dt">Stateful</span> a
lockExample <span class="fu">=</span> <span class="kw">do</span>
  ptr <span class="ot">&lt;- get  ::</span> <span class="dt">IState</span> a a a
<span class="ot">  acquire     ::</span> <span class="dt">IState</span> a <span class="dt">Locked</span> ()
  <span class="co">-- ...</span>
<span class="ot">  release     ::</span> <span class="dt">IState</span> <span class="dt">Locked</span> <span class="dt">Unlocked</span> ()
  return ptr

<span class="co">-- Couldn&#39;t match type `Locked&#39; with `Unlocked&#39;</span>
<span class="co">-- In a stmt of a &#39;do&#39; block: return ptr</span>
<span class="ot">failure1 ::</span> <span class="dt">Stateful</span> a
failure1 <span class="fu">=</span> <span class="kw">do</span>
  ptr <span class="ot">&lt;-</span> get
  acquire
  return ptr <span class="co">-- didn&#39;t release</span>

<span class="co">-- Couldn&#39;t match type `a&#39; with `Locked&#39;</span>
<span class="co">-- In a stmt of a &#39;do&#39; block: release</span>
<span class="ot">failure2 ::</span> <span class="dt">Stateful</span> a
failure2 <span class="fu">=</span> <span class="kw">do</span>
  ptr <span class="ot">&lt;-</span> get
  release <span class="co">-- didn&#39;t acquire</span>
  return ptr

<span class="co">-- Evaluate the resulting state, statically ensuring that the</span>
<span class="co">-- lock is released when finished.</span>
<span class="ot">evalReleased ::</span> <span class="dt">IState</span> i <span class="dt">Unlocked</span> a <span class="ot">-&gt;</span> i <span class="ot">-&gt;</span> a
evalReleased f st <span class="fu">=</span> evalIState f st

<span class="ot">example ::</span> <span class="dt">IO</span> (<span class="dt">IORef</span> <span class="dt">Integer</span>)
example <span class="fu">=</span> evalReleased <span class="fu">&lt;$&gt;</span> pure lockExample <span class="fu">&lt;*&gt;</span> newIORef <span class="dv">0</span></code></pre></div>
<p>See: <a href="http://www.cl.cam.ac.uk/~dao29/ixmonad/ixmonad-fita14.pdf">Fun with Indexed monads</a></p>
<h2 id="lifted-base">lifted-base</h2>
<p>The default prelude predates a lot of the work on monad transformers and as such many of the common functions for handling errors and interacting with IO are bound strictly to the IO monad and not to functions implementing stacks on top of IO or ST. The lifted-base provides generic control operations such as <code>catch</code> can be lifted from IO or any other base monad.</p>
<h4 id="monad-base">monad-base</h4>
<p>Monad base provides an abstraction over <code>liftIO</code> and other functions to explicitly lift into a &quot;privileged&quot; layer of the transformer stack. It's implemented a multiparamater typeclass with the &quot;base&quot; monad as the parameter b.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Lift a computation from the base monad</span>
<span class="kw">class</span> (<span class="dt">Applicative</span> b, <span class="dt">Applicative</span> m, <span class="dt">Monad</span> b, <span class="dt">Monad</span> m)
      <span class="ot">=&gt;</span> <span class="dt">MonadBase</span> b m <span class="fu">|</span> m <span class="ot">-&gt;</span> b <span class="kw">where</span>
  liftBase <span class="ot">∷</span> b a <span class="ot">-&gt;</span> m a</code></pre></div>
<h4 id="monad-control">monad-control</h4>
<p>Monad control builds on top of monad-base to extended lifting operation to control operations like <code>catch</code> and <code>bracket</code> can be written generically in terms of any transformer with a base layer supporting these operations. Generic operations can then be expressed in terms of a <code>MonadBaseControl</code> and written in terms of the combinator <code>control</code> which handles the bracket and automatic handler lifting.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">control ::</span> <span class="dt">MonadBaseControl</span> b m <span class="ot">=&gt;</span> (<span class="dt">RunInBase</span> m b <span class="ot">-&gt;</span> b (<span class="dt">StM</span> m a)) <span class="ot">-&gt;</span> m a</code></pre></div>
<p>For example the function catch provided by <code>Control.Exception</code> is normally locked into IO.</p>
<pre><code>catch :: Exception e =&gt; IO a -&gt; (e -&gt; IO a) -&gt; IO a</code></pre>
<p>By composing it in terms of control we can construct a generic version which automatically lifts inside of any combination of the usual transformer stacks that has <code>MonadBaseControl</code> instance.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">catch
<span class="ot">  ::</span> (<span class="dt">MonadBaseControl</span> <span class="dt">IO</span> m, <span class="dt">Exception</span> e)
  <span class="ot">=&gt;</span> m a        <span class="co">-- ^ Computation</span>
  <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> m a) <span class="co">-- ^ Handler</span>
  <span class="ot">-&gt;</span> m a
catch a handler <span class="fu">=</span> control <span class="fu">$</span> \runInIO <span class="ot">-&gt;</span>
                    E.catch (runInIO a)
                            (\e <span class="ot">-&gt;</span> runInIO <span class="fu">$</span> handler e)</code></pre></div>
<hr />
<h1 id="quantification">Quantification</h1>
<div class="alert alert-danger">
<p>This is an advanced section, and is not typically necessary to write Haskell.</p>
</div>
<h2 id="universal-quantification">Universal Quantification</h2>
<p>Universal quantification the primary mechanism of encoding polymorphism in Haskell. The essence of universal quantification is that we can express functions which operate the same way for a set of types and whose function behavior is entirely determined <em>only</em> by the behavior of all types in this span.</p>
<div class="sourceCode" include="src/11-quantification/universal.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ExplicitForAll #-}</span>

<span class="co">-- ∀a. [a]</span>
<span class="ot">example1 ::</span> forall a<span class="fu">.</span> [a]
example1 <span class="fu">=</span> []

<span class="co">-- ∀a. [a]</span>
<span class="ot">example2 ::</span> forall a<span class="fu">.</span> [a]
example2 <span class="fu">=</span> [undefined]

<span class="co">-- ∀a. ∀b. (a → b) → [a] → [b]</span>
<span class="ot">map&#39; ::</span> forall a<span class="fu">.</span> forall b<span class="fu">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
map&#39; f <span class="fu">=</span> foldr ((<span class="fu">:</span>) <span class="fu">.</span> f) []

<span class="co">-- ∀a. [a] → [a]</span>
<span class="ot">reverse&#39; ::</span> forall a<span class="fu">.</span> [a] <span class="ot">-&gt;</span> [a]
reverse&#39; <span class="fu">=</span> foldl (flip (<span class="fu">:</span>)) []</code></pre></div>
<p>Normally quantifiers are omitted in type signatures since in Haskell's vanilla surface language it is unambiguous to assume to that free type variables are universally quantified.</p>
<h2 id="free-theorems">Free theorems</h2>
<p>A universally quantified type-variable actually implies quite a few rather deep properties about the implementation of a function that can be deduced from its type signature. For instance the identity function in Haskell is guaranteed to only have one implementation since the only information that the information that can present in the body</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">id<span class="ot"> ::</span> forall a<span class="fu">.</span> a <span class="ot">-&gt;</span> a
id x <span class="fu">=</span> x</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap<span class="ot"> ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre></div>
<p>The free theorem of fmap:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">forall f g<span class="fu">.</span> fmap f <span class="fu">.</span> fmap g <span class="fu">=</span> fmap (f <span class="fu">.</span> g)</code></pre></div>
<p>See: <a href="http://www-ps.iai.uni-bonn.de/cgi-bin/free-theorems-webui.cgi?">Theorems for Free</a></p>
<h2 id="type-systems">Type Systems</h2>
<p><strong>Hindley-Milner type system</strong></p>
<p>The Hindley-Milner type system is historically important as one of the first typed lambda calculi that admitted both polymorphism and a variety of inference techniques that could always decide principal types.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">e <span class="fu">:</span> x
  <span class="fu">|</span> λx<span class="fu">:</span>t<span class="fu">.</span>e            <span class="co">-- value abstraction</span>
  <span class="fu">|</span> e1 e2             <span class="co">-- application</span>
  <span class="fu">|</span> <span class="kw">let</span> x <span class="fu">=</span> e1 <span class="kw">in</span> e2  <span class="co">-- let</span>

t <span class="fu">:</span> t <span class="ot">-&gt;</span> t     <span class="co">-- function types</span>
  <span class="fu">|</span> a          <span class="co">-- type variables</span>

σ <span class="fu">:</span> <span class="ot">∀</span> a <span class="fu">.</span> t    <span class="co">-- type scheme</span></code></pre></div>
<p>In an implementation, the function <code>generalize</code> converts all type variables within the type into polymorphic type variables yielding a type scheme. The function <code>instantiate</code> maps a scheme to a type, but with any polymorphic variables converted into unbound type variables.</p>
<h2 id="rank-n-types">Rank-N Types</h2>
<p>System-F is the type system that underlies Haskell. System-F subsumes the HM type system in the sense that every type expressible in HM can be expressed within System-F. System-F is sometimes referred to in texts as the <em>Girald-Reynolds polymorphic lambda calculus</em> or <em>second-order lambda calculus</em>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">t <span class="fu">:</span> t <span class="ot">-&gt;</span> t     <span class="co">-- function types</span>
  <span class="fu">|</span> a          <span class="co">-- type variables</span>
  <span class="fu">|</span> <span class="ot">∀</span> a <span class="fu">.</span> t    <span class="co">-- forall</span>

e <span class="fu">:</span> x          <span class="co">-- variables</span>
  <span class="fu">|</span> λ(x<span class="fu">:</span>t)<span class="fu">.</span>e   <span class="co">-- value abstraction</span>
  <span class="fu">|</span> e1 e2      <span class="co">-- value application</span>
  <span class="fu">|</span> Λa<span class="fu">.</span>e       <span class="co">-- type abstraction</span>
  <span class="fu">|</span> e_t        <span class="co">-- type application</span></code></pre></div>
<p>An example with equivalents of GHC Core in comments:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">id <span class="fu">:</span> <span class="ot">∀</span> t<span class="fu">.</span> t <span class="ot">-&gt;</span> t
id <span class="fu">=</span> Λt<span class="fu">.</span> λx<span class="fu">:</span>t<span class="fu">.</span> x
<span class="co">-- id :: forall t. t -&gt; t</span>
<span class="co">-- id = \ (@ t) (x :: t) -&gt; x</span>

tr <span class="fu">:</span> <span class="ot">∀</span> a<span class="fu">.</span> <span class="ot">∀</span> b<span class="fu">.</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a
tr <span class="fu">=</span> Λa<span class="fu">.</span> Λb<span class="fu">.</span> λx<span class="fu">:</span>a<span class="fu">.</span> λy<span class="fu">:</span>b<span class="fu">.</span> x
<span class="co">-- tr :: forall a b. a -&gt; b -&gt; a</span>
<span class="co">-- tr = \ (@ a) (@ b) (x :: a) (y :: b) -&gt; x</span>

fl <span class="fu">:</span> <span class="ot">∀</span> a<span class="fu">.</span> <span class="ot">∀</span> b<span class="fu">.</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b
fl <span class="fu">=</span> Λa<span class="fu">.</span> Λb<span class="fu">.</span> λx<span class="fu">:</span>a<span class="fu">.</span> λy<span class="fu">:</span>b<span class="fu">.</span> y
<span class="co">-- fl :: forall a b. a -&gt; b -&gt; b</span>
<span class="co">-- fl = \ (@ a) (@ b) (x :: a) (y :: b) -&gt; y</span>

nil <span class="fu">:</span> <span class="ot">∀</span> a<span class="fu">.</span> [a]
nil <span class="fu">=</span> Λa<span class="fu">.</span> Λb<span class="fu">.</span> λz<span class="fu">:</span>b<span class="fu">.</span> λf<span class="fu">:</span>(a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b)<span class="fu">.</span> z
<span class="co">-- nil :: forall a. [a]</span>
<span class="co">-- nil = \ (@ a) (@ b) (z :: b) (f :: a -&gt; b -&gt; b) -&gt; z</span>

cons <span class="fu">:</span> <span class="ot">∀</span> a<span class="fu">.</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
cons <span class="fu">=</span> Λa<span class="fu">.</span> λx<span class="fu">:</span>a<span class="fu">.</span> λxs<span class="fu">:</span>(<span class="ot">∀</span> b<span class="fu">.</span> b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b)<span class="fu">.</span>
    Λb<span class="fu">.</span> λz<span class="fu">:</span>b<span class="fu">.</span> λf <span class="fu">:</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b)<span class="fu">.</span> f x (xs_b z f)
<span class="co">-- cons :: forall a. a</span>
<span class="co">--       -&gt; (forall b. (a -&gt; b -&gt; b) -&gt; b) -&gt; (forall b. (a -&gt; b -&gt; b) -&gt; b)</span>
<span class="co">-- cons = \ (@ a) (x :: a) (xs :: forall b. (a -&gt; b -&gt; b) -&gt; b)</span>
<span class="co">--     (@ b) (z :: b) (f :: a -&gt; b -&gt; b) -&gt; f x (xs @ b z f)</span></code></pre></div>
<p>Normally when Haskell's typechecker infers a type signature it places all quantifiers of type variables at the outermost position such that no quantifiers appear within the body of the type expression, called the prenex restriction. This restricts an entire class of type signatures that would otherwise be expressible within System-F, but has the benefit of making inference much easier.</p>
<p><code>-XRankNTypes</code> loosens the prenex restriction such that we may explicitly place quantifiers within the body of the type. The bad news is that the general problem of inference in this relaxed system is undecidable in general, so we're required to explicitly annotate functions which use RankNTypes or they are otherwise inferred as rank 1 and may not typecheck at all.</p>
<div class="sourceCode" include="src/11-quantification/rankn.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RankNTypes #-}</span>

<span class="co">-- Can&#39;t unify ( Bool ~ Char )</span>
<span class="ot">rank1 ::</span> forall a<span class="fu">.</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (<span class="dt">Bool</span>, <span class="dt">Char</span>)
rank1 f <span class="fu">=</span> (f <span class="dt">True</span>, f <span class="ch">&#39;a&#39;</span>)

<span class="ot">rank2 ::</span> (forall a<span class="fu">.</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (<span class="dt">Bool</span>, <span class="dt">Char</span>)
rank2 f <span class="fu">=</span> (f <span class="dt">True</span>, f <span class="ch">&#39;a&#39;</span>)

<span class="ot">auto ::</span> (forall a<span class="fu">.</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (forall b<span class="fu">.</span> b <span class="ot">-&gt;</span> b)
auto x <span class="fu">=</span> x

<span class="ot">xauto ::</span> forall a<span class="fu">.</span> (forall b<span class="fu">.</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
xauto f <span class="fu">=</span> f</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Monomorphic</span> <span class="dt">Rank</span> <span class="dv">0</span><span class="fu">:</span> t
<span class="dt">Polymorphic</span> <span class="dt">Rank</span> <span class="dv">1</span><span class="fu">:</span> forall a<span class="fu">.</span> a <span class="ot">-&gt;</span> t
<span class="dt">Polymorphic</span> <span class="dt">Rank</span> <span class="dv">2</span><span class="fu">:</span> (forall a<span class="fu">.</span> a <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> t
<span class="dt">Polymorphic</span> <span class="dt">Rank</span> <span class="dv">3</span><span class="fu">:</span> ((forall a<span class="fu">.</span> a <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> t</code></pre></div>
<p>Of important note is that the type variables bound by an explicit quantifier in a higher ranked type may not escape their enclosing scope. The typechecker will explicitly enforce this by enforcing that variables bound inside of rank-n types (called skolem constants) will not unify with free meta type variables inferred by the inference engine.</p>
<div class="sourceCode" include="src/11-quantification/skolem_capture.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RankNTypes #-}</span>

<span class="ot">escape ::</span> (forall a<span class="fu">.</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Int</span>
escape f <span class="fu">=</span> f <span class="dv">0</span>

g x <span class="fu">=</span> escape (\a <span class="ot">-&gt;</span> x)</code></pre></div>
<p>In this example in order for the expression to be well typed, <code>f</code> would necessarily have (<code>Int -&gt; Int</code>) which implies that <code>a ~ Int</code> over the whole type, but since <code>a</code> is bound under the quantifier it must not be unified with <code>Int</code> and so the typechecker must fail with a skolem capture error.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl">Couldn<span class="kw">&#39;</span><span class="st">t match expected type `a</span><span class="kw">&#39;</span> with actual type <span class="kw">`</span><span class="st">t&#39;</span>
<span class="kw">`</span>a<span class="kw">&#39;</span><span class="st"> is a rigid type variable bound by a type expected by the context: a -&gt; a</span>
<span class="st">`t</span><span class="kw">&#39;</span> is a rigid type variable bound by the inferred type of g :: t -&gt; Int
In the expression: x In the first argument of <span class="kw">`</span><span class="st">escape&#39;, namely </span><span class="kw">`</span>(\ a -&gt; x)<span class="kw">&#39;</span>
<span class="st">In the expression: escape (\ a -&gt; x)</span></code></pre></div>
<p>This can actually be used for our advantage to enforce several types of invariants about scope and use of specific type variables. For example the ST monad uses a second rank type to prevent the capture of references between ST monads with separate state threads where the <code>s</code> type variable is bound within a rank-2 type and cannot escape, statically guaranteeing that the implementation details of the ST internals can't leak out and thus ensuring its referential transparency.</p>
<h2 id="existential-quantification">Existential Quantification</h2>
<p>An existential type is a pair of a type and a term with a special set of packing and unpacking semantics. The type of the value encoded in the existential is known by the producer but not by the consumer of the existential value.</p>
<div class="sourceCode" include="src/11-quantification/existential.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span>
<span class="ot">{-# LANGUAGE RankNTypes #-}</span>

<span class="co">-- ∃ t. (t, t → t, t → String)</span>
<span class="kw">data</span> <span class="dt">Box</span> <span class="fu">=</span> forall a<span class="fu">.</span> <span class="dt">Box</span> a (a <span class="ot">-&gt;</span> a) (a <span class="ot">-&gt;</span> <span class="dt">String</span>)

<span class="ot">boxa ::</span> <span class="dt">Box</span>
boxa <span class="fu">=</span> <span class="dt">Box</span> <span class="dv">1</span> negate show

<span class="ot">boxb ::</span> <span class="dt">Box</span>
boxb <span class="fu">=</span> <span class="dt">Box</span> <span class="st">&quot;foo&quot;</span> reverse show

<span class="ot">apply ::</span> <span class="dt">Box</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
apply (<span class="dt">Box</span> x f p) <span class="fu">=</span> p (f x)

<span class="co">-- ∃ t. Show t =&gt; t</span>
<span class="kw">data</span> <span class="dt">SBox</span> <span class="fu">=</span> forall a<span class="fu">.</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">SBox</span> a

<span class="ot">boxes ::</span> [<span class="dt">SBox</span>]
boxes <span class="fu">=</span> [<span class="dt">SBox</span> (), <span class="dt">SBox</span> <span class="dv">2</span>, <span class="dt">SBox</span> <span class="st">&quot;foo&quot;</span>]

<span class="ot">showBox ::</span> <span class="dt">SBox</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
showBox (<span class="dt">SBox</span> a) <span class="fu">=</span> show a

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> mapM_ (putStrLn <span class="fu">.</span> showBox) boxes
<span class="co">-- ()</span>
<span class="co">-- 2</span>
<span class="co">-- &quot;foo&quot;</span></code></pre></div>
<p>The existential over <code>SBox</code> gathers a collection of values defined purely in terms of their Show interface and an opaque pointer, no other information is available about the values and they can't be accessed or unpacked in any other way.</p>
<p>Passing around existential types allows us to hide information from consumers of data types and restrict the behavior that functions can use. Passing records around with existential variables allows a type to be &quot;bundled&quot; with a fixed set of functions that operate over its hidden internals.</p>
<div class="sourceCode" include="src/11-quantification/existential_records.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RankNTypes #-}</span>
<span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span>

<span class="co">-- a b are existentially bound type variables, m is a free type variable</span>
<span class="kw">data</span> <span class="dt">MonadI</span> m <span class="fu">=</span> <span class="dt">MonadI</span>
  { _<span class="ot">return ::</span> forall a <span class="fu">.</span> a <span class="ot">-&gt;</span> m a
  , _<span class="ot">bind   ::</span> forall a b <span class="fu">.</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b
  }

<span class="ot">monadMaybe::</span> <span class="dt">MonadI</span> <span class="dt">Maybe</span>
monadMaybe <span class="fu">=</span> <span class="dt">MonadI</span>
  { _return <span class="fu">=</span> <span class="dt">Just</span>
  , _bind   <span class="fu">=</span> \m f <span class="ot">-&gt;</span> <span class="kw">case</span> m <span class="kw">of</span>
      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
      <span class="dt">Just</span> x  <span class="ot">-&gt;</span> f x
  }</code></pre></div>
<h2 id="impredicative-types">Impredicative Types</h2>
<div class="alert alert-danger">
<p>This is an advanced section, and is not typically necessary to write Haskell.</p>
</div>
<p>Although extremely brittle, GHC also has limited support for impredicative polymorphism which allows instantiating type variable with a polymorphic type. Implied is that this loosens the restriction that quantifiers must precede arrow types and now they may be placed inside of type-constructors.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Can&#39;t unify ( Int ~ Char )</span>

<span class="ot">revUni ::</span> forall a<span class="fu">.</span> <span class="dt">Maybe</span> ([a] <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> ([<span class="dt">Int</span>], [<span class="dt">Char</span>])
revUni (<span class="dt">Just</span> g) <span class="fu">=</span> <span class="dt">Just</span> (g [<span class="dv">3</span>], g <span class="st">&quot;hello&quot;</span>)
revUni <span class="dt">Nothing</span>  <span class="fu">=</span> <span class="dt">Nothing</span></code></pre></div>
<div class="sourceCode" include="src/11-quantification/impredicative.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ImpredicativeTypes #-}</span>

<span class="co">-- Uses higher-ranked polymorphism.</span>
<span class="ot">f ::</span> (forall a<span class="fu">.</span> [a] <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Char</span>)
f get <span class="fu">=</span> (get [<span class="dv">1</span>,<span class="dv">2</span>], get [<span class="ch">&#39;a&#39;</span>, <span class="ch">&#39;b&#39;</span>, <span class="ch">&#39;c&#39;</span>])

<span class="co">-- Uses impredicative polymorphism.</span>
<span class="ot">g ::</span> <span class="dt">Maybe</span> (forall a<span class="fu">.</span> [a] <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Char</span>)
g <span class="dt">Nothing</span> <span class="fu">=</span> (<span class="dv">0</span>, <span class="ch">&#39;0&#39;</span>)
g (<span class="dt">Just</span> get) <span class="fu">=</span> (get [<span class="dv">1</span>,<span class="dv">2</span>], get [<span class="ch">&#39;a&#39;</span>,<span class="ch">&#39;b&#39;</span>,<span class="ch">&#39;c&#39;</span>])</code></pre></div>
<p>Use of this extension is very rare, and there is some consideration that <code>-XImpredicativeTypes</code> is fundamentally broken. Although GHC is very liberal about telling us to enable it when one accidentally makes a typo in a type signature!</p>
<p>Some notable trivia, the <code>($)</code> operator is wired into GHC in a very special way as to allow impredicative instantiation of <code>runST</code> to be applied via <code>($)</code> by special-casing the <code>($)</code> operator only when used for the ST monad. If this sounds like an ugly hack it's because it is, but a rather convenient hack.</p>
<p>For example if we define a function <code>apply</code> which should behave identically to <code>($)</code> we'll get an error about polymorphic instantiation even though they are defined identically!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RankNTypes #-}</span>

<span class="kw">import </span><span class="dt">Control.Monad.ST</span>

f <span class="ot">`apply`</span> x <span class="fu">=</span>  f x

<span class="ot">foo ::</span> (forall s<span class="fu">.</span> <span class="dt">ST</span> s a) <span class="ot">-&gt;</span> a
foo st <span class="fu">=</span> runST <span class="fu">$</span> st

<span class="ot">bar ::</span> (forall s<span class="fu">.</span> <span class="dt">ST</span> s a) <span class="ot">-&gt;</span> a
bar st <span class="fu">=</span> runST <span class="ot">`apply`</span> st</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="dt">Couldn&#39;t</span> match expected <span class="kw">type</span> <span class="ot">`forall s. ST s a&#39;</span>
<span class="ot">                with actual type `</span><span class="dt">ST</span> s0 a&#39;
    <span class="dt">In</span> the second argument <span class="kw">of</span> <span class="ot">`apply&#39;, namely `</span>st&#39;
    <span class="dt">In</span> the expression<span class="fu">:</span> runST <span class="ot">`apply`</span> st
    <span class="dt">In</span> an equation for <span class="ot">`bar&#39;: bar st = runST `</span>apply<span class="ot">` st</span></code></pre></div>
<p>See:</p>
<ul>
<li><a href="https://www.haskell.org/pipermail/glasgow-haskell-users/2010-November/019431.html">SPJ Notes on $</a></li>
</ul>
<h2 id="scoped-type-variables">Scoped Type Variables</h2>
<p>Normally the type variables used within the toplevel signature for a function are only scoped to the type-signature and not the body of the function and its rigid signatures over terms and let/where clauses. Enabling <code>-XScopedTypeVariables</code> loosens this restriction allowing the type variables mentioned in the toplevel to be scoped within the value-level body of a function and all signatures contained therein.</p>
<div class="sourceCode" include="src/11-quantification/scopedtvars.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ExplicitForAll #-}</span>
<span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span>

<span class="ot">poly ::</span> forall a b c<span class="fu">.</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> (a, a)
poly x y z <span class="fu">=</span> (f x y, f x z)
  <span class="kw">where</span>
    <span class="co">-- second argument is universally quantified from inference</span>
    <span class="co">-- f :: forall t0 t1. t0 -&gt; t1 -&gt; t0</span>
    f x&#39; _ <span class="fu">=</span> x&#39;

<span class="ot">mono ::</span> forall a b c<span class="fu">.</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> (a, a)
mono x y z <span class="fu">=</span> (f x y, f x z)
  <span class="kw">where</span>
    <span class="co">-- b is not implictly universally quantified because it is in scope</span>
<span class="ot">    f ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a
    f x&#39; _ <span class="fu">=</span> x&#39;

<span class="ot">example ::</span> <span class="dt">IO</span> ()
example <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">  x ::</span> [<span class="dt">Int</span>] <span class="ot">&lt;-</span> readLn
  print x</code></pre></div>
<hr />
<h1 id="gadts">GADTs</h1>
<h2 id="gadts-1">GADTs</h2>
<p><em>Generalized Algebraic Data types</em> (GADTs) are an extension to algebraic datatypes that allow us to qualify the constructors to datatypes with type equality constraints, allowing a class of types that are not expressible using vanilla ADTs.</p>
<p><code>-XGADTs</code> implicitly enables an alternative syntax for datatype declarations ( <code>-XGADTSyntax</code> ) such that the following declarations are equivalent:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Vanilla</span>
<span class="kw">data</span> <span class="dt">List</span> a
  <span class="fu">=</span> <span class="dt">Empty</span>
  <span class="fu">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)

<span class="co">-- GADTSyntax</span>
<span class="kw">data</span> <span class="dt">List</span> a <span class="kw">where</span>
  <span class="dt">Empty</span><span class="ot"> ::</span> <span class="dt">List</span> a
  <span class="dt">Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a</code></pre></div>
<p>For an example use consider the data type <code>Term</code>, we have a term in which we <code>Succ</code> which takes a <code>Term</code> parameterized by <code>a</code> which span all types. Problems arise between the clash whether (<code>a ~ Bool</code>) or (<code>a ~ Int</code>) when trying to write the evaluator.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Term</span> a
  <span class="fu">=</span> <span class="dt">Lit</span> a
  <span class="fu">|</span> <span class="dt">Succ</span> (<span class="dt">Term</span> a)
  <span class="fu">|</span> <span class="dt">IsZero</span> (<span class="dt">Term</span> a)

<span class="co">-- can&#39;t be well-typed :(</span>
eval (<span class="dt">Lit</span> i)      <span class="fu">=</span> i
eval (<span class="dt">Succ</span> t)     <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> eval t
eval (<span class="dt">IsZero</span> i)   <span class="fu">=</span> eval i <span class="fu">==</span> <span class="dv">0</span></code></pre></div>
<p>And we admit the construction of meaningless terms which forces more error handling cases.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- This is a valid type.</span>
failure <span class="fu">=</span> <span class="dt">Succ</span> ( <span class="dt">Lit</span> <span class="dt">True</span> )</code></pre></div>
<p>Using a GADT we can express the type invariants for our language (i.e. only type-safe expressions are representable). Pattern matching on this GADTs then carries type equality constraints without the need for explicit tags.</p>
<div class="sourceCode" include="src/12-gadts/gadt.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# Language GADTs #-}</span>

<span class="kw">data</span> <span class="dt">Term</span> a <span class="kw">where</span>
  <span class="dt">Lit</span><span class="ot">    ::</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a
  <span class="dt">Succ</span><span class="ot">   ::</span> <span class="dt">Term</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Int</span>
  <span class="dt">IsZero</span><span class="ot"> ::</span> <span class="dt">Term</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Bool</span>
  <span class="dt">If</span><span class="ot">     ::</span> <span class="dt">Term</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a

<span class="ot">eval ::</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> a
eval (<span class="dt">Lit</span> i)      <span class="fu">=</span> i                                   <span class="co">-- Term a</span>
eval (<span class="dt">Succ</span> t)     <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> eval t                          <span class="co">-- Term (a ~ Int)</span>
eval (<span class="dt">IsZero</span> i)   <span class="fu">=</span> eval i <span class="fu">==</span> <span class="dv">0</span>                         <span class="co">-- Term (a ~ Int)</span>
eval (<span class="dt">If</span> b e1 e2) <span class="fu">=</span> <span class="kw">if</span> eval b <span class="kw">then</span> eval e1 <span class="kw">else</span> eval e2 <span class="co">-- Term (a ~ Bool)</span>

<span class="ot">example ::</span> <span class="dt">Int</span>
example <span class="fu">=</span> eval (<span class="dt">Succ</span> (<span class="dt">Succ</span> (<span class="dt">Lit</span> <span class="dv">3</span>)))</code></pre></div>
<p>This time around:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- This is rejected at compile-time.</span>
failure <span class="fu">=</span> <span class="dt">Succ</span> ( <span class="dt">Lit</span> <span class="dt">True</span> )</code></pre></div>
<p>Explicit equality constraints (<code>a ~ b</code>) can be added to a function's context. For example the following expand out to the same types.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (a, a)
<span class="ot">f ::</span> (a <span class="fu">~</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> (a,b)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="dt">Int</span> <span class="fu">~</span> <span class="dt">Int</span>)  <span class="ot">=&gt;</span> <span class="fu">...</span>
(a <span class="fu">~</span> <span class="dt">Int</span>)    <span class="ot">=&gt;</span> <span class="fu">...</span>
(<span class="dt">Int</span> <span class="fu">~</span> a)    <span class="ot">=&gt;</span> <span class="fu">...</span>
(a <span class="fu">~</span> b)      <span class="ot">=&gt;</span> <span class="fu">...</span>
(<span class="dt">Int</span> <span class="fu">~</span> <span class="dt">Bool</span>) <span class="ot">=&gt;</span> <span class="fu">...</span> <span class="co">-- Will not typecheck.</span></code></pre></div>
<p>This is effectively the implementation detail of what GHC is doing behind the scenes to implement GADTs ( implicitly passing and threading equality terms around ). If we wanted we could do the same setup that GHC does just using equality constraints and existential quantification. Indeed, the internal representation of GADTs is as regular algebraic datatypes that carry coercion evidence as arguments.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span>

<span class="co">-- Using Constraints</span>
<span class="kw">data</span> <span class="dt">Exp</span> a
  <span class="fu">=</span> (a <span class="fu">~</span> <span class="dt">Int</span>) <span class="ot">=&gt;</span> <span class="dt">LitInt</span> a
  <span class="fu">|</span> (a <span class="fu">~</span> <span class="dt">Bool</span>) <span class="ot">=&gt;</span> <span class="dt">LitBool</span> a
  <span class="fu">|</span> forall b<span class="fu">.</span> (b <span class="fu">~</span> <span class="dt">Bool</span>) <span class="ot">=&gt;</span> <span class="dt">If</span> (<span class="dt">Exp</span> b) (<span class="dt">Exp</span> a) (<span class="dt">Exp</span> a)

<span class="co">-- Using GADTs</span>
<span class="co">-- data Exp a where</span>
<span class="co">--   LitInt  :: Int  -&gt; Exp Int</span>
<span class="co">--   LitBool :: Bool -&gt; Exp Bool</span>
<span class="co">--   If      :: Exp Bool -&gt; Exp a -&gt; Exp a -&gt; Exp a</span>

<span class="ot">eval ::</span> <span class="dt">Exp</span> a <span class="ot">-&gt;</span> a
eval e <span class="fu">=</span> <span class="kw">case</span> e <span class="kw">of</span>
  <span class="dt">LitInt</span> i   <span class="ot">-&gt;</span> i
  <span class="dt">LitBool</span> b  <span class="ot">-&gt;</span> b
  <span class="dt">If</span> b tr fl <span class="ot">-&gt;</span> <span class="kw">if</span> eval b <span class="kw">then</span> eval tr <span class="kw">else</span> eval fl</code></pre></div>
<p>In the presence of GADTs inference becomes intractable in many cases, often requiring an explicit annotation. For example <code>f</code> can either have <code>T a -&gt; [a]</code> or <code>T a -&gt; [Int]</code> and neither is principal.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">T</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">T1</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">T</span> <span class="dt">Int</span>
  <span class="dt">T2</span><span class="ot"> ::</span> <span class="dt">T</span> a

f (<span class="dt">T1</span> n) <span class="fu">=</span> [n]
f <span class="dt">T2</span>     <span class="fu">=</span> []</code></pre></div>
<h2 id="kind-signatures">Kind Signatures</h2>
<p>Haskell's kind system (i.e. the &quot;type of the types&quot;) is a system consisting the single kind <code>*</code> and an arrow kind <code>-&gt;</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">κ <span class="fu">:</span> <span class="fu">*</span>
  <span class="fu">|</span> κ <span class="ot">-&gt;</span> κ</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Int</span><span class="ot"> ::</span> <span class="fu">*</span>
<span class="dt">Maybe</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>
<span class="dt">Either</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span></code></pre></div>
<p>There are in fact some extensions to this system that will be covered later ( see: PolyKinds and Unboxed types in later sections ) but most kinds in everyday code are simply either stars or arrows.</p>
<p>With the KindSignatures extension enabled we can now annotate top level type signatures with their explicit kinds, bypassing the normal kind inference procedures.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE KindSignatures #-}</span>

id<span class="ot"> ::</span> forall (<span class="ot">a ::</span> <span class="fu">*</span>)<span class="fu">.</span> a <span class="ot">-&gt;</span> a
id x <span class="fu">=</span> x</code></pre></div>
<p>On top of default GADT declaration we can also constrain the parameters of the GADT to specific kinds. For basic usage Haskell's kind inference can deduce this reasonably well, but combined with some other type system extensions that extend the kind system this becomes essential.</p>
<div class="sourceCode" include="src/12-gadts/kindsignatures.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# Language GADTs #-}</span>
<span class="ot">{-# LANGUAGE KindSignatures #-}</span>

<span class="kw">data</span> <span class="dt">Term</span><span class="ot"> a ::</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">Lit</span><span class="ot">    ::</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a
  <span class="dt">Succ</span><span class="ot">   ::</span> <span class="dt">Term</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Int</span>
  <span class="dt">IsZero</span><span class="ot"> ::</span> <span class="dt">Term</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Bool</span>
  <span class="dt">If</span><span class="ot">     ::</span> <span class="dt">Term</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a

<span class="kw">data</span> <span class="dt">Vec</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">Vec</span> n a
  <span class="dt">Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a

<span class="kw">data</span> <span class="dt">Fix</span><span class="ot"> ::</span> (<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">In</span><span class="ot"> ::</span> f (<span class="dt">Fix</span> f) <span class="ot">-&gt;</span> <span class="dt">Fix</span> f</code></pre></div>
<h2 id="void">Void</h2>
<p>The Void type is the type with no inhabitants. It unifies only with itself.</p>
<p>Using a newtype wrapper we can create a type where recursion makes it impossible to construct an inhabitant.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Void :: Void -&gt; Void</span>
<span class="kw">newtype</span> <span class="dt">Void</span> <span class="fu">=</span> <span class="dt">Void</span> <span class="dt">Void</span></code></pre></div>
<p>Or using <code>-XEmptyDataDecls</code> we can also construct the uninhabited type equivalently as a data declaration with no constructors.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Void</span></code></pre></div>
<p>The only inhabitant of both of these types is a diverging term like (<code>undefined</code>).</p>
<h2 id="phantom-types">Phantom Types</h2>
<p>Phantom types are parameters that appear on the left hand side of a type declaration but which are not constrained by the values of the types inhabitants. They are effectively slots for us to encode additional information at the type-level.</p>
<div class="sourceCode" include="src/12-gadts/phantom.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Void</span>

<span class="kw">data</span> <span class="dt">Foo</span> tag a <span class="fu">=</span> <span class="dt">Foo</span> a

<span class="ot">combine ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Foo</span> tag a <span class="ot">-&gt;</span> <span class="dt">Foo</span> tag a <span class="ot">-&gt;</span> <span class="dt">Foo</span> tag a
combine (<span class="dt">Foo</span> a) (<span class="dt">Foo</span> b) <span class="fu">=</span> <span class="dt">Foo</span> (a<span class="fu">+</span>b)

<span class="co">-- All identical at the value level, but differ at the type level.</span>
<span class="ot">a ::</span> <span class="dt">Foo</span> () <span class="dt">Int</span>
a <span class="fu">=</span> <span class="dt">Foo</span> <span class="dv">1</span>

<span class="ot">b ::</span> <span class="dt">Foo</span> t <span class="dt">Int</span>
b <span class="fu">=</span> <span class="dt">Foo</span> <span class="dv">1</span>

<span class="ot">c ::</span> <span class="dt">Foo</span> <span class="dt">Void</span> <span class="dt">Int</span>
c <span class="fu">=</span> <span class="dt">Foo</span> <span class="dv">1</span>

<span class="co">-- () ~ ()</span>
<span class="ot">example1 ::</span> <span class="dt">Foo</span> () <span class="dt">Int</span>
example1 <span class="fu">=</span> combine a a

<span class="co">-- t ~ ()</span>
<span class="ot">example2 ::</span> <span class="dt">Foo</span> () <span class="dt">Int</span>
example2 <span class="fu">=</span> combine a b

<span class="co">-- t0 ~ t1</span>
<span class="ot">example3 ::</span> <span class="dt">Foo</span> t <span class="dt">Int</span>
example3 <span class="fu">=</span> combine b b

<span class="co">-- Couldn&#39;t match type `t&#39; with `Void&#39;</span>
<span class="ot">example4 ::</span> <span class="dt">Foo</span> t <span class="dt">Int</span>
example4 <span class="fu">=</span> combine b c</code></pre></div>
<p>Notice the type variable <code>tag</code> does not appear in the right hand side of the declaration. Using this allows us to express invariants at the type-level that need not manifest at the value-level. We're effectively programming by adding extra information at the type-level.</p>
<p>Consider the case of using newtypes to statically distinguish between plaintext and cryptotext.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Plaintext</span> <span class="fu">=</span> <span class="dt">Plaintext</span> <span class="dt">Text</span>
<span class="kw">newtype</span> <span class="dt">Crytpotext</span> <span class="fu">=</span> <span class="dt">Cryptotext</span> <span class="dt">Text</span>

<span class="ot">encrypt ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">Plaintext</span> <span class="ot">-&gt;</span> <span class="dt">Cryptotext</span>
<span class="ot">decrypt ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">Cryptotext</span> <span class="ot">-&gt;</span> <span class="dt">Plaintext</span></code></pre></div>
<p>Using phantom types we use an extra parameter.</p>
<div class="sourceCode" include="src/12-gadts/phantom_example.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Text</span>

<span class="kw">data</span> <span class="dt">Cryptotext</span>
<span class="kw">data</span> <span class="dt">Plaintext</span>

<span class="kw">data</span> <span class="dt">Msg</span> a <span class="fu">=</span> <span class="dt">Msg</span> <span class="dt">Text</span>

<span class="ot">encrypt ::</span> <span class="dt">Msg</span> <span class="dt">Plaintext</span> <span class="ot">-&gt;</span> <span class="dt">Msg</span> <span class="dt">Cryptotext</span>
encrypt <span class="fu">=</span> undefined

<span class="ot">decrypt ::</span> <span class="dt">Msg</span> <span class="dt">Cryptotext</span> <span class="ot">-&gt;</span> <span class="dt">Msg</span> <span class="dt">Plaintext</span>
decrypt <span class="fu">=</span> undefined</code></pre></div>
<p>Using <code>-XEmptyDataDecls</code> can be a powerful combination with phantom types that contain no value inhabitants and are &quot;anonymous types&quot;.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE EmptyDataDecls #-}</span>

<span class="kw">data</span> <span class="dt">Token</span> a</code></pre></div>
<p>See: <a href="http://www.researchgate.net/publication/228707929_Fun_with_phantom_types/file/9c960525654760c169.pdf">Fun with Phantom Types</a></p>
<h2 id="typelevel-operations">Typelevel Operations</h2>
<div class="alert alert-danger">
<p>This is an advanced section, and is not typically necessary to write Haskell.</p>
</div>
<p>With a richer language for datatypes we can express terms that witness the relationship between terms in the constructors, for example we can now express a term which expresses propositional equality between two types.</p>
<p>The type <code>Eql a b</code> is a proof that types <code>a</code> and <code>b</code> are equal, by pattern matching on the single <code>Refl</code> constructor we introduce the equality constraint into the body of the pattern match.</p>
<div class="sourceCode" include="src/12-gadts/equal.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">{-# LANGUAGE ExplicitForAll #-}</span>

<span class="co">-- a ≡ b</span>
<span class="kw">data</span> <span class="dt">Eql</span> a b <span class="kw">where</span>
  <span class="dt">Refl</span><span class="ot"> ::</span> <span class="dt">Eql</span> a a

<span class="co">-- Congruence</span>
<span class="co">-- (f : A → B) {x y} → x ≡ y → f x ≡ f y</span>
<span class="ot">cong ::</span> <span class="dt">Eql</span> a b <span class="ot">-&gt;</span> <span class="dt">Eql</span> (f a) (f b)
cong <span class="dt">Refl</span> <span class="fu">=</span> <span class="dt">Refl</span>

<span class="co">-- Symmetry</span>
<span class="co">-- {a b : A} → a ≡ b → a ≡ b</span>
<span class="ot">sym ::</span> <span class="dt">Eql</span> a b <span class="ot">-&gt;</span> <span class="dt">Eql</span> b a
sym <span class="dt">Refl</span> <span class="fu">=</span> <span class="dt">Refl</span>

<span class="co">-- Transitivity</span>
<span class="co">-- {a b c : A} → a ≡ b → b ≡ c → a ≡ c</span>
<span class="ot">trans ::</span> <span class="dt">Eql</span> a b <span class="ot">-&gt;</span> <span class="dt">Eql</span> b c <span class="ot">-&gt;</span> <span class="dt">Eql</span> a c
trans <span class="dt">Refl</span> <span class="dt">Refl</span> <span class="fu">=</span> <span class="dt">Refl</span>

<span class="co">-- Coerce one type to another given a proof of their equality.</span>
<span class="co">-- {a b : A} → a ≡ b → a → b</span>
<span class="ot">castWith ::</span> <span class="dt">Eql</span> a b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b
castWith <span class="dt">Refl</span> <span class="fu">=</span> id

<span class="co">-- Trivial cases</span>
<span class="ot">a ::</span> forall n<span class="fu">.</span> <span class="dt">Eql</span> n n
a <span class="fu">=</span> <span class="dt">Refl</span>

<span class="ot">b ::</span> forall<span class="fu">.</span> <span class="dt">Eql</span> () ()
b <span class="fu">=</span> <span class="dt">Refl</span></code></pre></div>
<p>As of GHC 7.8 these constructors and functions are included in the Prelude in the <a href="http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Type-Equality.html">Data.Type.Equality</a> module.</p>
</hr>
<h1 id="interpreters">Interpreters</h1>
<p>The lambda calculus forms the theoretical and practical foundation for many languages. At the heart of every calculus is three components:</p>
<ul>
<li><strong>Var</strong> - A variable</li>
<li><strong>Lam</strong> - A lambda abstraction</li>
<li><strong>App</strong> - An application</li>
</ul>
<div class="center">
<div class="figure">
<img src="img/lambda.png" alt="" />

</div>
</div>
<p>There are many different ways of modeling these constructions and data structure representations, but they all more or less contain these three elements. For example, a lambda calculus that uses String names on lambda binders and variables might be written like the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="kw">data</span> <span class="dt">Exp</span>
  <span class="fu">=</span> <span class="dt">Var</span> <span class="dt">Name</span>
  <span class="fu">|</span> <span class="dt">Lam</span> <span class="dt">Name</span> <span class="dt">Exp</span>
  <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Exp</span> <span class="dt">Exp</span></code></pre></div>
<p>A lambda expression in which all variables that appear in the body of the expression are referenced in an outer lambda binder is said to be <em>closed</em> while an expression with unbound free variables is <em>open</em>.</p>
<h2 id="hoas">HOAS</h2>
<p>Higher Order Abstract Syntax (<em>HOAS</em>) is a technique for implementing the lambda calculus in a language where the binders of the lambda expression map directly onto lambda binders of the host language ( i.e. Haskell ) to give us substitution machinery in our custom language by exploiting Haskell's implementation.</p>
<div class="sourceCode" include="src/13-lambda-calculus/hoas.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>

<span class="kw">data</span> <span class="dt">Expr</span> a <span class="kw">where</span>
  <span class="dt">Con</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a
  <span class="dt">Lam</span><span class="ot"> ::</span> (<span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> b) <span class="ot">-&gt;</span> <span class="dt">Expr</span> (a <span class="ot">-&gt;</span> b)
  <span class="dt">App</span><span class="ot"> ::</span> <span class="dt">Expr</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> b

<span class="ot">i ::</span> <span class="dt">Expr</span> (a <span class="ot">-&gt;</span> a)
i <span class="fu">=</span> <span class="dt">Lam</span> (\x <span class="ot">-&gt;</span> x)

<span class="ot">k ::</span> <span class="dt">Expr</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a)
k <span class="fu">=</span> <span class="dt">Lam</span> (\x <span class="ot">-&gt;</span> <span class="dt">Lam</span> (\y <span class="ot">-&gt;</span> x))

<span class="ot">s ::</span> <span class="dt">Expr</span> ((a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> c))
s <span class="fu">=</span> <span class="dt">Lam</span> (\x <span class="ot">-&gt;</span> <span class="dt">Lam</span> (\y <span class="ot">-&gt;</span> <span class="dt">Lam</span> (\z <span class="ot">-&gt;</span> <span class="dt">App</span> (<span class="dt">App</span> x z) (<span class="dt">App</span> y z))))

<span class="ot">eval ::</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> a
eval (<span class="dt">Con</span> v) <span class="fu">=</span> v
eval (<span class="dt">Lam</span> f) <span class="fu">=</span> \x <span class="ot">-&gt;</span> eval (f (<span class="dt">Con</span> x))
eval (<span class="dt">App</span> e1 e2) <span class="fu">=</span> (eval e1) (eval e2)


<span class="ot">skk ::</span> <span class="dt">Expr</span> (a <span class="ot">-&gt;</span> a)
skk <span class="fu">=</span> <span class="dt">App</span> (<span class="dt">App</span> s k) k

<span class="ot">example ::</span> <span class="dt">Integer</span>
example <span class="fu">=</span> eval skk <span class="dv">1</span>
<span class="co">-- 1</span></code></pre></div>
<p>Pretty printing HOAS terms can also be quite complicated since the body of the function is under a Haskell lambda binder.</p>
<h2 id="phoas">PHOAS</h2>
<p>A slightly different form of HOAS called PHOAS uses lambda datatype parameterized over the binder type. In this form evaluation requires unpacking into a separate Value type to wrap the lambda expression.</p>
<div class="sourceCode" include="src/13-lambda-calculus/phoas.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RankNTypes #-}</span>

<span class="kw">data</span> <span class="dt">ExprP</span> a
  <span class="fu">=</span> <span class="dt">VarP</span> a
  <span class="fu">|</span> <span class="dt">AppP</span> (<span class="dt">ExprP</span> a) (<span class="dt">ExprP</span> a)
  <span class="fu">|</span> <span class="dt">LamP</span> (a <span class="ot">-&gt;</span> <span class="dt">ExprP</span> a)
  <span class="fu">|</span> <span class="dt">LitP</span> <span class="dt">Integer</span>

<span class="kw">data</span> <span class="dt">Value</span>
  <span class="fu">=</span> <span class="dt">VLit</span> <span class="dt">Integer</span>
  <span class="fu">|</span> <span class="dt">VFun</span> (<span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>)

<span class="ot">fromVFun ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> (<span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>)
fromVFun val <span class="fu">=</span> <span class="kw">case</span> val <span class="kw">of</span>
  <span class="dt">VFun</span> f <span class="ot">-&gt;</span> f
  _      <span class="ot">-&gt;</span> error <span class="st">&quot;not a function&quot;</span>

<span class="ot">fromVLit ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
fromVLit val <span class="fu">=</span> <span class="kw">case</span> val <span class="kw">of</span>
  <span class="dt">VLit</span> n <span class="ot">-&gt;</span> n
  _      <span class="ot">-&gt;</span> error <span class="st">&quot;not a integer&quot;</span>

<span class="kw">newtype</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">Expr</span> {<span class="ot"> unExpr ::</span> forall a <span class="fu">.</span> <span class="dt">ExprP</span> a }

<span class="ot">eval ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
eval e <span class="fu">=</span> ev (unExpr e) <span class="kw">where</span>
  ev (<span class="dt">LamP</span> f)      <span class="fu">=</span> <span class="dt">VFun</span>(ev <span class="fu">.</span> f)
  ev (<span class="dt">VarP</span> v)      <span class="fu">=</span> v
  ev (<span class="dt">AppP</span> e1 e2)  <span class="fu">=</span> fromVFun (ev e1) (ev e2)
  ev (<span class="dt">LitP</span> n)      <span class="fu">=</span> <span class="dt">VLit</span> n

<span class="ot">i ::</span> <span class="dt">ExprP</span> a
i <span class="fu">=</span> <span class="dt">LamP</span> (\a <span class="ot">-&gt;</span> <span class="dt">VarP</span> a)

<span class="ot">k ::</span> <span class="dt">ExprP</span> a
k <span class="fu">=</span> <span class="dt">LamP</span> (\x <span class="ot">-&gt;</span> <span class="dt">LamP</span> (\y <span class="ot">-&gt;</span> <span class="dt">VarP</span> x))

<span class="ot">s ::</span> <span class="dt">ExprP</span> a
s <span class="fu">=</span> <span class="dt">LamP</span> (\x <span class="ot">-&gt;</span> <span class="dt">LamP</span> (\y <span class="ot">-&gt;</span> <span class="dt">LamP</span> (\z <span class="ot">-&gt;</span> <span class="dt">AppP</span> (<span class="dt">AppP</span> (<span class="dt">VarP</span> x) (<span class="dt">VarP</span> z)) (<span class="dt">AppP</span> (<span class="dt">VarP</span> y) (<span class="dt">VarP</span> z)))))

<span class="ot">skk ::</span> <span class="dt">ExprP</span> a
skk <span class="fu">=</span> <span class="dt">AppP</span> (<span class="dt">AppP</span> s k) k

<span class="ot">example ::</span> <span class="dt">Integer</span>
example <span class="fu">=</span> fromVLit <span class="fu">$</span> eval <span class="fu">$</span> <span class="dt">Expr</span> (<span class="dt">AppP</span> skk (<span class="dt">LitP</span> <span class="dv">3</span>))</code></pre></div>
<p>See:</p>
<ul>
<li><a href="http://adam.chlipala.net/papers/PhoasICFP08/PhoasICFP08Talk.pdf">PHOAS</a></li>
<li><a href="http://www.seas.upenn.edu/~sweirich/papers/itabox/icfp-published-version.pdf">Encoding Higher-Order Abstract Syntax with Parametric Polymorphism</a></li>
</ul>
<h2 id="final-interpreters">Final Interpreters</h2>
<p>Using typeclasses we can implement a <em>final interpreter</em> which models a set of extensible terms using functions bound to typeclasses rather than data constructors. Instances of the typeclass form interpreters over these terms.</p>
<p>For example we can write a small language that includes basic arithmetic, and then retroactively extend our expression language with a multiplication operator without changing the base. At the same time our interpreter logic remains invariant under extension with new expressions.</p>
<div class="sourceCode" include="src/14-interpreters/fext.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE FlexibleContexts #-}</span>
<span class="ot">{-# LANGUAGE TypeSynonymInstances #-}</span>
<span class="ot">{-# LANGUAGE NoMonomorphismRestriction #-}</span>

<span class="kw">class</span> <span class="dt">Expr</span> repr <span class="kw">where</span>
<span class="ot">  lit ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> repr
<span class="ot">  neg ::</span> repr <span class="ot">-&gt;</span> repr
<span class="ot">  add ::</span> repr <span class="ot">-&gt;</span> repr <span class="ot">-&gt;</span> repr
<span class="ot">  mul ::</span> repr <span class="ot">-&gt;</span> repr <span class="ot">-&gt;</span> repr

<span class="kw">instance</span> <span class="dt">Expr</span> <span class="dt">Int</span> <span class="kw">where</span>
  lit n <span class="fu">=</span> n
  neg a <span class="fu">=</span> <span class="fu">-</span>a
  add a b <span class="fu">=</span> a <span class="fu">+</span> b
  mul a b <span class="fu">=</span> a <span class="fu">*</span> b

<span class="kw">instance</span> <span class="dt">Expr</span> <span class="dt">String</span> <span class="kw">where</span>
  lit n <span class="fu">=</span> show n
  neg a <span class="fu">=</span> <span class="st">&quot;(-&quot;</span> <span class="fu">++</span> a <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
  add a b <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> a <span class="fu">++</span> <span class="st">&quot; + &quot;</span> <span class="fu">++</span> b <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
  mul a b <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> a <span class="fu">++</span> <span class="st">&quot; * &quot;</span> <span class="fu">++</span> b <span class="fu">++</span> <span class="st">&quot;)&quot;</span>

<span class="kw">class</span> <span class="dt">BoolExpr</span> repr <span class="kw">where</span>
<span class="ot">  eq ::</span> repr <span class="ot">-&gt;</span> repr <span class="ot">-&gt;</span> repr
<span class="ot">  tr ::</span> repr
<span class="ot">  fl ::</span> repr

<span class="kw">instance</span> <span class="dt">BoolExpr</span> <span class="dt">Int</span> <span class="kw">where</span>
  eq a b <span class="fu">=</span> <span class="kw">if</span> a <span class="fu">==</span> b <span class="kw">then</span> tr <span class="kw">else</span> fl
  tr <span class="fu">=</span> <span class="dv">1</span>
  fl <span class="fu">=</span> <span class="dv">0</span>

<span class="kw">instance</span> <span class="dt">BoolExpr</span> <span class="dt">String</span> <span class="kw">where</span>
  eq a b <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> a <span class="fu">++</span> <span class="st">&quot; == &quot;</span> <span class="fu">++</span> b <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
  tr <span class="fu">=</span> <span class="st">&quot;true&quot;</span>
  fl <span class="fu">=</span> <span class="st">&quot;false&quot;</span>

<span class="ot">eval ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
eval <span class="fu">=</span> id

<span class="ot">render ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
render <span class="fu">=</span> id

<span class="ot">expr ::</span> (<span class="dt">BoolExpr</span> repr, <span class="dt">Expr</span> repr) <span class="ot">=&gt;</span> repr
expr <span class="fu">=</span> eq (add (lit <span class="dv">1</span>) (lit <span class="dv">2</span>)) (lit <span class="dv">3</span>)

<span class="ot">result ::</span> <span class="dt">Int</span>
result <span class="fu">=</span> eval expr
<span class="co">-- 1</span>

<span class="ot">string ::</span> <span class="dt">String</span>
string <span class="fu">=</span> render expr
<span class="co">-- &quot;((1 + 2) == 3)&quot;</span></code></pre></div>
<h2 id="finally-tagless">Finally Tagless</h2>
<p>Writing an evaluator for the lambda calculus can likewise also be modeled with a final interpreter and a Identity functor.</p>
<div class="sourceCode" include="src/14-interpreters/final.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (id)

<span class="kw">class</span> <span class="dt">Expr</span> rep <span class="kw">where</span>
<span class="ot">  lam ::</span> (rep a <span class="ot">-&gt;</span> rep b) <span class="ot">-&gt;</span> rep (a <span class="ot">-&gt;</span> b)
<span class="ot">  app ::</span> rep (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (rep a <span class="ot">-&gt;</span> rep b)
<span class="ot">  lit ::</span> a <span class="ot">-&gt;</span> rep a

<span class="kw">newtype</span> <span class="dt">Interpret</span> a <span class="fu">=</span> <span class="dt">R</span> {<span class="ot"> reify ::</span> a }

<span class="kw">instance</span> <span class="dt">Expr</span> <span class="dt">Interpret</span> <span class="kw">where</span>
  lam f   <span class="fu">=</span> <span class="dt">R</span> <span class="fu">$</span> reify <span class="fu">.</span> f <span class="fu">.</span> <span class="dt">R</span>
  app f a <span class="fu">=</span> <span class="dt">R</span> <span class="fu">$</span> reify f <span class="fu">$</span> reify a
  lit     <span class="fu">=</span> <span class="dt">R</span>

<span class="ot">eval ::</span> <span class="dt">Interpret</span> a <span class="ot">-&gt;</span> a
eval e <span class="fu">=</span> reify e

<span class="ot">e1 ::</span> <span class="dt">Expr</span> rep <span class="ot">=&gt;</span> rep <span class="dt">Int</span>
e1 <span class="fu">=</span> app (lam (\x <span class="ot">-&gt;</span> x)) (lit <span class="dv">3</span>)

<span class="ot">e2 ::</span> <span class="dt">Expr</span> rep <span class="ot">=&gt;</span> rep <span class="dt">Int</span>
e2 <span class="fu">=</span> app (lam (\x <span class="ot">-&gt;</span> lit <span class="dv">4</span>)) (lam <span class="fu">$</span> \x <span class="ot">-&gt;</span> lam <span class="fu">$</span> \y <span class="ot">-&gt;</span> y)

<span class="ot">example1 ::</span> <span class="dt">Int</span>
example1 <span class="fu">=</span> eval e1
<span class="co">-- 3</span>

<span class="ot">example2 ::</span> <span class="dt">Int</span>
example2 <span class="fu">=</span> eval e2
<span class="co">-- 4</span></code></pre></div>
<p>See: <a href="http://okmij.org/ftp/tagless-final/">Typed Tagless Interpretations and Typed Compilation</a></p>
<h2 id="datatypes">Datatypes</h2>
<p>The usual hand-wavy of describing algebraic datatypes is to indicate the how natural correspondence between sum types, product types, and polynomial expressions arises.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Void</span>                       <span class="co">-- 0</span>
<span class="kw">data</span> <span class="dt">Unit</span>     <span class="fu">=</span> <span class="dt">Unit</span>            <span class="co">-- 1</span>
<span class="kw">data</span> <span class="dt">Sum</span> a b  <span class="fu">=</span> <span class="dt">Inl</span> a <span class="fu">|</span> <span class="dt">Inr</span> b   <span class="co">-- a + b</span>
<span class="kw">data</span> <span class="dt">Prod</span> a b <span class="fu">=</span> <span class="dt">Prod</span> a b        <span class="co">-- a * b</span>
<span class="kw">type</span> (<span class="ot">-&gt;</span>) a b <span class="fu">=</span> a <span class="ot">-&gt;</span> b          <span class="co">-- b ^ a</span></code></pre></div>
<p>Intuitively it follows the notion that the cardinality of set of inhabitants of a type can always be given as a function of the number of its holes. A product type admits a number of inhabitants as a function of the product (i.e. cardinality of the Cartesian product), a sum type as the sum of its holes and a function type as the exponential of the span of the domain and codomain.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- 1 + A</span>
<span class="kw">data</span> <span class="dt">Maybe</span> a <span class="fu">=</span> <span class="dt">Nothing</span> <span class="fu">|</span> <span class="dt">Just</span> a</code></pre></div>
<p>Recursive types are correspond to infinite series of these terms.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- pseudocode</span>

<span class="co">-- μX. 1 + X</span>
<span class="kw">data</span> <span class="dt">Nat</span> a <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Nat</span>
<span class="dt">Nat</span> a <span class="fu">=</span> μ a<span class="fu">.</span> <span class="dv">1</span> <span class="fu">+</span> a
      <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="fu">...</span>))

<span class="co">-- μX. 1 + A * X</span>
<span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)
<span class="dt">List</span> a <span class="fu">=</span> μ a<span class="fu">.</span> <span class="dv">1</span> <span class="fu">+</span> a <span class="fu">*</span> (<span class="dt">List</span> a)
       <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> a <span class="fu">+</span> a<span class="fu">^</span><span class="dv">2</span> <span class="fu">+</span> a<span class="fu">^</span><span class="dv">3</span> <span class="fu">+</span> a<span class="fu">^</span><span class="dv">4</span> <span class="fu">...</span>

<span class="co">-- μX. A + A*X*X</span>
<span class="kw">data</span> <span class="dt">Tree</span> a f <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Tree</span> a f f
<span class="dt">Tree</span> a <span class="fu">=</span> μ a<span class="fu">.</span> <span class="dv">1</span> <span class="fu">+</span> a <span class="fu">*</span> (<span class="dt">List</span> a)
       <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> a<span class="fu">^</span><span class="dv">2</span> <span class="fu">+</span> a<span class="fu">^</span><span class="dv">4</span> <span class="fu">+</span> a<span class="fu">^</span><span class="dv">6</span> <span class="fu">+</span> a<span class="fu">^</span><span class="dv">8</span> <span class="fu">...</span></code></pre></div>
<p>See: <a href="http://www.cis.upenn.edu/~byorgey/papers/species-pearl.pdf">Species and Functors and Types, Oh My!</a></p>
<h2 id="f-algebras">F-Algebras</h2>
<div class="alert alert-danger">
<p>This is an advanced section, and is not typically necessary to write Haskell.</p>
</div>
<p>The <em>initial algebra</em> approach differs from the final interpreter approach in that we now represent our terms as algebraic datatypes and the interpreter implements recursion and evaluation occurs through pattern matching.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Algebra</span> f a <span class="fu">=</span> f a <span class="ot">-&gt;</span> a
<span class="kw">type</span> <span class="dt">Coalgebra</span> f a <span class="fu">=</span> a <span class="ot">-&gt;</span> f a
<span class="kw">newtype</span> <span class="dt">Fix</span> f <span class="fu">=</span> <span class="dt">Fix</span> {<span class="ot"> unFix ::</span> f (<span class="dt">Fix</span> f) }

<span class="ot">cata ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Algebra</span> f a <span class="ot">-&gt;</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> a
<span class="ot">ana  ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Coalgebra</span> f a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Fix</span> f
<span class="ot">hylo ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Algebra</span> f b <span class="ot">-&gt;</span> <span class="dt">Coalgebra</span> f a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</code></pre></div>
<p>In Haskell a F-algebra is a functor <code>f a</code> together with a function <code>f a -&gt; a</code>. A coalgebra reverses the function. For a functor <code>f</code> we can form its recursive unrolling using the recursive <code>Fix</code> newtype wrapper.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Fix</span> f <span class="fu">=</span> <span class="dt">Fix</span> {<span class="ot"> unFix ::</span> f (<span class="dt">Fix</span> f) }

<span class="dt">Fix</span><span class="ot"> ::</span> f (<span class="dt">Fix</span> f) <span class="ot">-&gt;</span> <span class="dt">Fix</span> f
<span class="ot">unFix ::</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> f (<span class="dt">Fix</span> f)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Fix</span> f <span class="fu">=</span> f (f (f (f (f (f ( <span class="fu">...</span> ))))))

<span class="kw">newtype</span> <span class="dt">T</span> b a <span class="fu">=</span> <span class="dt">T</span> (a <span class="ot">-&gt;</span> b)

<span class="dt">Fix</span> (<span class="dt">T</span> a)
<span class="dt">Fix</span> <span class="dt">T</span> <span class="ot">-&gt;</span> a
(<span class="dt">Fix</span> <span class="dt">T</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a
(<span class="dt">Fix</span> <span class="dt">T</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="fu">...</span></code></pre></div>
<p>In this form we can write down a generalized fold/unfold function that are datatype generic and written purely in terms of the recursing under the functor.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">cata ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Algebra</span> f a <span class="ot">-&gt;</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> a
cata alg <span class="fu">=</span> alg <span class="fu">.</span> fmap (cata alg) <span class="fu">.</span> unFix

<span class="ot">ana ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Coalgebra</span> f a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Fix</span> f
ana coalg <span class="fu">=</span> <span class="dt">Fix</span> <span class="fu">.</span> fmap (ana coalg) <span class="fu">.</span> coalg</code></pre></div>
<p>We call these functions <em>catamorphisms</em> and <em>anamorphisms</em>. Notice especially that the types of these two functions simply reverse the direction of arrows. Interpreted in another way they transform an algebra/coalgebra which defines a flat structure-preserving mapping between <code>Fix f</code> <code>f</code> into a function which either rolls or unrolls the fixpoint. What is particularly nice about this approach is that the recursion is abstracted away inside the functor definition and we are free to just implement the flat transformation logic!</p>
<p>For example a construction of the natural numbers in this form:</p>
<div class="sourceCode" include="src/14-interpreters/initial.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE DeriveFunctor #-}</span>
<span class="ot">{-# LANGUAGE StandaloneDeriving #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>

<span class="kw">type</span> <span class="dt">Algebra</span> f a <span class="fu">=</span> f a <span class="ot">-&gt;</span> a
<span class="kw">type</span> <span class="dt">Coalgebra</span> f a <span class="fu">=</span> a <span class="ot">-&gt;</span> f a

<span class="kw">newtype</span> <span class="dt">Fix</span> f <span class="fu">=</span> <span class="dt">Fix</span> {<span class="ot"> unFix ::</span> f (<span class="dt">Fix</span> f) }

<span class="co">-- catamorphism</span>
<span class="ot">cata ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Algebra</span> f a <span class="ot">-&gt;</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> a
cata alg <span class="fu">=</span> alg <span class="fu">.</span> fmap (cata alg) <span class="fu">.</span> unFix

<span class="co">-- anamorphism</span>
<span class="ot">ana ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Coalgebra</span> f a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Fix</span> f
ana coalg <span class="fu">=</span> <span class="dt">Fix</span> <span class="fu">.</span> fmap (ana coalg) <span class="fu">.</span> coalg

<span class="co">-- hylomorphism</span>
<span class="ot">hylo ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Algebra</span> f b <span class="ot">-&gt;</span> <span class="dt">Coalgebra</span> f a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b
hylo f g <span class="fu">=</span> cata f <span class="fu">.</span> ana g

<span class="kw">type</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Fix</span> <span class="dt">NatF</span>
<span class="kw">data</span> <span class="dt">NatF</span> a <span class="fu">=</span> <span class="dt">S</span> a <span class="fu">|</span> <span class="dt">Z</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">NatF</span> <span class="kw">where</span>
  fmap f <span class="dt">Z</span>     <span class="fu">=</span> <span class="dt">Z</span>
  fmap f (<span class="dt">S</span> x) <span class="fu">=</span> <span class="dt">S</span> (f x)

<span class="ot">plus ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span>
plus n <span class="fu">=</span> cata phi <span class="kw">where</span>
  phi <span class="dt">Z</span>     <span class="fu">=</span> n
  phi (<span class="dt">S</span> m) <span class="fu">=</span> s m

<span class="ot">times ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span>
times n <span class="fu">=</span> cata phi <span class="kw">where</span>
  phi <span class="dt">Z</span>     <span class="fu">=</span> z
  phi (<span class="dt">S</span> m) <span class="fu">=</span> plus n m

<span class="ot">int ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
int <span class="fu">=</span> cata phi <span class="kw">where</span>
  phi  <span class="dt">Z</span>    <span class="fu">=</span> <span class="dv">0</span>
  phi (<span class="dt">S</span> f) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> f

<span class="ot">nat ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span>
nat <span class="fu">=</span> ana (psi <span class="dt">Z</span> <span class="dt">S</span>) <span class="kw">where</span>
  psi f _ <span class="dv">0</span> <span class="fu">=</span> f
  psi _ f n <span class="fu">=</span> f (n<span class="fu">-</span><span class="dv">1</span>)

<span class="ot">z ::</span> <span class="dt">Nat</span>
z <span class="fu">=</span> <span class="dt">Fix</span> <span class="dt">Z</span>

<span class="ot">s ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span>
s <span class="fu">=</span> <span class="dt">Fix</span> <span class="fu">.</span> <span class="dt">S</span>


<span class="kw">type</span> <span class="dt">Str</span> <span class="fu">=</span> <span class="dt">Fix</span> <span class="dt">StrF</span>
<span class="kw">data</span> <span class="dt">StrF</span> x <span class="fu">=</span> <span class="dt">Cons</span> <span class="dt">Char</span> x <span class="fu">|</span> <span class="dt">Nil</span>

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">StrF</span> <span class="kw">where</span>
  fmap f (<span class="dt">Cons</span> a as) <span class="fu">=</span> <span class="dt">Cons</span> a (f as)
  fmap f <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nil</span>

<span class="ot">nil ::</span> <span class="dt">Str</span>
nil <span class="fu">=</span> <span class="dt">Fix</span> <span class="dt">Nil</span>

<span class="ot">cons ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Str</span> <span class="ot">-&gt;</span> <span class="dt">Str</span>
cons x xs <span class="fu">=</span> <span class="dt">Fix</span> (<span class="dt">Cons</span> x xs)

<span class="ot">str ::</span> <span class="dt">Str</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
str <span class="fu">=</span> cata phi <span class="kw">where</span>
  phi <span class="dt">Nil</span>         <span class="fu">=</span> []
  phi (<span class="dt">Cons</span> x xs) <span class="fu">=</span> x <span class="fu">:</span> xs

<span class="ot">str&#39; ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Str</span>
str&#39; <span class="fu">=</span> ana (psi <span class="dt">Nil</span> <span class="dt">Cons</span>) <span class="kw">where</span>
  psi f _ []     <span class="fu">=</span> f
  psi _ f (a<span class="fu">:</span>as) <span class="fu">=</span> f a as

<span class="ot">map&#39; ::</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>) <span class="ot">-&gt;</span> <span class="dt">Str</span> <span class="ot">-&gt;</span> <span class="dt">Str</span>
map&#39; f <span class="fu">=</span> hylo g unFix
  <span class="kw">where</span>
    g <span class="dt">Nil</span>        <span class="fu">=</span> <span class="dt">Fix</span> <span class="dt">Nil</span>
    g (<span class="dt">Cons</span> a x) <span class="fu">=</span> <span class="dt">Fix</span> <span class="fu">$</span> <span class="dt">Cons</span> (f a) x


<span class="kw">type</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Fix</span> (<span class="dt">TreeF</span> a)
<span class="kw">data</span> <span class="dt">TreeF</span> a f <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Tree</span> a f f <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">TreeF</span> a) <span class="kw">where</span>
  fmap f (<span class="dt">Leaf</span> a) <span class="fu">=</span> <span class="dt">Leaf</span> a
  fmap f (<span class="dt">Tree</span> a b c) <span class="fu">=</span> <span class="dt">Tree</span> a (f b) (f c)

<span class="ot">depth ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span>
depth <span class="fu">=</span> cata phi <span class="kw">where</span>
  phi (<span class="dt">Leaf</span> _)     <span class="fu">=</span> <span class="dv">0</span>
  phi (<span class="dt">Tree</span> _ l r) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> max l r


<span class="ot">example1 ::</span> <span class="dt">Int</span>
example1 <span class="fu">=</span> int (plus (nat <span class="dv">125</span>) (nat <span class="dv">25</span>))
<span class="co">-- 150</span></code></pre></div>
<p>Or for example an interpreter for a small expression language that depends on a scoping dictionary.</p>
<div class="sourceCode" include="src/14-interpreters/initial_interpreter.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">{-# LANGUAGE DeriveFunctor #-}</span>
<span class="ot">{-# LANGUAGE StandaloneDeriving #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>

<span class="kw">import </span><span class="dt">Control.Applicative</span>
<span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span>

<span class="kw">type</span> <span class="dt">Algebra</span> f a <span class="fu">=</span> f a <span class="ot">-&gt;</span> a
<span class="kw">type</span> <span class="dt">Coalgebra</span> f a <span class="fu">=</span> a <span class="ot">-&gt;</span> f a

<span class="kw">newtype</span> <span class="dt">Fix</span> f <span class="fu">=</span> <span class="dt">Fix</span> {<span class="ot"> unFix ::</span> f (<span class="dt">Fix</span> f) }

<span class="ot">cata ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Algebra</span> f a <span class="ot">-&gt;</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> a
cata alg <span class="fu">=</span> alg <span class="fu">.</span> fmap (cata alg) <span class="fu">.</span> unFix

<span class="ot">ana ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Coalgebra</span> f a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Fix</span> f
ana coalg <span class="fu">=</span> <span class="dt">Fix</span> <span class="fu">.</span> fmap (ana coalg) <span class="fu">.</span> coalg

<span class="ot">hylo ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Algebra</span> f b <span class="ot">-&gt;</span> <span class="dt">Coalgebra</span> f a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b
hylo f g <span class="fu">=</span> cata f <span class="fu">.</span> ana g

<span class="kw">type</span> <span class="dt">Id</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> <span class="dt">M.Map</span> <span class="dt">Id</span> <span class="dt">Int</span>

<span class="kw">type</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">Fix</span> <span class="dt">ExprF</span>
<span class="kw">data</span> <span class="dt">ExprF</span> a
  <span class="fu">=</span> <span class="dt">Lit</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">Var</span> <span class="dt">Id</span>
  <span class="fu">|</span> <span class="dt">Add</span> a a
  <span class="fu">|</span> <span class="dt">Mul</span> a a
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Functor</span>)

<span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Eq</span> (f (<span class="dt">Fix</span> f)) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Fix</span> f)
<span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Ord</span> (f (<span class="dt">Fix</span> f)) <span class="ot">=&gt;</span> <span class="dt">Ord</span> (<span class="dt">Fix</span> f)
<span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> (f (<span class="dt">Fix</span> f)) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Fix</span> f)

<span class="ot">eval ::</span> <span class="dt">M.Map</span> <span class="dt">Id</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Fix</span> <span class="dt">ExprF</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
eval env <span class="fu">=</span> cata phi <span class="kw">where</span>
  phi ex <span class="fu">=</span> <span class="kw">case</span> ex <span class="kw">of</span>
    <span class="dt">Lit</span> c   <span class="ot">-&gt;</span> pure c
    <span class="dt">Var</span> i   <span class="ot">-&gt;</span> M.lookup i env
    <span class="dt">Add</span> x y <span class="ot">-&gt;</span> liftA2 (<span class="fu">+</span>) x y
    <span class="dt">Mul</span> x y <span class="ot">-&gt;</span> liftA2 (<span class="fu">*</span>) x y

<span class="ot">expr ::</span> <span class="dt">Expr</span>
expr <span class="fu">=</span> <span class="dt">Fix</span> (<span class="dt">Mul</span> n (<span class="dt">Fix</span> (<span class="dt">Add</span> x y)))
  <span class="kw">where</span>
    n <span class="fu">=</span> <span class="dt">Fix</span> (<span class="dt">Lit</span> <span class="dv">10</span>)
    x <span class="fu">=</span> <span class="dt">Fix</span> (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>)
    y <span class="fu">=</span> <span class="dt">Fix</span> (<span class="dt">Var</span> <span class="st">&quot;y&quot;</span>)

<span class="ot">env ::</span> <span class="dt">M.Map</span> <span class="dt">Id</span> <span class="dt">Int</span>
env <span class="fu">=</span> M.fromList [(<span class="st">&quot;x&quot;</span>, <span class="dv">1</span>), (<span class="st">&quot;y&quot;</span>, <span class="dv">2</span>)]

<span class="ot">compose ::</span> (f (<span class="dt">Fix</span> f) <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Fix</span> f) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c
compose x y <span class="fu">=</span> x <span class="fu">.</span> unFix <span class="fu">.</span> y

<span class="ot">example ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
example <span class="fu">=</span> eval env expr
<span class="co">-- Just 30</span></code></pre></div>
<p>What's especially nice about this approach is how naturally catamorphisms compose into efficient composite transformations.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">compose ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (f (<span class="dt">Fix</span> f) <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Fix</span> f) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c
compose f g <span class="fu">=</span> f <span class="fu">.</span> unFix <span class="fu">.</span> g</code></pre></div>
<ul>
<li><a href="https://www.fpcomplete.com/user/bartosz/understanding-algebras">Understanding F-Algebras</a></li>
</ul>
<h2 id="recursion-schemes">recursion-schemes</h2>
<div class="alert alert-danger">
<p>This is an advanced section, and is not typically necessary to write Haskell.</p>
</div>
<p>The code from the F-algebra examples above is implemented in an off-the-shelf library called <code>recursion-schemes</code>.</p>
<div class="sourceCode" include="src/14-interpreters/recursion_schemes.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE DeriveFunctor #-}</span>

<span class="kw">import </span><span class="dt">Data.Functor.Foldable</span>

<span class="kw">type</span> <span class="dt">Var</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="kw">data</span> <span class="dt">Exp</span>
  <span class="fu">=</span> <span class="dt">Var</span> <span class="dt">Var</span>
  <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
  <span class="fu">|</span> <span class="dt">Lam</span> [<span class="dt">Var</span>] <span class="dt">Exp</span>
  <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">data</span> <span class="dt">ExpF</span> a
  <span class="fu">=</span> <span class="dt">VarF</span> <span class="dt">Var</span>
  <span class="fu">|</span> <span class="dt">AppF</span> a a
  <span class="fu">|</span> <span class="dt">LamF</span> [<span class="dt">Var</span>] a
  <span class="kw">deriving</span> <span class="dt">Functor</span>

<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Base</span> <span class="dt">Exp</span> <span class="fu">=</span> <span class="dt">ExpF</span>

<span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">Exp</span> <span class="kw">where</span>
  project (<span class="dt">Var</span> a)     <span class="fu">=</span> <span class="dt">VarF</span> a
  project (<span class="dt">App</span> a b)   <span class="fu">=</span> <span class="dt">AppF</span> a b
  project (<span class="dt">Lam</span> a b)   <span class="fu">=</span> <span class="dt">LamF</span> a b

<span class="kw">instance</span> <span class="dt">Unfoldable</span> <span class="dt">Exp</span> <span class="kw">where</span>
  embed (<span class="dt">VarF</span> a)      <span class="fu">=</span> <span class="dt">Var</span> a
  embed (<span class="dt">AppF</span> a b)    <span class="fu">=</span> <span class="dt">App</span> a b
  embed (<span class="dt">LamF</span> a b)    <span class="fu">=</span> <span class="dt">Lam</span> a b

<span class="ot">fvs ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> [<span class="dt">Var</span>]
fvs <span class="fu">=</span> cata phi
  <span class="kw">where</span> phi (<span class="dt">VarF</span> a)    <span class="fu">=</span> [a]
        phi (<span class="dt">AppF</span> a b)  <span class="fu">=</span> a <span class="fu">++</span> b
        phi (<span class="dt">LamF</span> a b) <span class="fu">=</span> foldr (filter <span class="fu">.</span> (<span class="fu">/=</span>)) a b</code></pre></div>
<p>An example of usage:</p>
<div class="sourceCode" include="src/14-interpreters/catamorphism.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span>
<span class="ot">{-# LANGUAGE KindSignatures #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE TypeSynonymInstances #-}</span>

<span class="kw">import </span><span class="dt">Data.Traversable</span>
<span class="kw">import </span><span class="dt">Control.Monad</span> <span class="kw">hiding</span> (forM_, mapM, sequence)
<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (mapM)
<span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span>

<span class="kw">newtype</span> <span class="dt">Fix</span> (<span class="ot">f ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="fu">=</span> <span class="dt">Fix</span> {<span class="ot"> outF ::</span> f (<span class="dt">Fix</span> f) }

<span class="co">-- Catamorphism</span>
<span class="ot">cata ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> a
cata f <span class="fu">=</span> f <span class="fu">.</span> fmap (cata f) <span class="fu">.</span> outF

<span class="co">-- Monadic catamorphism</span>
<span class="ot">cataM ::</span> (<span class="dt">Traversable</span> f, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (f a <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> m a
cataM f <span class="fu">=</span> f <span class="fu">&lt;=&lt;</span> mapM (cataM f) <span class="fu">.</span> outF

<span class="kw">data</span> <span class="dt">ExprF</span> r
  <span class="fu">=</span> <span class="dt">EVar</span> <span class="dt">String</span>
  <span class="fu">|</span> <span class="dt">EApp</span> r r
  <span class="fu">|</span> <span class="dt">ELam</span> r r
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Functor</span>)

<span class="kw">type</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">Fix</span> <span class="dt">ExprF</span>

<span class="kw">instance</span> <span class="dt">Show</span> (<span class="dt">Fix</span> <span class="dt">ExprF</span>) <span class="kw">where</span>
  show (<span class="dt">Fix</span> f) <span class="fu">=</span> show f

<span class="kw">instance</span> <span class="dt">Eq</span> (<span class="dt">Fix</span> <span class="dt">ExprF</span>) <span class="kw">where</span>
  <span class="dt">Fix</span> x <span class="fu">==</span> <span class="dt">Fix</span> y <span class="fu">=</span> x <span class="fu">==</span> y

<span class="kw">instance</span> <span class="dt">Ord</span> (<span class="dt">Fix</span> <span class="dt">ExprF</span>) <span class="kw">where</span>
  compare (<span class="dt">Fix</span> x) (<span class="dt">Fix</span> y) <span class="fu">=</span> compare x y


<span class="ot">mkApp ::</span> <span class="dt">Fix</span> <span class="dt">ExprF</span> <span class="ot">-&gt;</span> <span class="dt">Fix</span> <span class="dt">ExprF</span> <span class="ot">-&gt;</span> <span class="dt">Fix</span> <span class="dt">ExprF</span>
mkApp x y <span class="fu">=</span> <span class="dt">Fix</span> (<span class="dt">EApp</span> x y)

<span class="ot">mkVar ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Fix</span> <span class="dt">ExprF</span>
mkVar x <span class="fu">=</span> <span class="dt">Fix</span> (<span class="dt">EVar</span> x)

<span class="ot">mkLam ::</span> <span class="dt">Fix</span> <span class="dt">ExprF</span> <span class="ot">-&gt;</span> <span class="dt">Fix</span> <span class="dt">ExprF</span> <span class="ot">-&gt;</span> <span class="dt">Fix</span> <span class="dt">ExprF</span>
mkLam x y <span class="fu">=</span> <span class="dt">Fix</span> (<span class="dt">ELam</span> x y)

<span class="ot">i ::</span> <span class="dt">Fix</span> <span class="dt">ExprF</span>
i <span class="fu">=</span> mkLam (mkVar <span class="st">&quot;x&quot;</span>) (mkVar <span class="st">&quot;x&quot;</span>)

<span class="ot">k ::</span> <span class="dt">Fix</span> <span class="dt">ExprF</span>
k <span class="fu">=</span> mkLam (mkVar <span class="st">&quot;x&quot;</span>) <span class="fu">$</span> mkLam (mkVar <span class="st">&quot;y&quot;</span>) <span class="fu">$</span> (mkVar <span class="st">&quot;x&quot;</span>)

<span class="ot">subst ::</span> <span class="dt">M.Map</span> <span class="dt">String</span> (<span class="dt">ExprF</span> <span class="dt">Expr</span>) <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span>
subst env <span class="fu">=</span> cata alg <span class="kw">where</span>
  alg (<span class="dt">EVar</span> x) <span class="fu">|</span> <span class="dt">Just</span> e <span class="ot">&lt;-</span> M.lookup x env <span class="fu">=</span> <span class="dt">Fix</span> e
  alg e <span class="fu">=</span> <span class="dt">Fix</span> e</code></pre></div>
<p>See:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/recursion-schemes">recursion-schemes</a></li>
</ul>
<h2 id="data-types-à-la-carte">Data types à la carte</h2>
<p>TODO</p>
<h2 id="hint-and-mueval">Hint and Mueval</h2>
<div class="alert alert-danger">
<p>This is an advanced section, and is not typically necessary to write Haskell.</p>
</div>
<p>GHC itself can actually interpret arbitrary Haskell source on the fly by hooking into the GHC's bytecode interpreter ( the same used for GHCi ). The hint package allows us to parse, typecheck, and evaluate arbitrary strings into arbitrary Haskell programs and evaluate them.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Language.Haskell.Interpreter</span>

<span class="ot">foo ::</span> <span class="dt">Interpreter</span> <span class="dt">String</span>
foo <span class="fu">=</span> eval <span class="st">&quot;(\\x -&gt; x) 1&quot;</span>

<span class="ot">example ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">InterpreterError</span> <span class="dt">String</span>)
example <span class="fu">=</span> runInterpreter foo</code></pre></div>
<p>This is generally not a wise thing to build a library around, unless of course the purpose of the program is itself to evaluate arbitrary Haskell code ( something like an online Haskell shell or the likes ).</p>
<p>Both hint and mueval do effectively the same task, designed around slightly different internals of the GHC Api.</p>
<p>See:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/mueval">hint</a></li>
<li><a href="http://hackage.haskell.org/package/mueval">mueval</a></li>
</ul>
</hr>
<h1 id="testing">Testing</h1>
<p>Contrary to a lot of misinformation, unit testing in Haskell is quite common and robust. Although generally speaking unit tests tend to be of less importance in Haskell since the type system makes an enormous amount of invalid programs completely inexpressible by construction. Unit tests tend to be written later in the development lifecycle and generally tend to be about the core logic of the program and not the intermediate plumbing.</p>
<p>A prominent school of thought on Haskell library design tends to favor constructing programs built around strong equation laws which guarantee strong invariants about program behavior under composition. Many of the testing tools are built around this style of design.</p>
<h2 id="quickcheck">QuickCheck</h2>
<p>Probably the most famous Haskell library, QuickCheck is a testing framework for generating large random tests for arbitrary functions automatically based on the types of their arguments.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">quickCheck ::</span> <span class="dt">Testable</span> prop <span class="ot">=&gt;</span> prop <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">(==&gt;) ::</span> <span class="dt">Testable</span> prop <span class="ot">=&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> prop <span class="ot">-&gt;</span> <span class="dt">Property</span>
<span class="ot">forAll ::</span> (<span class="dt">Show</span> a, <span class="dt">Testable</span> prop) <span class="ot">=&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> prop) <span class="ot">-&gt;</span> <span class="dt">Property</span>
<span class="ot">choose ::</span> <span class="dt">Random</span> a <span class="ot">=&gt;</span> (a, a) <span class="ot">-&gt;</span> <span class="dt">Gen</span> a</code></pre></div>
<div class="sourceCode" include="src/15-testing/qcheck.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Test.QuickCheck</span>

<span class="ot">qsort ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
qsort []     <span class="fu">=</span> []
qsort (x<span class="fu">:</span>xs) <span class="fu">=</span> qsort lhs <span class="fu">++</span> [x] <span class="fu">++</span> qsort rhs
    <span class="kw">where</span> lhs <span class="fu">=</span> filter  (<span class="fu">&lt;</span> x) xs
          rhs <span class="fu">=</span> filter (<span class="fu">&gt;=</span> x) xs

<span class="ot">prop_maximum ::</span>  [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Property</span>
prop_maximum xs <span class="fu">=</span> not (null xs) <span class="fu">==&gt;</span>
                  last (qsort xs) <span class="fu">==</span> maximum xs

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> quickCheck prop_maximum</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">runhaskell</span> qcheck.hs
<span class="kw">***</span> Failed! Falsifiable (after 3 tests and 4 shrinks)<span class="kw">:</span>
[<span class="kw">0</span>]
[<span class="kw">1</span>]

$ <span class="kw">runhaskell</span> qcheck.hs
<span class="kw">+++</span> OK, passed 1000 tests.</code></pre></div>
<p>The test data generator can be extended with custom types and refined with predicates that restrict the domain of cases to test.</p>
<div class="sourceCode" include="src/15-testing/arbitrary.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Test.QuickCheck</span>

<span class="kw">data</span> <span class="dt">Color</span> <span class="fu">=</span> <span class="dt">Red</span> <span class="fu">|</span> <span class="dt">Green</span> <span class="fu">|</span> <span class="dt">Blue</span> <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Color</span> <span class="kw">where</span>
  arbitrary <span class="fu">=</span> <span class="kw">do</span>
    n <span class="ot">&lt;-</span> choose (<span class="dv">0</span>,<span class="dv">2</span>)<span class="ot"> ::</span> <span class="dt">Gen</span> <span class="dt">Int</span>
    return <span class="fu">$</span> <span class="kw">case</span> n <span class="kw">of</span>
      <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="dt">Red</span>
      <span class="dv">1</span> <span class="ot">-&gt;</span> <span class="dt">Green</span>
      <span class="dv">2</span> <span class="ot">-&gt;</span> <span class="dt">Blue</span>

<span class="ot">example1 ::</span> <span class="dt">IO</span> [<span class="dt">Color</span>]
example1 <span class="fu">=</span> sample&#39; arbitrary
<span class="co">-- [Red,Green,Red,Blue,Red,Red,Red,Blue,Green,Red,Red]</span></code></pre></div>
<p>See: <a href="../../www.cse.chalmers.se/_rjmh/QuickCheck/manual.html">QuickCheck: An Automatic Testing Tool for Haskell</a></p>
<h2 id="smallcheck">SmallCheck</h2>
<p>Like QuickCheck, SmallCheck is a property testing system but instead of producing random arbitrary test data it instead enumerates a deterministic series of test data to a fixed depth.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">smallCheck ::</span> <span class="dt">Testable</span> <span class="dt">IO</span> a <span class="ot">=&gt;</span> <span class="dt">Depth</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">list ::</span> <span class="dt">Depth</span> <span class="ot">-&gt;</span> <span class="dt">Series</span> <span class="dt">Identity</span> a <span class="ot">-&gt;</span> [a]
<span class="ot">sample&#39; ::</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> [a]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> list <span class="dv">3</span><span class="ot"> series ::</span> [<span class="dt">Int</span>]
[<span class="dv">0</span>,<span class="dv">1</span>,<span class="fu">-</span><span class="dv">1</span>,<span class="dv">2</span>,<span class="fu">-</span><span class="dv">2</span>,<span class="dv">3</span>,<span class="fu">-</span><span class="dv">3</span>]

λ<span class="fu">:</span> list <span class="dv">3</span><span class="ot"> series ::</span> [<span class="dt">Double</span>]
[<span class="fl">0.0</span>,<span class="fl">1.0</span>,<span class="fu">-</span><span class="fl">1.0</span>,<span class="fl">2.0</span>,<span class="fl">0.5</span>,<span class="fu">-</span><span class="fl">2.0</span>,<span class="fl">4.0</span>,<span class="fl">0.25</span>,<span class="fu">-</span><span class="fl">0.5</span>,<span class="fu">-</span><span class="fl">4.0</span>,<span class="fu">-</span><span class="fl">0.25</span>]

λ<span class="fu">:</span> list <span class="dv">3</span><span class="ot"> series ::</span> [(<span class="dt">Int</span>, <span class="dt">String</span>)]
[(<span class="dv">0</span>,<span class="st">&quot;&quot;</span>),(<span class="dv">1</span>,<span class="st">&quot;&quot;</span>),(<span class="dv">0</span>,<span class="st">&quot;a&quot;</span>),(<span class="fu">-</span><span class="dv">1</span>,<span class="st">&quot;&quot;</span>),(<span class="dv">0</span>,<span class="st">&quot;b&quot;</span>),(<span class="dv">1</span>,<span class="st">&quot;a&quot;</span>),(<span class="dv">2</span>,<span class="st">&quot;&quot;</span>),(<span class="dv">1</span>,<span class="st">&quot;b&quot;</span>),(<span class="fu">-</span><span class="dv">1</span>,<span class="st">&quot;a&quot;</span>),(<span class="fu">-</span><span class="dv">2</span>,<span class="st">&quot;&quot;</span>),(<span class="fu">-</span><span class="dv">1</span>,<span class="st">&quot;b&quot;</span>),(<span class="dv">2</span>,<span class="st">&quot;a&quot;</span>),(<span class="fu">-</span><span class="dv">2</span>,<span class="st">&quot;a&quot;</span>),(<span class="dv">2</span>,<span class="st">&quot;b&quot;</span>),(<span class="fu">-</span><span class="dv">2</span>,<span class="st">&quot;b&quot;</span>)]</code></pre></div>
<p>It is useful to generate test cases over <em>all</em> possible inputs of a program up to some depth.</p>
<div class="sourceCode" include="src/15-testing/smallcheck.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Test.SmallCheck</span>

<span class="ot">distrib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
distrib a b c <span class="fu">=</span> a <span class="fu">*</span> (b <span class="fu">+</span> c) <span class="fu">==</span> a <span class="fu">*</span> b <span class="fu">+</span> a <span class="fu">*</span> c

<span class="ot">cauchy ::</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
cauchy xs ys <span class="fu">=</span> (abs (dot xs ys))<span class="fu">^</span><span class="dv">2</span> <span class="fu">&lt;=</span> (dot xs xs) <span class="fu">*</span> (dot ys ys)

<span class="ot">failure ::</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
failure xs ys <span class="fu">=</span> abs (dot xs ys) <span class="fu">&lt;=</span> (dot xs xs) <span class="fu">*</span> (dot ys ys)

<span class="ot">dot ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a
dot xs ys <span class="fu">=</span> sum (zipWith (<span class="fu">*</span>) xs ys)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  putStrLn <span class="st">&quot;Testing distributivity...&quot;</span>
  smallCheck <span class="dv">25</span> distrib

  putStrLn <span class="st">&quot;Testing Cauchy-Schwarz...&quot;</span>
  smallCheck <span class="dv">4</span> cauchy

  putStrLn <span class="st">&quot;Testing invalid Cauchy-Schwarz...&quot;</span>
  smallCheck <span class="dv">4</span> failure</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">$</span> runhaskell smallcheck<span class="fu">.</span>hs
<span class="dt">Testing</span> distributivity<span class="fu">...</span>
<span class="dt">Completed</span> <span class="dv">132651</span> tests without failure<span class="fu">.</span>

<span class="dt">Testing</span> <span class="dt">Cauchy</span><span class="fu">-Schwarz...</span>
<span class="dt">Completed</span> <span class="dv">27556</span> tests without failure<span class="fu">.</span>

<span class="dt">Testing</span> invalid <span class="dt">Cauchy</span><span class="fu">-Schwarz...</span>
<span class="dt">Failed</span> test no<span class="fu">.</span> <span class="dv">349</span><span class="fu">.</span>
there exist [<span class="fl">1.0</span>] [<span class="fl">0.5</span>] such that
  condition is false</code></pre></div>
<p>Just like for QuickCheck we can implement series instances for our custom datatypes. For example there is no default instance for Vector, so let's implement one:</p>
<div class="sourceCode" include="src/15-testing/smallcheck_series.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span>

<span class="kw">import </span><span class="dt">Test.SmallCheck</span>
<span class="kw">import </span><span class="dt">Test.SmallCheck.Series</span>
<span class="kw">import </span><span class="dt">Control.Applicative</span>

<span class="kw">import qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">V</span>

<span class="ot">dot ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">V.Vector</span> a <span class="ot">-&gt;</span> <span class="dt">V.Vector</span> a <span class="ot">-&gt;</span> a
dot xs ys <span class="fu">=</span> V.sum (V.zipWith (<span class="fu">*</span>) xs ys)

<span class="ot">cauchy ::</span> <span class="dt">V.Vector</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">V.Vector</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
cauchy xs ys <span class="fu">=</span> (abs (dot xs ys))<span class="fu">^</span><span class="dv">2</span> <span class="fu">&lt;=</span> (dot xs xs) <span class="fu">*</span> (dot ys ys)

<span class="kw">instance</span> (<span class="dt">Serial</span> m a, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Serial</span> m (<span class="dt">V.Vector</span> a) <span class="kw">where</span>
  series <span class="fu">=</span> V.fromList <span class="fu">&lt;$&gt;</span> series

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> smallCheck <span class="dv">4</span> cauchy</code></pre></div>
<p>SmallCheck can also use Generics to derive Serial instances, for example to enumerate all trees of a certain depth we might use:</p>
<div class="sourceCode" include="src/15-testing/smallcheck_tree.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class="ot">{-# LANGUAGE DeriveGeneric #-}</span>

<span class="kw">import </span><span class="dt">GHC.Generics</span>
<span class="kw">import </span><span class="dt">Test.SmallCheck.Series</span>

<span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Null</span> <span class="fu">|</span> <span class="dt">Fork</span> (<span class="dt">Tree</span> a) a (<span class="dt">Tree</span> a)
    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>)

<span class="kw">instance</span> <span class="dt">Serial</span> m a <span class="ot">=&gt;</span> <span class="dt">Serial</span> m (<span class="dt">Tree</span> a)

<span class="ot">example ::</span> [<span class="dt">Tree</span> ()]
example <span class="fu">=</span> list <span class="dv">3</span> series

main <span class="fu">=</span> print example</code></pre></div>
<h2 id="quickspec">QuickSpec</h2>
<p>Using the QuickCheck arbitrary machinery we can also rather remarkably enumerate a large number of combinations of functions to try and deduce algebraic laws from trying out inputs for small cases.</p>
<p>Of course the fundamental limitation of this approach is that a function may not exhibit any interesting properties for small cases or for simple function compositions. So in general case this approach won't work, but practically it still quite useful.</p>
<div class="sourceCode" include="src/15-testing/quickspec.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE ConstraintKinds #-}</span>
<span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span>

<span class="kw">import </span><span class="dt">Data.List</span>
<span class="kw">import </span><span class="dt">Data.Typeable</span>

<span class="kw">import </span><span class="dt">Test.QuickSpec</span> <span class="kw">hiding</span> (lists, bools, arith)
<span class="kw">import </span><span class="dt">Test.QuickCheck</span>

<span class="kw">type</span> <span class="dt">Var</span> k a <span class="fu">=</span> (<span class="dt">Typeable</span> a, <span class="dt">Arbitrary</span> a, <span class="dt">CoArbitrary</span> a, k a)

<span class="ot">listCons ::</span> forall a<span class="fu">.</span> <span class="dt">Var</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Sig</span>
listCons a <span class="fu">=</span> background
  [
    <span class="st">&quot;[]&quot;</span>      <span class="ot">`fun0`</span> ([]<span class="ot">      ::</span> [a]),
    <span class="st">&quot;:&quot;</span>       <span class="ot">`fun2`</span> (<span class="ot">(:)     ::</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a])
  ]

<span class="ot">lists ::</span> forall a<span class="fu">.</span> <span class="dt">Var</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [<span class="dt">Sig</span>]
lists a <span class="fu">=</span>
  [
    <span class="co">-- Names to print arbitrary variables</span>
    funs&#39;,
    funvars&#39;,
    vars&#39;,

    <span class="co">-- Ambient definitions</span>
    listCons a,

    <span class="co">-- Expressions to deduce properties of</span>
    <span class="st">&quot;sort&quot;</span>     <span class="ot">`fun1`</span> (sort<span class="ot">    ::</span> [a] <span class="ot">-&gt;</span> [a]),
    <span class="st">&quot;map&quot;</span>      <span class="ot">`fun2`</span> (map<span class="ot">     ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]),
    <span class="st">&quot;id&quot;</span>       <span class="ot">`fun1`</span> (id<span class="ot">      ::</span> [a] <span class="ot">-&gt;</span> [a]),
    <span class="st">&quot;reverse&quot;</span>  <span class="ot">`fun1`</span> (reverse<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]),
    <span class="st">&quot;minimum&quot;</span>  <span class="ot">`fun1`</span> (minimum<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> a),
    <span class="st">&quot;length&quot;</span>   <span class="ot">`fun1`</span> (length<span class="ot">  ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span>),
    <span class="st">&quot;++&quot;</span>       <span class="ot">`fun2`</span> (<span class="ot">(++)    ::</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a])
  ]

  <span class="kw">where</span>
    funs&#39;    <span class="fu">=</span> funs (undefined<span class="ot"> ::</span> a)
    funvars&#39; <span class="fu">=</span> vars [<span class="st">&quot;f&quot;</span>, <span class="st">&quot;g&quot;</span>, <span class="st">&quot;h&quot;</span>] (undefined<span class="ot"> ::</span> a <span class="ot">-&gt;</span> a)
    vars&#39;    <span class="fu">=</span> [<span class="st">&quot;xs&quot;</span>, <span class="st">&quot;ys&quot;</span>, <span class="st">&quot;zs&quot;</span>] <span class="ot">`vars`</span> (undefined<span class="ot"> ::</span> [a])


<span class="ot">tvar ::</span> <span class="dt">A</span>
tvar <span class="fu">=</span> undefined

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> quickSpec (lists tvar)</code></pre></div>
<p>Running this we rather see it is able to deduce most of the laws for list functions.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">runhaskell</span> src/quickspec.hs
== <span class="kw">API</span> ==
<span class="kw">--</span> functions --
<span class="kw">map</span> :: (A -<span class="kw">&gt;</span> A) <span class="kw">-&gt;</span> [A] -<span class="kw">&gt;</span> [A]
<span class="kw">minimum</span> :: [A] -<span class="kw">&gt;</span> A
<span class="kw">(++)</span> :: [<span class="kw">A</span>] -<span class="kw">&gt;</span> [A] -<span class="kw">&gt;</span> [A]
<span class="kw">length</span> :: [A] -<span class="kw">&gt;</span> Int
<span class="kw">sort</span>, id, reverse :: [A] -<span class="kw">&gt;</span> [A]

<span class="kw">--</span> background functions --
<span class="kw">id</span> :: A -<span class="kw">&gt;</span> A
<span class="kw">(:)</span> :: <span class="kw">A</span> -<span class="kw">&gt;</span> [A] -<span class="kw">&gt;</span> [A]
<span class="kw">(.)</span> :: <span class="kw">(A</span> -<span class="kw">&gt;</span> A<span class="kw">)</span> <span class="kw">-&gt;</span> (A -<span class="kw">&gt;</span> A) <span class="kw">-&gt;</span> A -<span class="kw">&gt;</span> A
[] :: [<span class="kw">A</span>]

<span class="kw">--</span> variables --
<span class="kw">f</span>, g, h :: A -<span class="kw">&gt;</span> A
<span class="kw">xs</span>, ys, zs :: [A]

<span class="kw">--</span> the following types are using non-standard equality --
<span class="kw">A</span> -<span class="kw">&gt;</span> A

<span class="kw">--</span> WARNING: there are no variables of the following types<span class="kw">;</span> <span class="kw">consider</span> adding some --
<span class="kw">A</span>

== <span class="kw">Testing</span> ==
<span class="kw">Depth</span> 1: 12 terms, 4 tests, 24 evaluations, 12 classes, 0 raw equations.
<span class="kw">Depth</span> 2: 80 terms, 500 tests, 18673 evaluations, 52 classes, 28 raw equations.
<span class="kw">Depth</span> 3: 1553 terms, 500 tests, 255056 evaluations, 1234 classes, 319 raw equations.
<span class="kw">319</span> raw equations<span class="kw">;</span> <span class="kw">1234</span> terms in universe.

== <span class="kw">Equations</span> about map ==
  <span class="kw">1</span>: map f [] == []
  <span class="kw">2</span>: map id xs == xs
  <span class="kw">3</span>: map (f.g) <span class="kw">xs</span> == map f (map g xs)

== <span class="kw">Equations</span> about minimum ==
  <span class="kw">4</span>: minimum [] == undefined

== <span class="kw">Equations</span> about (++) ==
  <span class="kw">5</span>: xs++[] == xs
  <span class="kw">6</span>: []++xs == xs
  <span class="kw">7</span>: (xs++ys)<span class="kw">++zs</span> == xs++(ys++zs)

== <span class="kw">Equations</span> about sort ==
  <span class="kw">8</span>: sort [] == []
  <span class="kw">9</span>: sort (sort xs) == <span class="kw">sort</span> xs

== <span class="kw">Equations</span> about id ==
 <span class="kw">10</span>: id xs == xs

== <span class="kw">Equations</span> about reverse ==
 <span class="kw">11</span>: reverse [] == []
 <span class="kw">12</span>: reverse (reverse xs) == <span class="kw">xs</span>

== <span class="kw">Equations</span> about several functions ==
 <span class="kw">13</span>: minimum (xs++ys) == <span class="kw">minimum</span> (ys++xs)
 <span class="kw">14</span>: length (map f xs) == <span class="kw">length</span> xs
 <span class="kw">15</span>: length (xs++ys) == <span class="kw">length</span> (ys++xs)
 <span class="kw">16</span>: sort (xs++ys) == <span class="kw">sort</span> (ys++xs)
 <span class="kw">17</span>: map f (reverse xs) == <span class="kw">reverse</span> (map f xs)
 <span class="kw">18</span>: minimum (sort xs) == <span class="kw">minimum</span> xs
 <span class="kw">19</span>: minimum (reverse xs) == <span class="kw">minimum</span> xs
 <span class="kw">20</span>: minimum (xs++xs) == <span class="kw">minimum</span> xs
 <span class="kw">21</span>: length (sort xs) == <span class="kw">length</span> xs
 <span class="kw">22</span>: length (reverse xs) == <span class="kw">length</span> xs
 <span class="kw">23</span>: sort (reverse xs) == <span class="kw">sort</span> xs
 <span class="kw">24</span>: map f xs++map f ys == map f (xs++ys)
 <span class="kw">25</span>: reverse xs++reverse ys == reverse (ys++xs)</code></pre></div>
<p>Keep in mind the rather remarkable fact that this is all deduced automatically from the types alone!</p>
<h2 id="criterion">Criterion</h2>
<p>Criterion is a statistically aware benchmarking tool.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">whnf ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Pure</span>
<span class="ot">nf ::</span> <span class="dt">NFData</span> b <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Pure</span>
<span class="ot">nfIO ::</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">bench ::</span> <span class="dt">Benchmarkable</span> b <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Benchmark</span></code></pre></div>
<div class="sourceCode" include="src/15-testing/criterion.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Criterion.Main</span>
<span class="kw">import </span><span class="dt">Criterion.Config</span>

<span class="co">-- Naive recursion for fibonacci numbers.</span>
<span class="ot">fib1 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
fib1 <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
fib1 <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span>
fib1 n <span class="fu">=</span> fib1 (n<span class="fu">-</span><span class="dv">1</span>) <span class="fu">+</span> fib1 (n<span class="fu">-</span><span class="dv">2</span>)

<span class="co">-- Use the De Moivre closed form for fibonacci numbers.</span>
<span class="ot">fib2 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
fib2 x <span class="fu">=</span> truncate <span class="fu">$</span> ( <span class="dv">1</span> <span class="fu">/</span> sqrt <span class="dv">5</span> ) <span class="fu">*</span> ( phi <span class="fu">^</span> x <span class="fu">-</span> psi <span class="fu">^</span> x )
  <span class="kw">where</span>
      phi <span class="fu">=</span> ( <span class="dv">1</span> <span class="fu">+</span> sqrt <span class="dv">5</span> ) <span class="fu">/</span> <span class="dv">2</span>
      psi <span class="fu">=</span> ( <span class="dv">1</span> <span class="fu">-</span> sqrt <span class="dv">5</span> ) <span class="fu">/</span> <span class="dv">2</span>

<span class="ot">suite ::</span> [<span class="dt">Benchmark</span>]
suite <span class="fu">=</span> [
    bgroup <span class="st">&quot;naive&quot;</span> [
      bench <span class="st">&quot;fib 10&quot;</span> <span class="fu">$</span> whnf fib1 <span class="dv">5</span>
    , bench <span class="st">&quot;fib 20&quot;</span> <span class="fu">$</span> whnf fib1 <span class="dv">10</span>
    ],
    bgroup <span class="st">&quot;de moivre&quot;</span> [
      bench <span class="st">&quot;fib 10&quot;</span> <span class="fu">$</span> whnf fib2 <span class="dv">5</span>
    , bench <span class="st">&quot;fib 20&quot;</span> <span class="fu">$</span> whnf fib2 <span class="dv">10</span>
    ]
  ]

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> defaultMain suite</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">$</span> runhaskell criterion<span class="fu">.</span>hs
warming up
estimating clock resolution<span class="fu">...</span>
mean is <span class="fl">2.349801</span> us (<span class="dv">320001</span> iterations)
found <span class="dv">1788</span> outliers among <span class="dv">319999</span> samples (<span class="fl">0.6</span><span class="fu">%</span>)
  <span class="dv">1373</span> (<span class="fl">0.4</span><span class="fu">%</span>) high severe
estimating cost <span class="kw">of</span> a clock call<span class="fu">...</span>
mean is <span class="fl">65.52118</span> ns (<span class="dv">23</span> iterations)
found <span class="dv">1</span> outliers among <span class="dv">23</span> samples (<span class="fl">4.3</span><span class="fu">%</span>)
  <span class="dv">1</span> (<span class="fl">4.3</span><span class="fu">%</span>) high severe

benchmarking naive<span class="fu">/</span>fib <span class="dv">10</span>
mean<span class="fu">:</span> <span class="fl">9.903067</span> us, lb <span class="fl">9.885143</span> us, ub <span class="fl">9.924404</span> us, ci <span class="fl">0.950</span>
std dev<span class="fu">:</span> <span class="fl">100.4508</span> ns, lb <span class="fl">85.04638</span> ns, ub <span class="fl">123.1707</span> ns, ci <span class="fl">0.950</span>

benchmarking naive<span class="fu">/</span>fib <span class="dv">20</span>
mean<span class="fu">:</span> <span class="fl">120.7269</span> us, lb <span class="fl">120.5470</span> us, ub <span class="fl">120.9459</span> us, ci <span class="fl">0.950</span>
std dev<span class="fu">:</span> <span class="fl">1.014556</span> us, lb <span class="fl">858.6037</span> ns, ub <span class="fl">1.296920</span> us, ci <span class="fl">0.950</span>

benchmarking de moivre<span class="fu">/</span>fib <span class="dv">10</span>
mean<span class="fu">:</span> <span class="fl">7.699219</span> us, lb <span class="fl">7.671107</span> us, ub <span class="fl">7.802116</span> us, ci <span class="fl">0.950</span>
std dev<span class="fu">:</span> <span class="fl">247.3021</span> ns, lb <span class="fl">61.66586</span> ns, ub <span class="fl">572.1260</span> ns, ci <span class="fl">0.950</span>
found <span class="dv">4</span> outliers among <span class="dv">100</span> samples (<span class="fl">4.0</span><span class="fu">%</span>)
  <span class="dv">2</span> (<span class="fl">2.0</span><span class="fu">%</span>) high mild
  <span class="dv">2</span> (<span class="fl">2.0</span><span class="fu">%</span>) high severe
variance introduced by outliers<span class="fu">:</span> <span class="fl">27.726</span><span class="fu">%</span>
variance is moderately inflated by outliers

benchmarking de moivre<span class="fu">/</span>fib <span class="dv">20</span>
mean<span class="fu">:</span> <span class="fl">8.082639</span> us, lb <span class="fl">8.018560</span> us, ub <span class="fl">8.350159</span> us, ci <span class="fl">0.950</span>
std dev<span class="fu">:</span> <span class="fl">595.2161</span> ns, lb <span class="fl">77.46251</span> ns, ub <span class="fl">1.408784</span> us, ci <span class="fl">0.950</span>
found <span class="dv">8</span> outliers among <span class="dv">100</span> samples (<span class="fl">8.0</span><span class="fu">%</span>)
  <span class="dv">4</span> (<span class="fl">4.0</span><span class="fu">%</span>) high mild
  <span class="dv">4</span> (<span class="fl">4.0</span><span class="fu">%</span>) high severe
variance introduced by outliers<span class="fu">:</span> <span class="fl">67.628</span><span class="fu">%</span>
variance is severely inflated by outliers</code></pre></div>
<p>Criterion can also generate a HTML page containing the benchmark results plotted</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">ghc</span> -O2 --make criterion.hs
$ <span class="kw">./criterion</span> -o bench.html</code></pre></div>
<div class="figure">
<img src="img/criterion.png" alt="" />

</div>
<h2 id="tasty">Tasty</h2>
<p>Tasty combines all of the testing frameworks into a common API for forming runnable batches of tests and collecting the results.</p>
<div class="sourceCode" include="src/15-testing/tasty.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Test.Tasty</span>
<span class="kw">import </span><span class="dt">Test.Tasty.HUnit</span>
<span class="kw">import </span><span class="dt">Test.Tasty.QuickCheck</span>
<span class="kw">import qualified</span> <span class="dt">Test.Tasty.SmallCheck</span> <span class="kw">as</span> <span class="dt">SC</span>

<span class="ot">arith ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Property</span>
arith x y <span class="fu">=</span> (x <span class="fu">&gt;</span> <span class="dv">0</span>) <span class="fu">&amp;&amp;</span> (y <span class="fu">&gt;</span> <span class="dv">0</span>) <span class="fu">==&gt;</span> (x<span class="fu">+</span>y)<span class="fu">^</span><span class="dv">2</span> <span class="fu">&gt;</span> x<span class="fu">^</span><span class="dv">2</span> <span class="fu">+</span> y<span class="fu">^</span><span class="dv">2</span>

<span class="ot">negation ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
negation x <span class="fu">=</span> abs (x<span class="fu">^</span><span class="dv">2</span>) <span class="fu">&gt;=</span> x

<span class="ot">suite ::</span> <span class="dt">TestTree</span>
suite <span class="fu">=</span> testGroup <span class="st">&quot;Test Suite&quot;</span> [
    testGroup <span class="st">&quot;Units&quot;</span>
      [ testCase <span class="st">&quot;Equality&quot;</span> <span class="fu">$</span> <span class="dt">True</span> <span class="fu">@=?</span> <span class="dt">True</span>
      , testCase <span class="st">&quot;Assertion&quot;</span> <span class="fu">$</span> assert <span class="fu">$</span> (length [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]) <span class="fu">==</span> <span class="dv">3</span>
      ],

    testGroup <span class="st">&quot;QuickCheck tests&quot;</span>
      [ testProperty <span class="st">&quot;Quickcheck test&quot;</span> arith
      ],

    testGroup <span class="st">&quot;SmallCheck tests&quot;</span>
      [ SC.testProperty <span class="st">&quot;Negation&quot;</span> negation
      ]
  ]

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> defaultMain suite</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">runhaskell</span> TestSuite.hs
<span class="kw">Unit</span> tests
  <span class="kw">Units</span>
    <span class="kw">Equality</span>:        OK
    <span class="kw">Assertion</span>:       OK
  <span class="kw">QuickCheck</span> tests
    <span class="kw">Quickcheck</span> test: OK
      <span class="kw">+++</span> OK, passed 100 tests.
  <span class="kw">SmallCheck</span> tests
    <span class="kw">Negation</span>:        OK
      <span class="kw">11</span> tests completed</code></pre></div>
<h2 id="silently">silently</h2>
<p>Often in the process of testing IO heavy code we'll need to redirect stdout to compare it some known quantity. The <code>silently</code> package allows us to capture anything done to stdout across any library inside of IO block and return the result to the test runner.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">capture ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">String</span>, a)</code></pre></div>
<div class="sourceCode" include="src/15-testing/silently.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Test.Tasty</span>
<span class="kw">import </span><span class="dt">Test.Tasty.HUnit</span>
<span class="kw">import </span><span class="dt">System.IO.Silently</span>

<span class="ot">test ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
test n <span class="fu">=</span> print (n <span class="fu">*</span> n)

testCapture n <span class="fu">=</span> <span class="kw">do</span>
  (stdout, result) <span class="ot">&lt;-</span> capture (test n)
  assert (stdout <span class="fu">==</span> show (n<span class="fu">*</span>n) <span class="fu">++</span> <span class="st">&quot;\n&quot;</span>)

<span class="ot">suite ::</span> <span class="dt">TestTree</span>
suite <span class="fu">=</span> testGroup <span class="st">&quot;Test Suite&quot;</span> [
    testGroup <span class="st">&quot;Units&quot;</span>
      [ testCase <span class="st">&quot;Equality&quot;</span> <span class="fu">$</span> testCapture <span class="dv">10</span>
      ]
  ]

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> defaultMain suite</code></pre></div>
</hr>
<h1 id="type-families">Type Families</h1>
<h2 id="multiparam-typeclasses">MultiParam Typeclasses</h2>
<p>Resolution of vanilla Haskell 98 typeclasses proceeds via very simple context reduction that minimizes interdependency between predicates, resolves superclasses, and reduces the types to head normal form. For example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="dt">Eq</span> [a], <span class="dt">Ord</span> [a]) <span class="ot">=&gt;</span> [a]
<span class="fu">==&gt;</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a]</code></pre></div>
<p>If a single parameter typeclass expresses a property of a type ( i.e. it's in a class or not in class ) then a multiparameter typeclass expresses relationships between types. For example if we wanted to express the relation a type can be converted to another type we might use a class like:</p>
<div class="sourceCode" include="src/16-type-families/mparam.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span>

<span class="kw">import </span><span class="dt">Data.Char</span>

<span class="kw">class</span> <span class="dt">Convertible</span> a b <span class="kw">where</span>
<span class="ot">  convert ::</span> a <span class="ot">-&gt;</span> b

<span class="kw">instance</span> <span class="dt">Convertible</span> <span class="dt">Int</span> <span class="dt">Integer</span> <span class="kw">where</span>
  convert <span class="fu">=</span> toInteger

<span class="kw">instance</span> <span class="dt">Convertible</span> <span class="dt">Int</span> <span class="dt">Char</span> <span class="kw">where</span>
  convert <span class="fu">=</span> chr

<span class="kw">instance</span> <span class="dt">Convertible</span> <span class="dt">Char</span> <span class="dt">Int</span> <span class="kw">where</span>
  convert <span class="fu">=</span> ord</code></pre></div>
<p>Of course now our instances for <code>Convertible Int</code> are not unique anymore, so there no longer exists a nice procedure for determining the inferred type of <code>b</code> from just <code>a</code>. To remedy this let's add a functional dependency <code>a -&gt; b</code>, which tells GHC that an instance <code>a</code> uniquely determines the instance that b can be. So we'll see that our two instances relating <code>Int</code> to both <code>Integer</code> and <code>Char</code> conflict.</p>
<div class="sourceCode" include="src/16-type-families/mparam_fun.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class="ot">{-# LANGUAGE FunctionalDependencies #-}</span>


<span class="kw">import </span><span class="dt">Data.Char</span>

<span class="kw">class</span> <span class="dt">Convertible</span> a b <span class="fu">|</span> a <span class="ot">-&gt;</span> b <span class="kw">where</span>
<span class="ot">  convert ::</span> a <span class="ot">-&gt;</span> b

<span class="kw">instance</span> <span class="dt">Convertible</span> <span class="dt">Int</span> <span class="dt">Char</span> <span class="kw">where</span>
  convert <span class="fu">=</span> chr

<span class="kw">instance</span> <span class="dt">Convertible</span> <span class="dt">Char</span> <span class="dt">Int</span> <span class="kw">where</span>
  convert <span class="fu">=</span> ord</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Functional</span> dependencies conflict between <span class="kw">instance</span> declarations<span class="fu">:</span>
  <span class="kw">instance</span> <span class="dt">Convertible</span> <span class="dt">Int</span> <span class="dt">Integer</span>
  <span class="kw">instance</span> <span class="dt">Convertible</span> <span class="dt">Int</span> <span class="dt">Char</span></code></pre></div>
<p>Now there's a simpler procedure for determining instances uniquely and multiparameter typeclasses become more usable and inferable again. Effectively a functional dependency <code>| a -&gt; b</code> says that we can't define multiple multiparamater typeclass instances with the same <code>a</code> but different <code>b</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> convert (<span class="dv">42</span><span class="ot"> ::</span> <span class="dt">Int</span>)
<span class="ch">&#39;*&#39;</span>
λ<span class="fu">:</span> convert <span class="ch">&#39;*&#39;</span>
<span class="dv">42</span></code></pre></div>
<p>Now let's make things not so simple. Turning on <code>UndecidableInstances</code> loosens the constraint on context reduction that can only allow constraints of the class to become structural smaller than its head. As a result implicit computation can now occur <em>within in the type class instance search</em>. Combined with a type-level representation of Peano numbers we find that we can encode basic arithmetic at the type-level.</p>
<div class="sourceCode" include="src/16-type-families/fundeps.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class="ot">{-# LANGUAGE FunctionalDependencies #-}</span>
<span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>

<span class="kw">data</span> <span class="dt">Z</span>
<span class="kw">data</span> <span class="dt">S</span> n

<span class="kw">type</span> <span class="dt">Zero</span>  <span class="fu">=</span> <span class="dt">Z</span>
<span class="kw">type</span> <span class="dt">One</span>   <span class="fu">=</span> <span class="dt">S</span> <span class="dt">Zero</span>
<span class="kw">type</span> <span class="dt">Two</span>   <span class="fu">=</span> <span class="dt">S</span> <span class="dt">One</span>
<span class="kw">type</span> <span class="dt">Three</span> <span class="fu">=</span> <span class="dt">S</span> <span class="dt">Two</span>
<span class="kw">type</span> <span class="dt">Four</span>  <span class="fu">=</span> <span class="dt">S</span> <span class="dt">Three</span>

<span class="ot">zero ::</span> <span class="dt">Zero</span>
zero <span class="fu">=</span> undefined

<span class="ot">one ::</span> <span class="dt">One</span>
one <span class="fu">=</span> undefined

<span class="ot">two ::</span> <span class="dt">Two</span>
two <span class="fu">=</span> undefined

<span class="ot">three ::</span> <span class="dt">Three</span>
three <span class="fu">=</span> undefined

<span class="ot">four ::</span> <span class="dt">Four</span>
four <span class="fu">=</span> undefined

<span class="kw">class</span> <span class="dt">Eval</span> a <span class="kw">where</span>
<span class="ot">  eval ::</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span>

<span class="kw">instance</span> <span class="dt">Eval</span> <span class="dt">Zero</span> <span class="kw">where</span>
  eval _ <span class="fu">=</span> <span class="dv">0</span>

<span class="kw">instance</span> <span class="dt">Eval</span> n <span class="ot">=&gt;</span> <span class="dt">Eval</span> (<span class="dt">S</span> n) <span class="kw">where</span>
  eval m <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> eval (prev m)

<span class="kw">class</span> <span class="dt">Pred</span> a b <span class="fu">|</span> a <span class="ot">-&gt;</span> b <span class="kw">where</span>
<span class="ot">  prev ::</span> a <span class="ot">-&gt;</span> b

<span class="kw">instance</span> <span class="dt">Pred</span> <span class="dt">Zero</span> <span class="dt">Zero</span> <span class="kw">where</span>
  prev <span class="fu">=</span> undefined

<span class="kw">instance</span> <span class="dt">Pred</span> (<span class="dt">S</span> n) n <span class="kw">where</span>
  prev <span class="fu">=</span> undefined

<span class="kw">class</span> <span class="dt">Add</span> a b c <span class="fu">|</span> a b <span class="ot">-&gt;</span> c <span class="kw">where</span>
<span class="ot">  add ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c

<span class="kw">instance</span> <span class="dt">Add</span> <span class="dt">Zero</span> a a <span class="kw">where</span>
  add <span class="fu">=</span> undefined

<span class="kw">instance</span> <span class="dt">Add</span> a b c <span class="ot">=&gt;</span> <span class="dt">Add</span> (<span class="dt">S</span> a) b (<span class="dt">S</span> c) <span class="kw">where</span>
  add <span class="fu">=</span> undefined

<span class="ot">f ::</span> <span class="dt">Three</span>
f <span class="fu">=</span> add one two

<span class="ot">g ::</span> <span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>)))
g <span class="fu">=</span> add two two

<span class="ot">h ::</span> <span class="dt">Int</span>
h <span class="fu">=</span> eval (add three four)</code></pre></div>
<p>If the typeclass contexts look similar to Prolog you're not wrong, if one reads the contexts qualifier <code>(=&gt;)</code> backwards as turnstiles <code>:-</code> then it's precisely the same equations.</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">add(<span class="dv">0</span><span class="kw">,</span> <span class="dt">A</span><span class="kw">,</span> <span class="dt">A</span>)<span class="kw">.</span>
add(s(<span class="dt">A</span>)<span class="kw">,</span> <span class="dt">B</span><span class="kw">,</span> s(<span class="dt">C</span>)) <span class="kw">:-</span> add(<span class="dt">A</span><span class="kw">,</span> <span class="dt">B</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">.</span>

pred(<span class="dv">0</span><span class="kw">,</span> <span class="dv">0</span>)<span class="kw">.</span>
pred(<span class="dt">S</span>(<span class="dt">A</span>)<span class="kw">,</span> <span class="dt">A</span>)<span class="kw">.</span></code></pre></div>
<p>This is kind of abusing typeclasses and if used carelessly it can fail to terminate or overflow at compile-time. <code>UndecidableInstances</code> shouldn't be turned on without careful forethought about what it implies.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span>
    <span class="dt">Context</span> reduction stack overflow; size <span class="fu">=</span> <span class="dv">201</span></code></pre></div>
<h2 id="type-families-1">Type Families</h2>
<p>Type families allows us to write functions in the type domain which take types as arguments which can yield either types or values indexed on their arguments which are evaluated at compile-time in during typechecking. Type families come in two varieties: <strong>data families</strong> and <strong>type synonym families</strong>.</p>
<ul>
<li><strong>type families</strong> are named function on types</li>
<li><strong>data families</strong> are type-indexed data types</li>
</ul>
<p>First let's look at <em>type synonym families</em>, there are two equivalent syntactic ways of constructing them. Either as <em>associated</em> type families declared within a typeclass or as standalone declarations at the toplevel. The following forms are semantically equivalent, although the unassociated form is strictly more general:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- (1) Unassociated form</span>
<span class="kw">type</span> family <span class="dt">Rep</span> a
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Rep</span> <span class="dt">Int</span> <span class="fu">=</span> <span class="dt">Char</span>
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Rep</span> <span class="dt">Char</span> <span class="fu">=</span> <span class="dt">Int</span>

<span class="kw">class</span> <span class="dt">Convertible</span> a <span class="kw">where</span>
<span class="ot">  convert ::</span> a <span class="ot">-&gt;</span> <span class="dt">Rep</span> a

<span class="kw">instance</span> <span class="dt">Convertible</span> <span class="dt">Int</span> <span class="kw">where</span>
  convert <span class="fu">=</span> chr

<span class="kw">instance</span> <span class="dt">Convertible</span> <span class="dt">Char</span> <span class="kw">where</span>
  convert <span class="fu">=</span> ord



<span class="co">-- (2) Associated form</span>
<span class="kw">class</span> <span class="dt">Convertible</span> a <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Rep</span> a
<span class="ot">  convert ::</span> a <span class="ot">-&gt;</span> <span class="dt">Rep</span> a

<span class="kw">instance</span> <span class="dt">Convertible</span> <span class="dt">Int</span> <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Rep</span> <span class="dt">Int</span> <span class="fu">=</span> <span class="dt">Char</span>
  convert <span class="fu">=</span> chr

<span class="kw">instance</span> <span class="dt">Convertible</span> <span class="dt">Char</span> <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Rep</span> <span class="dt">Char</span> <span class="fu">=</span> <span class="dt">Int</span>
  convert <span class="fu">=</span> ord</code></pre></div>
<p>Using the same example we used for multiparameter + functional dependencies illustration we see that there is a direct translation between the type family approach and functional dependencies. These two approaches have the same expressive power.</p>
<p>An associated type family can be queried using the <code>:kind!</code> command in GHCi.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">Rep</span> <span class="dt">Int</span>
<span class="dt">Rep</span> <span class="dt">Int</span><span class="ot"> ::</span> <span class="fu">*</span>
<span class="fu">=</span> <span class="dt">Char</span>
λ<span class="fu">:</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">Rep</span> <span class="dt">Char</span>
<span class="dt">Rep</span> <span class="dt">Char</span><span class="ot"> ::</span> <span class="fu">*</span>
<span class="fu">=</span> <span class="dt">Int</span></code></pre></div>
<p><em>Data families</em> on the other hand allow us to create new type parameterized data constructors. Normally we can only define typeclasses functions whose behavior results in a uniform result which is purely a result of the typeclasses arguments. With data families we can allow specialized behavior indexed on the type.</p>
<p>For example if we wanted to create more complicated vector structures ( bit-masked vectors, vectors of tuples, ... ) that exposed a uniform API but internally handled the differences in their data layout we can use data families to accomplish this:</p>
<div class="sourceCode" include="src/16-type-families/datafamily.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeFamilies #-}</span>

<span class="kw">import qualified</span> <span class="dt">Data.Vector.Unboxed</span> <span class="kw">as</span> <span class="dt">V</span>

<span class="kw">data</span> family <span class="dt">Array</span> a
<span class="kw">data</span> <span class="kw">instance</span> <span class="dt">Array</span> <span class="dt">Int</span>       <span class="fu">=</span> <span class="dt">IArray</span> (<span class="dt">V.Vector</span> <span class="dt">Int</span>)
<span class="kw">data</span> <span class="kw">instance</span> <span class="dt">Array</span> <span class="dt">Bool</span>      <span class="fu">=</span> <span class="dt">BArray</span> (<span class="dt">V.Vector</span> <span class="dt">Bool</span>)
<span class="kw">data</span> <span class="kw">instance</span> <span class="dt">Array</span> (a,b)     <span class="fu">=</span> <span class="dt">PArray</span> (<span class="dt">Array</span> a) (<span class="dt">Array</span> b)
<span class="kw">data</span> <span class="kw">instance</span> <span class="dt">Array</span> (<span class="dt">Maybe</span> a) <span class="fu">=</span> <span class="dt">MArray</span> (<span class="dt">V.Vector</span> <span class="dt">Bool</span>) (<span class="dt">Array</span> a)

<span class="kw">class</span> <span class="dt">IArray</span> a <span class="kw">where</span>
<span class="ot">  index ::</span> <span class="dt">Array</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a

<span class="kw">instance</span> <span class="dt">IArray</span> <span class="dt">Int</span> <span class="kw">where</span>
  index (<span class="dt">IArray</span> xs) i <span class="fu">=</span> xs <span class="fu">V.!</span> i

<span class="kw">instance</span> <span class="dt">IArray</span> <span class="dt">Bool</span> <span class="kw">where</span>
  index (<span class="dt">BArray</span> xs) i <span class="fu">=</span> xs <span class="fu">V.!</span> i

<span class="co">-- Vector of pairs</span>
<span class="kw">instance</span> (<span class="dt">IArray</span> a, <span class="dt">IArray</span> b) <span class="ot">=&gt;</span> <span class="dt">IArray</span> (a, b) <span class="kw">where</span>
  index (<span class="dt">PArray</span> xs ys) i <span class="fu">=</span> (index xs i, index ys i)

<span class="co">-- Vector of missing values</span>
<span class="kw">instance</span> (<span class="dt">IArray</span> a) <span class="ot">=&gt;</span> <span class="dt">IArray</span> (<span class="dt">Maybe</span> a) <span class="kw">where</span>
  index (<span class="dt">MArray</span> bm xs) i <span class="fu">=</span>
    <span class="kw">case</span> bm <span class="fu">V.!</span> i <span class="kw">of</span>
      <span class="dt">True</span>  <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
      <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="fu">$</span> index xs i</code></pre></div>
<h2 id="injectivity">Injectivity</h2>
<p>The type level functions defined by type-families are not necessarily <em>injective</em>, the function may map two distinct input types to the same output type. This differs from the behavior of type constructors ( which are also type-level functions ) which are injective.</p>
<p>For example for the constructor <code>Maybe</code>, <code>Maybe t1 = Maybe t2</code> implies that <code>t1 = t2</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="fu">=</span> <span class="dt">Nothing</span> <span class="fu">|</span> <span class="dt">Just</span> a
<span class="co">-- Maybe a ~ Maybe b  implies  a ~ b</span>

<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">F</span> <span class="dt">Int</span> <span class="fu">=</span> <span class="dt">Bool</span>
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">F</span> <span class="dt">Char</span> <span class="fu">=</span> <span class="dt">Bool</span>

<span class="co">-- F a ~ F b does not imply  a ~ b, in general</span></code></pre></div>
<h2 id="roles">Roles</h2>
<div class="alert alert-danger">
<p>This is an advanced section, and is not typically necessary to write Haskell.</p>
</div>
<p>Roles are a further level of specification for type variables parameters of datatypes.</p>
<ul>
<li><code>nominal</code></li>
<li><code>representational</code></li>
<li><code>phantom</code></li>
</ul>
<p>They were added to the language to address a rather nasty and long-standing bug around the correspondence between a newtype and its runtime representation. The fundamental distinction that roles introduce is there are two notions of type equality. Two types are <em>nominally equal</em> when they have the same name. This is the usual equality in Haskell or Core. Two types are <em>representationally equal</em> when they have the same representation. (If a type is higher-kinded, all nominally equal instantiations lead to representationally equal types.)</p>
<ul>
<li><code>nominal</code> - Two types are the same.</li>
<li><code>representational</code> - Two types have the same runtime representation.</li>
</ul>
<div class="sourceCode" include="src/16-type-families/roles.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE StandaloneDeriving #-}</span>
<span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>

<span class="kw">newtype</span> <span class="dt">Age</span> <span class="fu">=</span> <span class="dt">MkAge</span> {<span class="ot"> unAge ::</span> <span class="dt">Int</span> }

<span class="kw">type</span> family <span class="dt">Inspect</span> x
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Inspect</span> <span class="dt">Age</span> <span class="fu">=</span> <span class="dt">Int</span>
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Inspect</span> <span class="dt">Int</span> <span class="fu">=</span> <span class="dt">Bool</span>

<span class="kw">class</span> <span class="dt">Boom</span> a <span class="kw">where</span>
<span class="ot">  boom ::</span> a <span class="ot">-&gt;</span> <span class="dt">Inspect</span> a

<span class="kw">instance</span> <span class="dt">Boom</span> <span class="dt">Int</span> <span class="kw">where</span>
  boom <span class="fu">=</span> (<span class="fu">==</span> <span class="dv">0</span>)

<span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Boom</span> <span class="dt">Age</span>

<span class="co">-- GHC 7.6.3 exhibits undefined behavior</span>
failure <span class="fu">=</span> boom (<span class="dt">MkAge</span> <span class="dv">3</span>)
<span class="co">-- -6341068275333450897</span></code></pre></div>
<p>Roles are normally inferred automatically, but with the <code>RoleAnnotations</code> extension they can be manually annotated. Except in rare cases this should not be necessary although it is helpful to know what is going on under the hood.</p>
<div class="sourceCode" include="src/16-type-families/role_infer.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">{-# LANGUAGE PolyKinds #-}</span>
<span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE KindSignatures #-}</span>
<span class="ot">{-# LANGUAGE RoleAnnotations #-}</span>

<span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Zero</span> <span class="fu">|</span> <span class="dt">Suc</span> <span class="dt">Nat</span>

<span class="kw">type</span> role <span class="dt">Vec</span> nominal representational
<span class="kw">data</span> <span class="dt">Vec</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">Vec</span> <span class="dt">Zero</span> a
<span class="ot">  (:*) ::</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (<span class="dt">Suc</span> n) a

<span class="kw">type</span> role <span class="dt">App</span> representational nominal
<span class="kw">data</span> <span class="dt">App</span> (<span class="ot">f ::</span> k <span class="ot">-&gt;</span> <span class="fu">*</span>) (<span class="ot">a ::</span> k) <span class="fu">=</span> <span class="dt">App</span> (f a)

<span class="kw">type</span> role <span class="dt">Mu</span> nominal nominal
<span class="kw">data</span> <span class="dt">Mu</span> (<span class="ot">f ::</span> (k <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="fu">*</span>) (<span class="ot">a ::</span> k) <span class="fu">=</span> <span class="dt">Roll</span> (f (<span class="dt">Mu</span> f) a)

<span class="kw">type</span> role <span class="dt">Proxy</span> phantom
<span class="kw">data</span> <span class="dt">Proxy</span> (<span class="ot">a ::</span> k) <span class="fu">=</span> <span class="dt">Proxy</span></code></pre></div>
<p>See:</p>
<ul>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Roles">Roles</a></li>
<li><a href="http://typesandkinds.wordpress.com/2013/08/15/roles-a-new-feature-of-ghc/">Roles: A New Feature of GHC</a></li>
</ul>
<h2 id="monotraversable">Monotraversable</h2>
<p>Using type families, mono-traversable generalizes the notion of Functor, Foldable, and Traversable to include both monomorphic and polymorphic types.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">omap ::</span> <span class="dt">MonoFunctor</span> mono <span class="ot">=&gt;</span> (<span class="dt">Element</span> mono <span class="ot">-&gt;</span> <span class="dt">Element</span> mono) <span class="ot">-&gt;</span> mono <span class="ot">-&gt;</span> mono

<span class="ot">otraverse ::</span> (<span class="dt">Applicative</span> f, <span class="dt">MonoTraversable</span> mono)
          <span class="ot">=&gt;</span> (<span class="dt">Element</span> mono <span class="ot">-&gt;</span> f (<span class="dt">Element</span> mono)) <span class="ot">-&gt;</span> mono <span class="ot">-&gt;</span> f mono

<span class="ot">ofoldMap ::</span> (<span class="dt">Monoid</span> m, <span class="dt">MonoFoldable</span> mono)
         <span class="ot">=&gt;</span> (<span class="dt">Element</span> mono <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> mono <span class="ot">-&gt;</span> m
<span class="ot">ofoldl&#39; ::</span> <span class="dt">MonoFoldable</span> mono
        <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Element</span> mono <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> mono <span class="ot">-&gt;</span> a
<span class="ot">ofoldr ::</span> <span class="dt">MonoFoldable</span> mono
        <span class="ot">=&gt;</span> (<span class="dt">Element</span> mono <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> mono <span class="ot">-&gt;</span> b</code></pre></div>
<p>For example the text type normally does not admit any of these type-classes since, but now we can write down the instances that model the interface of Foldable and Traversable.</p>
<div class="sourceCode" include="src/16-type-families/mono.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Data.Text</span>
<span class="kw">import </span><span class="dt">Data.Char</span>
<span class="kw">import </span><span class="dt">Data.Monoid</span>
<span class="kw">import </span><span class="dt">Data.MonoTraversable</span>
<span class="kw">import </span><span class="dt">Control.Applicative</span>

<span class="ot">bs ::</span> <span class="dt">Text</span>
bs <span class="fu">=</span> <span class="st">&quot;Hello Haskell.&quot;</span>

<span class="ot">shift ::</span> <span class="dt">Text</span>
shift <span class="fu">=</span> omap (chr <span class="fu">.</span> (<span class="fu">+</span><span class="dv">1</span>) <span class="fu">.</span> ord) bs
<span class="co">-- &quot;Ifmmp!Ibtlfmm/&quot;</span>

<span class="ot">backwards ::</span> [<span class="dt">Char</span>]
backwards <span class="fu">=</span> ofoldl&#39; (flip (<span class="fu">:</span>)) <span class="st">&quot;&quot;</span> bs
<span class="co">-- &quot;.lleksaH olleH&quot;</span>


<span class="kw">data</span> <span class="dt">MyMonoType</span> <span class="fu">=</span> <span class="dt">MNil</span> <span class="fu">|</span> <span class="dt">MCons</span> <span class="dt">Int</span> <span class="dt">MyMonoType</span> <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Element</span> <span class="dt">MyMonoType</span> <span class="fu">=</span> <span class="dt">Int</span>

<span class="kw">instance</span> <span class="dt">MonoFunctor</span> <span class="dt">MyMonoType</span> <span class="kw">where</span>
  omap f <span class="dt">MNil</span> <span class="fu">=</span> <span class="dt">MNil</span>
  omap f (<span class="dt">MCons</span> x xs) <span class="fu">=</span> f x <span class="ot">`MCons`</span> omap f xs

<span class="kw">instance</span> <span class="dt">MonoFoldable</span> <span class="dt">MyMonoType</span> <span class="kw">where</span>
  ofoldMap f <span class="fu">=</span> ofoldr (mappend <span class="fu">.</span> f) mempty
  ofoldr       <span class="fu">=</span> mfoldr
  ofoldl&#39;      <span class="fu">=</span> mfoldl&#39;
  ofoldr1Ex f  <span class="fu">=</span> ofoldr1Ex f <span class="fu">.</span> mtoList
  ofoldl1Ex&#39; f <span class="fu">=</span> ofoldl1Ex&#39; f <span class="fu">.</span> mtoList

<span class="kw">instance</span> <span class="dt">MonoTraversable</span> <span class="dt">MyMonoType</span> <span class="kw">where</span>
  omapM f xs <span class="fu">=</span> mapM f (mtoList xs) <span class="fu">&gt;&gt;=</span> return <span class="fu">.</span> mfromList
  otraverse f <span class="fu">=</span> ofoldr acons (pure <span class="dt">MNil</span>)
    <span class="kw">where</span> acons x ys <span class="fu">=</span> <span class="dt">MCons</span> <span class="fu">&lt;$&gt;</span> f x <span class="fu">&lt;*&gt;</span> ys

<span class="ot">mtoList ::</span> <span class="dt">MyMonoType</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
mtoList (<span class="dt">MNil</span>) <span class="fu">=</span> []
mtoList (<span class="dt">MCons</span> x xs) <span class="fu">=</span> x <span class="fu">:</span> (mtoList xs)

<span class="ot">mfromList ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">MyMonoType</span>
mfromList [] <span class="fu">=</span> <span class="dt">MNil</span>
mfromList (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">MCons</span> x (mfromList xs)

<span class="ot">mfoldr ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MyMonoType</span> <span class="ot">-&gt;</span> a
mfoldr f z <span class="dt">MNil</span> <span class="fu">=</span>  z
mfoldr f z (<span class="dt">MCons</span> x xs) <span class="fu">=</span>  f x (mfoldr f z xs)

<span class="ot">mfoldl&#39; ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">MyMonoType</span> <span class="ot">-&gt;</span> a
mfoldl&#39; f z <span class="dt">MNil</span> <span class="fu">=</span> z
mfoldl&#39; f z (<span class="dt">MCons</span> x xs) <span class="fu">=</span> <span class="kw">let</span> z&#39; <span class="fu">=</span> z <span class="ot">`f`</span> x
                           <span class="kw">in</span> seq z&#39; <span class="fu">$</span> mfoldl&#39; f z&#39; xs

<span class="ot">ex1 ::</span> <span class="dt">Int</span>
ex1 <span class="fu">=</span> mfoldl&#39; (<span class="fu">+</span>) <span class="dv">0</span> (mfromList [<span class="dv">1</span><span class="fu">..</span><span class="dv">25</span>])

<span class="ot">ex2 ::</span> <span class="dt">MyMonoType</span>
ex2 <span class="fu">=</span> omap (<span class="fu">+</span><span class="dv">1</span>) (mfromList [<span class="dv">1</span><span class="fu">..</span><span class="dv">25</span>])</code></pre></div>
<p>See: <a href="http://fundeps.com/tables/FromSemigroupToMonads.pdf">From Semigroups to Monads</a></p>
<h2 id="nonempty">NonEmpty</h2>
<p>Rather than having degenerate (and often partial) cases of many of the Prelude functions to accommodate the null case of lists, it is sometimes preferable to statically enforce empty lists from even being constructed as an inhabitant of a type.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:|</span>, <span class="fu">&lt;|</span>
<span class="kw">data</span> <span class="dt">NonEmpty</span> a <span class="fu">=</span> a <span class="fu">:|</span> [a]

head<span class="ot"> ::</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a
<span class="ot">toList ::</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> [a]
<span class="ot">fromList ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> a</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">head<span class="ot"> ::</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a
head <span class="fu">~</span>(a <span class="fu">:|</span> _) <span class="fu">=</span> a</code></pre></div>
<div class="sourceCode" include="src/16-type-families/noempty.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List.NonEmpty</span>
<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (head, tail, foldl1)
<span class="kw">import </span><span class="dt">Data.Foldable</span> (foldl1)

<span class="ot">a ::</span> <span class="dt">NonEmpty</span> <span class="dt">Integer</span>
a <span class="fu">=</span> fromList [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
<span class="co">-- 1 :| [2,3]</span>

<span class="ot">b ::</span> <span class="dt">NonEmpty</span> <span class="dt">Integer</span>
b <span class="fu">=</span> <span class="dv">1</span> <span class="fu">:|</span> [<span class="dv">2</span>,<span class="dv">3</span>]
<span class="co">-- 1 :| [2,3]</span>

<span class="ot">c ::</span> <span class="dt">NonEmpty</span> <span class="dt">Integer</span>
c <span class="fu">=</span> fromList []
<span class="co">-- *** Exception: NonEmpty.fromList: empty list</span>

<span class="ot">d ::</span> <span class="dt">Integer</span>
d <span class="fu">=</span> foldl1 (<span class="fu">+</span>) <span class="fu">$</span> fromList [<span class="dv">1</span><span class="fu">..</span><span class="dv">100</span>]
<span class="co">-- 5050</span></code></pre></div>
<h2 id="overloaded-lists-1">Overloaded Lists</h2>
<p>In GHC 7.8 <code>-XOverloadedLists</code> can be used to avoid the extraneous <code>fromList</code> and <code>toList</code> conversions.</p>
<h2 id="manual-proofs">Manual Proofs</h2>
<div class="alert alert-danger">
<p>This is an advanced section, and is not typically necessary to write Haskell.</p>
</div>
<p>One of most deep results in computer science, the <a href="../../en.wikipedia.org/wiki/Curry%e2%80%93Howard_correspondence.html">Curry–Howard correspondence</a>, is the relation that logical propositions can be modeled by types and instantiating those types constitute proofs of these propositions. Programs are proofs and proofs are programs.</p>
<table>
<thead>
<tr class="header">
<th align="left">Types</th>
<th align="left">Logic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>A</code></td>
<td align="left">proposition</td>
</tr>
<tr class="even">
<td align="left"><code>a : A</code></td>
<td align="left">proof</td>
</tr>
<tr class="odd">
<td align="left"><code>B(x)</code></td>
<td align="left">predicate</td>
</tr>
<tr class="even">
<td align="left"><code>Void</code></td>
<td align="left">⊥</td>
</tr>
<tr class="odd">
<td align="left"><code>Unit</code></td>
<td align="left">⊤</td>
</tr>
<tr class="even">
<td align="left"><code>A + B</code></td>
<td align="left">A ∨ B</td>
</tr>
<tr class="odd">
<td align="left"><code>A × B</code></td>
<td align="left">A ∧ B</td>
</tr>
<tr class="even">
<td align="left"><code>A -&gt; B</code></td>
<td align="left">A ⇒ B</td>
</tr>
</tbody>
</table>
<p>In dependently typed languages we can exploit this result to its full extent, in Haskell we don't have the strength that dependent types provide but can still prove trivial results. For example, now we can model a type level function for addition and provide a small proof that zero is an additive identity.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">P</span> <span class="dv">0</span>                   [ base step ]
<span class="ot">∀</span>n<span class="fu">.</span> <span class="dt">P</span> n  <span class="ot">→</span> <span class="dt">P</span> (<span class="dv">1</span><span class="fu">+</span>n)    [ inductive step ]
<span class="fu">-------------------</span>
<span class="ot">∀</span>n<span class="fu">.</span> <span class="dt">P</span>(n)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Axiom</span> <span class="dv">1</span><span class="fu">:</span> a <span class="fu">+</span> <span class="dv">0</span> <span class="fu">=</span> a
<span class="dt">Axiom</span> <span class="dv">2</span><span class="fu">:</span> a <span class="fu">+</span> suc b <span class="fu">=</span> suc (a <span class="fu">+</span> b)

  <span class="dv">0</span> <span class="fu">+</span> suc a
<span class="fu">=</span> suc (<span class="dv">0</span> <span class="fu">+</span> a)  [by <span class="dt">Axiom</span> <span class="dv">2</span>]
<span class="fu">=</span> suc a        [<span class="dt">Induction</span> hypothesis]
∎</code></pre></div>
<p>Translated into Haskell our axioms are simply type definitions and recursing over the inductive datatype constitutes the inductive step of our proof.</p>
<div class="sourceCode" include="src/16-type-families/proof.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE ExplicitForAll #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>

<span class="kw">data</span> <span class="dt">Z</span>
<span class="kw">data</span> <span class="dt">S</span> n

<span class="kw">data</span> <span class="dt">SNat</span> n <span class="kw">where</span>
  <span class="dt">Zero</span><span class="ot"> ::</span> <span class="dt">SNat</span> <span class="dt">Z</span>
  <span class="dt">Succ</span><span class="ot"> ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">SNat</span> (<span class="dt">S</span> n)

<span class="kw">data</span> <span class="dt">Eql</span> a b <span class="kw">where</span>
  <span class="dt">Refl</span><span class="ot"> ::</span> <span class="dt">Eql</span> a a

<span class="kw">type</span> family <span class="dt">Add</span> m n
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Add</span> <span class="dt">Z</span> n <span class="fu">=</span> n
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Add</span> (<span class="dt">S</span> m) n <span class="fu">=</span> <span class="dt">S</span> (<span class="dt">Add</span> m n)

<span class="ot">add ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">SNat</span> (<span class="dt">Add</span> n m)
add <span class="dt">Zero</span>     m <span class="fu">=</span> m
add (<span class="dt">Succ</span> n) m <span class="fu">=</span> <span class="dt">Succ</span> (add n m)

<span class="ot">cong ::</span> <span class="dt">Eql</span> a b <span class="ot">-&gt;</span> <span class="dt">Eql</span> (f a) (f b)
cong <span class="dt">Refl</span> <span class="fu">=</span> <span class="dt">Refl</span>

<span class="co">-- ∀n. 0 + suc n = suc n</span>
<span class="ot">plus_suc ::</span> forall n<span class="fu">.</span>  <span class="dt">SNat</span> n
         <span class="ot">-&gt;</span> <span class="dt">Eql</span> (<span class="dt">Add</span> <span class="dt">Z</span> (<span class="dt">S</span> n)) (<span class="dt">S</span> n)
plus_suc <span class="dt">Zero</span> <span class="fu">=</span> <span class="dt">Refl</span>
plus_suc (<span class="dt">Succ</span> n) <span class="fu">=</span> cong (plus_suc n)

<span class="co">-- ∀n. 0 + n = n</span>
<span class="ot">plus_zero ::</span> forall n<span class="fu">.</span> <span class="dt">SNat</span> n
         <span class="ot">-&gt;</span> <span class="dt">Eql</span> (<span class="dt">Add</span> <span class="dt">Z</span> n) n
plus_zero <span class="dt">Zero</span> <span class="fu">=</span> <span class="dt">Refl</span>
plus_zero (<span class="dt">Succ</span> n) <span class="fu">=</span> cong (plus_zero n)</code></pre></div>
<p>Using the <code>TypeOperators</code> extension we can also use infix notation at the type-level.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> a <span class="fu">:=:</span> b <span class="kw">where</span>
  <span class="dt">Refl</span><span class="ot"> ::</span> a <span class="fu">:=:</span> a

<span class="ot">cong ::</span> a <span class="fu">:=:</span> b <span class="ot">-&gt;</span> (f a) <span class="fu">:=:</span> (f b)
cong <span class="dt">Refl</span> <span class="fu">=</span> <span class="dt">Refl</span>

<span class="kw">type</span> family (<span class="ot">n ::</span> <span class="dt">Nat</span>) <span class="fu">:+</span> (<span class="ot">m ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span>
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Zero</span>     <span class="fu">:+</span> m <span class="fu">=</span> m
<span class="kw">type</span> <span class="kw">instance</span> (<span class="dt">Succ</span> n) <span class="fu">:+</span> m <span class="fu">=</span> <span class="dt">Succ</span> (n <span class="fu">:+</span> m)

<span class="ot">plus_suc ::</span> forall n m<span class="fu">.</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> (n <span class="fu">:+</span> (<span class="dt">S</span> m)) <span class="fu">:=:</span> (<span class="dt">S</span> (n <span class="fu">:+</span> m))
plus_suc <span class="dt">Zero</span> m <span class="fu">=</span> <span class="dt">Refl</span>
plus_suc (<span class="dt">Succ</span> n) m <span class="fu">=</span> cong (plus_suc n m)</code></pre></div>
<h2 id="constraint-kinds">Constraint Kinds</h2>
<div class="alert alert-danger">
<p>This is an advanced section, and is not typically necessary to write Haskell.</p>
</div>
<p>GHC's implementation also exposes the predicates that bound quantifiers in Haskell as types themselves, with the <code>-XConstraintKinds</code> extension enabled. Using this extension we work with constraints as first class types.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Num</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span>
<span class="dt">Odd</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">T1</span> a <span class="fu">=</span> (<span class="dt">Num</span> a, <span class="dt">Ord</span> a)</code></pre></div>
<p>The empty constraint set is indicated by <code>() :: Constraint</code>.</p>
<p>For a contrived example if we wanted to create a generic <code>Sized</code> class that carried with it constraints on the elements of the container in question we could achieve this quite simply using type families.</p>
<div class="sourceCode" include="src/16-type-families/constraintkinds.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE ConstraintKinds #-}</span>

<span class="kw">import </span><span class="dt">GHC.Exts</span> (<span class="dt">Constraint</span>)
<span class="kw">import </span><span class="dt">Data.Hashable</span>
<span class="kw">import </span><span class="dt">Data.HashSet</span>

<span class="kw">type</span> family <span class="dt">Con</span><span class="ot"> a ::</span> <span class="dt">Constraint</span>
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Con</span> [a] <span class="fu">=</span> (<span class="dt">Ord</span> a, <span class="dt">Eq</span> a)
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Con</span> (<span class="dt">HashSet</span> a) <span class="fu">=</span> (<span class="dt">Hashable</span> a)

<span class="kw">class</span> <span class="dt">Sized</span> a <span class="kw">where</span>
<span class="ot">  gsize ::</span> <span class="dt">Con</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span>

<span class="kw">instance</span> <span class="dt">Sized</span> [a] <span class="kw">where</span>
  gsize <span class="fu">=</span> length

<span class="kw">instance</span> <span class="dt">Sized</span> (<span class="dt">HashSet</span> a) <span class="kw">where</span>
  gsize <span class="fu">=</span> size</code></pre></div>
<p>One use-case of this is to capture the typeclass dictionary constrained by a function and reify it as a value.</p>
<div class="sourceCode" include="src/16-type-families/dict.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">{-# LANGUAGE ConstraintKinds #-}</span>
<span class="ot">{-# LANGUAGE KindSignatures #-}</span>

<span class="kw">import </span><span class="dt">GHC.Exts</span> (<span class="dt">Constraint</span>)

<span class="kw">data</span> <span class="dt">Dict</span><span class="ot"> ::</span> <span class="dt">Constraint</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">Dict</span><span class="ot"> ::</span> (c) <span class="ot">=&gt;</span> <span class="dt">Dict</span> c

<span class="ot">dShow ::</span> <span class="dt">Dict</span> (<span class="dt">Show</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>
dShow <span class="dt">Dict</span> x <span class="fu">=</span> show x

<span class="ot">dEqNum ::</span> <span class="dt">Dict</span> (<span class="dt">Eq</span> a, <span class="dt">Num</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
dEqNum <span class="dt">Dict</span> x <span class="fu">=</span> x <span class="fu">==</span> <span class="dv">0</span>


<span class="ot">fShow ::</span> <span class="dt">String</span>
fShow <span class="fu">=</span> dShow <span class="dt">Dict</span> <span class="dv">10</span>

<span class="ot">fEqual ::</span> <span class="dt">Bool</span>
fEqual <span class="fu">=</span> dEqNum <span class="dt">Dict</span> <span class="dv">0</span></code></pre></div>
<h2 id="typefamilydependencies">TypeFamilyDependencies</h2>
<p>Type families historically have not been injective, i.e. they are not guaranteed to maps distinct elements of its arguments to the same element of its result. The syntax is similar to the multiparmater typeclass functional dependencies in that the resulting type is uniquely determined by a set of the type families parameters.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE XTypeFamilyDependencies #-}</span>

<span class="kw">type</span> family <span class="dt">F</span> a b c <span class="fu">=</span> (<span class="ot">result ::</span> k) <span class="fu">|</span> result <span class="ot">-&gt;</span> a b c
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">F</span> <span class="dt">Int</span>  <span class="dt">Char</span> <span class="dt">Bool</span> <span class="fu">=</span> <span class="dt">Bool</span>
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">F</span> <span class="dt">Char</span> <span class="dt">Bool</span> <span class="dt">Int</span>  <span class="fu">=</span> <span class="dt">Int</span>
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">F</span> <span class="dt">Bool</span> <span class="dt">Int</span>  <span class="dt">Char</span> <span class="fu">=</span> <span class="dt">Char</span></code></pre></div>
<p>See:</p>
<ul>
<li><a href="http://ics.p.lodz.pl/~stolarek/_media/pl:research:stolarek_peyton-jones_eisenberg_injectivity_extended.pdf">Injective type families for Haskell</a></li>
</ul>
</hr>
<h1 id="promotion">Promotion</h1>
<h2 id="higher-kinded-types">Higher Kinded Types</h2>
<p>What are higher kinded types?</p>
<p>The kind system in Haskell is unique by contrast with most other languages in that it allows datatypes to be constructed which take types and type constructor to other types. Such a system is said to support <em>higher kinded types</em>.</p>
<p>All kind annotations in Haskell necessarily result in a kind <code>*</code> although any terms to the left may be higher-kinded (<code>* -&gt; *</code>).</p>
<p>The common example is the Monad which has kind <code>* -&gt; *</code>. But we have also seen this higher-kindedness in free monads.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Free</span> f a <span class="kw">where</span>
  <span class="dt">Pure</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Free</span> f a
  <span class="dt">Free</span><span class="ot"> ::</span> f (<span class="dt">Free</span> f a) <span class="ot">-&gt;</span> <span class="dt">Free</span> f a

<span class="kw">data</span> <span class="dt">Cofree</span> f a <span class="kw">where</span>
  <span class="dt">Cofree</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> f a) <span class="ot">-&gt;</span> <span class="dt">Cofree</span> f a</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Free</span><span class="ot"> ::</span> (<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>
<span class="dt">Cofree</span><span class="ot"> ::</span> (<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span></code></pre></div>
<p>For instance <code>Cofree Maybe a</code> for some monokinded type <code>a</code> models a non-empty list with <code>Maybe :: * -&gt; *</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Cofree Maybe a is a non-empty list</span>
<span class="ot">testCofree ::</span> <span class="dt">Cofree</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
testCofree <span class="fu">=</span> (<span class="dt">Cofree</span> <span class="dv">1</span> (<span class="dt">Just</span> (<span class="dt">Cofree</span> <span class="dv">2</span> <span class="dt">Nothing</span>)))</code></pre></div>
<h2 id="kind-polymorphism">Kind Polymorphism</h2>
<div class="alert alert-danger">
<p>This is an advanced section, knowledge of kind polymorphism is not typically necessary to write Haskell.</p>
</div>
<p>The regular value level function which takes a function and applies it to an argument is universally generalized over in the usual Hindley-Milner way.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">app ::</span> forall a b<span class="fu">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b
app f a <span class="fu">=</span> f a</code></pre></div>
<p>But when we do the same thing at the type-level we see we lose information about the polymorphism of the constructor applied.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- TApp :: (* -&gt; *) -&gt; * -&gt; *</span>
<span class="kw">data</span> <span class="dt">TApp</span> f a <span class="fu">=</span> <span class="dt">MkTApp</span> (f a)</code></pre></div>
<p>Turning on <code>-XPolyKinds</code> allows polymorphic variables at the kind level as well.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Default:   (* -&gt; *) -&gt; * -&gt; *</span>
<span class="co">-- PolyKinds: (k -&gt; *) -&gt; k -&gt; *</span>
<span class="kw">data</span> <span class="dt">TApp</span> f a <span class="fu">=</span> <span class="dt">MkTApp</span> (f a)

<span class="co">-- Default:   ((* -&gt; *) -&gt; (* -&gt; *)) -&gt; (* -&gt; *)</span>
<span class="co">-- PolyKinds: ((k -&gt; *) -&gt; (k -&gt; *)) -&gt; (k -&gt; *)</span>
<span class="kw">data</span> <span class="dt">Mu</span> f a <span class="fu">=</span> <span class="dt">Roll</span> (f (<span class="dt">Mu</span> f) a)

<span class="co">-- Default:   * -&gt; *</span>
<span class="co">-- PolyKinds: k -&gt; *</span>
<span class="kw">data</span> <span class="dt">Proxy</span> a <span class="fu">=</span> <span class="dt">Proxy</span></code></pre></div>
<p>Using the polykinded <code>Proxy</code> type allows us to write down type class functions over constructors of arbitrary kind arity.</p>
<div class="sourceCode" include="src/17-promotion/kindpoly.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE PolyKinds #-}</span>
<span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">{-# LANGUAGE KindSignatures #-}</span>

<span class="kw">data</span> <span class="dt">Proxy</span> a <span class="fu">=</span> <span class="dt">Proxy</span>
<span class="kw">data</span> <span class="dt">Rep</span> <span class="fu">=</span> <span class="dt">Rep</span>

<span class="kw">class</span> <span class="dt">PolyClass</span> a <span class="kw">where</span>
<span class="ot">  foo ::</span> <span class="dt">Proxy</span> a <span class="ot">-&gt;</span> <span class="dt">Rep</span>
  foo <span class="fu">=</span> const <span class="dt">Rep</span>

<span class="co">-- () :: *</span>
<span class="co">-- [] :: * -&gt; *</span>
<span class="co">-- Either :: * -&gt; * -&gt; *</span>

<span class="kw">instance</span> <span class="dt">PolyClass</span> ()
<span class="kw">instance</span> <span class="dt">PolyClass</span> []
<span class="kw">instance</span> <span class="dt">PolyClass</span> <span class="dt">Either</span></code></pre></div>
<p>For example we can write down the polymorphic <code>S</code> <code>K</code> combinators at the type level now.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE PolyKinds #-}</span>

<span class="kw">newtype</span> <span class="dt">I</span> (<span class="ot">a ::</span> <span class="fu">*</span>) <span class="fu">=</span> <span class="dt">I</span> a
<span class="kw">newtype</span> <span class="dt">K</span> (<span class="ot">a ::</span> <span class="fu">*</span>) (<span class="ot">b ::</span> k) <span class="fu">=</span> <span class="dt">K</span> a
<span class="kw">newtype</span> <span class="dt">Flip</span> (<span class="ot">f ::</span> k1 <span class="ot">-&gt;</span> k2 <span class="ot">-&gt;</span> <span class="fu">*</span>) (<span class="ot">x ::</span> k2) (<span class="ot">y ::</span> k1) <span class="fu">=</span> <span class="dt">Flip</span> (f y x)

<span class="ot">unI ::</span> <span class="dt">I</span> a <span class="ot">-&gt;</span> a
unI (<span class="dt">I</span> x) <span class="fu">=</span> x

<span class="ot">unK ::</span> <span class="dt">K</span> a b <span class="ot">-&gt;</span> a
unK (<span class="dt">K</span> x) <span class="fu">=</span> x

<span class="ot">unFlip ::</span> <span class="dt">Flip</span> f x y <span class="ot">-&gt;</span> f y x
unFlip (<span class="dt">Flip</span> x) <span class="fu">=</span> x</code></pre></div>
<h2 id="data-kinds">Data Kinds</h2>
<div class="alert alert-danger">
<p>This is an advanced section, knowledge of kind data kinds is not typically necessary to write Haskell.</p>
</div>
<p>The <code>-XDataKinds</code> extension allows us to use refer to constructors at the value level and the type level. Consider a simple sum type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">S</span> a b <span class="fu">=</span> <span class="dt">L</span> a <span class="fu">|</span> <span class="dt">R</span> b

<span class="co">-- S :: * -&gt; * -&gt; *</span>
<span class="co">-- L :: a -&gt; S a b</span>
<span class="co">-- R :: b -&gt; S a b</span></code></pre></div>
<p>With the extension enabled we see that our type constructors are now automatically promoted so that <code>L</code> or <code>R</code> can be viewed as both a data constructor of the type <code>S</code> or as the type <code>L</code> with kind <code>S</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>

<span class="kw">data</span> <span class="dt">S</span> a b <span class="fu">=</span> <span class="dt">L</span> a <span class="fu">|</span> <span class="dt">R</span> b

<span class="co">-- S :: * -&gt; * -&gt; *</span>
<span class="co">-- L :: * -&gt; S * *</span>
<span class="co">-- R :: * -&gt; S * *</span></code></pre></div>
<p>Promoted data constructors can referred to in type signatures by prefixing them with a single quote. Also of importance is that these promoted constructors are not exported with a module by default, but type synonym instances can be created for the ticked promoted types and exported directly.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Foo</span> <span class="fu">=</span> <span class="dt">Bar</span> <span class="fu">|</span> <span class="dt">Baz</span>
<span class="kw">type</span> <span class="dt">Bar</span> <span class="fu">=</span> <span class="ch">&#39;Bar</span>
<span class="kw">type</span> <span class="dt">Baz</span> <span class="fu">=</span> <span class="ch">&#39;Baz</span></code></pre></div>
<p>Combining this with type families we see we can write meaningful, meaningful type-level functions by lifting types to the kind level.</p>
<div class="sourceCode" include="src/17-promotion/typefamily.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE DataKinds #-}</span>

<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (<span class="dt">Bool</span>(..))

<span class="kw">data</span> <span class="dt">Bool</span> <span class="fu">=</span> <span class="dt">True</span> <span class="fu">|</span> <span class="dt">False</span>

<span class="kw">type</span> family <span class="dt">Not</span> (<span class="ot">a ::</span> <span class="dt">Bool</span>)<span class="ot"> ::</span> <span class="dt">Bool</span>

<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Not</span> <span class="dt">True</span> <span class="fu">=</span> <span class="dt">False</span>
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Not</span> <span class="dt">False</span> <span class="fu">=</span> <span class="dt">True</span>

<span class="ot">false ::</span> <span class="dt">Not</span> <span class="dt">True</span> <span class="fu">~</span> <span class="dt">False</span> <span class="ot">=&gt;</span> a
false <span class="fu">=</span> undefined

<span class="ot">true ::</span> <span class="dt">Not</span> <span class="dt">False</span> <span class="fu">~</span> <span class="dt">True</span> <span class="ot">=&gt;</span> a
true <span class="fu">=</span> undefined

<span class="co">-- Fails at compile time.</span>
<span class="co">-- Couldn&#39;t match type &#39;False with &#39;True</span>
<span class="ot">invalid ::</span> <span class="dt">Not</span> <span class="dt">True</span> <span class="fu">~</span> <span class="dt">True</span> <span class="ot">=&gt;</span> a
invalid <span class="fu">=</span> undefined</code></pre></div>
<h2 id="size-indexed-vectors">Size-Indexed Vectors</h2>
<p>Using this new structure we can create a <code>Vec</code> type which is parameterized by its length as well as its element type now that we have a kind language rich enough to encode the successor type in the kind signature of the generalized algebraic datatype.</p>
<div class="sourceCode" include="src/17-promotion/datakinds.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE KindSignatures #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE FlexibleContexts #-}</span>

<span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Nat</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">type</span> <span class="dt">Zero</span>  <span class="fu">=</span> <span class="dt">Z</span>
<span class="kw">type</span> <span class="dt">One</span>   <span class="fu">=</span> <span class="dt">S</span> <span class="dt">Zero</span>
<span class="kw">type</span> <span class="dt">Two</span>   <span class="fu">=</span> <span class="dt">S</span> <span class="dt">One</span>
<span class="kw">type</span> <span class="dt">Three</span> <span class="fu">=</span> <span class="dt">S</span> <span class="dt">Two</span>
<span class="kw">type</span> <span class="dt">Four</span>  <span class="fu">=</span> <span class="dt">S</span> <span class="dt">Three</span>
<span class="kw">type</span> <span class="dt">Five</span>  <span class="fu">=</span> <span class="dt">S</span> <span class="dt">Four</span>

<span class="kw">data</span> <span class="dt">Vec</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">Vec</span> <span class="dt">Z</span> a
  <span class="dt">Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (<span class="dt">S</span> n) a

<span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Vec</span> n a) <span class="kw">where</span>
  show <span class="dt">Nil</span>         <span class="fu">=</span> <span class="st">&quot;Nil&quot;</span>
  show (<span class="dt">Cons</span> x xs) <span class="fu">=</span> <span class="st">&quot;Cons &quot;</span> <span class="fu">++</span> show x <span class="fu">++</span> <span class="st">&quot; (&quot;</span> <span class="fu">++</span> show xs <span class="fu">++</span> <span class="st">&quot;)&quot;</span>

<span class="kw">class</span> <span class="dt">FromList</span> n <span class="kw">where</span>
<span class="ot">  fromList ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a

<span class="kw">instance</span> <span class="dt">FromList</span> <span class="dt">Z</span> <span class="kw">where</span>
  fromList [] <span class="fu">=</span> <span class="dt">Nil</span>

<span class="kw">instance</span> <span class="dt">FromList</span> n <span class="ot">=&gt;</span> <span class="dt">FromList</span> (<span class="dt">S</span> n) <span class="kw">where</span>
  fromList (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Cons</span> x <span class="fu">$</span> fromList xs


<span class="ot">lengthVec ::</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Nat</span>
lengthVec <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Z</span>
lengthVec (<span class="dt">Cons</span> x xs) <span class="fu">=</span> <span class="dt">S</span> (lengthVec xs)

<span class="ot">zipVec ::</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n b <span class="ot">-&gt;</span> <span class="dt">Vec</span> n (a,b)
zipVec <span class="dt">Nil</span> <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nil</span>
zipVec (<span class="dt">Cons</span> x xs) (<span class="dt">Cons</span> y ys) <span class="fu">=</span> <span class="dt">Cons</span> (x,y) (zipVec xs ys)

<span class="ot">vec4 ::</span> <span class="dt">Vec</span> <span class="dt">Four</span> <span class="dt">Int</span>
vec4 <span class="fu">=</span> fromList [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]

<span class="ot">vec5 ::</span> <span class="dt">Vec</span> <span class="dt">Five</span> <span class="dt">Int</span>
vec5 <span class="fu">=</span> fromList [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]


<span class="ot">example1 ::</span> <span class="dt">Nat</span>
example1 <span class="fu">=</span> lengthVec vec4
<span class="co">-- S (S (S (S Z)))</span>

<span class="ot">example2 ::</span> <span class="dt">Vec</span> <span class="dt">Four</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
example2 <span class="fu">=</span> zipVec vec4 vec4
<span class="co">-- Cons (0,0) (Cons (1,1) (Cons (2,2) (Cons (3,3) (Nil))))</span></code></pre></div>
<p>So now if we try to zip two <code>Vec</code> types with the wrong shape then we get an error at compile-time about the off-by-one error.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">example2 <span class="fu">=</span> zipVec vec4 vec5
<span class="co">-- Couldn&#39;t match type &#39;S &#39;Z with &#39;Z</span>
<span class="co">-- Expected type: Vec Four Int</span>
<span class="co">--   Actual type: Vec Five Int</span></code></pre></div>
<p>The same technique we can use to create a container which is statically indexed by an empty or non-empty flag, such that if we try to take the head of an empty list we'll get a compile-time error, or stated equivalently we have an obligation to prove to the compiler that the argument we hand to the head function is non-empty.</p>
<div class="sourceCode" include="src/17-promotion/nonempty.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE KindSignatures #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE FlexibleContexts #-}</span>

<span class="kw">data</span> <span class="dt">Size</span> <span class="fu">=</span> <span class="dt">Empty</span> <span class="fu">|</span> <span class="dt">NonEmpty</span>

<span class="kw">data</span> <span class="dt">List</span> a b <span class="kw">where</span>
  <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">List</span> <span class="dt">Empty</span> a
  <span class="dt">Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> b a <span class="ot">-&gt;</span> <span class="dt">List</span> <span class="dt">NonEmpty</span> a

<span class="ot">head&#39; ::</span> <span class="dt">List</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a
head&#39; (<span class="dt">Cons</span> x _) <span class="fu">=</span> x

<span class="ot">example1 ::</span> <span class="dt">Int</span>
example1 <span class="fu">=</span> head&#39; (<span class="dv">1</span> <span class="ot">`Cons`</span> (<span class="dv">2</span> <span class="ot">`Cons`</span> <span class="dt">Nil</span>))

<span class="co">-- Cannot match type Empty with NonEmpty</span>
<span class="ot">example2 ::</span> <span class="dt">Int</span>
example2 <span class="fu">=</span> head&#39; <span class="dt">Nil</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Couldn&#39;t</span> match <span class="kw">type</span> <span class="dt">None</span> with <span class="dt">Many</span>
<span class="dt">Expected</span> <span class="kw">type</span><span class="fu">:</span> <span class="dt">List</span> <span class="dt">NonEmpty</span> <span class="dt">Int</span>
  <span class="dt">Actual</span> <span class="kw">type</span><span class="fu">:</span> <span class="dt">List</span> <span class="dt">Empty</span> <span class="dt">Int</span></code></pre></div>
<p>See:</p>
<ul>
<li><a href="https://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf">Giving Haskell a Promotion</a></li>
</ul>
<h2 id="typelevel-numbers">Typelevel Numbers</h2>
<p>GHC's type literals can also be used in place of explicit Peano arithmetic.</p>
<p>GHC 7.6 is very conservative about performing reduction, GHC 7.8 is much less so and will can solve many typelevel constraints involving natural numbers but sometimes still needs a little coaxing.</p>
<div class="sourceCode" include="src/17-promotion/typenat.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE KindSignatures #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>

<span class="kw">import </span><span class="dt">GHC.TypeLits</span>

<span class="kw">data</span> <span class="dt">Vec</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">Vec</span> <span class="dv">0</span> a
  <span class="dt">Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (<span class="dv">1</span> <span class="fu">+</span> n) a

<span class="co">-- GHC 7.6 will not reduce</span>
<span class="co">-- vec3 :: Vec (1 + (1 + (1 + 0))) Int</span>

<span class="ot">vec3 ::</span> <span class="dt">Vec</span> <span class="dv">3</span> <span class="dt">Int</span>
vec3 <span class="fu">=</span> <span class="dv">0</span> <span class="ot">`Cons`</span> (<span class="dv">1</span> <span class="ot">`Cons`</span> (<span class="dv">2</span> <span class="ot">`Cons`</span> <span class="dt">Nil</span>))</code></pre></div>
<div class="sourceCode" include="src/17-promotion/typenat_cmp.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE KindSignatures #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE FlexibleContexts #-}</span>

<span class="kw">import </span><span class="dt">GHC.TypeLits</span>
<span class="kw">import </span><span class="dt">Data.Type.Equality</span>

<span class="kw">data</span> <span class="dt">Foo</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">Small</span><span class="ot">    ::</span> (n <span class="fu">&lt;=</span> <span class="dv">2</span>)  <span class="ot">=&gt;</span> <span class="dt">Foo</span> n
  <span class="dt">Big</span><span class="ot">      ::</span> (<span class="dv">3</span> <span class="fu">&lt;=</span> n) <span class="ot">=&gt;</span> <span class="dt">Foo</span> n

  <span class="dt">Empty</span><span class="ot">    ::</span> ((n <span class="fu">==</span> <span class="dv">0</span>) <span class="fu">~</span> <span class="dt">True</span>) <span class="ot">=&gt;</span> <span class="dt">Foo</span> n
  <span class="dt">NonEmpty</span><span class="ot"> ::</span> ((n <span class="fu">==</span> <span class="dv">0</span>) <span class="fu">~</span> <span class="dt">False</span>) <span class="ot">=&gt;</span> <span class="dt">Foo</span> n

<span class="ot">big ::</span> <span class="dt">Foo</span> <span class="dv">10</span>
big <span class="fu">=</span> <span class="dt">Big</span>

<span class="ot">small ::</span> <span class="dt">Foo</span> <span class="dv">2</span>
small <span class="fu">=</span> <span class="dt">Small</span>

<span class="ot">empty ::</span> <span class="dt">Foo</span> <span class="dv">0</span>
empty <span class="fu">=</span> <span class="dt">Empty</span>

<span class="ot">nonempty ::</span> <span class="dt">Foo</span> <span class="dv">3</span>
nonempty <span class="fu">=</span> <span class="dt">NonEmpty</span></code></pre></div>
<p>See: <a href="http://www.haskell.org/ghc/docs/7.8.2/html/users_guide/type-level-literals.html">Type-Level Literals</a></p>
<h2 id="typelevel-strings">Typelevel Strings</h2>
<h2 id="custom-errors">Custom Errors</h2>
<p>As of GHC 8.0 we have the capacity to provide custom type error using type families. The messages themselves hook into GHC and expressed using the small datatype found in <code>GHC.TypeLits</code></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ErrorMessage</span> <span class="kw">where</span>
  <span class="dt">Text</span><span class="ot"> ::</span> <span class="dt">Symbol</span> <span class="ot">-&gt;</span> <span class="dt">ErrorMessage</span>
  <span class="dt">ShowType</span><span class="ot"> ::</span> t <span class="ot">-&gt;</span> <span class="dt">ErrorMessage</span>

  <span class="co">-- Put two messages next to each other</span>
<span class="ot">  (:&lt;&gt;:) ::</span> <span class="dt">ErrorMessage</span> <span class="ot">-&gt;</span> <span class="dt">ErrorMessage</span> <span class="ot">-&gt;</span> <span class="dt">ErrorMessage</span>

  <span class="co">-- Put two messages on top of each other</span>
<span class="ot">  (:$$:) ::</span> <span class="dt">ErrorMessage</span> <span class="ot">-&gt;</span> <span class="dt">ErrorMessage</span> <span class="ot">-&gt;</span> <span class="dt">ErrorMessage</span></code></pre></div>
<p>If one of these expressions is found in the signature of an expression GHC reports an error message of the form:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">example<span class="fu">.</span>hs<span class="fu">:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span> error<span class="fu">:</span>
    • <span class="dt">My</span> custom error message line <span class="dv">1</span><span class="fu">.</span>
    • <span class="dt">My</span> custom error message line <span class="dv">2</span><span class="fu">.</span>
    • <span class="dt">In</span> the expression<span class="fu">:</span> example
      <span class="dt">In</span> an equation for ‘foo’<span class="fu">:</span> foo <span class="fu">=</span> <span class="dt">ECoerce</span> (<span class="dt">EFloat</span> <span class="dv">3</span>) (<span class="dt">EInt</span> <span class="dv">4</span>)</code></pre></div>
<div class="sourceCode" include="src/17-promotion/errors.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>

<span class="kw">import </span><span class="dt">GHC.TypeLits</span>

<span class="kw">instance</span>
  <span class="co">-- Error Message</span>
  <span class="dt">TypeError</span> (<span class="dt">Text</span> <span class="st">&quot;Equality is not defined for functions&quot;</span>
  <span class="fu">:$$:</span>
  (<span class="dt">ShowType</span> a <span class="fu">:&lt;&gt;:</span> <span class="dt">Text</span> <span class="st">&quot; -&gt; &quot;</span> <span class="fu">:&lt;&gt;:</span> <span class="dt">ShowType</span> b))

  <span class="co">-- Instance head</span>
  <span class="ot">=&gt;</span> <span class="dt">Eq</span> (a <span class="ot">-&gt;</span> b) <span class="kw">where</span> (<span class="fu">==</span>) <span class="fu">=</span> undefined

<span class="co">-- Fail when we try to equate two functions</span>
example <span class="fu">=</span> id <span class="fu">==</span> id</code></pre></div>
<p>A less contrived example would be creating a type-safe embedded DSL that enforces invariants about the semantics at the type-level. We've been able to do this sort of thing using GADTs and type-families for a while but the error reporting has been horrible. With 8.0 we can have type-families that emit useful type errors that reflect what actually goes wrong and integrate this inside of GHC.</p>
<div class="sourceCode" include="src/17-promotion/errors_dsl.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>

<span class="kw">import </span><span class="dt">GHC.TypeLits</span>

<span class="kw">type</span> family <span class="dt">Coerce</span> a b <span class="kw">where</span>
  <span class="dt">Coerce</span> <span class="dt">Int</span> <span class="dt">Int</span>     <span class="fu">=</span> <span class="dt">Int</span>
  <span class="dt">Coerce</span> <span class="dt">Float</span> <span class="dt">Float</span> <span class="fu">=</span> <span class="dt">Float</span>
  <span class="dt">Coerce</span> <span class="dt">Int</span> <span class="dt">Float</span>   <span class="fu">=</span> <span class="dt">Float</span>
  <span class="dt">Coerce</span> <span class="dt">Float</span> <span class="dt">Int</span>   <span class="fu">=</span> <span class="dt">TypeError</span> (<span class="dt">Text</span> <span class="st">&quot;Cannot cast to smaller type&quot;</span>)

<span class="kw">data</span> <span class="dt">Expr</span> a <span class="kw">where</span>
  <span class="dt">EInt</span><span class="ot">    ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Int</span>
  <span class="dt">EFloat</span><span class="ot">  ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Float</span>
  <span class="dt">ECoerce</span><span class="ot"> ::</span> <span class="dt">Expr</span> b <span class="ot">-&gt;</span> <span class="dt">Expr</span> c <span class="ot">-&gt;</span> <span class="dt">Expr</span> (<span class="dt">Coerce</span> b c)

<span class="ot">foo ::</span> <span class="dt">Expr</span> <span class="dt">Int</span>
foo <span class="fu">=</span> <span class="dt">ECoerce</span> (<span class="dt">EFloat</span> <span class="dv">3</span>) (<span class="dt">EInt</span> <span class="dv">4</span>)</code></pre></div>
<h2 id="type-equality">Type Equality</h2>
<p>Continuing with the theme of building more elaborate proofs in Haskell, GHC 7.8 recently shipped with the <code>Data.Type.Equality</code> module which provides us with an extended set of type-level operations for expressing the equality of types as values, constraints, and promoted booleans.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(~)   ::</span> k <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Constraint</span>
<span class="ot">(==)  ::</span> k <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">(&lt;=)  ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span>
<span class="ot">(&lt;=?) ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">(+)   ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span>
<span class="ot">(-)   ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span>
<span class="ot">(*)   ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span>
<span class="ot">(^)   ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(:~:)     ::</span> k <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="fu">*</span>
<span class="dt">Refl</span><span class="ot">      ::</span> a1 <span class="fu">:~:</span> a1
<span class="ot">sym       ::</span> (a <span class="fu">:~:</span> b) <span class="ot">-&gt;</span> b <span class="fu">:~:</span> a
<span class="ot">trans     ::</span> (a <span class="fu">:~:</span> b) <span class="ot">-&gt;</span> (b <span class="fu">:~:</span> c) <span class="ot">-&gt;</span> a <span class="fu">:~:</span> c
<span class="ot">castWith  ::</span> (a <span class="fu">:~:</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b
<span class="ot">gcastWith ::</span> (a <span class="fu">:~:</span> b) <span class="ot">-&gt;</span> (a <span class="fu">~</span> b <span class="ot">=&gt;</span> r) <span class="ot">-&gt;</span> r</code></pre></div>
<p>With this we have a much stronger language for writing restrictions that can be checked at a compile-time, and a mechanism that will later allow us to write more advanced proofs.</p>
<div class="sourceCode" include="src/17-promotion/type_equality.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE ConstraintKinds #-}</span>

<span class="kw">import </span><span class="dt">GHC.TypeLits</span>
<span class="kw">import </span><span class="dt">Data.Type.Equality</span>

<span class="kw">type</span> <span class="dt">Not</span> a b <span class="fu">=</span> ((b <span class="fu">==</span> a) <span class="fu">~</span> <span class="dt">False</span>)

<span class="ot">restrictUnit ::</span> <span class="dt">Not</span> () a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a
restrictUnit <span class="fu">=</span> id

<span class="ot">restrictChar ::</span> <span class="dt">Not</span> <span class="dt">Char</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a
restrictChar <span class="fu">=</span> id</code></pre></div>
<h2 id="proxies">Proxies</h2>
<p>Using kind polymorphism with phantom types allows us to express the Proxy type which is inhabited by a single constructor with no arguments but with a polykinded phantom type variable which carries an arbitrary type.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE PolyKinds #-}</span>

<span class="co">-- | A concrete, poly-kinded proxy type</span>
<span class="kw">data</span> <span class="dt">Proxy</span> t <span class="fu">=</span> <span class="dt">Proxy</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Proxy</span>

<span class="ot">a ::</span> <span class="dt">Proxy</span> ()
a <span class="fu">=</span> <span class="dt">Proxy</span>

<span class="ot">b ::</span> <span class="dt">Proxy</span> <span class="dv">3</span>
b <span class="fu">=</span> <span class="dt">Proxy</span>

<span class="ot">c ::</span> <span class="dt">Proxy</span> <span class="st">&quot;symbol&quot;</span>
c <span class="fu">=</span> <span class="dt">Proxy</span>

<span class="ot">d ::</span> <span class="dt">Proxy</span> <span class="dt">Maybe</span>
d <span class="fu">=</span> <span class="dt">Proxy</span>

<span class="ot">e ::</span> <span class="dt">Proxy</span> (<span class="dt">Maybe</span> ())
e <span class="fu">=</span> <span class="dt">Proxy</span></code></pre></div>
<p>In cases where we'd normally pass around a <code>undefined</code> as a witness of a typeclass dictionary, we can instead pass a Proxy object which carries the phantom type without the need for the bottom. Using scoped type variables we can then operate with the phantom paramater and manipulate wherever is needed.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">t1 ::</span> a
t1 <span class="fu">=</span> (undefined<span class="ot"> ::</span> a)

<span class="ot">t2 ::</span> <span class="dt">Proxy</span> a
t2 <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> a</code></pre></div>
<h2 id="promoted-syntax">Promoted Syntax</h2>
<p>We've seen constructors promoted using DataKinds, but just like at the value-level GHC also allows us some syntactic sugar for list and tuples instead of explicit cons'ing and pair'ing. This is enabled with the <code>-XTypeOperators</code> extension, which introduces list syntax and tuples of arbitrary arity at the type-level.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">HList</span><span class="ot"> ::</span> [<span class="fu">*</span>] <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">HNil</span><span class="ot">  ::</span> <span class="dt">HList</span> <span class="ch">&#39;[]</span>
  <span class="dt">HCons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">HList</span> t <span class="ot">-&gt;</span> <span class="dt">HList</span> (a <span class="ch">&#39;: t)</span>

<span class="kw">data</span> <span class="dt">Tuple</span><span class="ot"> ::</span> (<span class="fu">*</span>,<span class="fu">*</span>) <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">Tuple</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Tuple</span> <span class="ch">&#39;(a,b)</span></code></pre></div>
<p>Using this we can construct all variety of composite type-level objects.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> <span class="fu">:</span>kind <span class="dv">1</span>
<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Nat</span>

λ<span class="fu">:</span> <span class="fu">:</span>kind <span class="st">&quot;foo&quot;</span>
<span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> <span class="dt">Symbol</span>

λ<span class="fu">:</span> <span class="fu">:</span>kind [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]<span class="ot"> ::</span> [<span class="dt">Nat</span>]

λ<span class="fu">:</span> <span class="fu">:</span>kind [<span class="dt">Int</span>, <span class="dt">Bool</span>, <span class="dt">Char</span>]
[<span class="dt">Int</span>, <span class="dt">Bool</span>, <span class="dt">Char</span>]<span class="ot"> ::</span> [<span class="fu">*</span>]

λ<span class="fu">:</span> <span class="fu">:</span>kind <span class="dt">Just</span> [<span class="dt">Int</span>, <span class="dt">Bool</span>, <span class="dt">Char</span>]
<span class="dt">Just</span> [<span class="dt">Int</span>, <span class="dt">Bool</span>, <span class="dt">Char</span>]<span class="ot"> ::</span> <span class="dt">Maybe</span> [<span class="fu">*</span>]

λ<span class="fu">:</span> <span class="fu">:</span>kind <span class="ch">&#39;(&quot;a&quot;, Int)</span>
(,) <span class="dt">Symbol</span> <span class="fu">*</span>

λ<span class="fu">:</span> <span class="fu">:</span>kind [ <span class="ch">&#39;(&quot;a&quot;, Int), &#39;</span>(<span class="st">&quot;b&quot;</span>, <span class="dt">Bool</span>) ]
[ <span class="ch">&#39;(&quot;a&quot;, Int), &#39;</span>(<span class="st">&quot;b&quot;</span>, <span class="dt">Bool</span>) ]<span class="ot"> ::</span> [(,) <span class="dt">Symbol</span> <span class="fu">*</span>]</code></pre></div>
<h2 id="singleton-types">Singleton Types</h2>
<div class="alert alert-danger">
<p>This is an advanced section, knowledge of singletons is not typically necessary to write Haskell.</p>
</div>
<p>A singleton type is a type with a single value inhabitant. Singleton types can be constructed in a variety of ways using GADTs or with data families.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="kw">instance</span> <span class="dt">Sing</span> (<span class="ot">a ::</span> <span class="dt">Nat</span>) <span class="kw">where</span>
  <span class="dt">SZ</span><span class="ot"> ::</span> <span class="dt">Sing</span> <span class="ch">&#39;Z</span>
  <span class="dt">SS</span><span class="ot"> ::</span> <span class="dt">Sing</span> n <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="ch">&#39;S n)</span>

<span class="kw">data</span> <span class="kw">instance</span> <span class="dt">Sing</span> (<span class="ot">a ::</span> <span class="dt">Maybe</span> k) <span class="kw">where</span>
  <span class="dt">SNothing</span><span class="ot"> ::</span> <span class="dt">Sing</span> <span class="ch">&#39;Nothing</span>
  <span class="dt">SJust</span><span class="ot"> ::</span> <span class="dt">Sing</span> x <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="ch">&#39;Just x)</span>

<span class="kw">data</span> <span class="kw">instance</span> <span class="dt">Sing</span> (<span class="ot">a ::</span> <span class="dt">Bool</span>) <span class="kw">where</span>
  <span class="dt">STrue</span><span class="ot"> ::</span> <span class="dt">Sing</span> <span class="dt">True</span>
  <span class="dt">SFalse</span><span class="ot"> ::</span> <span class="dt">Sing</span> <span class="dt">False</span></code></pre></div>
<p><strong>Promoted Naturals</strong></p>
<table>
<thead>
<tr class="header">
<th align="left">Value-level</th>
<th align="left">Type-level</th>
<th align="left">Models</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">SZ</td>
<td align="left">Sing 'Z</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="left">SS SZ</td>
<td align="left">Sing ('S 'Z)</td>
<td align="left">1</td>
</tr>
<tr class="odd">
<td align="left">SS (SS SZ)</td>
<td align="left">Sing ('S ('S 'Z))</td>
<td align="left">2</td>
</tr>
</tbody>
</table>
<p><strong>Promoted Booleans</strong></p>
<table>
<thead>
<tr class="header">
<th align="left">Value-level</th>
<th align="left">Type-level</th>
<th align="left">Models</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">STrue</td>
<td align="left">Sing 'False</td>
<td align="left">False</td>
</tr>
<tr class="even">
<td align="left">SFalse</td>
<td align="left">Sing 'True</td>
<td align="left">True</td>
</tr>
</tbody>
</table>
<p><strong>Promoted Maybe</strong></p>
<table>
<thead>
<tr class="header">
<th align="left">Value-level</th>
<th align="left">Type-level</th>
<th align="left">Models</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">SJust a</td>
<td align="left">Sing (SJust 'a)</td>
<td align="left">Just a</td>
</tr>
<tr class="even">
<td align="left">SNothing</td>
<td align="left">Sing Nothing</td>
<td align="left">Nothing</td>
</tr>
</tbody>
</table>
<p>Singleton types are an integral part of the small cottage industry of faking dependent types in Haskell, i.e. constructing types with terms predicated upon values. Singleton types are a way of &quot;cheating&quot; by modeling the map between types and values as a structural property of the type.</p>
<div class="sourceCode" include="src/17-promotion/singleton_class.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">{-# LANGUAGE RankNTypes #-}</span>
<span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE PolyKinds #-}</span>
<span class="ot">{-# LANGUAGE KindSignatures #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE StandaloneDeriving #-}</span>
<span class="ot">{-# LANGUAGE TypeSynonymInstances #-}</span>
<span class="ot">{-# LANGUAGE FlexibleContexts #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>

<span class="kw">import </span><span class="dt">Data.Proxy</span>
<span class="kw">import </span><span class="dt">GHC.Exts</span> (<span class="dt">Any</span>)
<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (succ)

<span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Nat</span>

<span class="co">-- kind-indexed data family</span>
<span class="kw">data</span> family <span class="dt">Sing</span> (<span class="ot">a ::</span> k)

<span class="kw">data</span> <span class="kw">instance</span> <span class="dt">Sing</span> (<span class="ot">a ::</span> <span class="dt">Nat</span>) <span class="kw">where</span>
  <span class="dt">SZ</span><span class="ot"> ::</span> <span class="dt">Sing</span> <span class="ch">&#39;Z</span>
  <span class="dt">SS</span><span class="ot"> ::</span> <span class="dt">Sing</span> n <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="ch">&#39;S n)</span>

<span class="kw">data</span> <span class="kw">instance</span> <span class="dt">Sing</span> (<span class="ot">a ::</span> <span class="dt">Maybe</span> k) <span class="kw">where</span>
  <span class="dt">SNothing</span><span class="ot"> ::</span> <span class="dt">Sing</span> <span class="ch">&#39;Nothing</span>
  <span class="dt">SJust</span><span class="ot"> ::</span> <span class="dt">Sing</span> x <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="ch">&#39;Just x)</span>

<span class="kw">data</span> <span class="kw">instance</span> <span class="dt">Sing</span> (<span class="ot">a ::</span> <span class="dt">Bool</span>) <span class="kw">where</span>
  <span class="dt">STrue</span><span class="ot"> ::</span> <span class="dt">Sing</span> <span class="dt">True</span>
  <span class="dt">SFalse</span><span class="ot"> ::</span> <span class="dt">Sing</span> <span class="dt">False</span>

<span class="kw">data</span> <span class="dt">Fin</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>) <span class="kw">where</span>
  <span class="dt">FZ</span><span class="ot"> ::</span> <span class="dt">Fin</span> (<span class="dt">S</span> n)
  <span class="dt">FS</span><span class="ot"> ::</span> <span class="dt">Fin</span> n <span class="ot">-&gt;</span> <span class="dt">Fin</span> (<span class="dt">S</span> n)

<span class="kw">data</span> <span class="dt">Vec</span> a n <span class="kw">where</span>
  <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">Vec</span> a <span class="dt">Z</span>
  <span class="dt">Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">Vec</span> a (<span class="dt">S</span> n)

<span class="kw">class</span> <span class="dt">SingI</span> (<span class="ot">a ::</span> k) <span class="kw">where</span>
<span class="ot">  sing ::</span> <span class="dt">Sing</span> a

<span class="kw">instance</span> <span class="dt">SingI</span> <span class="dt">Z</span> <span class="kw">where</span>
  sing <span class="fu">=</span> <span class="dt">SZ</span>

<span class="kw">instance</span> <span class="dt">SingI</span> n <span class="ot">=&gt;</span> <span class="dt">SingI</span> (<span class="dt">S</span> n) <span class="kw">where</span>
  sing <span class="fu">=</span> <span class="dt">SS</span> sing

<span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Nat</span>
<span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> (<span class="dt">SNat</span> a)
<span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> (<span class="dt">SBool</span> a)
<span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> (<span class="dt">Fin</span> a)
<span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Vec</span> a n)

<span class="kw">type</span> family (<span class="ot">m ::</span> <span class="dt">Nat</span>) <span class="fu">:+</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span>
  <span class="dt">Z</span> <span class="fu">:+</span> n <span class="fu">=</span> n
  <span class="dt">S</span> m <span class="fu">:+</span> n <span class="fu">=</span> <span class="dt">S</span> (m <span class="fu">:+</span> n)

<span class="kw">type</span> <span class="dt">SNat</span> (<span class="ot">k ::</span> <span class="dt">Nat</span>) <span class="fu">=</span> <span class="dt">Sing</span> k
<span class="kw">type</span> <span class="dt">SBool</span> (<span class="ot">k ::</span> <span class="dt">Bool</span>) <span class="fu">=</span> <span class="dt">Sing</span> k
<span class="kw">type</span> <span class="dt">SMaybe</span> (<span class="ot">b ::</span> a) (<span class="ot">k ::</span> <span class="dt">Maybe</span> a) <span class="fu">=</span> <span class="dt">Sing</span> k

<span class="ot">size ::</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">SNat</span> n
size <span class="dt">Nil</span>         <span class="fu">=</span> <span class="dt">SZ</span>
size (<span class="dt">Cons</span> x xs) <span class="fu">=</span> <span class="dt">SS</span> (size xs)

<span class="ot">forget ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">Nat</span>
forget <span class="dt">SZ</span> <span class="fu">=</span> <span class="dt">Z</span>
forget (<span class="dt">SS</span> n) <span class="fu">=</span> <span class="dt">S</span> (forget n)

<span class="ot">natToInt ::</span> <span class="dt">Integral</span> n <span class="ot">=&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> n
natToInt <span class="dt">Z</span>     <span class="fu">=</span> <span class="dv">0</span>
natToInt (<span class="dt">S</span> n) <span class="fu">=</span> natToInt n <span class="fu">+</span> <span class="dv">1</span>

<span class="ot">intToNat ::</span> (<span class="dt">Integral</span> a, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Nat</span>
intToNat <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Z</span>
intToNat n <span class="fu">=</span> <span class="dt">S</span> <span class="fu">$</span> intToNat (n <span class="fu">-</span> <span class="dv">1</span>)

<span class="ot">sNatToInt ::</span> <span class="dt">Num</span> n <span class="ot">=&gt;</span> <span class="dt">SNat</span> x <span class="ot">-&gt;</span> n
sNatToInt <span class="dt">SZ</span>     <span class="fu">=</span> <span class="dv">0</span>
sNatToInt (<span class="dt">SS</span> n) <span class="fu">=</span> sNatToInt n <span class="fu">+</span> <span class="dv">1</span>

index<span class="ot"> ::</span> <span class="dt">Fin</span> n <span class="ot">-&gt;</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> a
index <span class="dt">FZ</span> (<span class="dt">Cons</span> x _)      <span class="fu">=</span> x
index (<span class="dt">FS</span> n) (<span class="dt">Cons</span> _ xs) <span class="fu">=</span> index n xs


<span class="ot">test1 ::</span> <span class="dt">Fin</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>)))
test1 <span class="fu">=</span> <span class="dt">FS</span> (<span class="dt">FS</span> <span class="dt">FZ</span>)

<span class="ot">test2 ::</span> <span class="dt">Int</span>
test2 <span class="fu">=</span> index <span class="dt">FZ</span> (<span class="dv">1</span> <span class="ot">`Cons`</span> (<span class="dv">2</span> <span class="ot">`Cons`</span> <span class="dt">Nil</span>))

<span class="ot">test3 ::</span> <span class="dt">Sing</span> (<span class="ch">&#39;Just (&#39;</span><span class="dt">S</span> (<span class="ch">&#39;S Z)))</span>
test3 <span class="fu">=</span> <span class="dt">SJust</span> (<span class="dt">SS</span> (<span class="dt">SS</span> <span class="dt">SZ</span>))

<span class="ot">test4 ::</span> <span class="dt">Sing</span> (<span class="ch">&#39;S (&#39;</span><span class="dt">S</span> <span class="dt">Z</span>))
test4 <span class="fu">=</span> <span class="dt">SS</span> (<span class="dt">SS</span> <span class="dt">SZ</span>)

<span class="co">-- polymorphic constructor SingI</span>
<span class="ot">test5 ::</span> <span class="dt">Sing</span> (<span class="ch">&#39;S (&#39;</span><span class="dt">S</span> <span class="dt">Z</span>))
test5 <span class="fu">=</span> sing</code></pre></div>
<p>The builtin singleton types provided in <code>GHC.TypeLits</code> have the useful implementation that type-level values can be reflected to the value-level and back up to the type-level, albeit under an existential.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">someNatVal ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">SomeNat</span>
<span class="ot">someSymbolVal ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">SomeSymbol</span>

<span class="ot">natVal ::</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> proxy n <span class="ot">-&gt;</span> <span class="dt">Integer</span>
<span class="ot">symbolVal ::</span> <span class="dt">KnownSymbol</span> n <span class="ot">=&gt;</span> proxy n <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre></div>
<div class="sourceCode" include="src/17-promotion/singleton.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE PolyKinds #-}</span>
<span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>

<span class="kw">import </span><span class="dt">Data.Proxy</span>
<span class="kw">import </span><span class="dt">GHC.TypeLits</span>

<span class="ot">a ::</span> <span class="dt">Integer</span>
a <span class="fu">=</span> natVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">1</span>)
<span class="co">-- 1</span>

<span class="ot">b ::</span> <span class="dt">String</span>
b <span class="fu">=</span> symbolVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="st">&quot;foo&quot;</span>)
<span class="co">-- &quot;foo&quot;</span>

<span class="ot">c ::</span> <span class="dt">Integer</span>
c <span class="fu">=</span> natVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>))
<span class="co">-- 5</span></code></pre></div>
<h2 id="closed-type-families">Closed Type Families</h2>
<p>In the type families we've used so far (called open type families) there is no notion of ordering of the equations involved in the type-level function. The type family can be extended at any point in the code resolution simply proceeds sequentially through the available definitions. Closed type-families allow an alternative declaration that allows for a base case for the resolution allowing us to actually write recursive functions over types.</p>
<p>For example consider if we wanted to write a function which counts the arguments in the type of a function and reifies at the value-level.</p>
<div class="sourceCode" include="src/17-promotion/countargs.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>

<span class="kw">import </span><span class="dt">Data.Proxy</span>
<span class="kw">import </span><span class="dt">GHC.TypeLits</span>

<span class="kw">type</span> family <span class="dt">Count</span> (<span class="ot">f ::</span> <span class="fu">*</span>)<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span>
  <span class="dt">Count</span> (a <span class="ot">-&gt;</span> b) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="dt">Count</span> b)
  <span class="dt">Count</span> x <span class="fu">=</span> <span class="dv">1</span>

<span class="kw">type</span> <span class="dt">Fn1</span> <span class="fu">=</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="kw">type</span> <span class="dt">Fn2</span> <span class="fu">=</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>

<span class="ot">fn1 ::</span> <span class="dt">Integer</span>
fn1 <span class="fu">=</span> natVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Count</span> <span class="dt">Fn1</span>))
<span class="co">-- 2</span>

<span class="ot">fn2 ::</span> <span class="dt">Integer</span>
fn2 <span class="fu">=</span> natVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Count</span> <span class="dt">Fn2</span>))
<span class="co">-- 4</span></code></pre></div>
<p>The variety of functions we can now write down are rather remarkable, allowing us to write meaningful logic at the type level.</p>
<div class="sourceCode" include="src/17-promotion/closed_typefamily.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE PolyKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span>
<span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>

<span class="kw">import </span><span class="dt">GHC.TypeLits</span>
<span class="kw">import </span><span class="dt">Data.Proxy</span>
<span class="kw">import </span><span class="dt">Data.Type.Equality</span>

<span class="co">-- Type-level functions over type-level lists.</span>

<span class="kw">type</span> family <span class="dt">Reverse</span> (<span class="ot">xs ::</span> [k])<span class="ot"> ::</span> [k] <span class="kw">where</span>
  <span class="dt">Reverse</span> <span class="ch">&#39;[] = &#39;</span>[]
  <span class="dt">Reverse</span> xs <span class="fu">=</span> <span class="dt">Rev</span> xs <span class="ch">&#39;[]</span>

<span class="kw">type</span> family <span class="dt">Rev</span> (<span class="ot">xs ::</span> [k]) (<span class="ot">ys ::</span> [k])<span class="ot"> ::</span> [k] <span class="kw">where</span>
  <span class="dt">Rev</span> <span class="ch">&#39;[] i = i</span>
  <span class="dt">Rev</span> (x <span class="ch">&#39;: xs) i = Rev xs (x &#39;</span><span class="fu">:</span> i)

<span class="kw">type</span> family <span class="dt">Length</span> (<span class="ot">as ::</span> [k])<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span>
  <span class="dt">Length</span> <span class="ch">&#39;[] = 0</span>
  <span class="dt">Length</span> (x <span class="ch">&#39;: xs) = 1 + Length xs</span>

<span class="kw">type</span> family <span class="dt">If</span> (<span class="ot">p ::</span> <span class="dt">Bool</span>) (<span class="ot">a ::</span> k) (<span class="ot">b ::</span> k)<span class="ot"> ::</span> k <span class="kw">where</span>
  <span class="dt">If</span> <span class="dt">True</span> a b <span class="fu">=</span> a
  <span class="dt">If</span> <span class="dt">False</span> a b <span class="fu">=</span> b

<span class="kw">type</span> family <span class="dt">Concat</span> (<span class="ot">as ::</span> [k]) (<span class="ot">bs ::</span> [k])<span class="ot"> ::</span> [k] <span class="kw">where</span>
  <span class="dt">Concat</span> a <span class="ch">&#39;[] = a</span>
  <span class="dt">Concat</span> <span class="ch">&#39;[] b = b</span>
  <span class="dt">Concat</span> (a <span class="ch">&#39;: as) bs = a &#39;</span><span class="fu">:</span> <span class="dt">Concat</span> as bs

<span class="kw">type</span> family <span class="dt">Map</span> (<span class="ot">f ::</span> a <span class="ot">-&gt;</span> b) (<span class="ot">as ::</span> [a])<span class="ot"> ::</span> [b] <span class="kw">where</span>
  <span class="dt">Map</span> f <span class="ch">&#39;[] = &#39;</span>[]
  <span class="dt">Map</span> f (x <span class="ch">&#39;: xs) = f x &#39;</span><span class="fu">:</span> <span class="dt">Map</span> f xs

<span class="kw">type</span> family <span class="dt">Sum</span> (<span class="ot">xs ::</span> [<span class="dt">Nat</span>])<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span>
  <span class="dt">Sum</span> <span class="ch">&#39;[] = 0</span>
  <span class="dt">Sum</span> (x <span class="ch">&#39;: xs) = x + Sum xs</span>

<span class="ot">ex1 ::</span> <span class="dt">Reverse</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="fu">~</span> [<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>] <span class="ot">=&gt;</span> <span class="dt">Proxy</span> a
ex1 <span class="fu">=</span> <span class="dt">Proxy</span>

<span class="ot">ex2 ::</span> <span class="dt">Length</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="fu">~</span> <span class="dv">3</span> <span class="ot">=&gt;</span> <span class="dt">Proxy</span> a
ex2 <span class="fu">=</span> <span class="dt">Proxy</span>

<span class="ot">ex3 ::</span> (<span class="dt">Length</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]) <span class="fu">~</span> (<span class="dt">Length</span> (<span class="dt">Reverse</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>])) <span class="ot">=&gt;</span> <span class="dt">Proxy</span> a
ex3 <span class="fu">=</span> <span class="dt">Proxy</span>

<span class="co">-- Reflecting type level computations back to the value level.</span>
<span class="ot">ex4 ::</span> <span class="dt">Integer</span>
ex4 <span class="fu">=</span> natVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Length</span> (<span class="dt">Concat</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>])))
<span class="co">-- 6</span>

<span class="ot">ex5 ::</span> <span class="dt">Integer</span>
ex5 <span class="fu">=</span> natVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Sum</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]))
<span class="co">-- 6</span>

<span class="co">-- Couldn&#39;t match type ‘2’ with ‘1’</span>
<span class="ot">ex6 ::</span> <span class="dt">Reverse</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="fu">~</span> [<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>] <span class="ot">=&gt;</span> <span class="dt">Proxy</span> a
ex6 <span class="fu">=</span> <span class="dt">Proxy</span></code></pre></div>
<p>The results of type family functions need not necessarily be kinded as <code>(*)</code> either. For example using Nat or Constraint is permitted.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Elem</span> (<span class="ot">a ::</span> k) (<span class="ot">bs ::</span> [k])<span class="ot"> ::</span> <span class="dt">Constraint</span> <span class="kw">where</span>
  <span class="dt">Elem</span> a (a <span class="ch">&#39;: bs) = (() :: Constraint)</span>
  <span class="dt">Elem</span> a (b <span class="ch">&#39;: bs) = a `Elem` bs</span>

<span class="kw">type</span> family <span class="dt">Sum</span> (<span class="ot">ns ::</span> [<span class="dt">Nat</span>])<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span>
  <span class="dt">Sum</span> <span class="ch">&#39;[] = 0</span>
  <span class="dt">Sum</span> (n <span class="ch">&#39;: ns) = n + Sum ns</span></code></pre></div>
<h2 id="kind-indexed-type-families">Kind Indexed Type Families</h2>
<div class="alert alert-danger">
<p>This is an advanced section, and is not typically necessary to write Haskell.</p>
</div>
<p>Just as typeclasses are normally indexed on types, type families can also be indexed on kinds with the kinds given as explicit kind signatures on type variables.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family (<span class="ot">a ::</span> k) <span class="fu">==</span> (<span class="ot">b ::</span> k)<span class="ot"> ::</span> <span class="dt">Bool</span>
<span class="kw">type</span> <span class="kw">instance</span> a <span class="fu">==</span> b <span class="fu">=</span> <span class="dt">EqStar</span> a b
<span class="kw">type</span> <span class="kw">instance</span> a <span class="fu">==</span> b <span class="fu">=</span> <span class="dt">EqArrow</span> a b
<span class="kw">type</span> <span class="kw">instance</span> a <span class="fu">==</span> b <span class="fu">=</span> <span class="dt">EqBool</span> a b

<span class="kw">type</span> family <span class="dt">EqStar</span> (<span class="ot">a ::</span> <span class="fu">*</span>) (<span class="ot">b ::</span> <span class="fu">*</span>) <span class="kw">where</span>
  <span class="dt">EqStar</span> a a <span class="fu">=</span> <span class="dt">True</span>
  <span class="dt">EqStar</span> a b <span class="fu">=</span> <span class="dt">False</span>

<span class="kw">type</span> family <span class="dt">EqArrow</span> (<span class="ot">a ::</span> k1 <span class="ot">-&gt;</span> k2) (<span class="ot">b ::</span> k1 <span class="ot">-&gt;</span> k2) <span class="kw">where</span>
  <span class="dt">EqArrow</span> a a <span class="fu">=</span> <span class="dt">True</span>
  <span class="dt">EqArrow</span> a b <span class="fu">=</span> <span class="dt">False</span>

<span class="kw">type</span> family <span class="dt">EqBool</span> a b <span class="kw">where</span>
  <span class="dt">EqBool</span> <span class="dt">True</span>  <span class="dt">True</span>  <span class="fu">=</span> <span class="dt">True</span>
  <span class="dt">EqBool</span> <span class="dt">False</span> <span class="dt">False</span> <span class="fu">=</span> <span class="dt">True</span>
  <span class="dt">EqBool</span> a     b     <span class="fu">=</span> <span class="dt">False</span>

<span class="kw">type</span> family <span class="dt">EqList</span> a b <span class="kw">where</span>
  <span class="dt">EqList</span> <span class="ch">&#39;[]        &#39;</span>[]        <span class="fu">=</span> <span class="dt">True</span>
  <span class="dt">EqList</span> (h1 <span class="ch">&#39;: t1) (h2 &#39;</span><span class="fu">:</span> t2) <span class="fu">=</span> (h1 <span class="fu">==</span> h2) <span class="fu">&amp;&amp;</span> (t1 <span class="fu">==</span> t2)
  <span class="dt">EqList</span> a          b          <span class="fu">=</span> <span class="dt">False</span>

<span class="kw">type</span> family a <span class="fu">&amp;&amp;</span> b <span class="kw">where</span>
  <span class="dt">True</span> <span class="fu">&amp;&amp;</span> <span class="dt">True</span> <span class="fu">=</span> <span class="dt">True</span>
  a    <span class="fu">&amp;&amp;</span> a    <span class="fu">=</span> <span class="dt">False</span></code></pre></div>
<h2 id="promoted-symbols">Promoted Symbols</h2>
<div class="sourceCode" include="src/17-promotion/hasfield.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE PolyKinds #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE FlexibleContexts #-}</span>
<span class="ot">{-# LANGUAGE FunctionalDependencies #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE ConstraintKinds #-}</span>


<span class="kw">import </span><span class="dt">GHC.TypeLits</span>
<span class="kw">import </span><span class="dt">Data.Type.Equality</span>

<span class="kw">data</span> <span class="dt">Label</span> (<span class="ot">l ::</span> <span class="dt">Symbol</span>) <span class="fu">=</span> <span class="dt">Get</span>

<span class="kw">class</span> <span class="dt">Has</span> a l b <span class="fu">|</span> a l <span class="ot">-&gt;</span> b <span class="kw">where</span>
<span class="ot">  from ::</span> a <span class="ot">-&gt;</span> <span class="dt">Label</span> l <span class="ot">-&gt;</span> b

<span class="kw">data</span> <span class="dt">Point2D</span> <span class="fu">=</span> <span class="dt">Point2</span> <span class="dt">Double</span> <span class="dt">Double</span> <span class="kw">deriving</span> <span class="dt">Show</span>
<span class="kw">data</span> <span class="dt">Point3D</span> <span class="fu">=</span> <span class="dt">Point3</span> <span class="dt">Double</span> <span class="dt">Double</span> <span class="dt">Double</span> <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">instance</span> <span class="dt">Has</span> <span class="dt">Point2D</span> <span class="st">&quot;x&quot;</span> <span class="dt">Double</span> <span class="kw">where</span>
  from (<span class="dt">Point2</span> x _) _ <span class="fu">=</span> x

<span class="kw">instance</span> <span class="dt">Has</span> <span class="dt">Point2D</span> <span class="st">&quot;y&quot;</span> <span class="dt">Double</span> <span class="kw">where</span>
  from (<span class="dt">Point2</span> _ y) _ <span class="fu">=</span> y


<span class="kw">instance</span> <span class="dt">Has</span> <span class="dt">Point3D</span> <span class="st">&quot;x&quot;</span> <span class="dt">Double</span> <span class="kw">where</span>
  from (<span class="dt">Point3</span> x _ _) _ <span class="fu">=</span> x

<span class="kw">instance</span> <span class="dt">Has</span> <span class="dt">Point3D</span> <span class="st">&quot;y&quot;</span> <span class="dt">Double</span> <span class="kw">where</span>
  from (<span class="dt">Point3</span> _ y _) _ <span class="fu">=</span> y

<span class="kw">instance</span> <span class="dt">Has</span> <span class="dt">Point3D</span> <span class="st">&quot;z&quot;</span> <span class="dt">Double</span> <span class="kw">where</span>
  from (<span class="dt">Point3</span> _ _ z) _ <span class="fu">=</span> z


<span class="kw">infixl</span> <span class="dv">6</span> <span class="fu">#</span>

<span class="ot">(#) ::</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b
(<span class="fu">#</span>) <span class="fu">=</span> flip (<span class="fu">$</span>)

_<span class="ot">x ::</span> <span class="dt">Has</span> a <span class="st">&quot;x&quot;</span> b <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b
_x pnt <span class="fu">=</span> from pnt (<span class="dt">Get</span><span class="ot"> ::</span> <span class="dt">Label</span> <span class="st">&quot;x&quot;</span>)

_<span class="ot">y ::</span> <span class="dt">Has</span> a <span class="st">&quot;y&quot;</span> b <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b
_y pnt <span class="fu">=</span> from pnt (<span class="dt">Get</span><span class="ot"> ::</span> <span class="dt">Label</span> <span class="st">&quot;y&quot;</span>)

_<span class="ot">z ::</span> <span class="dt">Has</span> a <span class="st">&quot;z&quot;</span> b <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b
_z pnt <span class="fu">=</span> from pnt (<span class="dt">Get</span><span class="ot"> ::</span> <span class="dt">Label</span> <span class="st">&quot;z&quot;</span>)

<span class="kw">type</span> <span class="dt">Point</span> a r <span class="fu">=</span> (<span class="dt">Has</span> a <span class="st">&quot;x&quot;</span> r, <span class="dt">Has</span> a <span class="st">&quot;y&quot;</span> r)

<span class="ot">distance ::</span> (<span class="dt">Point</span> a r, <span class="dt">Point</span> b r, <span class="dt">Floating</span> r) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> r
distance p1 p2 <span class="fu">=</span> sqrt (d1<span class="fu">^</span><span class="dv">2</span> <span class="fu">+</span> d2<span class="fu">^</span><span class="dv">2</span>)
  <span class="kw">where</span>
    d1 <span class="fu">=</span> (p1 <span class="fu">#</span> _x) <span class="fu">+</span> (p1 <span class="fu">#</span> _y)
    d2 <span class="fu">=</span> (p2 <span class="fu">#</span> _x) <span class="fu">+</span> (p2 <span class="fu">#</span> _y)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  print <span class="fu">$</span> (<span class="dt">Point2</span> <span class="dv">10</span> <span class="dv">20</span>) <span class="fu">#</span> _x

  <span class="co">-- Fails with: No instance for (Has Point2D &quot;z&quot; a0)</span>
  <span class="co">-- print $ (Point2 10 20) # _z</span>

  print <span class="fu">$</span> (<span class="dt">Point3</span> <span class="dv">10</span> <span class="dv">20</span> <span class="dv">30</span>) <span class="fu">#</span> _x
  print <span class="fu">$</span> (<span class="dt">Point3</span> <span class="dv">10</span> <span class="dv">20</span> <span class="dv">30</span>) <span class="fu">#</span> _z

  print <span class="fu">$</span> distance (<span class="dt">Point2</span> <span class="dv">1</span> <span class="dv">3</span>) (<span class="dt">Point2</span> <span class="dv">2</span> <span class="dv">7</span>)
  print <span class="fu">$</span> distance (<span class="dt">Point2</span> <span class="dv">1</span> <span class="dv">3</span>) (<span class="dt">Point3</span> <span class="dv">2</span> <span class="dv">7</span> <span class="dv">4</span>)
  print <span class="fu">$</span> distance (<span class="dt">Point3</span> <span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span>) (<span class="dt">Point3</span> <span class="dv">2</span> <span class="dv">7</span> <span class="dv">3</span>)</code></pre></div>
<p>Since record is fundamentally no different from the tuple we can also do the same kind of construction over record field names.</p>
<div class="sourceCode" include="src/17-promotion/typelevel_fields.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE KindSignatures #-}</span>
<span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class="ot">{-# LANGUAGE FunctionalDependencies #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE FlexibleContexts #-}</span>
<span class="ot">{-# LANGUAGE StandaloneDeriving #-}</span>
<span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span>
<span class="ot">{-# LANGUAGE ConstraintKinds #-}</span>


<span class="kw">import </span><span class="dt">GHC.TypeLits</span>

<span class="kw">newtype</span> <span class="dt">Field</span> (<span class="ot">n ::</span> <span class="dt">Symbol</span>) v <span class="fu">=</span> <span class="dt">Field</span> {<span class="ot"> unField ::</span> v }
  <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">data</span> <span class="dt">Person1</span> <span class="fu">=</span> <span class="dt">Person1</span>
  { _<span class="ot">age      ::</span> <span class="dt">Field</span> <span class="st">&quot;age&quot;</span> <span class="dt">Int</span>
  , _<span class="ot">name     ::</span> <span class="dt">Field</span> <span class="st">&quot;name&quot;</span> <span class="dt">String</span>
  }

<span class="kw">data</span> <span class="dt">Person2</span> <span class="fu">=</span> <span class="dt">Person2</span>
  { _<span class="ot">age&#39;  ::</span> <span class="dt">Field</span> <span class="st">&quot;age&quot;</span> <span class="dt">Int</span>
  , _<span class="ot">name&#39; ::</span> <span class="dt">Field</span> <span class="st">&quot;name&quot;</span> <span class="dt">String</span>
  , _<span class="ot">lib&#39;  ::</span> <span class="dt">Field</span> <span class="st">&quot;lib&quot;</span> <span class="dt">String</span>
  }

<span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Person1</span>
<span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Person2</span>

<span class="kw">data</span> <span class="dt">Label</span> (<span class="ot">l ::</span> <span class="dt">Symbol</span>) <span class="fu">=</span> <span class="dt">Get</span>

<span class="kw">class</span> <span class="dt">Has</span> a l b <span class="fu">|</span> a l <span class="ot">-&gt;</span> b <span class="kw">where</span>
<span class="ot">  from ::</span> a <span class="ot">-&gt;</span> <span class="dt">Label</span> l <span class="ot">-&gt;</span> b

<span class="kw">instance</span> <span class="dt">Has</span> <span class="dt">Person1</span> <span class="st">&quot;age&quot;</span> <span class="dt">Int</span> <span class="kw">where</span>
  from (<span class="dt">Person1</span> a _) _ <span class="fu">=</span> unField a

<span class="kw">instance</span> <span class="dt">Has</span> <span class="dt">Person1</span> <span class="st">&quot;name&quot;</span> <span class="dt">String</span> <span class="kw">where</span>
  from (<span class="dt">Person1</span> _ a) _ <span class="fu">=</span> unField a

<span class="kw">instance</span> <span class="dt">Has</span> <span class="dt">Person2</span> <span class="st">&quot;age&quot;</span> <span class="dt">Int</span> <span class="kw">where</span>
  from (<span class="dt">Person2</span> a _ _) _ <span class="fu">=</span> unField a

<span class="kw">instance</span> <span class="dt">Has</span> <span class="dt">Person2</span> <span class="st">&quot;name&quot;</span> <span class="dt">String</span> <span class="kw">where</span>
  from (<span class="dt">Person2</span> _ a _) _ <span class="fu">=</span> unField a

<span class="ot">age ::</span> <span class="dt">Has</span> a <span class="st">&quot;age&quot;</span> b <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b
age pnt <span class="fu">=</span> from pnt (<span class="dt">Get</span><span class="ot"> ::</span> <span class="dt">Label</span> <span class="st">&quot;age&quot;</span>)

<span class="ot">name ::</span> <span class="dt">Has</span> a <span class="st">&quot;name&quot;</span> b <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b
name pnt <span class="fu">=</span> from pnt (<span class="dt">Get</span><span class="ot"> ::</span> <span class="dt">Label</span> <span class="st">&quot;name&quot;</span>)

<span class="co">-- Parameterized constraint kind for &quot;Simon-ness&quot; of a record.</span>
<span class="kw">type</span> <span class="dt">Simon</span> a <span class="fu">=</span> (<span class="dt">Has</span> a <span class="st">&quot;name&quot;</span> <span class="dt">String</span>, <span class="dt">Has</span> a <span class="st">&quot;age&quot;</span> <span class="dt">Int</span>)

<span class="ot">spj ::</span> <span class="dt">Person1</span>
spj <span class="fu">=</span> <span class="dt">Person1</span> (<span class="dt">Field</span> <span class="dv">56</span>) (<span class="dt">Field</span> <span class="st">&quot;Simon Peyton Jones&quot;</span>)

<span class="ot">smarlow ::</span> <span class="dt">Person2</span>
smarlow <span class="fu">=</span> <span class="dt">Person2</span> (<span class="dt">Field</span> <span class="dv">38</span>) (<span class="dt">Field</span> <span class="st">&quot;Simon Marlow&quot;</span>) (<span class="dt">Field</span> <span class="st">&quot;rts&quot;</span>)


<span class="ot">catNames ::</span> (<span class="dt">Simon</span> a, <span class="dt">Simon</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">String</span>
catNames a b <span class="fu">=</span> name a <span class="fu">++</span> name b

<span class="ot">addAges ::</span> (<span class="dt">Simon</span> a, <span class="dt">Simon</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Int</span>
addAges a b <span class="fu">=</span> age a <span class="fu">+</span> age b


<span class="ot">names ::</span> <span class="dt">String</span>
names <span class="fu">=</span> name smarlow <span class="fu">++</span> <span class="st">&quot;,&quot;</span> <span class="fu">++</span> name spj
<span class="co">-- &quot;Simon Marlow,Simon Peyton Jones&quot;</span>

<span class="ot">ages ::</span> <span class="dt">Int</span>
ages <span class="fu">=</span> age spj <span class="fu">+</span> age smarlow
<span class="co">-- 94</span></code></pre></div>
<p>Notably this approach is mostly just all boilerplate class instantiation which could be abstracted away using TemplateHaskell or a Generic deriving.</p>
<h2 id="hlists">HLists</h2>
<div class="alert alert-danger">
<p>This is an advanced section, and is not typically necessary to write Haskell.</p>
</div>
<p>A heterogeneous list is a cons list whose type statically encodes the ordered types of its values.</p>
<div class="sourceCode" include="src/17-promotion/hlist.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE KindSignatures #-}</span>

<span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">::</span><span class="fu">:</span>

<span class="kw">data</span> <span class="dt">HList</span> (<span class="ot">ts ::</span> [ <span class="fu">*</span> ]) <span class="kw">where</span>
  <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">HList</span> <span class="ch">&#39;[]</span>
<span class="ot">  (:::) ::</span> t <span class="ot">-&gt;</span> <span class="dt">HList</span> ts <span class="ot">-&gt;</span> <span class="dt">HList</span> (t <span class="ch">&#39;: ts)</span>

<span class="co">-- Take the head of a non-empty list with the first value as Bool type.</span>
<span class="ot">headBool ::</span> <span class="dt">HList</span> (<span class="dt">Bool</span> <span class="ch">&#39;: xs) -&gt; Bool</span>
headBool hlist <span class="fu">=</span> <span class="kw">case</span> hlist <span class="kw">of</span>
  (a <span class="ot">::</span><span class="fu">:</span> _) <span class="ot">-&gt;</span> a

<span class="ot">hlength ::</span> <span class="dt">HList</span> x <span class="ot">-&gt;</span> <span class="dt">Int</span>
hlength <span class="dt">Nil</span> <span class="fu">=</span> <span class="dv">0</span>
hlength (_ <span class="ot">::</span><span class="fu">:</span> b) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> (hlength b)


<span class="ot">tuple ::</span> (<span class="dt">Bool</span>, (<span class="dt">String</span>, (<span class="dt">Double</span>, ())))
tuple <span class="fu">=</span> (<span class="dt">True</span>, (<span class="st">&quot;foo&quot;</span>, (<span class="fl">3.14</span>, ())))

<span class="ot">hlist ::</span> <span class="dt">HList</span> <span class="ch">&#39;[Bool, String , Double , ()]</span>
hlist <span class="fu">=</span> <span class="dt">True</span> <span class="ot">::</span><span class="fu">:</span> <span class="st">&quot;foo&quot;</span> <span class="ot">::</span><span class="fu">:</span> <span class="fl">3.14</span> <span class="ot">::</span><span class="fu">:</span> () <span class="ot">::</span><span class="fu">:</span> <span class="dt">Nil</span></code></pre></div>
<p>Of course this immediately begs the question of how to print such a list out to a string in the presence of type-heterogeneity. In this case we can use type-families combined with constraint kinds to apply the Show over the HLists parameters to generate the aggregate constraint that all types in the HList are Showable, and then derive the Show instance.</p>
<div class="sourceCode" include="src/17-promotion/constraint_list.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE PolyKinds #-}</span>
<span class="ot">{-# LANGUAGE KindSignatures #-}</span>
<span class="ot">{-# LANGUAGE ConstraintKinds #-}</span>
<span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>

<span class="kw">import </span><span class="dt">GHC.Exts</span> (<span class="dt">Constraint</span>)

<span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">::</span><span class="fu">:</span>

<span class="kw">data</span> <span class="dt">HList</span> (<span class="ot">ts ::</span> [ <span class="fu">*</span> ]) <span class="kw">where</span>
  <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">HList</span> <span class="ch">&#39;[]</span>
<span class="ot">  (:::) ::</span> t <span class="ot">-&gt;</span> <span class="dt">HList</span> ts <span class="ot">-&gt;</span> <span class="dt">HList</span> (t <span class="ch">&#39;: ts)</span>

<span class="kw">type</span> family <span class="dt">Map</span> (<span class="ot">f ::</span> a <span class="ot">-&gt;</span> b) (<span class="ot">xs ::</span> [a])<span class="ot"> ::</span> [b]
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Map</span> f <span class="ch">&#39;[] = &#39;</span>[]
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Map</span> f (x <span class="ch">&#39;: xs) = f x &#39;</span><span class="fu">:</span> <span class="dt">Map</span> f xs

<span class="kw">type</span> family <span class="dt">Constraints</span> (<span class="ot">cs ::</span> [<span class="dt">Constraint</span>])<span class="ot"> ::</span> <span class="dt">Constraint</span>
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Constraints</span> <span class="ch">&#39;[] = ()</span>
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Constraints</span> (c <span class="ch">&#39;: cs) = (c, Constraints cs)</span>

<span class="kw">type</span> <span class="dt">AllHave</span> (<span class="ot">c ::</span> k <span class="ot">-&gt;</span> <span class="dt">Constraint</span>) (<span class="ot">xs ::</span> [k]) <span class="fu">=</span> <span class="dt">Constraints</span> (<span class="dt">Map</span> c xs)

<span class="ot">showHList ::</span> <span class="dt">AllHave</span> <span class="dt">Show</span> xs <span class="ot">=&gt;</span> <span class="dt">HList</span> xs <span class="ot">-&gt;</span> [<span class="dt">String</span>]
showHList <span class="dt">Nil</span> <span class="fu">=</span> []
showHList (x <span class="ot">::</span><span class="fu">:</span> xs) <span class="fu">=</span> (show x) <span class="fu">:</span> showHList xs

<span class="kw">instance</span> <span class="dt">AllHave</span> <span class="dt">Show</span> xs <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">HList</span> xs) <span class="kw">where</span>
  show <span class="fu">=</span> show <span class="fu">.</span> showHList

<span class="ot">example1 ::</span> <span class="dt">HList</span> <span class="ch">&#39;[Bool, String , Double , ()]</span>
example1 <span class="fu">=</span> <span class="dt">True</span> <span class="ot">::</span><span class="fu">:</span> <span class="st">&quot;foo&quot;</span> <span class="ot">::</span><span class="fu">:</span> <span class="fl">3.14</span> <span class="ot">::</span><span class="fu">:</span> () <span class="ot">::</span><span class="fu">:</span> <span class="dt">Nil</span>
<span class="co">-- [&quot;True&quot;,&quot;\&quot;foo\&quot;&quot;,&quot;3.14&quot;,&quot;()&quot;]</span></code></pre></div>
<h2 id="typelevel-dictionaries">Typelevel Dictionaries</h2>
<p>Much of this discussion of promotion begs the question whether we can create data structures at the type-level to store information at compile-time. For example a type-level association list can be used to model a map between type-level symbols and any other promotable types. Together with type-families we can write down type-level traversal and lookup functions.</p>
<div class="sourceCode" include="src/17-promotion/typemap.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE PolyKinds #-}</span>
<span class="ot">{-# LANGUAGE RankNTypes #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE KindSignatures #-}</span>
<span class="ot">{-# LANGUAGE ConstraintKinds #-}</span>
<span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>

<span class="kw">import </span><span class="dt">GHC.TypeLits</span>
<span class="kw">import </span><span class="dt">Data.Proxy</span>
<span class="kw">import </span><span class="dt">Data.Type.Equality</span>

<span class="kw">type</span> family <span class="dt">If</span> (<span class="ot">p ::</span> <span class="dt">Bool</span>) (<span class="ot">a ::</span> k) (<span class="ot">b ::</span> k)<span class="ot"> ::</span> k <span class="kw">where</span>
  <span class="dt">If</span> <span class="dt">True</span> a b <span class="fu">=</span> a
  <span class="dt">If</span> <span class="dt">False</span> a b <span class="fu">=</span> b

<span class="kw">type</span> family <span class="dt">Lookup</span> (<span class="ot">k ::</span> a) (<span class="ot">ls ::</span> [(a, b)])<span class="ot"> ::</span> <span class="dt">Maybe</span> b <span class="kw">where</span>
  <span class="dt">Lookup</span> k <span class="ch">&#39;[] = &#39;</span><span class="dt">Nothing</span>
  <span class="dt">Lookup</span> k (<span class="ch">&#39;(a, b) &#39;</span><span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">If</span> (a <span class="fu">==</span> k) (<span class="ch">&#39;Just b) (Lookup k xs)</span>

<span class="kw">type</span> <span class="dt">M</span> <span class="fu">=</span> [
    <span class="ch">&#39;(&quot;a&quot;, 1)</span>
  , <span class="ch">&#39;(&quot;b&quot;, 2)</span>
  , <span class="ch">&#39;(&quot;c&quot;, 3)</span>
  , <span class="ch">&#39;(&quot;d&quot;, 4)</span>
  ]

<span class="kw">type</span> <span class="dt">K</span> <span class="fu">=</span> <span class="st">&quot;a&quot;</span>
<span class="kw">type</span> (<span class="fu">!!</span>) m (<span class="ot">k ::</span> <span class="dt">Symbol</span>) a <span class="fu">=</span> (<span class="dt">Lookup</span> k m) <span class="fu">~</span> <span class="dt">Just</span> a

<span class="ot">value ::</span> <span class="dt">Integer</span>
value <span class="fu">=</span> natVal ( <span class="dt">Proxy</span><span class="ot"> ::</span> (<span class="dt">M</span> <span class="fu">!!</span> <span class="st">&quot;a&quot;</span>) a <span class="ot">=&gt;</span> <span class="dt">Proxy</span> a )</code></pre></div>
<p>If we ask GHC to expand out the type signature we can view the explicit implementation of the type-level map lookup function.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="fu">!!</span>)
<span class="ot">  ::</span> <span class="dt">If</span>
       (<span class="dt">GHC.TypeLits.EqSymbol</span> <span class="st">&quot;a&quot;</span> k)
       (<span class="ch">&#39;Just 1)</span>
       (<span class="dt">If</span>
          (<span class="dt">GHC.TypeLits.EqSymbol</span> <span class="st">&quot;b&quot;</span> k)
          (<span class="ch">&#39;Just 2)</span>
          (<span class="dt">If</span>
             (<span class="dt">GHC.TypeLits.EqSymbol</span> <span class="st">&quot;c&quot;</span> k)
             (<span class="ch">&#39;Just 3)</span>
             (<span class="dt">If</span> (<span class="dt">GHC.TypeLits.EqSymbol</span> <span class="st">&quot;d&quot;</span> k) (<span class="ch">&#39;Just 4) &#39;</span><span class="dt">Nothing</span>)))
     <span class="fu">~</span> <span class="ch">&#39;Just v =&gt;</span>
     <span class="dt">Proxy</span> k <span class="ot">-&gt;</span> <span class="dt">Proxy</span> v</code></pre></div>
<h2 id="advanced-proofs">Advanced Proofs</h2>
<div class="alert alert-danger">
<p>This is an advanced section, and is not typically necessary to write Haskell.</p>
</div>
<p>Now that we have the length-indexed vector let's go write the reverse function, how hard could it be?</p>
<p>So we go and write down something like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">reverseNaive ::</span> forall n a<span class="fu">.</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">Vec</span> a n
reverseNaive xs <span class="fu">=</span> go <span class="dt">Nil</span> xs <span class="co">-- Error: n + 0 != n</span>
  <span class="kw">where</span>
<span class="ot">    go ::</span> <span class="dt">Vec</span> a m <span class="ot">-&gt;</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">Vec</span> a (n <span class="fu">:+</span> m)
    go acc <span class="dt">Nil</span> <span class="fu">=</span> acc
    go acc (<span class="dt">Cons</span> x xs) <span class="fu">=</span> go (<span class="dt">Cons</span> x acc) xs <span class="co">-- Error: n + succ m != succ (n + m)</span></code></pre></div>
<p>Running this we find that GHC is unhappy about two lines in the code:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Couldn&#39;t</span> match <span class="kw">type</span> ‘n’ with ‘n <span class="fu">:+</span> <span class="ch">&#39;Z’</span>
    <span class="dt">Expected</span> <span class="kw">type</span><span class="fu">:</span> <span class="dt">Vec</span> a n
      <span class="dt">Actual</span> <span class="kw">type</span><span class="fu">:</span> <span class="dt">Vec</span> a (n <span class="fu">:+</span> <span class="ch">&#39;Z)</span>

<span class="dt">Could</span> not deduce ((n1 <span class="fu">:+</span> <span class="ch">&#39;S m) ~ &#39;</span><span class="dt">S</span> (n1 <span class="fu">:+</span> m))
    <span class="dt">Expected</span> <span class="kw">type</span><span class="fu">:</span> <span class="dt">Vec</span> a1 (k <span class="fu">:+</span> m)
      <span class="dt">Actual</span> <span class="kw">type</span><span class="fu">:</span> <span class="dt">Vec</span> a1 (n1 <span class="fu">:+</span> <span class="ch">&#39;S m)</span></code></pre></div>
<p>As we unfold elements out of the vector we'll end up doing a lot of type-level arithmetic over indices as we combine the subparts of the vector backwards, but as a consequence we find that GHC will run into some unification errors because it doesn't know about basic arithmetic properties of the natural numbers. Namely that <code>forall n. n + 0 = 0</code> and <code>forall n m. n + (1 + m) = 1 + (n + m)</code>. Which of course it really shouldn't be given that we've constructed a system at the type-level which intuitively <em>models</em> arithmetic but GHC is just a dumb compiler, it can't automatically deduce the isomorphism between natural numbers and Peano numbers.</p>
<p>So at each of these call sites we now have a proof obligation to construct proof terms. Recall from our discussion of propositional equality from GADTs that we actually have such machinery to construct this now.</p>
<div class="sourceCode" include="src/17-promotion/reverse.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">{-# LANGUAGE PolyKinds #-}</span>
<span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE KindSignatures #-}</span>
<span class="ot">{-# LANGUAGE ExplicitForAll #-}</span>

<span class="kw">import </span><span class="dt">Data.Type.Equality</span>

<span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Nat</span>

<span class="kw">data</span> <span class="dt">SNat</span> n <span class="kw">where</span>
  <span class="dt">Zero</span><span class="ot"> ::</span> <span class="dt">SNat</span> <span class="dt">Z</span>
  <span class="dt">Succ</span><span class="ot"> ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">SNat</span> (<span class="dt">S</span> n)

<span class="kw">data</span> <span class="dt">Vec</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">Vec</span> a <span class="dt">Z</span>
  <span class="dt">Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">Vec</span> a (<span class="dt">S</span> n)

<span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Vec</span> a n) <span class="kw">where</span>
  show <span class="dt">Nil</span>         <span class="fu">=</span> <span class="st">&quot;Nil&quot;</span>
  show (<span class="dt">Cons</span> x xs) <span class="fu">=</span> <span class="st">&quot;Cons &quot;</span> <span class="fu">++</span> show x <span class="fu">++</span> <span class="st">&quot; (&quot;</span> <span class="fu">++</span> show xs <span class="fu">++</span> <span class="st">&quot;)&quot;</span>

<span class="kw">type</span> family (<span class="ot">m ::</span> <span class="dt">Nat</span>) <span class="fu">:+</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span>
  <span class="dt">Z</span> <span class="fu">:+</span> n <span class="fu">=</span> n
  <span class="dt">S</span> m <span class="fu">:+</span> n <span class="fu">=</span> <span class="dt">S</span> (m <span class="fu">:+</span> n)

<span class="co">-- (a ~ b) implies (f a ~ f b)</span>
<span class="ot">cong ::</span> a <span class="fu">:~:</span> b <span class="ot">-&gt;</span> f a <span class="fu">:~:</span> f b
cong <span class="dt">Refl</span> <span class="fu">=</span> <span class="dt">Refl</span>

<span class="co">-- (a ~ b) implies (f a) implies (f b)</span>
<span class="ot">subst ::</span> a <span class="fu">:~:</span> b <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b
subst <span class="dt">Refl</span> <span class="fu">=</span> id

<span class="ot">plus_zero ::</span> forall n<span class="fu">.</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> (n <span class="fu">:+</span> <span class="dt">Z</span>) <span class="fu">:~:</span> n
plus_zero <span class="dt">Zero</span> <span class="fu">=</span> <span class="dt">Refl</span>
plus_zero (<span class="dt">Succ</span> n) <span class="fu">=</span> cong (plus_zero n)

<span class="ot">plus_suc ::</span> forall n m<span class="fu">.</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> (n <span class="fu">:+</span> (<span class="dt">S</span> m)) <span class="fu">:~:</span> (<span class="dt">S</span> (n <span class="fu">:+</span> m))
plus_suc <span class="dt">Zero</span> m <span class="fu">=</span> <span class="dt">Refl</span>
plus_suc (<span class="dt">Succ</span> n) m <span class="fu">=</span> cong (plus_suc n m)

<span class="ot">size ::</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">SNat</span> n
size <span class="dt">Nil</span>         <span class="fu">=</span> <span class="dt">Zero</span>
size (<span class="dt">Cons</span> _ xs) <span class="fu">=</span> <span class="dt">Succ</span> <span class="fu">$</span> size xs

reverse<span class="ot"> ::</span> forall n a<span class="fu">.</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">Vec</span> a n
reverse xs <span class="fu">=</span> subst (plus_zero (size xs)) <span class="fu">$</span> go <span class="dt">Nil</span> xs
  <span class="kw">where</span>
<span class="ot">    go ::</span> <span class="dt">Vec</span> a m <span class="ot">-&gt;</span> <span class="dt">Vec</span> a k <span class="ot">-&gt;</span> <span class="dt">Vec</span> a (k <span class="fu">:+</span> m)
    go acc <span class="dt">Nil</span> <span class="fu">=</span> acc
    go acc (<span class="dt">Cons</span> x xs) <span class="fu">=</span> subst (plus_suc (size xs) (size acc)) <span class="fu">$</span> go (<span class="dt">Cons</span> x acc) xs

<span class="ot">append ::</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">Vec</span> a m <span class="ot">-&gt;</span> <span class="dt">Vec</span> a (n <span class="fu">:+</span> m)
append (<span class="dt">Cons</span> x xs) ys <span class="fu">=</span> <span class="dt">Cons</span> x (append xs ys)
append <span class="dt">Nil</span>         ys <span class="fu">=</span> ys

<span class="ot">vec ::</span> <span class="dt">Vec</span> <span class="dt">Int</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>)))
vec <span class="fu">=</span> <span class="dv">1</span> <span class="ot">`Cons`</span> (<span class="dv">2</span> <span class="ot">`Cons`</span> (<span class="dv">3</span> <span class="ot">`Cons`</span> <span class="dt">Nil</span>))

<span class="ot">test ::</span> <span class="dt">Vec</span> <span class="dt">Int</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>)))
test <span class="fu">=</span> Main.reverse vec</code></pre></div>
<p>One might consider whether we could avoid using the singleton trick and just use type-level natural numbers, and technically this approach should be feasible although it seems that the natural number solver in GHC 7.8 can decide some properties but not the ones needed to complete the natural number proofs for the reverse functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE ExplicitForAll #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>

<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (<span class="dt">Eq</span>)
<span class="kw">import </span><span class="dt">GHC.TypeLits</span>
<span class="kw">import </span><span class="dt">Data.Type.Equality</span>

<span class="kw">type</span> <span class="dt">Z</span> <span class="fu">=</span> <span class="dv">0</span>

<span class="kw">type</span> family <span class="dt">S</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span>
  <span class="dt">S</span> n <span class="fu">=</span> n <span class="fu">+</span> <span class="dv">1</span>

<span class="co">-- Yes!</span>
<span class="ot">eq_zero ::</span> <span class="dt">Z</span> <span class="fu">:~:</span> <span class="dt">Z</span>
eq_zero <span class="fu">=</span> <span class="dt">Refl</span>

<span class="co">-- Yes!</span>
<span class="ot">zero_plus_one ::</span> (<span class="dt">Z</span> <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">:~:</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dt">Z</span>)
zero_plus_one <span class="fu">=</span> <span class="dt">Refl</span>

<span class="co">-- Yes!</span>
<span class="ot">plus_zero ::</span> forall n<span class="fu">.</span> (n <span class="fu">+</span> <span class="dt">Z</span>) <span class="fu">:~:</span> n
plus_zero <span class="fu">=</span> <span class="dt">Refl</span>

<span class="co">-- Yes!</span>
<span class="ot">plus_one ::</span> forall n<span class="fu">.</span> (n <span class="fu">+</span> <span class="dt">S</span> <span class="dt">Z</span>) <span class="fu">:~:</span> <span class="dt">S</span> n
plus_one <span class="fu">=</span> <span class="dt">Refl</span>

<span class="co">-- No.</span>
<span class="ot">plus_suc ::</span> forall n m<span class="fu">.</span> (n <span class="fu">+</span> (<span class="dt">S</span> m)) <span class="fu">:~:</span> (<span class="dt">S</span> (n <span class="fu">+</span> m))
plus_suc <span class="fu">=</span> <span class="dt">Refl</span></code></pre></div>
<p>Caveat should be that there might be a way to do this in GHC 7.6 that I'm not aware of. In GHC 7.10 there are some planned changes to solver that should be able to resolve these issues. In particular there are plans to allow pluggable type system extensions that could outsource these kind of problems to third party SMT solvers which can solve these kind of numeric relations and return this information back to GHC's typechecker.</p>
<p>As an aside this is a direct transliteration of the equivalent proof in Agda, which is accomplished via the same method but without the song and dance to get around the lack of dependent types.</p>
<div class="sourceCode" include="src/17-promotion/Vector.agda"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Vector</span> <span class="kw">where</span>

<span class="kw">infixr</span> <span class="dv">10</span> _<span class="ot">∷</span>_

<span class="kw">data</span> ℕ <span class="fu">:</span> <span class="dt">Set</span> <span class="kw">where</span>
  zero <span class="fu">:</span> ℕ
  suc  <span class="fu">:</span> ℕ <span class="ot">→</span> ℕ

<span class="ot">{-# BUILTIN NATURAL ℕ    #-}</span>
<span class="ot">{-# BUILTIN ZERO    zero #-}</span>
<span class="ot">{-# BUILTIN SUC     suc  #-}</span>

<span class="kw">infixl</span> <span class="dv">6</span> _<span class="fu">+</span>_

_<span class="fu">+</span>_ <span class="fu">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> ℕ
<span class="dv">0</span> <span class="fu">+</span> n <span class="fu">=</span> n
suc m <span class="fu">+</span> n <span class="fu">=</span> suc (m <span class="fu">+</span> n)

<span class="kw">data</span> <span class="dt">Vec</span> (<span class="dt">A</span> <span class="fu">:</span> <span class="dt">Set</span>) <span class="fu">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span>
  []  <span class="fu">:</span> <span class="dt">Vec</span> <span class="dt">A</span> <span class="dv">0</span>
  _<span class="ot">∷</span>_ <span class="fu">:</span> <span class="ot">∀</span> {n} <span class="ot">→</span> <span class="dt">A</span> <span class="ot">→</span> <span class="dt">Vec</span> <span class="dt">A</span> n <span class="ot">→</span> <span class="dt">Vec</span> <span class="dt">A</span> (suc n)

_<span class="fu">++</span>_ <span class="fu">:</span> <span class="ot">∀</span> {<span class="dt">A</span> n m} <span class="ot">→</span> <span class="dt">Vec</span> <span class="dt">A</span> n <span class="ot">→</span> <span class="dt">Vec</span> <span class="dt">A</span> m <span class="ot">→</span> <span class="dt">Vec</span> <span class="dt">A</span> (n <span class="fu">+</span> m)
[] <span class="fu">++</span> ys <span class="fu">=</span> ys
(x <span class="ot">∷</span> xs) <span class="fu">++</span> ys <span class="fu">=</span> x <span class="ot">∷</span> (xs <span class="fu">++</span> ys)

infix <span class="dv">4</span> _≡_

<span class="kw">data</span> _≡_ {<span class="dt">A</span> <span class="fu">:</span> <span class="dt">Set</span>} (x <span class="fu">:</span> <span class="dt">A</span>) <span class="fu">:</span> <span class="dt">A</span> <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span>
  refl <span class="fu">:</span> x ≡ x

subst <span class="fu">:</span> {<span class="dt">A</span> <span class="fu">:</span> <span class="dt">Set</span>} <span class="ot">→</span> (<span class="dt">P</span> <span class="fu">:</span> <span class="dt">A</span> <span class="ot">→</span> <span class="dt">Set</span>) <span class="ot">→</span> <span class="ot">∀</span>{x y} <span class="ot">→</span> x ≡ y <span class="ot">→</span> <span class="dt">P</span> x <span class="ot">→</span> <span class="dt">P</span> y
subst <span class="dt">P</span> refl p <span class="fu">=</span> p

cong <span class="fu">:</span> {<span class="dt">A</span> <span class="dt">B</span> <span class="fu">:</span> <span class="dt">Set</span>} (f <span class="fu">:</span> <span class="dt">A</span> <span class="ot">→</span> <span class="dt">B</span>) <span class="ot">→</span> {x y <span class="fu">:</span> <span class="dt">A</span>} <span class="ot">→</span> x ≡ y <span class="ot">→</span> f x ≡ f y
cong f refl <span class="fu">=</span> refl

vec <span class="fu">:</span> <span class="ot">∀</span> {<span class="dt">A</span>} (k <span class="fu">:</span> ℕ) <span class="ot">→</span> <span class="dt">Set</span>
vec {<span class="dt">A</span>} k <span class="fu">=</span> <span class="dt">Vec</span> <span class="dt">A</span> k

plus_zero <span class="fu">:</span> {n <span class="fu">:</span> ℕ} <span class="ot">→</span> n <span class="fu">+</span> <span class="dv">0</span> ≡ n 
plus_zero {zero}  <span class="fu">=</span> refl
plus_zero {suc n} <span class="fu">=</span> cong suc plus_zero

plus_suc <span class="fu">:</span> {n <span class="fu">:</span> ℕ} <span class="ot">→</span> n <span class="fu">+</span> (suc <span class="dv">0</span>) ≡ suc n 
plus_suc {zero}  <span class="fu">=</span> refl
plus_suc {suc n} <span class="fu">=</span> cong suc (plus_suc {n})

reverse <span class="fu">:</span> <span class="ot">∀</span> {<span class="dt">A</span> n} <span class="ot">→</span> <span class="dt">Vec</span> <span class="dt">A</span> n <span class="ot">→</span> <span class="dt">Vec</span> <span class="dt">A</span> n
reverse []       <span class="fu">=</span> []
reverse {<span class="dt">A</span>} {suc n} (x <span class="ot">∷</span> xs) <span class="fu">=</span> subst vec (plus_suc {n}) (reverse xs <span class="fu">++</span> (x  <span class="ot">∷</span> []))</code></pre></div>
<h2 id="liquid-haskell">Liquid Haskell</h2>
<div class="alert alert-danger">
<p>This is an advanced section, knowledge of LiquidHaskell is not typically necessary to write Haskell.</p>
</div>
<p>LiquidHaskell is an extension to GHC's typesystem that adds the capactity for refinement types using the annotation syntax. The type signatures of functions can be checked by the external for richer type semantics than default GHC provides, including non-exhaustive patterns and complex arithemtic properties that require external SMT solvers to verify. For instance LiquidHaskell can statically verify that a function that operates over a <code>Maybe a</code> is always given a <code>Just</code> or that an arithmetic functions always yields an Int that is even positive number.</p>
<p>To Install LiquidHaskell in Ubuntu add the following line to your <code>/etc/sources.list</code>:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">deb</span> http://ppa.launchpad.net/hvr/z3/ubuntu trusty main</code></pre></div>
<p>And then install the external SMT solver.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">sudo</span> apt-key adv --keyserver keyserver.ubuntu.com --recv-keys F6F88286
$ <span class="kw">sudo</span> apt-get install z3</code></pre></div>
<p>Then clone the repo and build it using stack.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> clone --recursive git@github.com:ucsd-progsys/liquidhaskell.git
$ <span class="kw">cd</span> liquidhaskell
$ <span class="kw">stack</span> install</code></pre></div>
<p>Ensure that <code>$HOME/.local/bin</code> is on your <code>$PATH</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (mod, gcd)

<span class="co">{-@ mod :: a:Nat -&gt; b:{v:Nat| 0 &lt; v} -&gt; {v:Nat | v &lt; b} @-}</span>
mod<span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
mod a b
  <span class="fu">|</span> a <span class="fu">&lt;</span> b <span class="fu">=</span> a
  <span class="fu">|</span> otherwise <span class="fu">=</span> mod (a <span class="fu">-</span> b) b

<span class="co">{-@ gcd :: a:Nat -&gt; b:{v:Nat | v &lt; a} -&gt; Int @-}</span>
gcd<span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
gcd a <span class="dv">0</span> <span class="fu">=</span> a
gcd a b <span class="fu">=</span> gcd b (a <span class="ot">`mod`</span> b)</code></pre></div>
<p>The module can be run through the solver using the <code>liquid</code> command line tool.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">liquid</span> example.hs
<span class="kw">Done</span> solving.

<span class="kw">****</span> DONE:  solve **************************************************************


<span class="kw">****</span> DONE:  annotate ***********************************************************


<span class="kw">****</span> RESULT: SAFE **************************************************************</code></pre></div>
<p>For more extensive documentation and further use cases see the official documentation:</p>
<ul>
<li><a href="https://ucsd-progsys.github.io/liquidhaskell-tutorial/01-intro.html">Liquid Haskell Documentation</a></li>
</ul>
</hr>
<h1 id="generics">Generics</h1>
<p>Haskell has several techniques for automatic generation of type classes for a variety of tasks that consist largely of boilerplate code generation such as:</p>
<ul>
<li>Pretty Printing</li>
<li>Equality</li>
<li>Serialization</li>
<li>Ordering</li>
<li>Traversal</li>
</ul>
<p>These are achieved through several tools and techniques outlined in the next few sections:</p>
<ul>
<li>Typeable / Dynamic</li>
<li>Scrap Your Boilerplate</li>
<li>GHC.Generics</li>
<li>generics-sop</li>
</ul>
<h2 id="typeable">Typeable</h2>
<p>The <code>Typeable</code> class be used to create runtime type information for arbitrary types.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">typeOf ::</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">TypeRep</span></code></pre></div>
<div class="sourceCode" include="src/18-generics/typeable.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveDataTypeable #-}</span>

<span class="kw">import </span><span class="dt">Data.Typeable</span>

<span class="kw">data</span> <span class="dt">Animal</span> <span class="fu">=</span> <span class="dt">Cat</span> <span class="fu">|</span> <span class="dt">Dog</span> <span class="kw">deriving</span> <span class="dt">Typeable</span>
<span class="kw">data</span> <span class="dt">Zoo</span> a <span class="fu">=</span> <span class="dt">Zoo</span> [a] <span class="kw">deriving</span> <span class="dt">Typeable</span>

<span class="ot">equal ::</span> (<span class="dt">Typeable</span> a, <span class="dt">Typeable</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Bool</span>
equal a b <span class="fu">=</span> typeOf a <span class="fu">==</span> typeOf b

<span class="ot">example1 ::</span> <span class="dt">TypeRep</span>
example1 <span class="fu">=</span> typeOf <span class="dt">Cat</span>
<span class="co">-- Animal</span>

<span class="ot">example2 ::</span> <span class="dt">TypeRep</span>
example2 <span class="fu">=</span> typeOf (<span class="dt">Zoo</span> [<span class="dt">Cat</span>, <span class="dt">Dog</span>])
<span class="co">-- Zoo Animal</span>

<span class="ot">example3 ::</span> <span class="dt">TypeRep</span>
example3 <span class="fu">=</span> typeOf ((<span class="dv">1</span>, <span class="fl">6.636e-34</span>, <span class="st">&quot;foo&quot;</span>)<span class="ot"> ::</span> (<span class="dt">Int</span>, <span class="dt">Double</span>, <span class="dt">String</span>))
<span class="co">-- (Int,Double,[Char])</span>

<span class="ot">example4 ::</span> <span class="dt">Bool</span>
example4 <span class="fu">=</span> equal <span class="dt">False</span> ()
<span class="co">-- False</span></code></pre></div>
<p>Using the Typeable instance allows us to write down a type safe cast function which can safely use <code>unsafeCast</code> and provide a proof that the resulting type matches the input.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">cast ::</span> (<span class="dt">Typeable</span> a, <span class="dt">Typeable</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b
cast x
  <span class="fu">|</span> typeOf x <span class="fu">==</span> typeOf ret <span class="fu">=</span> <span class="dt">Just</span> ret
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Nothing</span>
  <span class="kw">where</span>
    ret <span class="fu">=</span> unsafeCast x</code></pre></div>
<p>Of historical note is that writing our own Typeable classes is currently possible of GHC 7.6 but allows us to introduce dangerous behavior that can cause crashes, and shouldn't be done except by GHC itself. As of 7.8 GHC forbids hand-written Typeable instances. As of 7.10 <code>-XAutoDeriveDataTypeable</code> is enabled by default.</p>
<p>See: <a href="http://chrisdone.com/posts/data-typeable">Typeable and Data in Haskell</a></p>
<h2 id="dynamic">Dynamic</h2>
<p>Since we have a way of querying runtime type information we can use this machinery to implement a <code>Dynamic</code> type. This allows us to box up any monotype into a uniform type that can be passed to any function taking a Dynamic type which can then unpack the underlying value in a type-safe way.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toDyn ::</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Dynamic</span>
<span class="ot">fromDyn ::</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> <span class="dt">Dynamic</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">fromDynamic ::</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> <span class="dt">Dynamic</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
<span class="ot">cast ::</span> (<span class="dt">Typeable</span> a, <span class="dt">Typeable</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</code></pre></div>
<div class="sourceCode" include="src/18-generics/dynamic.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Dynamic</span>
<span class="kw">import </span><span class="dt">Data.Maybe</span>

<span class="ot">dynamicBox ::</span> <span class="dt">Dynamic</span>
dynamicBox <span class="fu">=</span> toDyn (<span class="fl">6.62</span><span class="ot"> ::</span> <span class="dt">Double</span>)

<span class="ot">example1 ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
example1 <span class="fu">=</span> fromDynamic dynamicBox
<span class="co">-- Nothing</span>

<span class="ot">example2 ::</span> <span class="dt">Maybe</span> <span class="dt">Double</span>
example2 <span class="fu">=</span> fromDynamic dynamicBox
<span class="co">-- Just 6.62</span>

<span class="ot">example3 ::</span> <span class="dt">Int</span>
example3 <span class="fu">=</span> fromDyn dynamicBox <span class="dv">0</span>
<span class="co">-- 0</span>

<span class="ot">example4 ::</span> <span class="dt">Double</span>
example4 <span class="fu">=</span> fromDyn dynamicBox <span class="fl">0.0</span>
<span class="co">-- 6.62</span></code></pre></div>
<p>In GHC 7.8 the Typeable class is poly-kinded so polymorphic functions can be applied over functions and higher kinded types.</p>
<div class="alert alert-danger">
<p>Use of Dynamic is somewhat rare, except in odd cases that have to deal with foreign memory and FFI interfaces. Using it for business logic is considered a code smell. Consider a more idiomatic solution.</p>
</div>
<h2 id="data">Data</h2>
<p>Just as Typeable lets us create runtime type information, the Data class allows us to reflect information about the structure of datatypes to runtime as needed.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> <span class="dt">Data</span> a <span class="kw">where</span>
<span class="ot">  gfoldl  ::</span> (forall d b<span class="fu">.</span> <span class="dt">Data</span> d <span class="ot">=&gt;</span> c (d <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> c b)
          <span class="ot">-&gt;</span> (forall g<span class="fu">.</span> g <span class="ot">-&gt;</span> c g)
          <span class="ot">-&gt;</span> a
          <span class="ot">-&gt;</span> c a

<span class="ot">  gunfold ::</span> (forall b r<span class="fu">.</span> <span class="dt">Data</span> b <span class="ot">=&gt;</span> c (b <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> c r)
          <span class="ot">-&gt;</span> (forall r<span class="fu">.</span> r <span class="ot">-&gt;</span> c r)
          <span class="ot">-&gt;</span> <span class="dt">Constr</span>
          <span class="ot">-&gt;</span> c a

<span class="ot">  toConstr ::</span> a <span class="ot">-&gt;</span> <span class="dt">Constr</span>
<span class="ot">  dataTypeOf ::</span> a <span class="ot">-&gt;</span> <span class="dt">DataType</span>
<span class="ot">  gmapQl ::</span> (r <span class="ot">-&gt;</span> r&#39; <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> (forall d<span class="fu">.</span> <span class="dt">Data</span> d <span class="ot">=&gt;</span> d <span class="ot">-&gt;</span> r&#39;) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> r</code></pre></div>
<p>The types for <code>gfoldl</code> and <code>gunfold</code> are a little intimidating ( and depend on <code>RankNTypes</code> ), the best way to understand is to look at some examples. First the most trivial case a simple sum type <code>Animal</code> would produce the following code:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Animal</span> <span class="fu">=</span> <span class="dt">Cat</span> <span class="fu">|</span> <span class="dt">Dog</span> <span class="kw">deriving</span> <span class="dt">Typeable</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Data</span> <span class="dt">Animal</span> <span class="kw">where</span>
  gfoldl k z <span class="dt">Cat</span> <span class="fu">=</span> z <span class="dt">Cat</span>
  gfoldl k z <span class="dt">Dog</span> <span class="fu">=</span> z <span class="dt">Dog</span>

  gunfold k z c
    <span class="fu">=</span> <span class="kw">case</span> constrIndex c <span class="kw">of</span>
        <span class="dv">1</span> <span class="ot">-&gt;</span> z <span class="dt">Cat</span>
        <span class="dv">2</span> <span class="ot">-&gt;</span> z <span class="dt">Dog</span>

  toConstr <span class="dt">Cat</span> <span class="fu">=</span> cCat
  toConstr <span class="dt">Dog</span> <span class="fu">=</span> cDog

  dataTypeOf _ <span class="fu">=</span> tAnimal

<span class="ot">tAnimal ::</span> <span class="dt">DataType</span>
tAnimal <span class="fu">=</span> mkDataType <span class="st">&quot;Main.Animal&quot;</span> [cCat, cDog]

<span class="ot">cCat ::</span> <span class="dt">Constr</span>
cCat <span class="fu">=</span> mkConstr tAnimal <span class="st">&quot;Cat&quot;</span> [] <span class="dt">Prefix</span>

<span class="ot">cDog ::</span> <span class="dt">Constr</span>
cDog <span class="fu">=</span> mkConstr tAnimal <span class="st">&quot;Dog&quot;</span> [] <span class="dt">Prefix</span></code></pre></div>
<p>For a type with non-empty containers we get something a little more interesting. Consider the list type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> <span class="dt">Data</span> [a] <span class="kw">where</span>
  gfoldl _ z []     <span class="fu">=</span> z []
  gfoldl k z (x<span class="fu">:</span>xs) <span class="fu">=</span> z (<span class="fu">:</span>) <span class="ot">`k`</span> x <span class="ot">`k`</span> xs

  toConstr []    <span class="fu">=</span> nilConstr
  toConstr (_<span class="fu">:</span>_) <span class="fu">=</span> consConstr

  gunfold k z c
    <span class="fu">=</span> <span class="kw">case</span> constrIndex c <span class="kw">of</span>
        <span class="dv">1</span> <span class="ot">-&gt;</span> z []
        <span class="dv">2</span> <span class="ot">-&gt;</span> k (k (z (<span class="fu">:</span>)))

  dataTypeOf _ <span class="fu">=</span> listDataType

<span class="ot">nilConstr ::</span> <span class="dt">Constr</span>
nilConstr <span class="fu">=</span> mkConstr listDataType <span class="st">&quot;[]&quot;</span> [] <span class="dt">Prefix</span>

<span class="ot">consConstr ::</span> <span class="dt">Constr</span>
consConstr <span class="fu">=</span> mkConstr listDataType <span class="st">&quot;(:)&quot;</span> [] <span class="dt">Infix</span>

<span class="ot">listDataType ::</span> <span class="dt">DataType</span>
listDataType <span class="fu">=</span> mkDataType <span class="st">&quot;Prelude.[]&quot;</span> [nilConstr,consConstr]</code></pre></div>
<p>Looking at <code>gfoldl</code> we see the Data has an implementation of a function for us to walk an applicative over the elements of the constructor by applying a function <code>k</code> over each element and applying <code>z</code> at the spine. For example look at the instance for a 2-tuple as well:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Data</span> a, <span class="dt">Data</span> b) <span class="ot">=&gt;</span> <span class="dt">Data</span> (a,b) <span class="kw">where</span>
  gfoldl k z (a,b) <span class="fu">=</span> z (,) <span class="ot">`k`</span> a <span class="ot">`k`</span> b

  toConstr (_,_) <span class="fu">=</span> tuple2Constr

  gunfold k z c
    <span class="fu">=</span> <span class="kw">case</span> constrIndex c <span class="kw">of</span>
      <span class="dv">1</span> <span class="ot">-&gt;</span> k (k (z (,)))

  dataTypeOf _  <span class="fu">=</span> tuple2DataType

<span class="ot">tuple2Constr ::</span> <span class="dt">Constr</span>
tuple2Constr <span class="fu">=</span> mkConstr tuple2DataType <span class="st">&quot;(,)&quot;</span> [] <span class="dt">Infix</span>

<span class="ot">tuple2DataType ::</span> <span class="dt">DataType</span>
tuple2DataType <span class="fu">=</span> mkDataType <span class="st">&quot;Prelude.(,)&quot;</span> [tuple2Constr]</code></pre></div>
<p>This is pretty neat, now within the same typeclass we have a generic way to introspect any <code>Data</code> instance and write logic that depends on the structure and types of its subterms. We can now write a function which allows us to traverse an arbitrary instance of Data and twiddle values based on pattern matching on the runtime types. So let's write down a function <code>over</code> which increments a <code>Value</code> type for both for n-tuples and lists.</p>
<div class="sourceCode" include="src/18-generics/data.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveDataTypeable #-}</span>

<span class="kw">import </span><span class="dt">Data.Data</span>
<span class="kw">import </span><span class="dt">Control.Monad.Identity</span>
<span class="kw">import </span><span class="dt">Control.Applicative</span>

<span class="kw">data</span> <span class="dt">Animal</span> <span class="fu">=</span> <span class="dt">Cat</span> <span class="fu">|</span> <span class="dt">Dog</span> <span class="kw">deriving</span> (<span class="dt">Data</span>, <span class="dt">Typeable</span>)

<span class="kw">newtype</span> <span class="dt">Val</span> <span class="fu">=</span> <span class="dt">Val</span> <span class="dt">Int</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Data</span>, <span class="dt">Typeable</span>)

<span class="ot">incr ::</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a
incr <span class="fu">=</span> maybe id id (cast f)
  <span class="kw">where</span> f (<span class="dt">Val</span> x) <span class="fu">=</span> <span class="dt">Val</span> (x <span class="fu">*</span> <span class="dv">100</span>)

<span class="ot">over ::</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a
over x <span class="fu">=</span> runIdentity <span class="fu">$</span> gfoldl cont base (incr x)
  <span class="kw">where</span>
    cont k d <span class="fu">=</span> k <span class="fu">&lt;*&gt;</span> (pure <span class="fu">$</span> over d)
    base <span class="fu">=</span> pure


<span class="ot">example1 ::</span> <span class="dt">Constr</span>
example1 <span class="fu">=</span> toConstr <span class="dt">Dog</span>
<span class="co">-- Dog</span>

<span class="ot">example2 ::</span> <span class="dt">DataType</span>
example2 <span class="fu">=</span> dataTypeOf <span class="dt">Cat</span>
<span class="co">-- DataType {tycon = &quot;Main.Animal&quot;, datarep = AlgRep [Cat,Dog]}</span>

<span class="ot">example3 ::</span> [<span class="dt">Val</span>]
example3 <span class="fu">=</span> over [<span class="dt">Val</span> <span class="dv">1</span>, <span class="dt">Val</span> <span class="dv">2</span>, <span class="dt">Val</span> <span class="dv">3</span>]
<span class="co">-- [Val 100,Val 200,Val 300]</span>

<span class="ot">example4 ::</span> (<span class="dt">Val</span>, <span class="dt">Val</span>, <span class="dt">Val</span>)
example4 <span class="fu">=</span> over (<span class="dt">Val</span> <span class="dv">1</span>, <span class="dt">Val</span> <span class="dv">2</span>, <span class="dt">Val</span> <span class="dv">3</span>)
<span class="co">-- (Val 100,Val 200,Val 300)</span></code></pre></div>
<p>We can also write generic operations, for example to count the number of parameters in a data type.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">numHoles ::</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span>
numHoles <span class="fu">=</span> gmapQl (<span class="fu">+</span>) <span class="dv">0</span> (const <span class="dv">1</span>)

<span class="ot">example1 ::</span> <span class="dt">Int</span>
example1 <span class="fu">=</span> numHoles (<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>)
<span class="co">-- 7</span>

<span class="ot">example2 ::</span> <span class="dt">Int</span>
example2 <span class="fu">=</span> numHoles (<span class="dt">Just</span> <span class="dv">3</span>)
<span class="co">-- 1</span></code></pre></div>
<h2 id="syb">Syb</h2>
<p>Using the interface provided by the Data we can retrieve the information we need to, at runtime, inspect the types of expressions and rewrite them, collect terms, and find subterms matching specific predicates.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">everywhere ::</span> (forall a<span class="fu">.</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> forall a<span class="fu">.</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">everywhereM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">GenericM</span> m <span class="ot">-&gt;</span> <span class="dt">GenericM</span> m
<span class="ot">somewhere ::</span> <span class="dt">MonadPlus</span> m <span class="ot">=&gt;</span> <span class="dt">GenericM</span> m <span class="ot">-&gt;</span> <span class="dt">GenericM</span> m
<span class="ot">listify ::</span> <span class="dt">Typeable</span> r <span class="ot">=&gt;</span> (r <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">GenericQ</span> [r]
<span class="ot">everything ::</span> (r <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">GenericQ</span> r <span class="ot">-&gt;</span> <span class="dt">GenericQ</span> r</code></pre></div>
<p>For example consider we have some custom collection of datatypes for which we want to write generic transformations that transform numerical subexpressions according to set of rewrite rules. We can use <code>syb</code> to write the transformation rules quite succinctly.</p>
<div class="sourceCode" include="src/18-generics/syb.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveDataTypeable #-}</span>

<span class="kw">import </span><span class="dt">Data.Data</span>
<span class="kw">import </span><span class="dt">Data.Typeable</span>
<span class="kw">import </span><span class="dt">Data.Generics.Schemes</span>
<span class="kw">import </span><span class="dt">Data.Generics.Aliases</span> (mkT)

<span class="kw">data</span> <span class="dt">MyTuple</span> a <span class="fu">=</span> <span class="dt">MyTuple</span> a <span class="dt">Float</span>
  <span class="kw">deriving</span> (<span class="dt">Data</span>, <span class="dt">Typeable</span>, <span class="dt">Show</span>)

<span class="ot">exampleT ::</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> <span class="dt">MyTuple</span> a <span class="ot">-&gt;</span> <span class="dt">MyTuple</span> a
exampleT <span class="fu">=</span> everywhere (mkT go1) <span class="fu">.</span> everywhere (mkT go2)
  <span class="kw">where</span>
<span class="ot">    go1 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
    go1 x <span class="fu">=</span> succ x

<span class="ot">    go2 ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span>
    go2 x <span class="fu">=</span> succ x

<span class="ot">findFloat ::</span> <span class="dt">Data</span> x <span class="ot">=&gt;</span> x <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Float</span>
findFloat <span class="fu">=</span> gfindtype

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> term <span class="fu">=</span> <span class="dt">MyTuple</span> (<span class="dt">MyTuple</span> (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>) <span class="fl">2.0</span>) <span class="fl">3.0</span>
  print (exampleT term)
  print (gsize term)
  print (findFloat term)
  print (listify ((<span class="fu">&gt;</span><span class="dv">0</span>)<span class="ot"> ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)) term)</code></pre></div>
<ul>
<li><a href="https://hackage.haskell.org/package/syb-0.6/docs/Data-Generics-Schemes.html">Data.Generics.Schemes</a></li>
</ul>
<h2 id="generic">Generic</h2>
<p>The most modern method of doing generic programming uses type families to achieve a better method of deriving the structural properties of arbitrary type classes. Generic implements a typeclass with an associated type <code>Rep</code> ( Representation ) together with a pair of functions that form a 2-sided inverse ( isomorphism ) for converting to and from the associated type and the derived type in question.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Generic</span> a <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Rep</span> a
<span class="ot">  from ::</span> a <span class="ot">-&gt;</span> <span class="dt">Rep</span> a
<span class="ot">  to ::</span> <span class="dt">Rep</span> a <span class="ot">-&gt;</span> a

<span class="kw">class</span> <span class="dt">Datatype</span> d <span class="kw">where</span>
<span class="ot">  datatypeName ::</span> t d f a <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="ot">  moduleName ::</span> t d f a <span class="ot">-&gt;</span> <span class="dt">String</span>

<span class="kw">class</span> <span class="dt">Constructor</span> c <span class="kw">where</span>
<span class="ot">  conName ::</span> t c f a <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre></div>
<p><a href="https://www.haskell.org/ghc/docs/7.4.1/html/libraries/ghc-prim-0.2.0.0/GHC-Generics.html">GHC.Generics</a> defines a set of named types for modeling the various structural properties of types in available in Haskell.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Sums: encode choice between constructors</span>
<span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:+:</span>
<span class="kw">data</span> (<span class="fu">:+:</span>) f g p <span class="fu">=</span> <span class="dt">L1</span> (f p) <span class="fu">|</span> <span class="dt">R1</span> (g p)

<span class="co">-- | Products: encode multiple arguments to constructors</span>
<span class="kw">infixr</span> <span class="dv">6</span> <span class="fu">:*:</span>
<span class="kw">data</span> (<span class="fu">:*:</span>) f g p <span class="fu">=</span> f p <span class="fu">:*:</span> g p

<span class="co">-- | Tag for M1: datatype</span>
<span class="kw">data</span> <span class="dt">D</span>
<span class="co">-- | Tag for M1: constructor</span>
<span class="kw">data</span> <span class="dt">C</span>

<span class="co">-- | Constants, additional parameters and recursion of kind *</span>
<span class="kw">newtype</span> <span class="dt">K1</span> i c p <span class="fu">=</span> <span class="dt">K1</span> {<span class="ot"> unK1 ::</span> c }

<span class="co">-- | Meta-information (constructor names, etc.)</span>
<span class="kw">newtype</span> <span class="dt">M1</span> i c f p <span class="fu">=</span> <span class="dt">M1</span> {<span class="ot"> unM1 ::</span> f p }

<span class="co">-- | Type synonym for encoding meta-information for datatypes</span>
<span class="kw">type</span> <span class="dt">D1</span> <span class="fu">=</span> <span class="dt">M1</span> <span class="dt">D</span>

<span class="co">-- | Type synonym for encoding meta-information for constructors</span>
<span class="kw">type</span> <span class="dt">C1</span> <span class="fu">=</span> <span class="dt">M1</span> <span class="dt">C</span></code></pre></div>
<p>Using the deriving mechanics GHC can generate this Generic instance for us mechanically, if we were to write it by hand for a simple type it might look like this:</p>
<div class="sourceCode" include="src/18-generics/generics.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>

<span class="kw">import </span><span class="dt">GHC.Generics</span>

<span class="kw">data</span> <span class="dt">Animal</span>
  <span class="fu">=</span> <span class="dt">Dog</span>
  <span class="fu">|</span> <span class="dt">Cat</span>

<span class="kw">instance</span> <span class="dt">Generic</span> <span class="dt">Animal</span> <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Rep</span> <span class="dt">Animal</span> <span class="fu">=</span> <span class="dt">D1</span> <span class="dt">T_Animal</span> ((<span class="dt">C1</span> <span class="dt">C_Dog</span> <span class="dt">U1</span>) <span class="fu">:+:</span> (<span class="dt">C1</span> <span class="dt">C_Cat</span> <span class="dt">U1</span>))

  from <span class="dt">Dog</span> <span class="fu">=</span> <span class="dt">M1</span> (<span class="dt">L1</span> (<span class="dt">M1</span> <span class="dt">U1</span>))
  from <span class="dt">Cat</span> <span class="fu">=</span> <span class="dt">M1</span> (<span class="dt">R1</span> (<span class="dt">M1</span> <span class="dt">U1</span>))

  to (<span class="dt">M1</span> (<span class="dt">L1</span> (<span class="dt">M1</span> <span class="dt">U1</span>))) <span class="fu">=</span> <span class="dt">Dog</span>
  to (<span class="dt">M1</span> (<span class="dt">R1</span> (<span class="dt">M1</span> <span class="dt">U1</span>))) <span class="fu">=</span> <span class="dt">Cat</span>

<span class="kw">data</span> <span class="dt">T_Animal</span>
<span class="kw">data</span> <span class="dt">C_Dog</span>
<span class="kw">data</span> <span class="dt">C_Cat</span>

<span class="kw">instance</span> <span class="dt">Datatype</span> <span class="dt">T_Animal</span> <span class="kw">where</span>
  datatypeName _ <span class="fu">=</span> <span class="st">&quot;Animal&quot;</span>
  moduleName _ <span class="fu">=</span> <span class="st">&quot;Main&quot;</span>

<span class="kw">instance</span> <span class="dt">Constructor</span> <span class="dt">C_Dog</span> <span class="kw">where</span>
  conName _ <span class="fu">=</span> <span class="st">&quot;Dog&quot;</span>

<span class="kw">instance</span> <span class="dt">Constructor</span> <span class="dt">C_Cat</span> <span class="kw">where</span>
  conName _ <span class="fu">=</span> <span class="st">&quot;Cat&quot;</span></code></pre></div>
<p>Use <code>kind!</code> in GHCi we can look at the type family <code>Rep</code> associated with a Generic instance.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">Rep</span> <span class="dt">Animal</span>
<span class="dt">Rep</span> <span class="dt">Animal</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>
<span class="fu">=</span> <span class="dt">M1</span> <span class="dt">D</span> <span class="dt">T_Animal</span> (<span class="dt">M1</span> <span class="dt">C</span> <span class="dt">C_Dog</span> <span class="dt">U1</span> <span class="fu">:+:</span> <span class="dt">M1</span> <span class="dt">C</span> <span class="dt">C_Cat</span> <span class="dt">U1</span>)

λ<span class="fu">:</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">Rep</span> ()
<span class="dt">Rep</span><span class="ot"> () ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>
<span class="fu">=</span> <span class="dt">M1</span> <span class="dt">D</span> <span class="dt">GHC.Generics.D1</span>() (<span class="dt">M1</span> <span class="dt">C</span> <span class="dt">GHC.Generics.C1_0</span>() <span class="dt">U1</span>)

λ<span class="fu">:</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">Rep</span> [()]
<span class="dt">Rep</span> [()]<span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>
<span class="fu">=</span> <span class="dt">M1</span>
    <span class="dt">D</span>
    <span class="dt">GHC.Generics.D1</span>[]
    (<span class="dt">M1</span> <span class="dt">C</span> <span class="dt">GHC.Generics.C1_0</span>[] <span class="dt">U1</span>
     <span class="fu">:+:</span> <span class="dt">M1</span>
           <span class="dt">C</span>
           <span class="dt">GHC.Generics.C1_1</span>[]
           (<span class="dt">M1</span> <span class="dt">S</span> <span class="dt">NoSelector</span> (<span class="dt">K1</span> <span class="dt">R</span> ()) <span class="fu">:*:</span> <span class="dt">M1</span> <span class="dt">S</span> <span class="dt">NoSelector</span> (<span class="dt">K1</span> <span class="dt">R</span> [()])))</code></pre></div>
<p>Now the clever bit, instead writing our generic function over the datatype we instead write it over the Rep and then reify the result using <code>from</code>. So for an equivalent version of Haskell's default <code>Eq</code> that instead uses generic deriving we could write:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">GEq&#39;</span> f <span class="kw">where</span>
<span class="ot">  geq&#39; ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Bool</span>

<span class="kw">instance</span> <span class="dt">GEq&#39;</span> <span class="dt">U1</span> <span class="kw">where</span>
  geq&#39; _ _ <span class="fu">=</span> <span class="dt">True</span>

<span class="kw">instance</span> (<span class="dt">GEq</span> c) <span class="ot">=&gt;</span> <span class="dt">GEq&#39;</span> (<span class="dt">K1</span> i c) <span class="kw">where</span>
  geq&#39; (<span class="dt">K1</span> a) (<span class="dt">K1</span> b) <span class="fu">=</span> geq a b

<span class="kw">instance</span> (<span class="dt">GEq&#39;</span> a) <span class="ot">=&gt;</span> <span class="dt">GEq&#39;</span> (<span class="dt">M1</span> i c a) <span class="kw">where</span>
  geq&#39; (<span class="dt">M1</span> a) (<span class="dt">M1</span> b) <span class="fu">=</span> geq&#39; a b

<span class="co">-- Equality for sums.</span>
<span class="kw">instance</span> (<span class="dt">GEq&#39;</span> a, <span class="dt">GEq&#39;</span> b) <span class="ot">=&gt;</span> <span class="dt">GEq&#39;</span> (a <span class="fu">:+:</span> b) <span class="kw">where</span>
  geq&#39; (<span class="dt">L1</span> a) (<span class="dt">L1</span> b) <span class="fu">=</span> geq&#39; a b
  geq&#39; (<span class="dt">R1</span> a) (<span class="dt">R1</span> b) <span class="fu">=</span> geq&#39; a b
  geq&#39; _      _      <span class="fu">=</span> <span class="dt">False</span>

<span class="co">-- Equality for products.</span>
<span class="kw">instance</span> (<span class="dt">GEq&#39;</span> a, <span class="dt">GEq&#39;</span> b) <span class="ot">=&gt;</span> <span class="dt">GEq&#39;</span> (a <span class="fu">:*:</span> b) <span class="kw">where</span>
  geq&#39; (a1 <span class="fu">:*:</span> b1) (a2 <span class="fu">:*:</span> b2) <span class="fu">=</span> geq&#39; a1 a2 <span class="fu">&amp;&amp;</span> geq&#39; b1 b2</code></pre></div>
<p>To accommodate the two methods of writing classes (generic-deriving or custom implementations) we can use the <code>DefaultSignatures</code> extension to allow the user to leave typeclass functions blank and defer to Generic or to define their own.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DefaultSignatures #-}</span>

<span class="kw">class</span> <span class="dt">GEq</span> a <span class="kw">where</span>
<span class="ot">  geq ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>

  default<span class="ot"> geq ::</span> (<span class="dt">Generic</span> a, <span class="dt">GEq&#39;</span> (<span class="dt">Rep</span> a)) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
  geq x y <span class="fu">=</span> geq&#39; (from x) (from y)</code></pre></div>
<p>Now anyone using our library need only derive Generic and create an empty instance of our typeclass instance without writing any boilerplate for <code>GEq</code>.</p>
<p>Here is a complete example for deriving equality generics:</p>
<div class="sourceCode" include="src/18-generics/generic_impl.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE FlexibleContexts #-}</span>
<span class="ot">{-# LANGUAGE DefaultSignatures #-}</span>

<span class="kw">import </span><span class="dt">GHC.Generics</span>

<span class="co">-- Auxiliary class</span>
<span class="kw">class</span> <span class="dt">GEq&#39;</span> f <span class="kw">where</span>
<span class="ot">  geq&#39; ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Bool</span>

<span class="kw">instance</span> <span class="dt">GEq&#39;</span> <span class="dt">U1</span> <span class="kw">where</span>
  geq&#39; _ _ <span class="fu">=</span> <span class="dt">True</span>

<span class="kw">instance</span> (<span class="dt">GEq</span> c) <span class="ot">=&gt;</span> <span class="dt">GEq&#39;</span> (<span class="dt">K1</span> i c) <span class="kw">where</span>
  geq&#39; (<span class="dt">K1</span> a) (<span class="dt">K1</span> b) <span class="fu">=</span> geq a b

<span class="kw">instance</span> (<span class="dt">GEq&#39;</span> a) <span class="ot">=&gt;</span> <span class="dt">GEq&#39;</span> (<span class="dt">M1</span> i c a) <span class="kw">where</span>
  geq&#39; (<span class="dt">M1</span> a) (<span class="dt">M1</span> b) <span class="fu">=</span> geq&#39; a b

<span class="kw">instance</span> (<span class="dt">GEq&#39;</span> a, <span class="dt">GEq&#39;</span> b) <span class="ot">=&gt;</span> <span class="dt">GEq&#39;</span> (a <span class="fu">:+:</span> b) <span class="kw">where</span>
  geq&#39; (<span class="dt">L1</span> a) (<span class="dt">L1</span> b) <span class="fu">=</span> geq&#39; a b
  geq&#39; (<span class="dt">R1</span> a) (<span class="dt">R1</span> b) <span class="fu">=</span> geq&#39; a b
  geq&#39; _      _      <span class="fu">=</span> <span class="dt">False</span>

<span class="kw">instance</span> (<span class="dt">GEq&#39;</span> a, <span class="dt">GEq&#39;</span> b) <span class="ot">=&gt;</span> <span class="dt">GEq&#39;</span> (a <span class="fu">:*:</span> b) <span class="kw">where</span>
  geq&#39; (a1 <span class="fu">:*:</span> b1) (a2 <span class="fu">:*:</span> b2) <span class="fu">=</span> geq&#39; a1 a2 <span class="fu">&amp;&amp;</span> geq&#39; b1 b2

<span class="fu">--</span>
<span class="kw">class</span> <span class="dt">GEq</span> a <span class="kw">where</span>
<span class="ot">  geq ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
  default<span class="ot"> geq ::</span> (<span class="dt">Generic</span> a, <span class="dt">GEq&#39;</span> (<span class="dt">Rep</span> a)) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
  geq x y <span class="fu">=</span> geq&#39; (from x) (from y)

<span class="co">-- Base equalities</span>
<span class="kw">instance</span> <span class="dt">GEq</span> <span class="dt">Char</span> <span class="kw">where</span> geq <span class="fu">=</span> (<span class="fu">==</span>)
<span class="kw">instance</span> <span class="dt">GEq</span> <span class="dt">Int</span> <span class="kw">where</span> geq <span class="fu">=</span> (<span class="fu">==</span>)
<span class="kw">instance</span> <span class="dt">GEq</span> <span class="dt">Float</span> <span class="kw">where</span> geq <span class="fu">=</span> (<span class="fu">==</span>)

<span class="co">-- Equalities derived from structure of (:+:) and (:*:)</span>
<span class="kw">instance</span> <span class="dt">GEq</span> a <span class="ot">=&gt;</span> <span class="dt">GEq</span> (<span class="dt">Maybe</span> a)
<span class="kw">instance</span> (<span class="dt">GEq</span> a, <span class="dt">GEq</span> b) <span class="ot">=&gt;</span> <span class="dt">GEq</span> (a,b)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  print <span class="fu">$</span> geq <span class="dv">2</span> (<span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Int</span>)
  print <span class="fu">$</span> geq <span class="ch">&#39;a&#39;</span> <span class="ch">&#39;b&#39;</span>
  print <span class="fu">$</span> geq (<span class="dt">Just</span> <span class="ch">&#39;a&#39;</span>) (<span class="dt">Just</span> <span class="ch">&#39;a&#39;</span>)
  print <span class="fu">$</span> geq (<span class="ch">&#39;a&#39;</span>,<span class="ch">&#39;b&#39;</span>) (<span class="ch">&#39;a&#39;</span>, <span class="ch">&#39;b&#39;</span>)</code></pre></div>
<p>See:</p>
<ul>
<li><a href="../../www.stephendiehl.com/posts/generics.html">Cooking Classes with Datatype Generic Programming</a></li>
<li><a href="http://www.andres-loeh.de/DGP-Intro.pdf">Datatype-generic Programming in Haskell</a></li>
<li><a href="http://hackage.haskell.org/package/generic-deriving-1.6.3">generic-deriving</a></li>
</ul>
<h2 id="generic-deriving">Generic Deriving</h2>
<p>Using Generics many common libraries provide a mechanisms to derive common typeclass instances. Some real world examples:</p>
<p>The <a href="http://hackage.haskell.org/package/hashable">hashable</a> library allows us to derive hashing functions.</p>
<div class="sourceCode" include="src/18-generics/hashable.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span>

<span class="kw">import </span><span class="dt">GHC.Generics</span> (<span class="dt">Generic</span>)
<span class="kw">import </span><span class="dt">Data.Hashable</span>

<span class="kw">data</span> <span class="dt">Color</span> <span class="fu">=</span> <span class="dt">Red</span> <span class="fu">|</span> <span class="dt">Green</span> <span class="fu">|</span> <span class="dt">Blue</span> <span class="kw">deriving</span> (<span class="dt">Generic</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Hashable</span> <span class="dt">Color</span> <span class="kw">where</span>

<span class="ot">example1 ::</span> <span class="dt">Int</span>
example1 <span class="fu">=</span> hash <span class="dt">Red</span>
<span class="co">-- 839657738087498284</span>

<span class="ot">example2 ::</span> <span class="dt">Int</span>
example2 <span class="fu">=</span> hashWithSalt <span class="bn">0xDEADBEEF</span> <span class="dt">Red</span>
<span class="co">-- 62679985974121021</span></code></pre></div>
<p>The <a href="http://hackage.haskell.org/package/cereal-0.4.0.1">cereal</a> library allows us to automatically derive a binary representation.</p>
<div class="sourceCode" include="src/18-generics/cereal.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span>

<span class="kw">import </span><span class="dt">Data.Word</span>
<span class="kw">import </span><span class="dt">Data.ByteString</span>
<span class="kw">import </span><span class="dt">Data.Serialize</span>

<span class="kw">import </span><span class="dt">GHC.Generics</span>

<span class="kw">data</span> <span class="dt">Val</span> <span class="fu">=</span> <span class="dt">A</span> [<span class="dt">Val</span>] <span class="fu">|</span> <span class="dt">B</span> [(<span class="dt">Val</span>, <span class="dt">Val</span>)] <span class="fu">|</span> <span class="dt">C</span>
  <span class="kw">deriving</span> (<span class="dt">Generic</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Serialize</span> <span class="dt">Val</span> <span class="kw">where</span>

<span class="ot">encoded ::</span> <span class="dt">ByteString</span>
encoded <span class="fu">=</span> encode (<span class="dt">A</span> [<span class="dt">B</span> [(<span class="dt">C</span>, <span class="dt">C</span>)]])
<span class="co">-- &quot;\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\SOH\SOH\NUL\NUL\NUL\NUL\NUL\NUL\NUL\SOH\STX\STX&quot;</span>

<span class="ot">bytes ::</span> [<span class="dt">Word8</span>]
bytes <span class="fu">=</span> unpack encoded
<span class="co">-- [0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,2,2]</span>

<span class="ot">decoded ::</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Val</span>
decoded <span class="fu">=</span> decode encoded</code></pre></div>
<p>The <a href="http://hackage.haskell.org/package/aeson">aeson</a> library allows us to derive JSON representations for JSON instances.</p>
<div class="sourceCode" include="src/18-generics/derive_aeson.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span>
<span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Data.Aeson</span>
<span class="kw">import </span><span class="dt">GHC.Generics</span>

<span class="kw">data</span> <span class="dt">Point</span> <span class="fu">=</span> <span class="dt">Point</span> { _<span class="ot">x ::</span> <span class="dt">Double</span>, _<span class="ot">y ::</span> <span class="dt">Double</span> }
   <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>)

<span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Point</span>
<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Point</span>

<span class="ot">example1 ::</span> <span class="dt">Maybe</span> <span class="dt">Point</span>
example1 <span class="fu">=</span> decode <span class="st">&quot;{\&quot;x\&quot;:3.0,\&quot;y\&quot;:-1.0}&quot;</span>

example2 <span class="fu">=</span> encode <span class="fu">$</span> <span class="dt">Point</span> <span class="fl">123.4</span> <span class="dv">20</span></code></pre></div>
<p>See: <a href="http://dreixel.net/research/pdf/gdmh.pdf">A Generic Deriving Mechanism for Haskell</a></p>
<h5 id="higher-kinded-generics">Higher Kinded Generics</h5>
<p>Using the same interface GHC.Generics provides a separate typeclass for higher-kinded generics.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Generic1</span> f <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Rep1</span><span class="ot"> f ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>
<span class="ot">  from1  ::</span> f a <span class="ot">-&gt;</span> (<span class="dt">Rep1</span> f) a
<span class="ot">  to1    ::</span> (<span class="dt">Rep1</span> f) a <span class="ot">-&gt;</span> f a</code></pre></div>
<p>So for instance <code>Maybe</code> has <code>Rep1</code> of the form:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Rep1</span> <span class="dt">Maybe</span>
  <span class="fu">=</span> <span class="dt">D1</span>
      <span class="dt">GHC.Generics.D1Maybe</span>
      (<span class="dt">C1</span> <span class="dt">C1_0Maybe</span> <span class="dt">U1</span>
       <span class="fu">:+:</span> <span class="dt">C1</span> <span class="dt">C1_1Maybe</span> (<span class="dt">S1</span> <span class="dt">NoSelector</span> <span class="dt">Par1</span>))</code></pre></div>
<h2 id="generics-sop">generics-sop</h2>
<h2 id="uniplate">Uniplate</h2>
<p>Uniplate is a generics library for writing traversals and transformation for arbitrary data structures. It is extremely useful for writing AST transformations and rewriting systems.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">plate ::</span> from <span class="ot">-&gt;</span> <span class="dt">Type</span> from to
<span class="ot">(|*)  ::</span> <span class="dt">Type</span> (to <span class="ot">-&gt;</span> from) to <span class="ot">-&gt;</span> to <span class="ot">-&gt;</span> <span class="dt">Type</span> from to
<span class="ot">(|-)  ::</span> <span class="dt">Type</span> (item <span class="ot">-&gt;</span> from) to <span class="ot">-&gt;</span> item <span class="ot">-&gt;</span> <span class="dt">Type</span> from to

<span class="ot">descend   ::</span> <span class="dt">Uniplate</span> on <span class="ot">=&gt;</span> (on <span class="ot">-&gt;</span> on) <span class="ot">-&gt;</span> on <span class="ot">-&gt;</span> on
<span class="ot">transform ::</span> <span class="dt">Uniplate</span> on <span class="ot">=&gt;</span> (on <span class="ot">-&gt;</span> on) <span class="ot">-&gt;</span> on <span class="ot">-&gt;</span> on
<span class="ot">rewrite   ::</span> <span class="dt">Uniplate</span> on <span class="ot">=&gt;</span> (on <span class="ot">-&gt;</span> <span class="dt">Maybe</span> on) <span class="ot">-&gt;</span> on <span class="ot">-&gt;</span> on</code></pre></div>
<p>The <code>descend</code> function will apply a function to each immediate descendant of an expression and then combines them up into the parent expression.</p>
<p>The <code>transform</code> function will perform a single pass bottom-up transformation of all terms in the expression.</p>
<p>The <code>rewrite</code> function will perform an exhaustive transformation of all terms in the expression to fixed point, using Maybe to signify termination.</p>
<div class="sourceCode" include="src/18-generics/uniplate.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Generics.Uniplate.Direct</span>

<span class="kw">data</span> <span class="dt">Expr</span> a
  <span class="fu">=</span> <span class="dt">Fls</span>
  <span class="fu">|</span> <span class="dt">Tru</span>
  <span class="fu">|</span> <span class="dt">Var</span> a
  <span class="fu">|</span> <span class="dt">Not</span> (<span class="dt">Expr</span> a)
  <span class="fu">|</span> <span class="dt">And</span> (<span class="dt">Expr</span> a) (<span class="dt">Expr</span> a)
  <span class="fu">|</span> <span class="dt">Or</span>  (<span class="dt">Expr</span> a) (<span class="dt">Expr</span> a)
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)

<span class="kw">instance</span> <span class="dt">Uniplate</span> (<span class="dt">Expr</span> a) <span class="kw">where</span>
  uniplate (<span class="dt">Not</span> f)     <span class="fu">=</span> plate <span class="dt">Not</span> <span class="fu">|*</span> f
  uniplate (<span class="dt">And</span> f1 f2) <span class="fu">=</span> plate <span class="dt">And</span> <span class="fu">|*</span> f1 <span class="fu">|*</span> f2
  uniplate (<span class="dt">Or</span> f1 f2)  <span class="fu">=</span> plate <span class="dt">Or</span> <span class="fu">|*</span> f1 <span class="fu">|*</span> f2
  uniplate x           <span class="fu">=</span> plate x

<span class="ot">simplify ::</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a
simplify <span class="fu">=</span> transform simp
 <span class="kw">where</span>
   simp (<span class="dt">Not</span> (<span class="dt">Not</span> f)) <span class="fu">=</span> f
   simp (<span class="dt">Not</span> <span class="dt">Fls</span>) <span class="fu">=</span> <span class="dt">Tru</span>
   simp (<span class="dt">Not</span> <span class="dt">Tru</span>) <span class="fu">=</span> <span class="dt">Fls</span>
   simp x <span class="fu">=</span> x

<span class="ot">reduce ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a
reduce <span class="fu">=</span> rewrite cnf
  <span class="kw">where</span>
    <span class="co">-- double negation</span>
    cnf (<span class="dt">Not</span> (<span class="dt">Not</span> p)) <span class="fu">=</span> <span class="dt">Just</span> p

    <span class="co">-- de Morgan</span>
    cnf (<span class="dt">Not</span> (p <span class="ot">`Or`</span> q))  <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> (<span class="dt">Not</span> p) <span class="ot">`And`</span> (<span class="dt">Not</span> q)
    cnf (<span class="dt">Not</span> (p <span class="ot">`And`</span> q)) <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> (<span class="dt">Not</span> p) <span class="ot">`Or`</span> (<span class="dt">Not</span> q)

    <span class="co">-- distribute conjunctions</span>
    cnf (p <span class="ot">`Or`</span> (q <span class="ot">`And`</span> r)) <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> (p <span class="ot">`Or`</span> q) <span class="ot">`And`</span> (p <span class="ot">`Or`</span> r)
    cnf ((p <span class="ot">`And`</span> q) <span class="ot">`Or`</span> r) <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> (p <span class="ot">`Or`</span> q) <span class="ot">`And`</span> (p <span class="ot">`Or`</span> r)
    cnf _ <span class="fu">=</span> <span class="dt">Nothing</span>


<span class="ot">example1 ::</span> <span class="dt">Expr</span> <span class="dt">String</span>
example1 <span class="fu">=</span> simplify (<span class="dt">Not</span> (<span class="dt">Not</span> (<span class="dt">Not</span> (<span class="dt">Not</span> (<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>)))))
<span class="co">-- Var &quot;a&quot;</span>

<span class="ot">example2 ::</span> [<span class="dt">String</span>]
example2 <span class="fu">=</span> [a <span class="fu">|</span> <span class="dt">Var</span> a <span class="ot">&lt;-</span> universe ex]
  <span class="kw">where</span>
    ex <span class="fu">=</span> <span class="dt">Or</span> (<span class="dt">And</span> (<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;b&quot;</span>)) (<span class="dt">Not</span> (<span class="dt">And</span> (<span class="dt">Var</span> <span class="st">&quot;c&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;d&quot;</span>)))
<span class="co">-- [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]</span>

<span class="ot">example3 ::</span> <span class="dt">Expr</span> <span class="dt">String</span>
example3 <span class="fu">=</span> reduce <span class="fu">$</span> ((a <span class="ot">`And`</span> b) <span class="ot">`Or`</span> (c <span class="ot">`And`</span> d)) <span class="ot">`Or`</span> e
  <span class="kw">where</span>
    a <span class="fu">=</span> <span class="dt">Var</span> <span class="st">&quot;a&quot;</span>
    b <span class="fu">=</span> <span class="dt">Var</span> <span class="st">&quot;b&quot;</span>
    c <span class="fu">=</span> <span class="dt">Var</span> <span class="st">&quot;c&quot;</span>
    d <span class="fu">=</span> <span class="dt">Var</span> <span class="st">&quot;d&quot;</span>
    e <span class="fu">=</span> <span class="dt">Var</span> <span class="st">&quot;e&quot;</span></code></pre></div>
<p>Alternatively Uniplate instances can be derived automatically from instances of Data without the need to explicitly write a Uniplate instance. This approach carries a slight amount of overhead over an explicit hand-written instance.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Data</span>
<span class="kw">import </span><span class="dt">Data.Typeable</span>
<span class="kw">import </span><span class="dt">Data.Generics.Uniplate.Data</span>

<span class="kw">data</span> <span class="dt">Expr</span> a
  <span class="fu">=</span> <span class="dt">Fls</span>
  <span class="fu">|</span> <span class="dt">Tru</span>
  <span class="fu">|</span> <span class="dt">Lit</span> a
  <span class="fu">|</span> <span class="dt">Not</span> (<span class="dt">Expr</span> a)
  <span class="fu">|</span> <span class="dt">And</span> (<span class="dt">Expr</span> a) (<span class="dt">Expr</span> a)
  <span class="fu">|</span> <span class="dt">Or</span> (<span class="dt">Expr</span> a) (<span class="dt">Expr</span> a)
  <span class="kw">deriving</span> (<span class="dt">Data</span>, <span class="dt">Typeable</span>, <span class="dt">Show</span>, <span class="dt">Eq</span>)</code></pre></div>
<p><strong>Biplate</strong></p>
<p>Biplates generalize plates where the target type isn't necessarily the same as the source, it uses multiparameter typeclasses to indicate the type sub of the sub-target. The Uniplate functions all have an equivalent generalized biplate form.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">descendBi   ::</span> <span class="dt">Biplate</span> from to <span class="ot">=&gt;</span> (to <span class="ot">-&gt;</span> to) <span class="ot">-&gt;</span> from <span class="ot">-&gt;</span> from
<span class="ot">transformBi ::</span> <span class="dt">Biplate</span> from to <span class="ot">=&gt;</span> (to <span class="ot">-&gt;</span> to) <span class="ot">-&gt;</span> from <span class="ot">-&gt;</span> from
<span class="ot">rewriteBi   ::</span> <span class="dt">Biplate</span> from to <span class="ot">=&gt;</span> (to <span class="ot">-&gt;</span> <span class="dt">Maybe</span> to) <span class="ot">-&gt;</span> from <span class="ot">-&gt;</span> from

<span class="ot">descendBiM   ::</span> (<span class="dt">Monad</span> m, <span class="dt">Biplate</span> from to) <span class="ot">=&gt;</span> (to <span class="ot">-&gt;</span> m to) <span class="ot">-&gt;</span> from <span class="ot">-&gt;</span> m from
<span class="ot">transformBiM ::</span> (<span class="dt">Monad</span> m, <span class="dt">Biplate</span> from to) <span class="ot">=&gt;</span> (to <span class="ot">-&gt;</span> m to) <span class="ot">-&gt;</span> from <span class="ot">-&gt;</span> m from
<span class="ot">rewriteBiM   ::</span> (<span class="dt">Monad</span> m, <span class="dt">Biplate</span> from to) <span class="ot">=&gt;</span> (to <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> to)) <span class="ot">-&gt;</span> from <span class="ot">-&gt;</span> m from</code></pre></div>
<div class="sourceCode" include="src/18-generics/biplate.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class="ot">{-# LANGUAGE FlexibleContexts #-}</span>

<span class="kw">import </span><span class="dt">Data.Generics.Uniplate.Direct</span>

<span class="kw">type</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="dt">Var</span> <span class="dt">Name</span>
  <span class="fu">|</span> <span class="dt">Lam</span> <span class="dt">Name</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">data</span> <span class="dt">Stmt</span>
  <span class="fu">=</span> <span class="dt">Decl</span> [<span class="dt">Stmt</span>]
  <span class="fu">|</span> <span class="dt">Let</span> <span class="dt">Name</span> <span class="dt">Expr</span>
  <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">instance</span> <span class="dt">Uniplate</span> <span class="dt">Expr</span> <span class="kw">where</span>
  uniplate (<span class="dt">Var</span> x  ) <span class="fu">=</span> plate <span class="dt">Var</span> <span class="fu">|-</span> x
  uniplate (<span class="dt">App</span> x y) <span class="fu">=</span> plate <span class="dt">App</span> <span class="fu">|*</span> x <span class="fu">|*</span> y
  uniplate (<span class="dt">Lam</span> x y) <span class="fu">=</span> plate <span class="dt">Lam</span> <span class="fu">|-</span> x <span class="fu">|*</span> y

<span class="kw">instance</span> <span class="dt">Biplate</span> <span class="dt">Expr</span> <span class="dt">Expr</span> <span class="kw">where</span>
  biplate <span class="fu">=</span> plateSelf

<span class="kw">instance</span> <span class="dt">Uniplate</span> <span class="dt">Stmt</span> <span class="kw">where</span>
  uniplate (<span class="dt">Decl</span> x  ) <span class="fu">=</span> plate <span class="dt">Decl</span> <span class="fu">||*</span> x
  uniplate (<span class="dt">Let</span> x y) <span class="fu">=</span> plate <span class="dt">Let</span> <span class="fu">|-</span>  x <span class="fu">|-</span> y

<span class="kw">instance</span> <span class="dt">Biplate</span> <span class="dt">Stmt</span> <span class="dt">Stmt</span> <span class="kw">where</span>
  biplate <span class="fu">=</span> plateSelf

<span class="kw">instance</span> <span class="dt">Biplate</span> <span class="dt">Stmt</span> <span class="dt">Expr</span> <span class="kw">where</span>
  biplate (<span class="dt">Decl</span> x) <span class="fu">=</span> plate <span class="dt">Decl</span> <span class="fu">||+</span> x
  biplate (<span class="dt">Let</span> x y) <span class="fu">=</span> plate <span class="dt">Let</span> <span class="fu">|-</span> x <span class="fu">|*</span> y

<span class="ot">rename ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span>
rename from to <span class="fu">=</span> rewrite f
  <span class="kw">where</span>
    f (<span class="dt">Var</span> a) <span class="fu">|</span> a <span class="fu">==</span> from <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Var</span> to)
    f (<span class="dt">Lam</span> a b) <span class="fu">|</span> a <span class="fu">==</span> from <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Lam</span> to b)
    f _ <span class="fu">=</span> <span class="dt">Nothing</span>

s, k,<span class="ot"> sk ::</span> <span class="dt">Expr</span>
s <span class="fu">=</span> <span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;y&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;z&quot;</span> (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;z&quot;</span>)) (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;y&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;z&quot;</span>)))))
k <span class="fu">=</span> <span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;y&quot;</span> (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>))
sk <span class="fu">=</span> <span class="dt">App</span> s k

<span class="ot">m ::</span> <span class="dt">Stmt</span>
m <span class="fu">=</span> descendBi f <span class="fu">$</span> <span class="dt">Decl</span> [ (<span class="dt">Let</span> <span class="st">&quot;s&quot;</span> s) , <span class="dt">Let</span> <span class="st">&quot;k&quot;</span> k , <span class="dt">Let</span> <span class="st">&quot;sk&quot;</span> sk ]
  <span class="kw">where</span>
    f <span class="fu">=</span> rename <span class="st">&quot;x&quot;</span> <span class="st">&quot;a&quot;</span>
      <span class="fu">.</span> rename <span class="st">&quot;y&quot;</span> <span class="st">&quot;b&quot;</span>
      <span class="fu">.</span> rename <span class="st">&quot;z&quot;</span> <span class="st">&quot;c&quot;</span></code></pre></div>
</hr>
<h1 id="mathematics">Mathematics</h1>
<h2 id="numeric-tower">Numeric Tower</h2>
<p>Haskell's numeric tower is unusual and the source of some confusion for novices. Haskell is one of the few languages to incorporate statically typed overloaded literals without a mechanism for &quot;coercions&quot; often found in other languages.</p>
<p>To add to the confusion numerical literals in Haskell are desugared into a function from a numeric typeclass which yields a polymorphic value that can be instantiated to any instance of the <code>Num</code> or <code>Fractional</code> typeclass at the call-site, depending on the inferred type.</p>
<p>To use a blunt metaphor, we're effectively placing an object in a hole and the size and shape of the hole defines the object you place there. This is very different than in other languages where a numeric literal like <code>2.718</code> is hard coded in the compiler to be a specific type ( double or something ) and you cast the value at runtime to be something smaller or larger as needed.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dv">42</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a
fromInteger (<span class="dv">42</span><span class="ot"> ::</span> <span class="dt">Integer</span>)

<span class="fl">2.71</span><span class="ot"> ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> a
fromRational (<span class="fl">2.71</span><span class="ot"> ::</span> <span class="dt">Rational</span>)</code></pre></div>
<p>The numeric typeclass hierarchy is defined as such:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Num</span> a
<span class="kw">class</span> (<span class="dt">Num</span> a, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">Real</span> a
<span class="kw">class</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Fractional</span> a
<span class="kw">class</span> (<span class="dt">Real</span> a, <span class="dt">Enum</span> a) <span class="ot">=&gt;</span> <span class="dt">Integral</span> a
<span class="kw">class</span> (<span class="dt">Real</span> a, <span class="dt">Fractional</span> a) <span class="ot">=&gt;</span> <span class="dt">RealFrac</span> a
<span class="kw">class</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">Floating</span> a
<span class="kw">class</span> (<span class="dt">RealFrac</span> a, <span class="dt">Floating</span> a) <span class="ot">=&gt;</span> <span class="dt">RealFloat</span> a</code></pre></div>
<div class="figure">
<img src="img/numerics.png" alt="" />

</div>
<p>Conversions between concrete numeric types ( from : left column, to : top row ) is accomplished with several generic functions.</p>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">Double</th>
<th align="left">Float</th>
<th align="left">Int</th>
<th align="left">Word</th>
<th align="left">Integer</th>
<th align="left">Rational</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Double</td>
<td align="left">id</td>
<td align="left">fromRational</td>
<td align="left">truncate</td>
<td align="left">truncate</td>
<td align="left">truncate</td>
<td align="left">toRational</td>
</tr>
<tr class="even">
<td align="left">Float</td>
<td align="left">fromRational</td>
<td align="left">id</td>
<td align="left">truncate</td>
<td align="left">truncate</td>
<td align="left">truncate</td>
<td align="left">toRational</td>
</tr>
<tr class="odd">
<td align="left">Int</td>
<td align="left">fromIntegral</td>
<td align="left">fromIntegral</td>
<td align="left">id</td>
<td align="left">fromIntegral</td>
<td align="left">fromIntegral</td>
<td align="left">fromIntegral</td>
</tr>
<tr class="even">
<td align="left">Word</td>
<td align="left">fromIntegral</td>
<td align="left">fromIntegral</td>
<td align="left">fromIntegral</td>
<td align="left">id</td>
<td align="left">fromIntegral</td>
<td align="left">fromIntegral</td>
</tr>
<tr class="odd">
<td align="left">Integer</td>
<td align="left">fromIntegral</td>
<td align="left">fromIntegral</td>
<td align="left">fromIntegral</td>
<td align="left">fromIntegral</td>
<td align="left">id</td>
<td align="left">fromIntegral</td>
</tr>
<tr class="even">
<td align="left">Rational</td>
<td align="left">fromRatoinal</td>
<td align="left">fromRational</td>
<td align="left">truncate</td>
<td align="left">truncate</td>
<td align="left">truncate</td>
<td align="left">id</td>
</tr>
</tbody>
</table>
<h2 id="integer">Integer</h2>
<p>The <code>Integer</code> type in GHC is implemented by the GMP (<code>libgmp</code>) arbitrary precision arithmetic library. Unlike the <code>Int</code> type the size of Integer values is bounded only by the available memory. Most notably <code>libgmp</code> is one of the few libraries that compiled Haskell binaries are dynamically linked against.</p>
<p>An alternative library <code>integer-simple</code> can be linked in place of libgmp.</p>
<p>See: <a href="http://www.well-typed.com/blog/32/">GHC, primops and exorcising GMP</a></p>
<h2 id="complex">Complex</h2>
<p>Haskell supports arithmetic with complex numbers via a Complex datatype from the <code>Data.Complex</code> module. The first argument is the real part, while the second is the imaginary part. The type has a single parameter and inherits it's numerical typeclass components (Num, Fractional, Floating) from the type of this paramater.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- 1 + 2i</span>
<span class="kw">let</span> complex <span class="fu">=</span> <span class="dv">1</span> <span class="fu">:+</span> <span class="dv">2</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Complex</span> a <span class="fu">=</span> a <span class="fu">:+</span> a
<span class="ot">mkPolar ::</span> <span class="dt">RealFloat</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Complex</span> a</code></pre></div>
<p>The <code>Num</code> instance for <code>Complex</code> is only defined if parameter of <code>Complex</code> is an instance of <code>RealFloat</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> <span class="dv">0</span> <span class="fu">:+</span> <span class="dv">1</span>
<span class="dv">0</span> <span class="fu">:+</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Complex</span> <span class="dt">Integer</span>

λ<span class="fu">:</span> (<span class="dv">0</span> <span class="fu">:+</span> <span class="dv">1</span>) <span class="fu">+</span> (<span class="dv">1</span> <span class="fu">:+</span> <span class="dv">0</span>)
<span class="fl">1.0</span> <span class="fu">:+</span> <span class="fl">1.0</span><span class="ot"> ::</span> <span class="dt">Complex</span> <span class="dt">Integer</span>

λ<span class="fu">:</span> exp (<span class="dv">0</span> <span class="fu">:+</span> <span class="dv">2</span> <span class="fu">*</span> pi)
<span class="fl">1.0</span> <span class="fu">:+</span> (<span class="fu">-</span><span class="fl">2.4492935982947064e-16</span>)<span class="ot"> ::</span> <span class="dt">Complex</span> <span class="dt">Double</span>

λ<span class="fu">:</span> mkPolar <span class="dv">1</span> (<span class="dv">2</span><span class="fu">*</span>pi)
<span class="fl">1.0</span> <span class="fu">:+</span> (<span class="fu">-</span><span class="fl">2.4492935982947064e-16</span>)<span class="ot"> ::</span> <span class="dt">Complex</span> <span class="dt">Double</span>

λ<span class="fu">:</span> <span class="kw">let</span> f x n <span class="fu">=</span> (cos x <span class="fu">:+</span> sin x)<span class="fu">^</span>n
λ<span class="fu">:</span> <span class="kw">let</span> g x n <span class="fu">=</span> cos (n<span class="fu">*</span>x) <span class="fu">:+</span> sin (n<span class="fu">*</span>x)</code></pre></div>
<h2 id="scientific">Scientific</h2>
<p>Scientific provides arbitrary-precision numbers represented using scientific notation. The constructor takes an arbitrarily sized Integer argument for the digits and an Int for the exponent. Alternatively the value can be parsed from a String or coerced from either Double/Float.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">scientific ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Scientific</span>
<span class="ot">fromFloatDigits ::</span> <span class="dt">RealFloat</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Scientific</span></code></pre></div>
<div class="sourceCode" include="src/19-numbers/scientific.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Scientific</span>

c, h, g, a,<span class="ot"> k ::</span> <span class="dt">Scientific</span>
c <span class="fu">=</span> scientific <span class="dv">299792458</span> (<span class="dv">0</span>)   <span class="co">-- Speed of light</span>
h <span class="fu">=</span> scientific <span class="dv">662606957</span> (<span class="fu">-</span><span class="dv">42</span>) <span class="co">-- Planck&#39;s constant</span>
g <span class="fu">=</span> scientific <span class="dv">667384</span>    (<span class="fu">-</span><span class="dv">16</span>) <span class="co">-- Gravitational constant</span>
a <span class="fu">=</span> scientific <span class="dv">729735257</span> (<span class="fu">-</span><span class="dv">11</span>) <span class="co">-- Fine structure constant</span>
k <span class="fu">=</span> scientific <span class="dv">268545200</span> (<span class="fu">-</span><span class="dv">9</span>)  <span class="co">-- Khinchin Constant</span>

<span class="ot">tau ::</span> <span class="dt">Scientific</span>
tau <span class="fu">=</span> fromFloatDigits (<span class="dv">2</span><span class="fu">*</span>pi)

<span class="ot">maxDouble64 ::</span> <span class="dt">Double</span>
maxDouble64 <span class="fu">=</span> read <span class="st">&quot;1.7976931348623159e308&quot;</span>
<span class="co">-- Infinity</span>

<span class="ot">maxScientific ::</span> <span class="dt">Scientific</span>
maxScientific <span class="fu">=</span> read <span class="st">&quot;1.7976931348623159e308&quot;</span>
<span class="co">-- 1.7976931348623159e308</span></code></pre></div>
<h2 id="statistics">Statistics</h2>
<div class="sourceCode" include="src/19-numbers/stats.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Vector</span>
<span class="kw">import </span><span class="dt">Statistics.Sample</span>

<span class="kw">import </span><span class="dt">Statistics.Distribution.Normal</span>
<span class="kw">import </span><span class="dt">Statistics.Distribution.Poisson</span>
<span class="kw">import qualified</span> <span class="dt">Statistics.Distribution</span> <span class="kw">as</span> <span class="dt">S</span>

<span class="ot">s1 ::</span> <span class="dt">Vector</span> <span class="dt">Double</span>
s1 <span class="fu">=</span> fromList [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>]

<span class="ot">s2 ::</span> <span class="dt">PoissonDistribution</span>
s2 <span class="fu">=</span> poisson <span class="fl">2.5</span>

<span class="ot">s3 ::</span> <span class="dt">NormalDistribution</span>
s3 <span class="fu">=</span> normalDistr mean stdDev
  <span class="kw">where</span>
    mean   <span class="fu">=</span> <span class="dv">1</span>
    stdDev <span class="fu">=</span> <span class="dv">1</span>

descriptive <span class="fu">=</span> <span class="kw">do</span>
  print <span class="fu">$</span> range s1
  <span class="co">-- 9.0</span>
  print <span class="fu">$</span> mean s1
  <span class="co">-- 5.5</span>
  print <span class="fu">$</span> stdDev s1
  <span class="co">-- 3.0276503540974917</span>
  print <span class="fu">$</span> variance s1
  <span class="co">-- 8.25</span>
  print <span class="fu">$</span> harmonicMean s1
  <span class="co">-- 3.414171521474055</span>
  print <span class="fu">$</span> geometricMean s1
  <span class="co">-- 4.5287286881167645</span>

discrete <span class="fu">=</span> <span class="kw">do</span>
  print <span class="fu">$</span> S.cumulative s2 <span class="dv">0</span>
  <span class="co">-- 8.208499862389884e-2</span>
  print <span class="fu">$</span> S.mean s2
  <span class="co">-- 2.5</span>
  print <span class="fu">$</span> S.variance s2
  <span class="co">-- 2.5</span>
  print <span class="fu">$</span> S.stdDev s2
  <span class="co">-- 1.5811388300841898</span>

continuous <span class="fu">=</span> <span class="kw">do</span>
  print <span class="fu">$</span> S.cumulative s3 <span class="dv">0</span>
  <span class="co">-- 0.15865525393145707</span>
  print <span class="fu">$</span> S.quantile s3 <span class="fl">0.5</span>
  <span class="co">-- 1.0</span>
  print <span class="fu">$</span> S.density s3 <span class="dv">0</span>
  <span class="co">-- 0.24197072451914334</span>
  print <span class="fu">$</span> S.mean s3
  <span class="co">-- 1.0</span>
  print <span class="fu">$</span> S.variance s3
  <span class="co">-- 1.0</span>
  print <span class="fu">$</span> S.stdDev s3
  <span class="co">-- 1.0</span></code></pre></div>
<h2 id="constructive-reals">Constructive Reals</h2>
<p>Instead of modeling the real numbers on finite precision floating point numbers we alternatively work with <code>Num</code> which internally manipulate the power series expansions for the expressions when performing operations like arithmetic or transcendental functions without losing precision when performing intermediate computations. Then we simply slice off a fixed number of terms and approximate the resulting number to a desired precision. This approach is not without its limitations and caveats ( notably that it may diverge ).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">exp(x)    <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> x <span class="fu">+</span> <span class="dv">1</span><span class="fu">/</span><span class="dv">2</span><span class="fu">*</span>x<span class="fu">^</span><span class="dv">2</span> <span class="fu">+</span> <span class="dv">1</span><span class="fu">/</span><span class="dv">6</span><span class="fu">*</span>x<span class="fu">^</span><span class="dv">3</span> <span class="fu">+</span> <span class="dv">1</span><span class="fu">/</span><span class="dv">24</span><span class="fu">*</span>x<span class="fu">^</span><span class="dv">4</span> <span class="fu">+</span> <span class="dv">1</span><span class="fu">/</span><span class="dv">120</span><span class="fu">*</span>x<span class="fu">^</span><span class="dv">5</span> <span class="fu">...</span>
sqrt(<span class="dv">1</span><span class="fu">+</span>x) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">1</span><span class="fu">/</span><span class="dv">2</span><span class="fu">*</span>x <span class="fu">-</span> <span class="dv">1</span><span class="fu">/</span><span class="dv">8</span><span class="fu">*</span>x<span class="fu">^</span><span class="dv">2</span> <span class="fu">+</span> <span class="dv">1</span><span class="fu">/</span><span class="dv">16</span><span class="fu">*</span>x<span class="fu">^</span><span class="dv">3</span> <span class="fu">-</span> <span class="dv">5</span><span class="fu">/</span><span class="dv">128</span><span class="fu">*</span>x<span class="fu">^</span><span class="dv">4</span> <span class="fu">+</span> <span class="dv">7</span><span class="fu">/</span><span class="dv">256</span><span class="fu">*</span>x<span class="fu">^</span><span class="dv">5</span> <span class="fu">...</span>
atan(x)   <span class="fu">=</span> x <span class="fu">-</span> <span class="dv">1</span><span class="fu">/</span><span class="dv">3</span><span class="fu">*</span>x<span class="fu">^</span><span class="dv">3</span> <span class="fu">+</span> <span class="dv">1</span><span class="fu">/</span><span class="dv">5</span><span class="fu">*</span>x<span class="fu">^</span><span class="dv">5</span> <span class="fu">-</span> <span class="dv">1</span><span class="fu">/</span><span class="dv">7</span><span class="fu">*</span>x<span class="fu">^</span><span class="dv">7</span> <span class="fu">+</span> <span class="dv">1</span><span class="fu">/</span><span class="dv">9</span><span class="fu">*</span>x<span class="fu">^</span><span class="dv">9</span> <span class="fu">-</span> <span class="dv">1</span><span class="fu">/</span><span class="dv">11</span><span class="fu">*</span>x<span class="fu">^</span><span class="dv">11</span> <span class="fu">...</span>
pi        <span class="fu">=</span> <span class="dv">16</span> <span class="fu">*</span> atan (<span class="dv">1</span><span class="fu">/</span><span class="dv">5</span>) <span class="fu">-</span> <span class="dv">4</span> <span class="fu">*</span> atan (<span class="dv">1</span><span class="fu">/</span><span class="dv">239</span>)</code></pre></div>
<div class="sourceCode" include="src/19-numbers/creal.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Number.CReal</span>

<span class="co">-- algebraic</span>
<span class="ot">phi ::</span> <span class="dt">CReal</span>
phi <span class="fu">=</span> (<span class="dv">1</span> <span class="fu">+</span> sqrt <span class="dv">5</span>) <span class="fu">/</span> <span class="dv">2</span>

<span class="co">-- transcendental</span>
<span class="ot">ramanujan ::</span> <span class="dt">CReal</span>
ramanujan <span class="fu">=</span> exp (pi <span class="fu">*</span> sqrt <span class="dv">163</span>)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  putStrLn <span class="fu">$</span> showCReal <span class="dv">30</span> pi
  <span class="co">-- 3.141592653589793238462643383279</span>
  putStrLn <span class="fu">$</span> showCReal <span class="dv">30</span> phi
  <span class="co">-- 1.618033988749894848204586834366</span>
  putStrLn <span class="fu">$</span> showCReal <span class="dv">15</span> ramanujan
  <span class="co">-- 262537412640768743.99999999999925</span></code></pre></div>
<h2 id="sat-solvers">SAT Solvers</h2>
<p>A collection of constraint problems known as satisfiability problems show up in a number of different disciplines from type checking to package management. Simply put a satisfiability problem attempts to find solutions to a statement of conjoined conjunctions and disjunctions in terms of a series of variables. For example:</p>
<pre class="text"><code>(A v ¬B v C) ∧ (B v D v E) ∧ (D v F)</code></pre>
<p>To use the picosat library to solve this, it can be written as zero-terminated lists of integers and fed to the solver according to a number-to-variable relation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dv">1</span> <span class="fu">-</span><span class="dv">2</span> <span class="dv">3</span>  <span class="co">-- (A v ¬B v C)</span>
<span class="dv">2</span> <span class="dv">4</span> <span class="dv">5</span>   <span class="co">-- (B v D v E)</span>
<span class="dv">4</span> <span class="dv">6</span>     <span class="co">-- (D v F)</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Picosat</span>

<span class="ot">main ::</span> <span class="dt">IO</span> [<span class="dt">Int</span>]
main <span class="fu">=</span> <span class="kw">do</span>
  solve [[<span class="dv">1</span>, <span class="fu">-</span><span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">5</span>], [<span class="dv">4</span>,<span class="dv">6</span>]]
  <span class="co">-- Solution [1,-2,3,4,5,6]</span></code></pre></div>
<p>The SAT solver itself can be used to solve satisfiability problems with millions of variables in this form and is finely tuned.</p>
<p>See:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/picosat-0.1.1">picosat</a></li>
</ul>
<h2 id="smt-solvers">SMT Solvers</h2>
<p>A generalization of the SAT problem to include predicates other theories gives rise to the very sophisticated domain of &quot;Satisfiability Modulo Theory&quot; problems. The existing SMT solvers are very sophisticated projects ( usually bankrolled by large institutions ) and usually have to called out to via foreign function interface or via a common interface called SMT-lib. The two most common of use in Haskell are <code>cvc4</code> from Stanford and <code>z3</code> from Microsoft Research.</p>
<p>The SBV library can abstract over different SMT solvers to allow us to express the problem in an embedded domain language in Haskell and then offload the solving work to the third party library.</p>
<p>As an example, here's how you can solve a simple <a href="../../en.wikipedia.org/wiki/Verbal_arithmetic.html">cryptarithm</a></p>
<table>
<tbody>
<tr class="odd">
<td align="right"><code>M</code> <code>O</code> <code>N</code> <code>A</code> <code>D</code></td>
</tr>
<tr class="even">
<td align="right">+ <code>B</code> <code>U</code> <code>R</code> <code>R</code> <code>I</code> <code>T</code> <code>O</code></td>
</tr>
<tr class="odd">
<td align="right">= <code>B</code> <code>A</code> <code>N</code> <code>D</code> <code>A</code> <code>I</code> <code>D</code></td>
</tr>
</tbody>
</table>
<p>using SBV library:</p>
<div class="sourceCode" include="src/19-numbers/puzzle.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Foldable</span>
<span class="kw">import </span><span class="dt">Data.SBV</span>

<span class="co">-- | val [4,2] == 42</span>
<span class="ot">val ::</span> [<span class="dt">SInteger</span>] <span class="ot">-&gt;</span> <span class="dt">SInteger</span>
val <span class="fu">=</span> foldr1 (\d r <span class="ot">-&gt;</span> d <span class="fu">+</span> <span class="dv">10</span><span class="fu">*</span>r) <span class="fu">.</span> reverse

<span class="ot">puzzle ::</span> <span class="dt">Symbolic</span> <span class="dt">SBool</span>
puzzle <span class="fu">=</span> <span class="kw">do</span>
  ds<span class="fu">@</span>[b,u,r,i,t,o,m,n,a,d] <span class="ot">&lt;-</span> sequenceA [ sInteger [v] <span class="fu">|</span> v <span class="ot">&lt;-</span> <span class="st">&quot;buritomnad&quot;</span> ]
  constrain <span class="fu">$</span> allDifferent ds
  for_ ds <span class="fu">$</span> \d <span class="ot">-&gt;</span> constrain <span class="fu">$</span> inRange d (<span class="dv">0</span>,<span class="dv">9</span>)
  pure <span class="fu">$</span>    val [b,u,r,r,i,t,o]
          <span class="fu">+</span> val     [m,o,n,a,d]
        <span class="fu">.==</span> val [b,a,n,d,a,i,d]

</code></pre></div>
<p>Let's look at all possible solutions,</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> allSat puzzle
<span class="dt">Solution</span> <span class="fu">#</span><span class="dv">1</span><span class="fu">:</span>
  b <span class="fu">=</span> <span class="dv">4</span><span class="ot"> ::</span> <span class="dt">Integer</span>
  u <span class="fu">=</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Integer</span>
  r <span class="fu">=</span> <span class="dv">5</span><span class="ot"> ::</span> <span class="dt">Integer</span>
  i <span class="fu">=</span> <span class="dv">9</span><span class="ot"> ::</span> <span class="dt">Integer</span>
  t <span class="fu">=</span> <span class="dv">7</span><span class="ot"> ::</span> <span class="dt">Integer</span>
  o <span class="fu">=</span> <span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Integer</span>
  m <span class="fu">=</span> <span class="dv">8</span><span class="ot"> ::</span> <span class="dt">Integer</span>
  n <span class="fu">=</span> <span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Integer</span>
  a <span class="fu">=</span> <span class="dv">2</span><span class="ot"> ::</span> <span class="dt">Integer</span>
  d <span class="fu">=</span> <span class="dv">6</span><span class="ot"> ::</span> <span class="dt">Integer</span>
<span class="dt">This</span> is the only solution<span class="fu">.</span></code></pre></div>
<p>See:</p>
<ul>
<li><a href="http://leventerkok.github.io/sbv/">sbv</a></li>
<li><a href="http://cvc4.cs.nyu.edu/web/">cvc4</a></li>
<li><a href="http://z3.codeplex.com/">z3</a></li>
</ul>
<h2 id="z3">Z3</h2>
<p>TODO</p>
<p>See: <a href="https://hackage.haskell.org/package/z3">z3</a></p>
</hr>
<h1 id="data-structures">Data Structures</h1>
<h2 id="map">Map</h2>
<table>
<thead>
<tr class="header">
<th align="left">Functionality</th>
<th align="left">Function</th>
<th align="left">Time Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Initialization</td>
<td align="left">empty</td>
<td align="left">O(1)</td>
</tr>
<tr class="even">
<td align="left">Size</td>
<td align="left">size</td>
<td align="left">O(1)</td>
</tr>
<tr class="odd">
<td align="left">Lookup</td>
<td align="left">lookup</td>
<td align="left">O(log(n))</td>
</tr>
<tr class="even">
<td align="left">Insertion</td>
<td align="left">insert</td>
<td align="left">O(log(n))</td>
</tr>
<tr class="odd">
<td align="left">Traversal</td>
<td align="left">traverse</td>
<td align="left">O(n)</td>
</tr>
</tbody>
</table>
<p>A map is an associative array mapping any instance of <code>Ord</code> keys to values of any type.</p>
<div class="sourceCode" include="src/20-data-structures/map.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span>

<span class="ot">kv ::</span> <span class="dt">Map.Map</span> <span class="dt">Integer</span> <span class="dt">String</span>
kv <span class="fu">=</span> Map.fromList [(<span class="dv">1</span>, <span class="st">&quot;a&quot;</span>), (<span class="dv">2</span>, <span class="st">&quot;b&quot;</span>)]

<span class="ot">lkup ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
lkup key def <span class="fu">=</span>
  <span class="kw">case</span> Map.lookup key kv <span class="kw">of</span>
    <span class="dt">Just</span> val <span class="ot">-&gt;</span> val
    <span class="dt">Nothing</span>  <span class="ot">-&gt;</span> def</code></pre></div>
<h2 id="tree">Tree</h2>
<table>
<thead>
<tr class="header">
<th align="left">Functionality</th>
<th align="left">Function</th>
<th align="left">Time Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Initialization</td>
<td align="left">empty</td>
<td align="left">O(1)</td>
</tr>
<tr class="even">
<td align="left">Size</td>
<td align="left">size</td>
<td align="left">O(1)</td>
</tr>
<tr class="odd">
<td align="left">Lookup</td>
<td align="left">lookup</td>
<td align="left">O(log(n))</td>
</tr>
<tr class="even">
<td align="left">Insertion</td>
<td align="left">insert</td>
<td align="left">O(log(n))</td>
</tr>
<tr class="odd">
<td align="left">Traversal</td>
<td align="left">traverse</td>
<td align="left">O(n)</td>
</tr>
</tbody>
</table>
<div class="sourceCode" include="src/20-data-structures/tree.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Tree</span>

<span class="co">{-</span>

<span class="co">   A</span>
<span class="co">  / \</span>
<span class="co"> B   C</span>
<span class="co">    / \</span>
<span class="co">   D   E</span>

<span class="co">-}</span>

<span class="ot">tree ::</span> <span class="dt">Tree</span> <span class="dt">String</span>
tree <span class="fu">=</span> <span class="dt">Node</span> <span class="st">&quot;A&quot;</span> [<span class="dt">Node</span> <span class="st">&quot;B&quot;</span> [], <span class="dt">Node</span> <span class="st">&quot;C&quot;</span> [<span class="dt">Node</span> <span class="st">&quot;D&quot;</span> [], <span class="dt">Node</span> <span class="st">&quot;E&quot;</span> []]]

<span class="ot">postorder ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]
postorder (<span class="dt">Node</span> a ts) <span class="fu">=</span> elts <span class="fu">++</span> [a]
  <span class="kw">where</span> elts <span class="fu">=</span> concat (map postorder ts)

<span class="ot">preorder ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]
preorder (<span class="dt">Node</span> a ts) <span class="fu">=</span> a <span class="fu">:</span> elts
  <span class="kw">where</span> elts <span class="fu">=</span> concat (map preorder ts)

ex1 <span class="fu">=</span> drawTree tree
ex2 <span class="fu">=</span> drawForest (subForest tree)
ex3 <span class="fu">=</span> flatten tree
ex4 <span class="fu">=</span> levels tree
ex5 <span class="fu">=</span> preorder tree
ex6 <span class="fu">=</span> postorder tree</code></pre></div>
<h2 id="set">Set</h2>
<table>
<thead>
<tr class="header">
<th align="left">Functionality</th>
<th align="left">Function</th>
<th align="left">Time Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Initialization</td>
<td align="left">empty</td>
<td align="left">O(1)</td>
</tr>
<tr class="even">
<td align="left">Size</td>
<td align="left">size</td>
<td align="left">O(1)</td>
</tr>
<tr class="odd">
<td align="left">Insertion</td>
<td align="left">insert</td>
<td align="left">O(log(n))</td>
</tr>
<tr class="even">
<td align="left">Deletion</td>
<td align="left">delete</td>
<td align="left">O(log(n))</td>
</tr>
<tr class="odd">
<td align="left">Traversal</td>
<td align="left">traverse</td>
<td align="left">O(n)</td>
</tr>
<tr class="even">
<td align="left">Membership Test</td>
<td align="left">member</td>
<td align="left">O(log(n))</td>
</tr>
</tbody>
</table>
<p>Sets are an unordered data structures allow <code>Ord</code> values of any type and guaranteeing uniqueness with in the structure. They are not identical to the mathematical notion of a Set even though they share the same namesake.</p>
<div class="sourceCode" include="src/20-data-structures/set.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">Set</span>

<span class="ot">set ::</span> <span class="dt">Set.Set</span> <span class="dt">Integer</span>
set <span class="fu">=</span> Set.fromList [<span class="dv">1</span><span class="fu">..</span><span class="dv">1000</span>]

<span class="ot">memtest ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
memtest elt <span class="fu">=</span> Set.member elt set</code></pre></div>
<h2 id="vector">Vector</h2>
<table>
<thead>
<tr class="header">
<th align="left">Functionality</th>
<th align="left">Function</th>
<th align="left">Time Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Initialization</td>
<td align="left">empty</td>
<td align="left">O(1)</td>
</tr>
<tr class="even">
<td align="left">Size</td>
<td align="left">length</td>
<td align="left">O(1)</td>
</tr>
<tr class="odd">
<td align="left">Indexing</td>
<td align="left">(!)</td>
<td align="left">O(1)</td>
</tr>
<tr class="even">
<td align="left">Append</td>
<td align="left">append</td>
<td align="left">O(n)</td>
</tr>
<tr class="odd">
<td align="left">Traversal</td>
<td align="left">traverse</td>
<td align="left">O(n)</td>
</tr>
</tbody>
</table>
<p>Vectors are high performance single dimensional arrays that come come in six variants, two for each of the following types of a mutable and an immutable variant.</p>
<ul>
<li>Data.Vector</li>
<li>Data.Vector.Storable</li>
<li>Data.Vector.Unboxed</li>
</ul>
<p>The most notable feature of vectors is constant time memory access with (<code>(!)</code>) as well as variety of efficient map, fold and scan operations on top of a fusion framework that generates surprisingly optimal code.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fromList ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Vector</span> a
<span class="ot">toList ::</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> [a]
<span class="ot">(!) ::</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a
map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> b
foldl<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> b <span class="ot">-&gt;</span> a
scanl<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> b <span class="ot">-&gt;</span> <span class="dt">Vector</span> a
zipWith<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> b <span class="ot">-&gt;</span> <span class="dt">Vector</span> c
<span class="ot">iterateN ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> a</code></pre></div>
<div class="sourceCode" include="src/20-data-structures/vector.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Vector.Unboxed</span> <span class="kw">as</span> <span class="dt">V</span>

<span class="ot">norm ::</span>  <span class="dt">Vector</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
norm <span class="fu">=</span> sqrt <span class="fu">.</span> V.sum <span class="fu">.</span> V.map (\x <span class="ot">-&gt;</span> x<span class="fu">*</span>x)

<span class="ot">example1 ::</span> <span class="dt">Double</span>
example1 <span class="fu">=</span> norm <span class="fu">$</span> V.iterateN <span class="dv">100000000</span> (<span class="fu">+</span><span class="dv">1</span>) <span class="fl">0.0</span></code></pre></div>
<p>See: <a href="http://wiki.haskell.org/Numeric_Haskell:_A_Vector_Tutorial">Numerical Haskell: A Vector Tutorial</a></p>
<h2 id="mutable-vectors">Mutable Vectors</h2>
<table>
<thead>
<tr class="header">
<th align="left">Functionality</th>
<th align="left">Function</th>
<th align="left">Time Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Initialization</td>
<td align="left">empty</td>
<td align="left">O(1)</td>
</tr>
<tr class="even">
<td align="left">Size</td>
<td align="left">length</td>
<td align="left">O(1)</td>
</tr>
<tr class="odd">
<td align="left">Indexing</td>
<td align="left">(!)</td>
<td align="left">O(1)</td>
</tr>
<tr class="even">
<td align="left">Append</td>
<td align="left">append</td>
<td align="left">O(n)</td>
</tr>
<tr class="odd">
<td align="left">Traversal</td>
<td align="left">traverse</td>
<td align="left">O(n)</td>
</tr>
<tr class="even">
<td align="left">Update</td>
<td align="left">modify</td>
<td align="left">O(1)</td>
</tr>
<tr class="odd">
<td align="left">Read</td>
<td align="left">read</td>
<td align="left">O(1)</td>
</tr>
<tr class="even">
<td align="left">Write</td>
<td align="left">write</td>
<td align="left">O(1)</td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">freeze ::</span> <span class="dt">MVector</span> (<span class="dt">PrimState</span> m) a <span class="ot">-&gt;</span> m (<span class="dt">Vector</span> a)
<span class="ot">thaw ::</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">MVector</span> (<span class="dt">PrimState</span> m) a</code></pre></div>
<p>Within the IO monad we can perform arbitrary read and writes on the mutable vector with constant time reads and writes. When needed a static Vector can be created to/from the <code>MVector</code> using the freeze/thaw functions.</p>
<div class="sourceCode" include="src/20-data-structures/vector_mutable.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">GHC.Prim</span>
<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Control.Monad.ST</span>
<span class="kw">import </span><span class="dt">Control.Monad.Primitive</span>

<span class="kw">import </span><span class="dt">Data.Vector.Unboxed</span> (freeze)
<span class="kw">import </span><span class="dt">Data.Vector.Unboxed.Mutable</span>
<span class="kw">import qualified</span> <span class="dt">Data.Vector.Unboxed</span> <span class="kw">as</span> <span class="dt">V</span>

<span class="ot">example ::</span> <span class="dt">PrimMonad</span> m <span class="ot">=&gt;</span> m (<span class="dt">V.Vector</span> <span class="dt">Int</span>)
example <span class="fu">=</span> <span class="kw">do</span>
  v <span class="ot">&lt;-</span> new <span class="dv">10</span>
  forM_ [<span class="dv">0</span><span class="fu">..</span><span class="dv">9</span>] <span class="fu">$</span> \i <span class="ot">-&gt;</span>
     write v i (<span class="dv">2</span><span class="fu">*</span>i)
  freeze v

<span class="co">-- vector computation in IO</span>
<span class="ot">vecIO ::</span> <span class="dt">IO</span> (<span class="dt">V.Vector</span> <span class="dt">Int</span>)
vecIO <span class="fu">=</span> example

<span class="co">-- vector computation in ST</span>
<span class="ot">vecST ::</span> <span class="dt">ST</span> s (<span class="dt">V.Vector</span> <span class="dt">Int</span>)
vecST <span class="fu">=</span> example


<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  vecIO <span class="fu">&gt;&gt;=</span> print
  print <span class="fu">$</span> runST vecST</code></pre></div>
<p>The vector library itself normally does bounds checks on index operations to protect against memory corruption. This can be enabled or disabled on the library level by compiling with <code>boundschecks</code> cabal flag.</p>
<h2 id="unordered-containers">Unordered-Containers</h2>
<table>
<thead>
<tr class="header">
<th align="left">Functionality</th>
<th align="left">Function</th>
<th align="left">Time Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Initialization</td>
<td align="left">empty</td>
<td align="left">O(1)</td>
</tr>
<tr class="even">
<td align="left">Size</td>
<td align="left">size</td>
<td align="left">O(1)</td>
</tr>
<tr class="odd">
<td align="left">Lookup</td>
<td align="left">lookup</td>
<td align="left">O(log(n))</td>
</tr>
<tr class="even">
<td align="left">Insertion</td>
<td align="left">insert</td>
<td align="left">O(log(n))</td>
</tr>
<tr class="odd">
<td align="left">Traversal</td>
<td align="left">traverse</td>
<td align="left">O(n)</td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fromList ::</span> (<span class="dt">Eq</span> k, <span class="dt">Hashable</span> k) <span class="ot">=&gt;</span> [(k, v)] <span class="ot">-&gt;</span> <span class="dt">HashMap</span> k v
lookup<span class="ot"> ::</span> (<span class="dt">Eq</span> k, <span class="dt">Hashable</span> k) <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">HashMap</span> k v <span class="ot">-&gt;</span> <span class="dt">Maybe</span> v
<span class="ot">insert ::</span> (<span class="dt">Eq</span> k, <span class="dt">Hashable</span> k) <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> <span class="dt">HashMap</span> k v <span class="ot">-&gt;</span> <span class="dt">HashMap</span> k v</code></pre></div>
<p>Both the <code>HashMap</code> and <code>HashSet</code> are purely functional data structures that are drop in replacements for the <code>containers</code> equivalents but with more efficient space and time performance. Additionally all stored elements must have a <code>Hashable</code> instance.</p>
<div class="sourceCode" include="src/20-data-structures/unordered.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.HashSet</span> <span class="kw">as</span> <span class="dt">S</span>
<span class="kw">import qualified</span> <span class="dt">Data.HashMap.Lazy</span> <span class="kw">as</span> <span class="dt">M</span>

<span class="ot">example1 ::</span> <span class="dt">M.HashMap</span> <span class="dt">Int</span> <span class="dt">Char</span>
example1 <span class="fu">=</span> M.fromList <span class="fu">$</span> zip [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] [<span class="ch">&#39;a&#39;</span><span class="fu">..</span>]

<span class="ot">example2 ::</span> <span class="dt">S.HashSet</span> <span class="dt">Int</span>
example2 <span class="fu">=</span> S.fromList [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</code></pre></div>
<p>See: <a href="http://blog.johantibell.com/2012/03/announcing-unordered-containers-02.html">Announcing Unordered Containers</a></p>
<h2 id="hashtables">Hashtables</h2>
<table>
<thead>
<tr class="header">
<th align="left">Functionality</th>
<th align="left">Function</th>
<th align="left">Time Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Initialization</td>
<td align="left">empty</td>
<td align="left">O(1)</td>
</tr>
<tr class="even">
<td align="left">Size</td>
<td align="left">size</td>
<td align="left">O(1)</td>
</tr>
<tr class="odd">
<td align="left">Lookup</td>
<td align="left">lookup</td>
<td align="left">O(1)</td>
</tr>
<tr class="even">
<td align="left">Insertion</td>
<td align="left">insert</td>
<td align="left">O(1) amortized</td>
</tr>
<tr class="odd">
<td align="left">Traversal</td>
<td align="left">traverse</td>
<td align="left">O(n)</td>
</tr>
</tbody>
</table>
<p>Hashtables provides hashtables with efficient lookup within the ST or IO monad.</p>
<div class="sourceCode" include="src/20-data-structures/hashtables.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup)

<span class="kw">import </span><span class="dt">Control.Monad.ST</span>
<span class="kw">import </span><span class="dt">Data.HashTable.ST.Basic</span>

<span class="co">-- Hashtable parameterized by ST &quot;thread&quot;</span>
<span class="kw">type</span> <span class="dt">HT</span> s <span class="fu">=</span> <span class="dt">HashTable</span> s <span class="dt">String</span> <span class="dt">String</span>

<span class="ot">set ::</span> <span class="dt">ST</span> s (<span class="dt">HT</span> s)
set <span class="fu">=</span> <span class="kw">do</span>
  ht <span class="ot">&lt;-</span> new
  insert ht <span class="st">&quot;key&quot;</span> <span class="st">&quot;value1&quot;</span>
  return ht

<span class="ot">get ::</span> <span class="dt">HT</span> s <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> <span class="dt">String</span>)
get ht <span class="fu">=</span> <span class="kw">do</span>
  val <span class="ot">&lt;-</span> lookup ht <span class="st">&quot;key&quot;</span>
  return val

<span class="ot">example ::</span> <span class="dt">Maybe</span> <span class="dt">String</span>
example <span class="fu">=</span> runST (set <span class="fu">&gt;&gt;=</span> get)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">new ::</span> <span class="dt">ST</span> s (<span class="dt">HashTable</span> s k v)
<span class="ot">insert ::</span> (<span class="dt">Eq</span> k, <span class="dt">Hashable</span> k) <span class="ot">=&gt;</span> <span class="dt">HashTable</span> s k v <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()
lookup<span class="ot"> ::</span> (<span class="dt">Eq</span> k, <span class="dt">Hashable</span> k) <span class="ot">=&gt;</span> <span class="dt">HashTable</span> s k v <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> v)</code></pre></div>
<h2 id="graphs">Graphs</h2>
<p>The Graph module in the containers library is a somewhat antiquated API for working with directed graphs. A little bit of data wrapping makes it a little more straightforward to use. The library is not necessarily well-suited for large graph-theoretic operations but is perfectly fine for example, to use in a typechecker which need to resolve strongly connected components of the module definition graph.</p>
<div class="sourceCode" include="src/20-data-structures/graph.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Tree</span>
<span class="kw">import </span><span class="dt">Data.Graph</span>

<span class="kw">data</span> <span class="dt">Grph</span> node key <span class="fu">=</span> <span class="dt">Grph</span>
  { _<span class="ot">graph ::</span> <span class="dt">Graph</span>
  , _<span class="ot">vertices ::</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> (node, key, [key])
  }

<span class="ot">fromList ::</span> <span class="dt">Ord</span> key <span class="ot">=&gt;</span> [(node, key, [key])] <span class="ot">-&gt;</span> <span class="dt">Grph</span> node key
fromList <span class="fu">=</span> uncurry <span class="dt">Grph</span> <span class="fu">.</span> graphFromEdges&#39;

<span class="ot">vertexLabels ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Grph</span> b t <span class="ot">-&gt;</span> (f <span class="dt">Vertex</span>) <span class="ot">-&gt;</span> f b
vertexLabels g <span class="fu">=</span> fmap (vertexLabel g)

<span class="ot">vertexLabel ::</span> <span class="dt">Grph</span> b t <span class="ot">-&gt;</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> b
vertexLabel g <span class="fu">=</span> (\(vi, _, _) <span class="ot">-&gt;</span> vi) <span class="fu">.</span> (_vertices g)

<span class="co">-- Topologically sort graph</span>
<span class="ot">topo&#39; ::</span> <span class="dt">Grph</span> node key <span class="ot">-&gt;</span> [node]
topo&#39; g <span class="fu">=</span> vertexLabels g <span class="fu">$</span> topSort (_graph g)

<span class="co">-- Strongly connected components of graph</span>
<span class="ot">scc&#39; ::</span> <span class="dt">Grph</span> node key <span class="ot">-&gt;</span> [[node]]
scc&#39; g <span class="fu">=</span> fmap (vertexLabels g <span class="fu">.</span> flatten) <span class="fu">$</span> scc (_graph g)</code></pre></div>
<p>So for example we can construct a simple graph:</p>
<div class="figure">
<img src="img/graph1.png" alt="" />

</div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ex1 ::</span> [(<span class="dt">String</span>, <span class="dt">String</span>, [<span class="dt">String</span>])]
ex1 <span class="fu">=</span> [
    (<span class="st">&quot;a&quot;</span>,<span class="st">&quot;a&quot;</span>,[<span class="st">&quot;b&quot;</span>]),
    (<span class="st">&quot;b&quot;</span>,<span class="st">&quot;b&quot;</span>,[<span class="st">&quot;c&quot;</span>]),
    (<span class="st">&quot;c&quot;</span>,<span class="st">&quot;c&quot;</span>,[<span class="st">&quot;a&quot;</span>])
  ]

<span class="ot">ts1 ::</span> [<span class="dt">String</span>]
ts1 <span class="fu">=</span> topo&#39; (fromList ex1)
<span class="co">-- [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span>

<span class="ot">sc1 ::</span> [[<span class="dt">String</span>]]
sc1 <span class="fu">=</span> scc&#39; (fromList ex1)
<span class="co">-- [[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]]</span></code></pre></div>
<p>Or with two strongly connected subgraphs:</p>
<div class="figure">
<img src="img/graph2.png" alt="" />

</div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ex2 ::</span> [(<span class="dt">String</span>, <span class="dt">String</span>, [<span class="dt">String</span>])]
ex2 <span class="fu">=</span> [
    (<span class="st">&quot;a&quot;</span>,<span class="st">&quot;a&quot;</span>,[<span class="st">&quot;b&quot;</span>]),
    (<span class="st">&quot;b&quot;</span>,<span class="st">&quot;b&quot;</span>,[<span class="st">&quot;c&quot;</span>]),
    (<span class="st">&quot;c&quot;</span>,<span class="st">&quot;c&quot;</span>,[<span class="st">&quot;a&quot;</span>]),

    (<span class="st">&quot;d&quot;</span>,<span class="st">&quot;d&quot;</span>,[<span class="st">&quot;e&quot;</span>]),
    (<span class="st">&quot;e&quot;</span>,<span class="st">&quot;e&quot;</span>,[<span class="st">&quot;f&quot;</span>, <span class="st">&quot;e&quot;</span>]),
    (<span class="st">&quot;f&quot;</span>,<span class="st">&quot;f&quot;</span>,[<span class="st">&quot;d&quot;</span>, <span class="st">&quot;e&quot;</span>])
  ]


<span class="ot">ts2 ::</span> [<span class="dt">String</span>]
ts2 <span class="fu">=</span> topo&#39; (fromList ex2)
<span class="co">-- [&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span>

<span class="ot">sc2 ::</span> [[<span class="dt">String</span>]]
sc2 <span class="fu">=</span> scc&#39; (fromList ex2)
<span class="co">-- [[&quot;d&quot;,&quot;e&quot;,&quot;f&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]]</span></code></pre></div>
<p>See: <a href="http://hackage.haskell.org/package/GraphSCC">GraphSCC</a></p>
<h2 id="graph-theory">Graph Theory</h2>
<p>The <code>fgl</code> library provides a more efficient graph structure and a wide variety of common graph-theoretic operations. For example calculating the dominance frontier of a graph shows up quite frequently in control flow analysis for compiler design.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Graph.Inductive</span> <span class="kw">as</span> <span class="dt">G</span>

<span class="ot">cyc3 ::</span> <span class="dt">G.Gr</span> <span class="dt">Char</span> <span class="dt">String</span>
cyc3 <span class="fu">=</span> G.buildGr
       [([(<span class="st">&quot;ca&quot;</span>,<span class="dv">3</span>)],<span class="dv">1</span>,<span class="ch">&#39;a&#39;</span>,[(<span class="st">&quot;ab&quot;</span>,<span class="dv">2</span>)]),
                ([],<span class="dv">2</span>,<span class="ch">&#39;b&#39;</span>,[(<span class="st">&quot;bc&quot;</span>,<span class="dv">3</span>)]),
                ([],<span class="dv">3</span>,<span class="ch">&#39;c&#39;</span>,[])]

<span class="co">-- Loop query</span>
<span class="ot">ex1 ::</span> <span class="dt">Bool</span>
ex1 <span class="fu">=</span> G.hasLoop x

<span class="co">-- Dominators</span>
<span class="ot">ex2 ::</span> [(<span class="dt">G.Node</span>, [<span class="dt">G.Node</span>])]
ex2 <span class="fu">=</span> G.dom x <span class="dv">0</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">x ::</span> <span class="dt">G.Gr</span> <span class="dt">Int</span> ()
x <span class="fu">=</span> G.insEdges edges gr
  <span class="kw">where</span>
  gr <span class="fu">=</span> G.insNodes nodes G.empty
  edges <span class="fu">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>,()), (<span class="dv">0</span>,<span class="dv">2</span>,()), (<span class="dv">2</span>,<span class="dv">1</span>,()), (<span class="dv">2</span>,<span class="dv">3</span>,())]
  nodes <span class="fu">=</span> zip [<span class="dv">0</span>,<span class="dv">1</span> <span class="fu">..</span>] [<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">1</span>]</code></pre></div>
<div class="figure">
<img src="img/graphviz.png" alt="" />

</div>
<h2 id="dlist">DList</h2>
<table>
<thead>
<tr class="header">
<th align="left">Functionality</th>
<th align="left">Function</th>
<th align="left">Time Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Initialization</td>
<td align="left">empty</td>
<td align="left">O(1)</td>
</tr>
<tr class="even">
<td align="left">Size</td>
<td align="left">size</td>
<td align="left">O(1)</td>
</tr>
<tr class="odd">
<td align="left">Lookup</td>
<td align="left">lookup</td>
<td align="left">O(log(n))</td>
</tr>
<tr class="even">
<td align="left">Insertion</td>
<td align="left">insert</td>
<td align="left">O(log(n))</td>
</tr>
<tr class="odd">
<td align="left">Traversal</td>
<td align="left">traverse</td>
<td align="left">O(n)</td>
</tr>
<tr class="even">
<td align="left">Append</td>
<td align="left">(|&gt;)</td>
<td align="left">O(1)</td>
</tr>
<tr class="odd">
<td align="left">Prepend</td>
<td align="left">(&lt;|)</td>
<td align="left">O(1)</td>
</tr>
</tbody>
</table>
<p>A dlist is a list-like structure that is optimized for O(1) append operations, internally it uses a Church encoding of the list structure. It is specifically suited for operations which are append-only and need only access it when manifesting the entire structure. It is particularly well-suited for use in the Writer monad.</p>
<div class="sourceCode" include="src/20-data-structures/dlist.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.DList</span>
<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Control.Monad.Writer</span>

<span class="ot">logger ::</span> <span class="dt">Writer</span> (<span class="dt">DList</span> <span class="dt">Int</span>) ()
logger <span class="fu">=</span> replicateM_ <span class="dv">100000</span> <span class="fu">$</span> tell (singleton <span class="dv">0</span>)</code></pre></div>
<h2 id="sequence">Sequence</h2>
<p>The sequence data structure behaves structurally similar to list but is optimized for append/prepend operations and traversal.</p>
<div class="sourceCode" include="src/20-data-structures/sequence.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Sequence</span>

<span class="ot">a ::</span> <span class="dt">Seq</span> <span class="dt">Int</span>
a <span class="fu">=</span> fromList [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]

<span class="ot">a0 ::</span> <span class="dt">Seq</span> <span class="dt">Int</span>
a0 <span class="fu">=</span> a <span class="fu">|&gt;</span> <span class="dv">4</span>
<span class="co">-- [1,2,3,4]</span>

<span class="ot">a1 ::</span> <span class="dt">Seq</span> <span class="dt">Int</span>
a1 <span class="fu">=</span> <span class="dv">0</span> <span class="fu">&lt;|</span> a
<span class="co">-- [0,1,2,3]</span></code></pre></div>
<hr />
<h1 id="ffi">FFI</h1>
<div class="alert alert-danger">
<p>This is an advanced section, knowledge of FFI is not typically necessary to write Haskell.</p>
</div>
<h2 id="pure-functions">Pure Functions</h2>
<p>Wrapping pure C functions with primitive types is trivial.</p>
<div class="sourceCode" include="src/21-ffi/simple.html"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/* $(CC) -c simple.c -o simple.o */</span>

<span class="dt">int</span> example(<span class="dt">int</span> a, <span class="dt">int</span> b)
{
  <span class="kw">return</span> a + b;
}</code></pre></div>
<div class="sourceCode" include="src/21-ffi/simple_ffi.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- ghc simple.o simple_ffi.hs -o simple_ffi</span>
<span class="ot">{-# LANGUAGE ForeignFunctionInterface #-}</span>

<span class="kw">import </span><span class="dt">Foreign.C.Types</span>

foreign <span class="kw">import </span>ccall safe &quot;example&quot; example
<span class="ot">    ::</span> <span class="dt">CInt</span> <span class="ot">-&gt;</span> <span class="dt">CInt</span> <span class="ot">-&gt;</span> <span class="dt">CInt</span>

main <span class="fu">=</span> print (example <span class="dv">42</span> <span class="dv">27</span>)</code></pre></div>
<h2 id="storable-arrays">Storable Arrays</h2>
<p>There exists a <code>Storable</code> typeclass that can be used to provide low-level access to the memory underlying Haskell values. <code>Ptr</code> objects in Haskell behave much like C pointers although arithmetic with them is in terms of bytes only, not the size of the type associated with the pointer ( this differs from C).</p>
<p>The Prelude defines Storable interfaces for most of the basic types as well as types in the <code>Foreign.C</code> library.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Storable</span> a <span class="kw">where</span>
<span class="ot">  sizeOf ::</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">  alignment ::</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">  peek ::</span> <span class="dt">Ptr</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
<span class="ot">  poke ::</span> <span class="dt">Ptr</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</code></pre></div>
<p>To pass arrays from Haskell to C we can again use Storable Vector and several unsafe operations to grab a foreign pointer to the underlying data that can be handed off to C. Once we're in C land, nothing will protect us from doing evil things to memory!</p>
<div class="sourceCode" include="src/21-ffi/qsort.html"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/* $(CC) -c qsort.c -o qsort.o */</span>
<span class="dt">void</span> swap(<span class="dt">int</span> *a, <span class="dt">int</span> *b)
{
    <span class="dt">int</span> t = *a;
    *a = *b;
    *b = t;
}

<span class="dt">void</span> sort(<span class="dt">int</span> *xs, <span class="dt">int</span> beg, <span class="dt">int</span> end)
{
    <span class="kw">if</span> (end &gt; beg + <span class="dv">1</span>) {
        <span class="dt">int</span> piv = xs[beg], l = beg + <span class="dv">1</span>, r = end;

        <span class="kw">while</span> (l &lt; r) {
            <span class="kw">if</span> (xs[l] &lt;= piv) {
                l++;
            } <span class="kw">else</span> {
                swap(&amp;xs[l], &amp;xs[--r]);
            }
        }

        swap(&amp;xs[--l], &amp;xs[beg]);
        sort(xs, beg, l);
        sort(xs, r, end);
    }
}</code></pre></div>
<div class="sourceCode" include="src/21-ffi/ffi.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- ghc qsort.o ffi.hs -o ffi</span>
<span class="ot">{-# LANGUAGE ForeignFunctionInterface #-}</span>

<span class="kw">import </span><span class="dt">Foreign.Ptr</span>
<span class="kw">import </span><span class="dt">Foreign.C.Types</span>

<span class="kw">import qualified</span> <span class="dt">Data.Vector.Storable</span> <span class="kw">as</span> <span class="dt">V</span>
<span class="kw">import qualified</span> <span class="dt">Data.Vector.Storable.Mutable</span> <span class="kw">as</span> <span class="dt">VM</span>

foreign <span class="kw">import </span>ccall safe &quot;sort&quot; qsort
<span class="ot">    ::</span> <span class="dt">Ptr</span> a <span class="ot">-&gt;</span> <span class="dt">CInt</span> <span class="ot">-&gt;</span> <span class="dt">CInt</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> vs <span class="fu">=</span> V.fromList ([<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">9</span>,<span class="dv">6</span>]<span class="ot"> ::</span> [<span class="dt">CInt</span>])
  v <span class="ot">&lt;-</span> V.thaw vs
  VM.unsafeWith v <span class="fu">$</span> \ptr <span class="ot">-&gt;</span> <span class="kw">do</span>
    qsort ptr <span class="dv">0</span> <span class="dv">9</span>
  out <span class="ot">&lt;-</span> V.freeze v
  print out</code></pre></div>
<p>The names of foreign functions from a C specific header file can be qualified.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class="kw">import </span>ccall unsafe &quot;stdlib.h malloc&quot;
<span class="ot">    malloc ::</span> <span class="dt">CSize</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Ptr</span> a)</code></pre></div>
<p>Prepending the function name with a <code>&amp;</code> allows us to create a reference to the function pointer itself.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class="kw">import </span>ccall unsafe &quot;stdlib.h &amp;malloc&quot;
<span class="ot">    malloc ::</span> <span class="dt">FunPtr</span> a</code></pre></div>
<h2 id="function-pointers">Function Pointers</h2>
<p>Using the above FFI functionality, it's trivial to pass C function pointers into Haskell, but what about the inverse passing a function pointer to a Haskell function into C using <code>foreign import ccall &quot;wrapper&quot;</code>.</p>
<div class="sourceCode" include="src/21-ffi/pointer.html"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">void</span> invoke(<span class="dt">void</span> (*fn)(<span class="dt">int</span>))
{
  <span class="dt">int</span> n = <span class="dv">42</span>;
  printf(<span class="st">&quot;Inside of C, now we&#39;ll call Haskell.</span><span class="ch">\n</span><span class="st">&quot;</span>);
  fn(n);
  printf(<span class="st">&quot;Back inside of C again.</span><span class="ch">\n</span><span class="st">&quot;</span>);
}</code></pre></div>
<div class="sourceCode" include="src/21-ffi/pointer_use.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ForeignFunctionInterface #-}</span>

<span class="kw">import </span><span class="dt">Foreign</span>
<span class="kw">import </span><span class="dt">System.IO</span>
<span class="kw">import </span><span class="dt">Foreign.C.Types</span>(<span class="dt">CInt</span>(..))

foreign <span class="kw">import </span>ccall &quot;wrapper&quot;
<span class="ot">  makeFunPtr ::</span> (<span class="dt">CInt</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">FunPtr</span> (<span class="dt">CInt</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()))

foreign <span class="kw">import </span>ccall &quot;pointer.c invoke&quot;
<span class="ot">  invoke ::</span> <span class="dt">FunPtr</span> (<span class="dt">CInt</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()

<span class="ot">fn ::</span> <span class="dt">CInt</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
fn n <span class="fu">=</span> <span class="kw">do</span>
  putStrLn <span class="st">&quot;Hello from Haskell, here&#39;s a number passed between runtimes:&quot;</span>
  print n
  hFlush stdout

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  fptr <span class="ot">&lt;-</span> makeFunPtr fn
  invoke fptr</code></pre></div>
<p>Will yield the following output:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">Inside</span> of C, now we<span class="st">&#39;ll call Haskell</span>
<span class="st">Hello from Haskell, here&#39;</span>s a number passed between runtimes:
<span class="kw">42</span>
<span class="kw">Back</span> inside of C again.</code></pre></div>
<!--

Calling Haskell from C
----------------------

```cpp
#include <stdio.h>
#include "HsFFI.h"
#include "foo_stub.h"

extern void __stginit_Foo ( void );

int main(int argc, char *argv[])
{
  hs_init(&argc, &argv);
  hs_add_root(__stginit_Foo);

  hs_exit();
  return 0;
}
```


```haskell
{-# LANGUAGE CPP #-}
{-# LANGUAGE ForeignFunctionInterface #-}

module Example where

foreign export ccall example :: IO ()

example :: IO ()
example = do
  print "Hello from Haskell"
  return ()
```

```bash
$ hsc2hs Example.hsc
```

```cpp
#include "HsFFI.h"
#include "Example_stub.h"

int main( int argc, char *argv[] )
{
  // init GHC runtime
  hs_init (&argc, &argv);

  // call Haskell function
  example();
}
```

-->
<h1 id="concurrency">Concurrency</h1>
<p>The definitive reference on concurrency and parallelism in Haskell is Simon Marlow's text. This will section will just gloss over these topics because they are far better explained in this book.</p>
<p>See: <a href="http://chimera.labs.oreilly.com/books/1230000000929">Parallel and Concurrent Programming in Haskell</a></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">forkIO ::</span> <span class="dt">IO</span> () <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ThreadId</span></code></pre></div>
<p>Haskell threads are extremely cheap to spawn, using only 1.5KB of RAM depending on the platform and are much cheaper than a pthread in C. Calling forkIO 10<sup>6</sup> times completes just short of a 1s. Additionally, functional purity in Haskell also guarantees that a thread can almost always be terminated even in the middle of a computation without concern.</p>
<p>See: <a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Scheduler#TheScheduler">The Scheduler</a></p>
<h2 id="sparks">Sparks</h2>
<p>The most basic &quot;atom&quot; of parallelism in Haskell is a spark. It is a hint to the GHC runtime that a computation can be evaluated to weak head normal form in parallel.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rpar ::</span> a <span class="ot">-&gt;</span> <span class="dt">Eval</span> a
<span class="ot">rseq ::</span> <span class="dt">Strategy</span> a
<span class="ot">rdeepseq ::</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> <span class="dt">Strategy</span> a

<span class="ot">runEval ::</span> <span class="dt">Eval</span> a <span class="ot">-&gt;</span> a</code></pre></div>
<p><code>rpar a</code> spins off a separate spark that evolutes a to weak head normal form and places the computation in the spark pool. When the runtime determines that there is an available CPU to evaluate the computation it will evaluate ( <em>convert</em> ) the spark. If the main thread of the program is the evaluator for the spark, the spark is said to have <em>fizzled</em>. Fizzling is generally bad and indicates that the logic or parallelism strategy is not well suited to the work that is being evaluated.</p>
<p>The spark pool is also limited ( but user-adjustable ) to a default of 8000 (as of GHC 7.8.3 ). Sparks that are created beyond that limit are said to <em>overflow</em>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Evaluates the arguments to f in parallel before application.</span>
par2 f x y <span class="fu">=</span> x <span class="ot">`rpar`</span> y <span class="ot">`rpar`</span> f x y</code></pre></div>
<p>An argument to <code>rseq</code> forces the evaluation of a spark before evaluation continues.</p>
<table>
<thead>
<tr class="header">
<th align="left">Action</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>Fizzled</code></td>
<td align="left">The resulting value has already been evaluated by the main thread so the spark need not be converted.</td>
</tr>
<tr class="even">
<td align="left"><code>Dud</code></td>
<td align="left">The expression has already been evaluated, the computed value is returned and the spark is not converted.</td>
</tr>
<tr class="odd">
<td align="left"><code>GC'd</code></td>
<td align="left">The spark is added to the spark pool but the result is not referenced, so it is garbage collected.</td>
</tr>
<tr class="even">
<td align="left"><code>Overflowed</code></td>
<td align="left">Insufficient space in the spark pool when spawning.</td>
</tr>
</tbody>
</table>
<p>The parallel runtime is necessary to use sparks, and the resulting program must be compiled with <code>-threaded</code>. Additionally the program itself can be specified to take runtime options with <code>-rtsopts</code> such as the number of cores to use.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghc <span class="fu">-</span>threaded <span class="fu">-</span>rtsopts program<span class="fu">.</span>hs
<span class="fu">./</span>program <span class="fu">+</span><span class="dt">RTS</span> <span class="fu">-</span>s <span class="dt">N8</span> <span class="co">-- use 8 cores</span></code></pre></div>
<p>The runtime can be asked to dump information about the spark evaluation by passing the <code>-s</code> flag.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">$</span> <span class="fu">./</span>spark <span class="fu">+</span><span class="dt">RTS</span> <span class="fu">-</span><span class="dt">N4</span> <span class="fu">-</span>s

                                    <span class="dt">Tot</span> time (elapsed)  <span class="dt">Avg</span> pause  <span class="dt">Max</span> pause
  <span class="dt">Gen</span>  <span class="dv">0</span>         <span class="dv">5</span> colls,     <span class="dv">5</span> par    <span class="fl">0.02</span>s    <span class="fl">0.01</span>s     <span class="fl">0.0017</span>s    <span class="fl">0.0048</span>s
  <span class="dt">Gen</span>  <span class="dv">1</span>         <span class="dv">3</span> colls,     <span class="dv">2</span> par    <span class="fl">0.00</span>s    <span class="fl">0.00</span>s     <span class="fl">0.0004</span>s    <span class="fl">0.0007</span>s

  <span class="dt">Parallel</span> <span class="dt">GC</span> work balance<span class="fu">:</span> <span class="fl">1.83</span><span class="fu">%</span> (serial <span class="dv">0</span><span class="fu">%</span>, perfect <span class="dv">100</span><span class="fu">%</span>)

  <span class="dt">TASKS</span><span class="fu">:</span> <span class="dv">6</span> (<span class="dv">1</span> bound, <span class="dv">5</span> peak workers (<span class="dv">5</span> total), using <span class="fu">-</span><span class="dt">N4</span>)

  <span class="dt">SPARKS</span><span class="fu">:</span> <span class="dv">20000</span> (<span class="dv">20000</span> converted, <span class="dv">0</span> overflowed, <span class="dv">0</span> dud, <span class="dv">0</span> <span class="dt">GC&#39;d</span>, <span class="dv">0</span> fizzled)</code></pre></div>
<p>The parallel computations themselves are sequenced in the <code>Eval</code> monad, whose evaluation with <code>runEval</code> is itself a pure computation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">example ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (b, b)
example f x y <span class="fu">=</span> runEval <span class="fu">$</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> rpar <span class="fu">$</span> f x
  b <span class="ot">&lt;-</span> rpar <span class="fu">$</span> f y
  rseq a
  rseq b
  return (a, b)</code></pre></div>
<h2 id="threadscope">Threadscope</h2>
<p>Passing the flag <code>-l</code> generates the eventlog which can be rendered with the threadscope library.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">$</span> ghc <span class="fu">-</span><span class="dt">O2</span> <span class="fu">-</span>threaded <span class="fu">-</span>rtsopts <span class="fu">-</span>eventlog Example.hs
<span class="fu">$</span> <span class="fu">./</span>program <span class="fu">+</span><span class="dt">RTS</span> <span class="fu">-</span><span class="dt">N4</span> <span class="fu">-</span>l
<span class="fu">$</span> threadscope Example.eventlog</code></pre></div>
<div class="figure">
<img src="img/threadscope.png" alt="" />

</div>
<p>See Simon Marlows's <em>Parallel and Concurrent Programming in Haskell</em> for a detailed guide on interpreting and profiling using Threadscope.</p>
<p>See:</p>
<ul>
<li><a href="http://www.well-typed.com/blog/86/">Performance profiling with ghc-events-analyze</a></li>
</ul>
<h2 id="strategies">Strategies</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Strategy</span> a <span class="fu">=</span> a <span class="ot">-&gt;</span> <span class="dt">Eval</span> a
<span class="ot">using ::</span> a <span class="ot">-&gt;</span> <span class="dt">Strategy</span> a <span class="ot">-&gt;</span> a</code></pre></div>
<p>Sparks themselves form the foundation for higher level parallelism constructs known as <code>strategies</code> which adapt spark creation to fit the computation or data structure being evaluated. For instance if we wanted to evaluate both elements of a tuple in parallel we can create a strategy which uses sparks to evaluate both sides of the tuple.</p>
<div class="sourceCode" include="src/22-concurrency/strategies.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Parallel.Strategies</span>

<span class="ot">parPair&#39; ::</span> <span class="dt">Strategy</span> (a, b)
parPair&#39; (a, b) <span class="fu">=</span> <span class="kw">do</span>
  a&#39; <span class="ot">&lt;-</span> rpar a
  b&#39; <span class="ot">&lt;-</span> rpar b
  return (a&#39;, b&#39;)

<span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
fib <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
fib <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span>
fib n <span class="fu">=</span> fib (n<span class="fu">-</span><span class="dv">1</span>) <span class="fu">+</span> fib (n<span class="fu">-</span><span class="dv">2</span>)

<span class="ot">serial ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
serial   <span class="fu">=</span> (fib <span class="dv">30</span>, fib <span class="dv">31</span>)

<span class="ot">parallel ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
parallel <span class="fu">=</span> runEval <span class="fu">.</span> parPair&#39; <span class="fu">$</span> (fib <span class="dv">30</span>, fib <span class="dv">31</span>)</code></pre></div>
<p>This pattern occurs so frequently the combinator <code>using</code> can be used to write it equivalently in operator-like form that may be more visually appealing to some.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">using ::</span> a <span class="ot">-&gt;</span> <span class="dt">Strategy</span> a <span class="ot">-&gt;</span> a
x <span class="ot">`using`</span> s <span class="fu">=</span> runEval (s x)

parallel <span class="ot">::</span><span class="fu">:</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
parallel <span class="fu">=</span> (fib <span class="dv">30</span>, fib <span class="dv">31</span>) <span class="ot">`using`</span> parPair</code></pre></div>
<p>For a less contrived example consider a parallel <code>parmap</code> which maps a pure function over a list of a values in parallel.</p>
<div class="sourceCode" include="src/22-concurrency/spark.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Parallel.Strategies</span>

<span class="ot">parMap&#39; ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Eval</span> [b]
parMap&#39; f [] <span class="fu">=</span> return []
parMap&#39; f (a<span class="fu">:</span>as) <span class="fu">=</span> <span class="kw">do</span>
  b  <span class="ot">&lt;-</span> rpar (f a)
  bs <span class="ot">&lt;-</span> parMap&#39; f as
  return (b<span class="fu">:</span>bs)

<span class="ot">result ::</span> [<span class="dt">Int</span>]
result <span class="fu">=</span> runEval <span class="fu">$</span> parMap&#39; (<span class="fu">+</span><span class="dv">1</span>) [<span class="dv">1</span><span class="fu">..</span><span class="dv">1000</span>]</code></pre></div>
<p>The functions above are quite useful, but will break down if evaluation of the arguments needs to be parallelized beyond simply weak head normal form. For instance if the arguments to <code>rpar</code> is a nested constructor we'd like to parallelize the entire section of work in evaluated the expression to normal form instead of just the outer layer. As such we'd like to generalize our strategies so the the evaluation strategy for the arguments can be passed as an argument to the strategy.</p>
<p><code>Control.Parallel.Strategies</code> contains a generalized version of <code>rpar</code> which embeds additional evaluation logic inside the <code>rpar</code> computation in Eval monad.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rparWith ::</span> <span class="dt">Strategy</span> a <span class="ot">-&gt;</span> <span class="dt">Strategy</span> a</code></pre></div>
<p>Using the deepseq library we can now construct a Strategy variant of rseq that evaluates to full normal form.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rdeepseq ::</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> <span class="dt">Strategy</span> a
rdeepseq x <span class="fu">=</span> rseq (force x)</code></pre></div>
<p>We now can create a &quot;higher order&quot; strategy that takes two strategies and itself yields a a computation which when evaluated uses the passed strategies in its scheduling.</p>
<div class="sourceCode" include="src/22-concurrency/strategies_param.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.DeepSeq</span>
<span class="kw">import </span><span class="dt">Control.Parallel.Strategies</span>

<span class="ot">evalPair ::</span> <span class="dt">Strategy</span> a <span class="ot">-&gt;</span> <span class="dt">Strategy</span> b <span class="ot">-&gt;</span> <span class="dt">Strategy</span> (a, b)
evalPair sa sb (a, b) <span class="fu">=</span> <span class="kw">do</span>
  a&#39; <span class="ot">&lt;-</span> sa a
  b&#39; <span class="ot">&lt;-</span> sb b
  return (a&#39;, b&#39;)

<span class="ot">parPair ::</span> <span class="dt">Strategy</span> a <span class="ot">-&gt;</span> <span class="dt">Strategy</span> b <span class="ot">-&gt;</span> <span class="dt">Strategy</span> (a, b)
parPair sa sb <span class="fu">=</span> evalPair (rparWith sa) (rparWith sb)

<span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
fib <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
fib <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span>
fib n <span class="fu">=</span> fib (n<span class="fu">-</span><span class="dv">1</span>) <span class="fu">+</span> fib (n<span class="fu">-</span><span class="dv">2</span>)

<span class="ot">serial ::</span> ([<span class="dt">Int</span>], [<span class="dt">Int</span>])
serial <span class="fu">=</span> (a, b)
  <span class="kw">where</span>
    a <span class="fu">=</span> fmap fib [<span class="dv">0</span><span class="fu">..</span><span class="dv">30</span>]
    b <span class="fu">=</span> fmap fib [<span class="dv">1</span><span class="fu">..</span><span class="dv">30</span>]

<span class="ot">parallel ::</span> ([<span class="dt">Int</span>], [<span class="dt">Int</span>])
parallel <span class="fu">=</span> (a, b) <span class="ot">`using`</span> evalPair rdeepseq rdeepseq
  <span class="kw">where</span>
    a <span class="fu">=</span> fmap fib [<span class="dv">0</span><span class="fu">..</span><span class="dv">30</span>]
    b <span class="fu">=</span> fmap fib [<span class="dv">1</span><span class="fu">..</span><span class="dv">30</span>]</code></pre></div>
<p>These patterns are implemented in the Strategies library along with several other general forms and combinators for combining strategies to fit many different parallel computations.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parTraverse ::</span> <span class="dt">Traversable</span> t <span class="ot">=&gt;</span> <span class="dt">Strategy</span> a <span class="ot">-&gt;</span> <span class="dt">Strategy</span> (t a)
<span class="ot">dot ::</span> <span class="dt">Strategy</span> a <span class="ot">-&gt;</span> <span class="dt">Strategy</span> a <span class="ot">-&gt;</span> <span class="dt">Strategy</span> a
<span class="ot">($||) ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Strategy</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b
<span class="ot">(.||) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Strategy</span> b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</code></pre></div>
<p>See:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/parallel-3.2.0.4/docs/Control-Parallel-Strategies.html">Control.Concurent.Strategies</a></li>
</ul>
<h2 id="stm">STM</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">atomically ::</span> <span class="dt">STM</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
<span class="ot">orElse ::</span> <span class="dt">STM</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> a
<span class="ot">retry ::</span> <span class="dt">STM</span> a

<span class="ot">newTVar ::</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> (<span class="dt">TVar</span> a)
<span class="ot">newTVarIO ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">TVar</span> a)
<span class="ot">writeTVar ::</span> <span class="dt">TVar</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> ()
<span class="ot">readTVar ::</span> <span class="dt">TVar</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> a

<span class="ot">modifyTVar ::</span> <span class="dt">TVar</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">STM</span> ()
<span class="ot">modifyTVar&#39; ::</span> <span class="dt">TVar</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">STM</span> ()</code></pre></div>
<p>Software Transactional Memory is a technique for guaranteeing atomicity of values in parallel computations, such that all contexts view the same data when read and writes are guaranteed never to result in inconsistent states.</p>
<p>The strength of Haskell's purity guarantees that transactions within STM are pure and can always be rolled back if a commit fails.</p>
<div class="sourceCode" include="src/22-concurrency/stm.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Control.Concurrent</span>
<span class="kw">import </span><span class="dt">Control.Concurrent.STM</span>

<span class="kw">type</span> <span class="dt">Account</span> <span class="fu">=</span> <span class="dt">TVar</span> <span class="dt">Double</span>

<span class="ot">transfer ::</span> <span class="dt">Account</span> <span class="ot">-&gt;</span> <span class="dt">Account</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">STM</span> ()
transfer from to amount <span class="fu">=</span> <span class="kw">do</span>
  available <span class="ot">&lt;-</span> readTVar from
  when (amount <span class="fu">&gt;</span> available) retry

  modifyTVar from (<span class="fu">+</span> (<span class="fu">-</span>amount))
  modifyTVar to   (<span class="fu">+</span> amount)

<span class="co">-- Threads are scheduled non-deterministically.</span>
<span class="ot">actions ::</span> <span class="dt">Account</span> <span class="ot">-&gt;</span> <span class="dt">Account</span> <span class="ot">-&gt;</span> [<span class="dt">IO</span> <span class="dt">ThreadId</span>]
actions a b <span class="fu">=</span> map forkIO [
     <span class="co">-- transfer to</span>
       atomically (transfer a b <span class="dv">10</span>)
     , atomically (transfer a b (<span class="fu">-</span><span class="dv">20</span>))
     , atomically (transfer a b <span class="dv">30</span>)

     <span class="co">-- transfer back</span>
     , atomically (transfer a b (<span class="fu">-</span><span class="dv">30</span>))
     , atomically (transfer a b <span class="dv">20</span>)
     , atomically (transfer a b (<span class="fu">-</span><span class="dv">10</span>))
   ]

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  accountA <span class="ot">&lt;-</span> atomically <span class="fu">$</span> newTVar <span class="dv">60</span>
  accountB <span class="ot">&lt;-</span> atomically <span class="fu">$</span> newTVar <span class="dv">0</span>

  sequence_ (actions accountA accountB)

  balanceA <span class="ot">&lt;-</span> atomically <span class="fu">$</span> readTVar accountA
  balanceB <span class="ot">&lt;-</span> atomically <span class="fu">$</span> readTVar accountB

  print <span class="fu">$</span> balanceA <span class="fu">==</span> <span class="dv">60</span>
  print <span class="fu">$</span> balanceB <span class="fu">==</span> <span class="dv">0</span></code></pre></div>
<p>See: <a href="https://www.fpcomplete.com/school/advanced-haskell/beautiful-concurrency">Beautiful Concurrency</a></p>
<h2 id="monad-par">Monad Par</h2>
<p>Using the Par monad we express our computation as a data flow graph which is scheduled in order of the connections between forked computations which exchange resulting computations with <code>IVar</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">new ::</span> <span class="dt">Par</span> (<span class="dt">IVar</span> a)
<span class="ot">put ::</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> <span class="dt">IVar</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Par</span> ()
<span class="ot">get ::</span> <span class="dt">IVar</span> a <span class="ot">-&gt;</span> <span class="dt">Par</span> a
<span class="ot">fork ::</span> <span class="dt">Par</span> () <span class="ot">-&gt;</span> <span class="dt">Par</span> ()
<span class="ot">spawn ::</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> <span class="dt">Par</span> a <span class="ot">-&gt;</span> <span class="dt">Par</span> (<span class="dt">IVar</span> a)</code></pre></div>
<div class="figure">
<img src="img/par.png" alt="" />

</div>
<div class="sourceCode" include="src/22-concurrency/par.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Control.Monad.Par</span>

f,<span class="ot"> g ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
f x <span class="fu">=</span> x <span class="fu">+</span> <span class="dv">10</span>
g x <span class="fu">=</span> x <span class="fu">*</span> <span class="dv">10</span>

<span class="co">--   f x      g x</span>
<span class="co">--     \     /</span>
<span class="co">--      a + b</span>
<span class="co">--      /   \</span>
<span class="co">-- f (a+b)  g (a+b)</span>
<span class="co">--      \   /</span>
<span class="co">--      (d,e)</span>

<span class="ot">example1 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
example1 x <span class="fu">=</span> runPar <span class="fu">$</span> <span class="kw">do</span>
  [a,b,c,d,e] <span class="ot">&lt;-</span> replicateM <span class="dv">5</span> new
  fork (put a (f x))
  fork (put b (g x))
  a&#39; <span class="ot">&lt;-</span> get a
  b&#39; <span class="ot">&lt;-</span> get b
  fork (put c (a&#39; <span class="fu">+</span> b&#39;))
  c&#39; <span class="ot">&lt;-</span> get c
  fork (put d (f c&#39;))
  fork (put e (g c&#39;))
  d&#39; <span class="ot">&lt;-</span> get d
  e&#39; <span class="ot">&lt;-</span> get e
  return (d&#39;, e&#39;)

<span class="ot">example2 ::</span> [<span class="dt">Int</span>]
example2 <span class="fu">=</span> runPar <span class="fu">$</span> <span class="kw">do</span>
  xs <span class="ot">&lt;-</span> parMap (<span class="fu">+</span><span class="dv">1</span>) [<span class="dv">1</span><span class="fu">..</span><span class="dv">25</span>]
  return xs

<span class="co">-- foldr (+) 0 (map (^2) [1..xs])</span>
<span class="ot">example3 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
example3 n <span class="fu">=</span> runPar <span class="fu">$</span> <span class="kw">do</span>
  <span class="kw">let</span> range <span class="fu">=</span> (<span class="dt">InclusiveRange</span> <span class="dv">1</span> n)
  <span class="kw">let</span> mapper x <span class="fu">=</span> return (x<span class="fu">^</span><span class="dv">2</span>)
  <span class="kw">let</span> reducer x y <span class="fu">=</span> return (x<span class="fu">+</span>y)
  parMapReduceRangeThresh <span class="dv">10</span> range mapper reducer <span class="dv">0</span></code></pre></div>
<h2 id="async">async</h2>
<p>Async is a higher level set of functions that work on top of Control.Concurrent and STM.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">async ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Async</span> a)
<span class="ot">wait ::</span> <span class="dt">Async</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
<span class="ot">cancel ::</span> <span class="dt">Async</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">concurrently ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> (a, b)
<span class="ot">race ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> a b)</code></pre></div>
<div class="sourceCode" include="src/22-concurrency/async.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Control.Applicative</span>
<span class="kw">import </span><span class="dt">Control.Concurrent</span>
<span class="kw">import </span><span class="dt">Control.Concurrent.Async</span>
<span class="kw">import </span><span class="dt">Data.Time</span>

<span class="ot">timeit ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (a,<span class="dt">Double</span>)
timeit io <span class="fu">=</span> <span class="kw">do</span>
  t0 <span class="ot">&lt;-</span> getCurrentTime
  a <span class="ot">&lt;-</span> io
  t1 <span class="ot">&lt;-</span> getCurrentTime
  return (a, realToFrac (t1 <span class="ot">`diffUTCTime`</span> t0))

<span class="ot">worker ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int</span>
worker n <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- simulate some work</span>
  threadDelay (<span class="dv">10</span><span class="fu">^</span><span class="dv">2</span> <span class="fu">*</span> n)
  return (n <span class="fu">*</span> n)

<span class="co">-- Spawn 2 threads in parallel, halt on both finished.</span>
<span class="ot">test1 ::</span> <span class="dt">IO</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
test1 <span class="fu">=</span> <span class="kw">do</span>
  val1 <span class="ot">&lt;-</span> async <span class="fu">$</span> worker <span class="dv">1000</span>
  val2 <span class="ot">&lt;-</span> async <span class="fu">$</span> worker <span class="dv">2000</span>
  (,) <span class="fu">&lt;$&gt;</span> wait val1 <span class="fu">&lt;*&gt;</span> wait val2

<span class="co">-- Spawn 2 threads in parallel, halt on first finished.</span>
<span class="ot">test2 ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">Int</span> <span class="dt">Int</span>)
test2 <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> val1 <span class="fu">=</span> worker <span class="dv">1000</span>
  <span class="kw">let</span> val2 <span class="fu">=</span> worker <span class="dv">2000</span>
  race val1 val2

<span class="co">-- Spawn 10000 threads in parallel, halt on all finished.</span>
<span class="ot">test3 ::</span> <span class="dt">IO</span> [<span class="dt">Int</span>]
test3 <span class="fu">=</span> mapConcurrently worker [<span class="dv">0</span><span class="fu">..</span><span class="dv">10000</span>]

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  print <span class="fu">=&lt;&lt;</span> timeit test1
  print <span class="fu">=&lt;&lt;</span> timeit test2
  print <span class="fu">=&lt;&lt;</span> timeit test3</code></pre></div>
<hr />
<h1 id="graphics">Graphics</h1>
<h2 id="diagrams">Diagrams</h2>
<p>Diagrams is a a parser combinator library for generating vector images to SVG and a variety of other formats.</p>
<div class="sourceCode" include="src/23-graphics/diagrams.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Diagrams.Prelude</span>
<span class="kw">import </span><span class="dt">Diagrams.Backend.SVG.CmdLine</span>

<span class="ot">sierpinski ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Diagram</span> <span class="dt">SVG</span>
sierpinski <span class="dv">1</span> <span class="fu">=</span> eqTriangle <span class="dv">1</span>
sierpinski n <span class="fu">=</span>
      s
     <span class="fu">===</span>
  (s <span class="fu">|||</span> s) <span class="fu">#</span> centerX
  <span class="kw">where</span>
    s <span class="fu">=</span> sierpinski (n <span class="fu">-</span> <span class="dv">1</span>)

<span class="ot">example ::</span> <span class="dt">Diagram</span> <span class="dt">SVG</span>
example <span class="fu">=</span> sierpinski <span class="dv">5</span> <span class="fu">#</span> fc black

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> defaultMain example</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">runhaskell</span> diagram1.hs -w 256 -h 256 -o diagram1.svg</code></pre></div>
<div class="figure">
<img src="img/diagram1.png" alt="" />

</div>
<p>See: <a href="http://projects.haskell.org/diagrams/doc/quickstart.html">Diagrams Quick Start Tutorial</a></p>
<hr />
<h1 id="parsing">Parsing</h1>
<h2 id="parsec">Parsec</h2>
<p>For parsing in Haskell it is quite common to use a family of libraries known as <em>Parser Combinators</em> which let us write code to generate parsers which themselves looks very similar to the parser grammar itself!</p>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">Combinators</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>&lt;|&gt;</code></td>
<td align="left">The choice operator tries to parse the first argument before proceeding to the second. Can be chained sequentially to generate a sequence of options.</td>
</tr>
<tr class="even">
<td align="left"><code>many</code></td>
<td align="left">Consumes an arbitrary number of patterns matching the given pattern and returns them as a list.</td>
</tr>
<tr class="odd">
<td align="left"><code>many1</code></td>
<td align="left">Like many but requires at least one match.</td>
</tr>
<tr class="even">
<td align="left"><code>optional</code></td>
<td align="left">Optionally parses a given pattern returning its value as a Maybe.</td>
</tr>
<tr class="odd">
<td align="left"><code>try</code></td>
<td align="left">Backtracking operator will let us parse ambiguous matching expressions and restart with a different pattern.</td>
</tr>
</tbody>
</table>
<p>There are two styles of writing Parsec, one can choose to write with monads or with applicatives.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseM ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
parseM <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> identifier
  char <span class="ch">&#39;+&#39;</span>
  b <span class="ot">&lt;-</span> identifier
  return <span class="fu">$</span> <span class="dt">Add</span> a b</code></pre></div>
<p>The same code written with applicatives uses the applicative combinators:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Sequential application.</span>
<span class="ot">(&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b

<span class="co">-- | Sequence actions, discarding the value of the first argument.</span>
<span class="ot">(*&gt;) ::</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f b
(<span class="fu">*&gt;</span>) <span class="fu">=</span> liftA2 (const id)

<span class="co">-- | Sequence actions, discarding the value of the second argument.</span>
<span class="ot">(&lt;*) ::</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f a
(<span class="fu">&lt;*</span>) <span class="fu">=</span> liftA2 const</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseA ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
parseA <span class="fu">=</span> <span class="dt">Add</span> <span class="fu">&lt;$&gt;</span> identifier <span class="fu">&lt;*</span> char <span class="ch">&#39;+&#39;</span> <span class="fu">&lt;*&gt;</span> identifier</code></pre></div>
<p>Now for instance if we want to parse simple lambda expressions we can encode the parser logic as compositions of these combinators which yield the string parser when evaluated under with the <code>parse</code>.</p>
<div class="sourceCode" include="src/24-parsing/simple_parser.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Text.Parsec</span>
<span class="kw">import </span><span class="dt">Text.Parsec.String</span>

<span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="dt">Var</span> <span class="dt">Char</span>
  <span class="fu">|</span> <span class="dt">Lam</span> <span class="dt">Char</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="ot">lam ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
lam <span class="fu">=</span> <span class="kw">do</span>
  char <span class="ch">&#39;\\&#39;</span>
  n <span class="ot">&lt;-</span> letter
  string <span class="st">&quot;-&gt;&quot;</span>
  e <span class="ot">&lt;-</span> expr
  return <span class="fu">$</span> <span class="dt">Lam</span> n e

<span class="ot">app ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
app <span class="fu">=</span> <span class="kw">do</span>
  apps <span class="ot">&lt;-</span> many1 term
  return <span class="fu">$</span> foldl1 <span class="dt">App</span> apps

<span class="ot">var ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
var <span class="fu">=</span> <span class="kw">do</span>
  n <span class="ot">&lt;-</span> letter
  return <span class="fu">$</span> <span class="dt">Var</span> n

<span class="ot">parens ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
parens p <span class="fu">=</span> <span class="kw">do</span>
  char <span class="ch">&#39;(&#39;</span>
  e <span class="ot">&lt;-</span> p
  char <span class="ch">&#39;)&#39;</span>
  return e

<span class="ot">term ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
term <span class="fu">=</span> var <span class="fu">&lt;|&gt;</span> parens expr

<span class="ot">expr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
expr <span class="fu">=</span> lam <span class="fu">&lt;|&gt;</span> app

<span class="ot">decl ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
decl <span class="fu">=</span> <span class="kw">do</span>
  e <span class="ot">&lt;-</span> expr
  eof
  return e

<span class="ot">test ::</span> <span class="dt">IO</span> ()
test <span class="fu">=</span> parseTest decl <span class="st">&quot;\\y-&gt;y(\\x-&gt;x)y&quot;</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> test <span class="fu">&gt;&gt;=</span> print</code></pre></div>
<h2 id="custom-lexer">Custom Lexer</h2>
<p>In our previous example lexing pass was not necessary because each lexeme mapped to a sequential collection of characters in the stream type. If we wanted to extend this parser with a non-trivial set of tokens, then Parsec provides us with a set of functions for defining lexers and integrating these with the parser combinators. The simplest example builds on top of the builtin Parsec language definitions which define a set of most common lexical schemes.</p>
<p>For instance we'll build on top of the empty language grammar on top of the haskellDef grammer that uses the Text token instead of string.</p>
<div class="sourceCode" include="src/24-parsing/lexer_text.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Text.Parsec</span>
<span class="kw">import </span><span class="dt">Text.Parsec.Text</span>
<span class="kw">import qualified</span> <span class="dt">Text.Parsec.Token</span> <span class="kw">as</span> <span class="dt">Tok</span>
<span class="kw">import qualified</span> <span class="dt">Text.Parsec.Language</span> <span class="kw">as</span> <span class="dt">Lang</span>

<span class="kw">import </span><span class="dt">Data.Functor.Identity</span> (<span class="dt">Identity</span>)
<span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text.IO</span> <span class="kw">as</span> <span class="dt">TIO</span>

<span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="dt">Var</span> <span class="dt">T.Text</span>
  <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Lam</span> <span class="dt">T.Text</span> <span class="dt">Expr</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="ot">lexer ::</span> <span class="dt">Tok.GenTokenParser</span> <span class="dt">T.Text</span> () <span class="dt">Identity</span>
lexer <span class="fu">=</span> Tok.makeTokenParser style

<span class="ot">style ::</span> <span class="dt">Tok.GenLanguageDef</span> <span class="dt">T.Text</span> () <span class="dt">Identity</span>
style <span class="fu">=</span> Lang.emptyDef
  { Tok.commentStart    <span class="fu">=</span> <span class="st">&quot;{-&quot;</span>
  , Tok.commentEnd      <span class="fu">=</span> <span class="st">&quot;-}&quot;</span>
  , Tok.commentLine     <span class="fu">=</span> <span class="st">&quot;--&quot;</span>
  , Tok.nestedComments  <span class="fu">=</span> <span class="dt">True</span>
  , Tok.identStart      <span class="fu">=</span> letter
  , Tok.identLetter     <span class="fu">=</span> alphaNum <span class="fu">&lt;|&gt;</span> oneOf <span class="st">&quot;_&#39;&quot;</span>
  , Tok.opStart         <span class="fu">=</span> Tok.opLetter style
  , Tok.opLetter        <span class="fu">=</span> oneOf <span class="st">&quot;:!#$%&amp;*+./&lt;=&gt;?@\\^|-~&quot;</span>
  , Tok.reservedOpNames <span class="fu">=</span> []
  , Tok.reservedNames   <span class="fu">=</span> []
  , Tok.caseSensitive   <span class="fu">=</span> <span class="dt">True</span>
  }

<span class="ot">parens ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
parens <span class="fu">=</span> Tok.parens lexer

<span class="ot">reservedOp ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> ()
reservedOp op <span class="fu">=</span> Tok.reservedOp lexer (T.unpack op)

<span class="ot">ident ::</span> <span class="dt">Parser</span> <span class="dt">T.Text</span>
ident <span class="fu">=</span> T.pack <span class="fu">&lt;$&gt;</span> Tok.identifier lexer

<span class="ot">contents ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
contents p <span class="fu">=</span> <span class="kw">do</span>
  Tok.whiteSpace lexer
  r <span class="ot">&lt;-</span> p
  eof
  return r

<span class="ot">var ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
var <span class="fu">=</span> <span class="kw">do</span>
  var <span class="ot">&lt;-</span> ident
  return (<span class="dt">Var</span> var )

<span class="ot">app ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
app <span class="fu">=</span> <span class="kw">do</span>
  e1 <span class="ot">&lt;-</span> expr
  e2 <span class="ot">&lt;-</span> expr
  return (<span class="dt">App</span> e1 e2)

<span class="ot">fun ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
fun <span class="fu">=</span> <span class="kw">do</span>
  reservedOp <span class="st">&quot;\\&quot;</span>
  binder <span class="ot">&lt;-</span> ident
  reservedOp <span class="st">&quot;.&quot;</span>
  rhs <span class="ot">&lt;-</span> expr
  return (<span class="dt">Lam</span> binder rhs)

<span class="ot">expr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
expr <span class="fu">=</span> <span class="kw">do</span>
  es <span class="ot">&lt;-</span> many1 aexp
  return (foldl1 <span class="dt">App</span> es)

<span class="ot">aexp ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
aexp <span class="fu">=</span> fun <span class="fu">&lt;|&gt;</span> var <span class="fu">&lt;|&gt;</span> (parens expr)

<span class="ot">test ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ParseError</span> <span class="dt">Expr</span>
test <span class="fu">=</span> parse (contents expr) <span class="st">&quot;&lt;stdin&gt;&quot;</span>

<span class="ot">repl ::</span> <span class="dt">IO</span> ()
repl <span class="fu">=</span> <span class="kw">do</span>
  str <span class="ot">&lt;-</span> TIO.getLine
  print (test str)
  repl

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> repl</code></pre></div>
<p>See: <a href="https://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Language.html">Text.Parsec.Language</a></p>
<h2 id="simple-parsing">Simple Parsing</h2>
<p>Putting our lexer and parser together we can write down a more robust parser for our little lambda calculus syntax.</p>
<div class="sourceCode" include="src/24-parsing/parser.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Parser</span> (parseExpr) <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Text.Parsec</span>
<span class="kw">import </span><span class="dt">Text.Parsec.String</span> (<span class="dt">Parser</span>)
<span class="kw">import </span><span class="dt">Text.Parsec.Language</span> (haskellStyle)

<span class="kw">import qualified</span> <span class="dt">Text.Parsec.Expr</span> <span class="kw">as</span> <span class="dt">Ex</span>
<span class="kw">import qualified</span> <span class="dt">Text.Parsec.Token</span> <span class="kw">as</span> <span class="dt">Tok</span>

<span class="kw">type</span> <span class="dt">Id</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="dt">Lam</span> <span class="dt">Id</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Var</span> <span class="dt">Id</span>
  <span class="fu">|</span> <span class="dt">Num</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">Op</span>  <span class="dt">Binop</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="kw">data</span> <span class="dt">Binop</span> <span class="fu">=</span> <span class="dt">Add</span> <span class="fu">|</span> <span class="dt">Sub</span> <span class="fu">|</span> <span class="dt">Mul</span> <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="ot">lexer ::</span> <span class="dt">Tok.TokenParser</span> ()
lexer <span class="fu">=</span> Tok.makeTokenParser style
  <span class="kw">where</span> ops <span class="fu">=</span> [<span class="st">&quot;-&gt;&quot;</span>,<span class="st">&quot;\\&quot;</span>,<span class="st">&quot;+&quot;</span>,<span class="st">&quot;*&quot;</span>,<span class="st">&quot;-&quot;</span>,<span class="st">&quot;=&quot;</span>]
        style <span class="fu">=</span> haskellStyle {Tok.reservedOpNames <span class="fu">=</span> ops }

<span class="ot">reservedOp ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> ()
reservedOp <span class="fu">=</span> Tok.reservedOp lexer

<span class="ot">identifier ::</span> <span class="dt">Parser</span> <span class="dt">String</span>
identifier <span class="fu">=</span> Tok.identifier lexer

<span class="ot">parens ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
parens <span class="fu">=</span> Tok.parens lexer

<span class="ot">contents ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
contents p <span class="fu">=</span> <span class="kw">do</span>
  Tok.whiteSpace lexer
  r <span class="ot">&lt;-</span> p
  eof
  return r

<span class="ot">natural ::</span> <span class="dt">Parser</span> <span class="dt">Integer</span>
natural <span class="fu">=</span> Tok.natural lexer

<span class="ot">variable ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
variable <span class="fu">=</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> identifier
  return (<span class="dt">Var</span> x)

<span class="ot">number ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
number <span class="fu">=</span> <span class="kw">do</span>
  n <span class="ot">&lt;-</span> natural
  return (<span class="dt">Num</span> (fromIntegral n))

<span class="ot">lambda ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
lambda <span class="fu">=</span> <span class="kw">do</span>
  reservedOp <span class="st">&quot;\\&quot;</span>
  x <span class="ot">&lt;-</span> identifier
  reservedOp <span class="st">&quot;-&gt;&quot;</span>
  e <span class="ot">&lt;-</span> expr
  return (<span class="dt">Lam</span> x e)

<span class="ot">aexp ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
aexp <span class="fu">=</span>  parens expr
    <span class="fu">&lt;|&gt;</span> variable
    <span class="fu">&lt;|&gt;</span> number
    <span class="fu">&lt;|&gt;</span> lambda

<span class="ot">term ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
term <span class="fu">=</span> Ex.buildExpressionParser table aexp
  <span class="kw">where</span> infixOp x f <span class="fu">=</span> <span class="dt">Ex.Infix</span> (reservedOp x <span class="fu">&gt;&gt;</span> return f)
        table <span class="fu">=</span> [[infixOp <span class="st">&quot;*&quot;</span> (<span class="dt">Op</span> <span class="dt">Mul</span>) <span class="dt">Ex.AssocLeft</span>],
                 [infixOp <span class="st">&quot;+&quot;</span> (<span class="dt">Op</span> <span class="dt">Add</span>) <span class="dt">Ex.AssocLeft</span>]]

<span class="ot">expr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
expr <span class="fu">=</span> <span class="kw">do</span>
  es <span class="ot">&lt;-</span> many1 term
  return (foldl1 <span class="dt">App</span> es)

<span class="ot">parseExpr ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span>
parseExpr input <span class="fu">=</span>
  <span class="kw">case</span> parse (contents expr) <span class="st">&quot;&lt;stdin&gt;&quot;</span> input <span class="kw">of</span>
    <span class="dt">Left</span> err <span class="ot">-&gt;</span> error (show err)
    <span class="dt">Right</span> ast <span class="ot">-&gt;</span> ast

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> getLine <span class="fu">&gt;&gt;=</span> print <span class="fu">.</span> parseExpr <span class="fu">&gt;&gt;</span> main</code></pre></div>
<p>Trying it out:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">λ: <span class="kw">runhaskell</span> simpleparser.hs
<span class="kw">1+2</span>
<span class="kw">Op</span> Add (Num 1) <span class="kw">(Num</span> 2<span class="kw">)</span>

\<span class="kw">i</span> -<span class="kw">&gt;</span> \x -<span class="kw">&gt;</span> x
<span class="kw">Lam</span> <span class="st">&quot;i&quot;</span> (Lam <span class="st">&quot;x&quot;</span> (Var <span class="st">&quot;x&quot;</span>))

\<span class="kw">s</span> -<span class="kw">&gt;</span> \f -<span class="kw">&gt;</span> \g -<span class="kw">&gt;</span> \x -<span class="kw">&gt;</span> f x (g x)
<span class="kw">Lam</span> <span class="st">&quot;s&quot;</span> (Lam <span class="st">&quot;f&quot;</span> (Lam <span class="st">&quot;g&quot;</span> (Lam <span class="st">&quot;x&quot;</span> (App (App (Var <span class="st">&quot;f&quot;</span>) <span class="kw">(Var</span> <span class="st">&quot;x&quot;</span><span class="kw">)</span>) <span class="kw">(App</span> (Var <span class="st">&quot;g&quot;</span><span class="kw">)</span> <span class="kw">(Var</span> <span class="st">&quot;x&quot;</span><span class="kw">)</span>)))))</code></pre></div>
<h2 id="generic-parsing">Generic Parsing</h2>
<p>Previously we defined generic operations for pretty printing and this begs the question of whether we can write a parser on top of Generics. The answer is generally yes, so long as there is a direct mapping between the specific lexemes and sum and products types. Consider the simplest case where we just read off the names of the constructors using the regular Generics machinery and then build a Parsec parser terms of them.</p>
<div class="sourceCode" include="src/24-parsing/generics.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE DeriveGeneric #-}</span>
<span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE FlexibleContexts #-}</span>
<span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span>

<span class="kw">import </span><span class="dt">Text.Parsec</span>
<span class="kw">import </span><span class="dt">Text.Parsec.Text.Lazy</span>
<span class="kw">import </span><span class="dt">Control.Applicative</span> ((&lt;*), (&lt;*&gt;), (&lt;$&gt;))
<span class="kw">import </span><span class="dt">GHC.Generics</span>

<span class="kw">class</span> <span class="dt">GParse</span> f <span class="kw">where</span>
<span class="ot">  gParse ::</span> <span class="dt">Parser</span> (f a)

<span class="co">-- Type synonym metadata for constructors</span>
<span class="kw">instance</span> (<span class="dt">GParse</span> f, <span class="dt">Constructor</span> c) <span class="ot">=&gt;</span> <span class="dt">GParse</span> (<span class="dt">C1</span> c f) <span class="kw">where</span>
  gParse <span class="fu">=</span>
    <span class="kw">let</span> con <span class="fu">=</span> conName (undefined<span class="ot"> ::</span> t c f a) <span class="kw">in</span>
    (fmap <span class="dt">M1</span> gParse) <span class="fu">&lt;*</span> string con

<span class="co">-- Constructor names</span>
<span class="kw">instance</span> <span class="dt">GParse</span> f <span class="ot">=&gt;</span> <span class="dt">GParse</span> (<span class="dt">D1</span> c f) <span class="kw">where</span>
  gParse <span class="fu">=</span> fmap <span class="dt">M1</span> gParse

<span class="co">-- Sum types</span>
<span class="kw">instance</span> (<span class="dt">GParse</span> a, <span class="dt">GParse</span> b) <span class="ot">=&gt;</span> <span class="dt">GParse</span> (a <span class="fu">:+:</span> b) <span class="kw">where</span>
  gParse <span class="fu">=</span> try (fmap <span class="dt">L1</span> gParse <span class="fu">&lt;|&gt;</span> fmap <span class="dt">R1</span> gParse)

<span class="co">-- Product types</span>
<span class="kw">instance</span> (<span class="dt">GParse</span> f, <span class="dt">GParse</span> g) <span class="ot">=&gt;</span> <span class="dt">GParse</span> (f <span class="fu">:*:</span> g) <span class="kw">where</span>
  gParse <span class="fu">=</span> (<span class="fu">:*:</span>) <span class="fu">&lt;$&gt;</span> gParse <span class="fu">&lt;*&gt;</span> gParse

<span class="co">-- Nullary constructors</span>
<span class="kw">instance</span> <span class="dt">GParse</span> <span class="dt">U1</span> <span class="kw">where</span>
  gParse <span class="fu">=</span> return <span class="dt">U1</span>

<span class="kw">data</span> <span class="dt">Scientist</span>
  <span class="fu">=</span> <span class="dt">Newton</span>
  <span class="fu">|</span> <span class="dt">Einstein</span>
  <span class="fu">|</span> <span class="dt">Schrodinger</span>
  <span class="fu">|</span> <span class="dt">Feynman</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>)

<span class="kw">data</span> <span class="dt">Musician</span>
  <span class="fu">=</span> <span class="dt">Vivaldi</span>
  <span class="fu">|</span> <span class="dt">Bach</span>
  <span class="fu">|</span> <span class="dt">Mozart</span>
  <span class="fu">|</span> <span class="dt">Beethoven</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>)

<span class="ot">gparse ::</span> (<span class="dt">Generic</span> g, <span class="dt">GParse</span> (<span class="dt">Rep</span> g)) <span class="ot">=&gt;</span> <span class="dt">Parser</span> g
gparse <span class="fu">=</span> fmap to gParse

<span class="ot">scientist ::</span> <span class="dt">Parser</span> <span class="dt">Scientist</span>
scientist <span class="fu">=</span> gparse

<span class="ot">musician ::</span> <span class="dt">Parser</span> <span class="dt">Musician</span>
musician <span class="fu">=</span> gparse</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> parseTest parseMusician <span class="st">&quot;Bach&quot;</span>
<span class="dt">Bach</span>

λ<span class="fu">:</span> parseTest parseScientist <span class="st">&quot;Feynman&quot;</span>
<span class="dt">Feynman</span></code></pre></div>
<p>With a little more work and an outer wrapper, this example an easily be extended to automate parsing of a simple recursive type.</p>
<div class="sourceCode" include="src/24-parsing/recursive-generics.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE DeriveGeneric #-}</span>
<span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE FlexibleContexts #-}</span>
<span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span>
<span class="ot">{-# LANGUAGE DeriveAnyClass #-}</span>
<span class="ot">{-# LANGUAGE DefaultSignatures #-}</span>

<span class="kw">import </span><span class="dt">Control.Applicative</span>    ((&lt;*), (*&gt;), (&lt;*&gt;), (&lt;$&gt;), pure)
<span class="kw">import </span><span class="dt">GHC.Generics</span>
<span class="kw">import </span><span class="dt">Text.Parsec</span>            ((&lt;|&gt;), string, try, many1, digit, char, letter, spaces)
<span class="kw">import </span><span class="dt">Text.Parsec.Text.Lazy</span>  (<span class="dt">Parser</span>)

<span class="kw">class</span> <span class="dt">GParse</span> f <span class="kw">where</span>
<span class="ot">  gParse ::</span> <span class="dt">Parser</span> (f a)

<span class="co">-- Types</span>
<span class="kw">instance</span> (<span class="dt">Parse</span> a) <span class="ot">=&gt;</span> <span class="dt">GParse</span> (<span class="dt">K1</span> <span class="dt">R</span> a) <span class="kw">where</span>
  gParse <span class="fu">=</span> fmap <span class="dt">K1</span> parse

<span class="co">-- Selector names</span>
<span class="kw">instance</span> (<span class="dt">GParse</span> f, <span class="dt">Selector</span> s) <span class="ot">=&gt;</span> <span class="dt">GParse</span> (<span class="dt">M1</span> <span class="dt">S</span> s f) <span class="kw">where</span>
  gParse <span class="fu">=</span> fmap <span class="dt">M1</span> gParse

<span class="co">-- Type synonym metadata for constructors</span>
<span class="kw">instance</span> (<span class="dt">GParse</span> f, <span class="dt">Constructor</span> c) <span class="ot">=&gt;</span> <span class="dt">GParse</span> (<span class="dt">C1</span> c f) <span class="kw">where</span>
  gParse <span class="fu">=</span>
    <span class="kw">let</span> con <span class="fu">=</span> conName (undefined<span class="ot"> ::</span> t c f a) <span class="kw">in</span>
      (spaces <span class="fu">&gt;&gt;</span> string con <span class="fu">&gt;&gt;</span> spaces) <span class="fu">*&gt;</span> fmap <span class="dt">M1</span> gParse

<span class="co">-- Constructor names</span>
<span class="kw">instance</span> (<span class="dt">Datatype</span> d, <span class="dt">GParse</span> f) <span class="ot">=&gt;</span> <span class="dt">GParse</span> (<span class="dt">D1</span> d f) <span class="kw">where</span>
  gParse <span class="fu">=</span> fmap <span class="dt">M1</span> gParse

<span class="co">-- Sum types</span>
<span class="kw">instance</span> (<span class="dt">GParse</span> a, <span class="dt">GParse</span> b) <span class="ot">=&gt;</span> <span class="dt">GParse</span> (a <span class="fu">:+:</span> b) <span class="kw">where</span>
  gParse <span class="fu">=</span> try (fmap <span class="dt">L1</span> gParse) <span class="fu">&lt;|&gt;</span> try (fmap <span class="dt">R1</span> gParse)

<span class="co">-- Product types</span>
<span class="kw">instance</span> (<span class="dt">GParse</span> f, <span class="dt">GParse</span> g) <span class="ot">=&gt;</span> <span class="dt">GParse</span> (f <span class="fu">:*:</span> g) <span class="kw">where</span>
  gParse <span class="fu">=</span> (<span class="fu">:*:</span>) <span class="fu">&lt;$&gt;</span> try gParse <span class="fu">&lt;*&gt;</span> try gParse

<span class="co">-- Nullary constructors</span>
<span class="kw">instance</span> <span class="dt">GParse</span> <span class="dt">U1</span> <span class="kw">where</span>
  gParse <span class="fu">=</span> return <span class="dt">U1</span>

<span class="ot">gparse ::</span> (<span class="dt">Generic</span> g, <span class="dt">GParse</span> (<span class="dt">Rep</span> g)) <span class="ot">=&gt;</span> <span class="dt">Parser</span> g
gparse <span class="fu">=</span> fmap to gParse

<span class="kw">class</span> <span class="dt">Parse</span> a <span class="kw">where</span>
<span class="ot">  parse ::</span> <span class="dt">Parser</span> a
  default<span class="ot"> parse ::</span> (<span class="dt">Generic</span> a, <span class="dt">GParse</span> (<span class="dt">Rep</span> a)) <span class="ot">=&gt;</span> <span class="dt">Parser</span> a
  parse <span class="fu">=</span> spaces <span class="fu">&gt;&gt;</span> char <span class="ch">&#39;(&#39;</span> <span class="fu">&gt;&gt;</span> gparse <span class="fu">&gt;&gt;=</span> \e <span class="ot">-&gt;</span> char <span class="ch">&#39;)&#39;</span> <span class="fu">&gt;&gt;</span> return e

<span class="kw">instance</span> <span class="dt">Parse</span> <span class="dt">Integer</span> <span class="kw">where</span>
  parse <span class="fu">=</span> rd <span class="fu">&lt;$&gt;</span> (plus <span class="fu">&lt;|&gt;</span> minus <span class="fu">&lt;|&gt;</span> number)
    <span class="kw">where</span> rd     <span class="fu">=</span><span class="ot"> read ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
          plus   <span class="fu">=</span> char <span class="ch">&#39;+&#39;</span> <span class="fu">*&gt;</span> number
          minus  <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> char <span class="ch">&#39;-&#39;</span> <span class="fu">&lt;*&gt;</span> number
          number <span class="fu">=</span> many1 digit

<span class="kw">instance</span> <span class="dt">Parse</span> <span class="dt">String</span> <span class="kw">where</span>
   parse <span class="fu">=</span> many1 letter

<span class="kw">type</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="kw">data</span> <span class="dt">Exp</span> 
  <span class="fu">=</span> <span class="dt">Lit</span> <span class="dt">Integer</span>
  <span class="fu">|</span> <span class="dt">Var</span> <span class="dt">Name</span>
  <span class="fu">|</span> <span class="dt">Plus</span> <span class="dt">Exp</span> <span class="dt">Exp</span> 
  <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Exp</span> <span class="dt">Exp</span> 
  <span class="fu">|</span> <span class="dt">Abs</span> <span class="dt">Name</span> <span class="dt">Exp</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>, <span class="dt">Parse</span>)

<span class="ot">expr ::</span> <span class="dt">Parser</span> <span class="dt">Exp</span>
expr <span class="fu">=</span> parse</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> parseTest expr <span class="st">&quot;(App (Plus (Lit 1) (Var n)) (App (Plus (Lit 5) (Lit 5)) (Plus (Lit 6) (Lit 6))))&quot;</span>
<span class="dt">App</span> (<span class="dt">Plus</span> (<span class="dt">Lit</span> <span class="dv">1</span>) (<span class="dt">Var</span> <span class="st">&quot;n&quot;</span>)) (<span class="dt">App</span> (<span class="dt">Plus</span> (<span class="dt">Lit</span> <span class="dv">5</span>) (<span class="dt">Lit</span> <span class="dv">5</span>)) (<span class="dt">Plus</span> (<span class="dt">Lit</span> <span class="dv">6</span>) (<span class="dt">Lit</span> <span class="dv">6</span>)))</code></pre></div>
<h2 id="attoparsec">Attoparsec</h2>
<p>Attoparsec is a parser combinator like Parsec but more suited for bulk parsing of large text and binary files instead of parsing language syntax to ASTs. When written properly Attoparsec parsers can be <a href="http://www.serpentine.com/blog/2014/05/31/attoparsec/">efficient</a>.</p>
<p>One notable distinction between Parsec and Attoparsec is that backtracking operator (<code>try</code>) is not present and reflects on attoparsec's different underlying parser model.</p>
<p>For a simple little lambda calculus language we can use attoparsec much in the same we used parsec:</p>
<div class="sourceCode" include="src/24-parsing/attoparsec_lang.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="ot">{-# OPTIONS_GHC -fno-warn-unused-do-bind #-}</span>

<span class="kw">import </span><span class="dt">Control.Applicative</span>
<span class="kw">import </span><span class="dt">Data.Attoparsec.Text</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text.IO</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import </span><span class="dt">Data.List</span> (foldl1&#39;)

<span class="kw">data</span> <span class="dt">Name</span>
  <span class="fu">=</span> <span class="dt">Gen</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">Name</span> <span class="dt">T.Text</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Ord</span>)

<span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="dt">Var</span> <span class="dt">Name</span>
  <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Lam</span> [<span class="dt">Name</span>] <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Lit</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">Prim</span> <span class="dt">PrimOp</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">data</span> <span class="dt">PrimOp</span>
  <span class="fu">=</span> <span class="dt">Add</span>
  <span class="fu">|</span> <span class="dt">Sub</span>
  <span class="fu">|</span> <span class="dt">Mul</span>
  <span class="fu">|</span> <span class="dt">Div</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">data</span> <span class="dt">Defn</span> <span class="fu">=</span> <span class="dt">Defn</span> <span class="dt">Name</span> <span class="dt">Expr</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="ot">name ::</span> <span class="dt">Parser</span> <span class="dt">Name</span>
name <span class="fu">=</span> <span class="dt">Name</span> <span class="fu">.</span> T.pack <span class="fu">&lt;$&gt;</span> many1 letter

<span class="ot">num ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
num <span class="fu">=</span> <span class="dt">Lit</span> <span class="fu">&lt;$&gt;</span> signed decimal

<span class="ot">var ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
var <span class="fu">=</span> <span class="dt">Var</span> <span class="fu">&lt;$&gt;</span> name

<span class="ot">lam ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
lam <span class="fu">=</span> <span class="kw">do</span>
  string <span class="st">&quot;\\&quot;</span>
  vars <span class="ot">&lt;-</span> many1 (skipSpace <span class="fu">*&gt;</span> name)
  skipSpace <span class="fu">*&gt;</span> string <span class="st">&quot;-&gt;&quot;</span>
  body <span class="ot">&lt;-</span> expr
  return (<span class="dt">Lam</span> vars body)

<span class="ot">eparen ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
eparen <span class="fu">=</span> char <span class="ch">&#39;(&#39;</span> <span class="fu">*&gt;</span> expr <span class="fu">&lt;*</span> skipSpace <span class="fu">&lt;*</span> char <span class="ch">&#39;)&#39;</span>

<span class="ot">prim ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
prim <span class="fu">=</span> <span class="dt">Prim</span> <span class="fu">&lt;$&gt;</span> (
      char <span class="ch">&#39;+&#39;</span> <span class="fu">*&gt;</span> return <span class="dt">Add</span>
  <span class="fu">&lt;|&gt;</span> char <span class="ch">&#39;-&#39;</span> <span class="fu">*&gt;</span> return <span class="dt">Sub</span>
  <span class="fu">&lt;|&gt;</span> char <span class="ch">&#39;*&#39;</span> <span class="fu">*&gt;</span> return <span class="dt">Mul</span>
  <span class="fu">&lt;|&gt;</span> char <span class="ch">&#39;/&#39;</span> <span class="fu">*&gt;</span> return <span class="dt">Div</span>)

<span class="ot">expr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
expr <span class="fu">=</span> foldl1&#39; <span class="dt">App</span> <span class="fu">&lt;$&gt;</span> many1 (skipSpace <span class="fu">*&gt;</span> atom)

<span class="ot">atom ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
atom <span class="fu">=</span> try lam
    <span class="fu">&lt;|&gt;</span> eparen
    <span class="fu">&lt;|&gt;</span> prim
    <span class="fu">&lt;|&gt;</span> var
    <span class="fu">&lt;|&gt;</span> num

<span class="ot">def ::</span> <span class="dt">Parser</span> <span class="dt">Defn</span>
def <span class="fu">=</span> <span class="kw">do</span>
  skipSpace
  nm <span class="ot">&lt;-</span> name
  skipSpace <span class="fu">*&gt;</span> char <span class="ch">&#39;=&#39;</span> <span class="fu">*&gt;</span> skipSpace
  ex <span class="ot">&lt;-</span> expr
  skipSpace <span class="fu">&lt;*</span> char <span class="ch">&#39;;&#39;</span>
  return <span class="fu">$</span> <span class="dt">Defn</span> nm ex

<span class="ot">file ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> [<span class="dt">Defn</span>]
file <span class="fu">=</span> parseOnly (many def <span class="fu">&lt;*</span> skipSpace)

<span class="ot">parseFile ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">T.Text</span> [<span class="dt">Defn</span>])
parseFile path <span class="fu">=</span> <span class="kw">do</span>
  contents <span class="ot">&lt;-</span> T.readFile path
  <span class="kw">case</span> file contents <span class="kw">of</span>
    <span class="dt">Left</span> a <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">Left</span> (T.pack a)
    <span class="dt">Right</span> b <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">Right</span> b

<span class="ot">main ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">T.Text</span> [<span class="dt">Defn</span>])
main <span class="fu">=</span> parseFile <span class="st">&quot;simple.ml&quot;</span></code></pre></div>
<p>For an example try the above parser with the following simple lambda expression.</p>
<div class="sourceCode" include="src/24-parsing/simple.ml"><pre class="sourceCode ocaml"><code class="sourceCode ocaml">f = g (x - <span class="dv">1</span>);
g = f (x + <span class="dv">1</span>);
h = \x y -&gt; (f x) + (g y);</code></pre></div>
<p>Attoparsec adapts very well to binary and network protocol style parsing as well, this is extracted from a small implementation of a distributed consensus network protocol:</p>
<div class="sourceCode" include="src/24-parsing/attoparsec.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Control.Monad</span>

<span class="kw">import </span><span class="dt">Data.Attoparsec</span>
<span class="kw">import </span><span class="dt">Data.Attoparsec.Char8</span> <span class="kw">as</span> <span class="dt">A</span>
<span class="kw">import </span><span class="dt">Data.ByteString.Char8</span>

<span class="kw">data</span> <span class="dt">Action</span>
  <span class="fu">=</span> <span class="dt">Success</span>
  <span class="fu">|</span> <span class="dt">KeepAlive</span>
  <span class="fu">|</span> <span class="dt">NoResource</span>
  <span class="fu">|</span> <span class="dt">Hangup</span>
  <span class="fu">|</span> <span class="dt">NewLeader</span>
  <span class="fu">|</span> <span class="dt">Election</span>
  <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">type</span> <span class="dt">Sender</span> <span class="fu">=</span> <span class="dt">ByteString</span>
<span class="kw">type</span> <span class="dt">Payload</span> <span class="fu">=</span> <span class="dt">ByteString</span>

<span class="kw">data</span> <span class="dt">Message</span> <span class="fu">=</span> <span class="dt">Message</span>
  {<span class="ot"> action ::</span> <span class="dt">Action</span>
  ,<span class="ot"> sender ::</span> <span class="dt">Sender</span>
  ,<span class="ot"> payload ::</span> <span class="dt">Payload</span>
  } <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="ot">proto ::</span> <span class="dt">Parser</span> <span class="dt">Message</span>
proto <span class="fu">=</span> <span class="kw">do</span>
  act  <span class="ot">&lt;-</span> paction
  send <span class="ot">&lt;-</span> A.takeTill (<span class="fu">==</span> <span class="ch">&#39;.&#39;</span>)
  body <span class="ot">&lt;-</span> A.takeTill (A.isSpace)
  endOfLine
  return <span class="fu">$</span> <span class="dt">Message</span> act send body

<span class="ot">paction ::</span> <span class="dt">Parser</span> <span class="dt">Action</span>
paction <span class="fu">=</span> <span class="kw">do</span>
  c <span class="ot">&lt;-</span> anyWord8
  <span class="kw">case</span> c <span class="kw">of</span>
    <span class="dv">1</span>  <span class="ot">-&gt;</span> return <span class="dt">Success</span>
    <span class="dv">2</span>  <span class="ot">-&gt;</span> return <span class="dt">KeepAlive</span>
    <span class="dv">3</span>  <span class="ot">-&gt;</span> return <span class="dt">NoResource</span>
    <span class="dv">4</span>  <span class="ot">-&gt;</span> return <span class="dt">Hangup</span>
    <span class="dv">5</span>  <span class="ot">-&gt;</span> return <span class="dt">NewLeader</span>
    <span class="dv">6</span>  <span class="ot">-&gt;</span> return <span class="dt">Election</span>
    _  <span class="ot">-&gt;</span> mzero

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> msgtext <span class="fu">=</span> <span class="st">&quot;\x01\x6c\x61\x70\x74\x6f\x70\x2e\x33\x2e\x31\x34\x31\x35\x39\x32\x36\x35\x33\x35\x0A&quot;</span>
  <span class="kw">let</span> msg <span class="fu">=</span> parseOnly proto msgtext
  print msg</code></pre></div>
<p>See: <a href="https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/attoparsec">Text Parsing Tutorial</a></p>
<h2 id="optparse-applicative">Optparse Applicative</h2>
<p>Optparse-applicative is a combinator library for building command line interfaces that take in various user flags, commmands and switches and map them into Haskell data structures that can handle the input. The main interface is through the applicative functor <code>Parser</code> and various combinators such as <code>strArgument</code> and <code>flag</code> which populate the option parsing table with some monadic action which returns a Haskell value. The resulting sequence of values can be combined applicatively into a larger Config data structure that holds all the given options. The <code>--help</code> header is also automatically generated from the combinators.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">./optparse</span>
<span class="kw">Usage</span>: optparse.hs [filename...] [--quiet] [--cheetah]

<span class="kw">Available</span> options:
  <span class="kw">-h</span>,--help                Show this help text
  <span class="kw">filename...</span>              Input files
  <span class="kw">--quiet</span>                  Whether to shut up.
  <span class="kw">--cheetah</span>                Perform task quickly.</code></pre></div>
<div class="sourceCode" include="src/24-parsing/optparse_applicative.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List</span>
<span class="kw">import </span><span class="dt">Data.Monoid</span>
<span class="kw">import </span><span class="dt">Options.Applicative</span>

<span class="kw">data</span> <span class="dt">Opts</span> <span class="fu">=</span> <span class="dt">Opts</span>
  { _<span class="ot">files ::</span> [<span class="dt">String</span>]
  , _<span class="ot">quiet ::</span> <span class="dt">Bool</span>
  , _<span class="ot">fast ::</span> <span class="dt">Speed</span>
  }

<span class="kw">data</span> <span class="dt">Speed</span> <span class="fu">=</span> <span class="dt">Slow</span> <span class="fu">|</span> <span class="dt">Fast</span>

<span class="ot">options ::</span> <span class="dt">Parser</span> <span class="dt">Opts</span>
options <span class="fu">=</span> <span class="dt">Opts</span> <span class="fu">&lt;$&gt;</span> filename <span class="fu">&lt;*&gt;</span> quiet <span class="fu">&lt;*&gt;</span> fast
  <span class="kw">where</span>
<span class="ot">    filename ::</span> <span class="dt">Parser</span> [<span class="dt">String</span>]
    filename <span class="fu">=</span> many <span class="fu">$</span> argument str <span class="fu">$</span>
         metavar <span class="st">&quot;filename...&quot;</span>
      <span class="fu">&lt;&gt;</span> help <span class="st">&quot;Input files&quot;</span>

<span class="ot">    fast ::</span> <span class="dt">Parser</span> <span class="dt">Speed</span>
    fast <span class="fu">=</span> flag <span class="dt">Slow</span> <span class="dt">Fast</span> <span class="fu">$</span>
         long <span class="st">&quot;cheetah&quot;</span>
      <span class="fu">&lt;&gt;</span> help <span class="st">&quot;Perform task quickly.&quot;</span>

<span class="ot">    quiet ::</span> <span class="dt">Parser</span> <span class="dt">Bool</span>
    quiet <span class="fu">=</span> switch <span class="fu">$</span>
         long <span class="st">&quot;quiet&quot;</span>
      <span class="fu">&lt;&gt;</span> help <span class="st">&quot;Whether to shut up.&quot;</span>

<span class="ot">greet ::</span> <span class="dt">Opts</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
greet (<span class="dt">Opts</span> files quiet fast) <span class="fu">=</span> <span class="kw">do</span>
  putStrLn <span class="st">&quot;reading these files:&quot;</span>
  mapM_ print files

  <span class="kw">case</span> fast <span class="kw">of</span>
    <span class="dt">Fast</span> <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;quickly&quot;</span>
    <span class="dt">Slow</span> <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;slowly&quot;</span>

  <span class="kw">case</span> quiet <span class="kw">of</span>
    <span class="dt">True</span>  <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;quietly&quot;</span>
    <span class="dt">False</span> <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;loudly&quot;</span>

<span class="ot">opts ::</span> <span class="dt">ParserInfo</span> <span class="dt">Opts</span>
opts <span class="fu">=</span> info (helper <span class="fu">&lt;*&gt;</span> options) fullDesc

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> execParser opts <span class="fu">&gt;&gt;=</span> greet</code></pre></div>
<p>See: <a href="https://github.com/pcapriotti/optparse-applicative">Optparse Applicative Tutorial</a></p>
<h2 id="happy-alex">Happy &amp; Alex</h2>
<p>Happy is a parser generator system for Haskell, similar to the tool `yacc' for C. It works as a preprocessor with it's own syntax that generates a parse table from two specifications, a lexer file and parser file. Happy does not have the same underlying parser implementation as parser combinators and can effectively work with left-recursive grammars without explicit factorization. It can also easily be modified to track position information for tokens and handle offside parsing rules for indentation-sensitive grammars. Happy is used in GHC itself for Haskell's grammar.</p>
<ol style="list-style-type: decimal">
<li>Lexer.x</li>
<li>Parser.y</li>
</ol>
<p>Running the standalone commands will generate the Haskell source for the modules.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">alex</span> Lexer.x -o Lexer.hs
$ <span class="kw">happy</span> Parser.y -o Parser.hs</code></pre></div>
<p>The generated modules are not human readable generally and unfortunatly error messages are given in the Haskell source, not the Happy source.</p>
<h4 id="lexer">Lexer</h4>
<p>For instance we could define a little toy lexer with a custom set of tokens.</p>
<div class="sourceCode" include="src/24-parsing/happy/Lexer.x"><pre class="sourceCode haskell"><code class="sourceCode haskell">{
<span class="kw">module</span> <span class="dt">Lexer</span> (
  <span class="dt">Token</span>(<span class="fu">..</span>),
  scanTokens
) <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Syntax</span>
}

<span class="fu">%</span>wrapper <span class="st">&quot;basic&quot;</span>

<span class="fu">$</span>digit <span class="fu">=</span> <span class="dv">0</span><span class="fu">-</span><span class="dv">9</span>
<span class="fu">$</span>alpha <span class="fu">=</span> [a<span class="fu">-</span>zA<span class="fu">-</span><span class="dt">Z</span>]
<span class="fu">$</span>eol   <span class="fu">=</span> [\n]

tokens <span class="fu">:-</span>

  <span class="co">-- Whitespace insensitive</span>
  <span class="fu">$</span>eol                          ;
  <span class="fu">$</span>white<span class="fu">+</span>                       ;
  print                         { \s <span class="ot">-&gt;</span> <span class="dt">TokenPrint</span> }
  <span class="fu">$</span>digit<span class="fu">+</span>                       { \s <span class="ot">-&gt;</span> <span class="dt">TokenNum</span> (read s) }
  \<span class="fu">=</span>                            { \s <span class="ot">-&gt;</span> <span class="dt">TokenEq</span> }
  <span class="fu">$</span>alpha [<span class="fu">$</span>alpha <span class="fu">$</span>digit \_ \<span class="ch">&#39;]* { \s -&gt; TokenSym s }</span>

{

<span class="kw">data</span> <span class="dt">Token</span> 
  <span class="fu">=</span> <span class="dt">TokenNum</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">TokenSym</span> <span class="dt">String</span>
  <span class="fu">|</span> <span class="dt">TokenPrint</span>
  <span class="fu">|</span> <span class="dt">TokenEq</span>
  <span class="fu">|</span> <span class="dt">TokenEOF</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Show</span>)

scanTokens <span class="fu">=</span> alexScanTokens

}</code></pre></div>
<h4 id="parser">Parser</h4>
<p>The associated parser is list of a production rules and a monad to running the parser in. Production rules consist of a set of options on the left and generating Haskell expressions on the right with indexed metavariables (<code>$1</code>, <code>$2</code>, ...) mapping to the ordered terms on the left (i.e. in the second term <code>term</code> ~ <code>$1</code>, <code>term</code> ~ <code>$2</code>).</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl">terms
    : term                   { [<span class="dt">$1</span>] }
    | term terms             { <span class="dt">$1</span> : <span class="dt">$2</span> }</code></pre></div>
<div class="sourceCode" include="src/24-parsing/happy/Parser.y"><pre class="sourceCode haskell"><code class="sourceCode haskell">{
<span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>

<span class="kw">module</span> <span class="dt">Parser</span> (
  parseExpr,
) <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Lexer</span>
<span class="kw">import </span><span class="dt">Syntax</span>

<span class="kw">import </span><span class="dt">Control.Monad.Except</span>
}

<span class="fu">%</span>name expr
<span class="fu">%</span>tokentype { <span class="dt">Token</span> }
<span class="fu">%</span>monad { <span class="dt">Except</span> <span class="dt">String</span> } { (<span class="fu">&gt;&gt;=</span>) } { return }
<span class="fu">%</span>error { parseError }

<span class="fu">%</span>token
    int   { <span class="dt">TokenNum</span> <span class="fu">$$</span> }
    var   { <span class="dt">TokenSym</span> <span class="fu">$$</span> }
    print { <span class="dt">TokenPrint</span> }
    <span class="ch">&#39;=&#39;</span>   { <span class="dt">TokenEq</span> }

<span class="fu">%%</span>

terms 
    <span class="fu">:</span> term                   { [<span class="fu">$</span><span class="dv">1</span>] }
    <span class="fu">|</span> term terms             { <span class="fu">$</span><span class="dv">1</span> <span class="fu">:</span> <span class="fu">$</span><span class="dv">2</span> }

term 
   <span class="fu">:</span> var                     { <span class="dt">Var</span> <span class="fu">$</span><span class="dv">1</span> }
   <span class="fu">|</span> var <span class="ch">&#39;=&#39;</span> int             { <span class="dt">Assign</span> <span class="fu">$</span><span class="dv">1</span> <span class="fu">$</span><span class="dv">3</span> }
   <span class="fu">|</span> print term              { <span class="dt">Print</span> <span class="fu">$</span><span class="dv">2</span> }

{

<span class="ot">parseError ::</span> [<span class="dt">Token</span>] <span class="ot">-&gt;</span> <span class="dt">Except</span> <span class="dt">String</span> a
parseError (l<span class="fu">:</span>ls) <span class="fu">=</span> throwError (show l)
parseError [] <span class="fu">=</span> throwError <span class="st">&quot;Unexpected end of Input&quot;</span>

<span class="ot">parseExpr ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> [<span class="dt">Expr</span>]
parseExpr input <span class="fu">=</span> 
  <span class="kw">let</span> tokenStream <span class="fu">=</span> scanTokens input <span class="kw">in</span>
  runExcept (expr tokenStream)
}</code></pre></div>
<p>As a simple input consider the following simple program.</p>
<div class="sourceCode" include="src/24-parsing/happy/input.test"><pre class="sourceCode haskell"><code class="sourceCode haskell">x <span class="fu">=</span> <span class="dv">4</span>
print x
y <span class="fu">=</span> <span class="dv">5</span>
print y
y <span class="fu">=</span> <span class="dv">6</span>
print y</code></pre></div>
<h2 id="configurator">Configurator</h2>
<div class="sourceCode" include="src/24-parsing/configurator.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Data.Text</span>
<span class="kw">import qualified</span> <span class="dt">Data.Configurator</span> <span class="kw">as</span> <span class="dt">C</span>

<span class="kw">data</span> <span class="dt">Config</span> <span class="fu">=</span> <span class="dt">Config</span>
  {<span class="ot"> verbose      ::</span> <span class="dt">Bool</span>
  ,<span class="ot"> loggingLevel ::</span> <span class="dt">Int</span>
  ,<span class="ot"> logfile      ::</span> FilePath
  ,<span class="ot"> dbHost       ::</span> <span class="dt">Text</span>
  ,<span class="ot"> dbUser       ::</span> <span class="dt">Text</span>
  ,<span class="ot"> dbDatabase   ::</span> <span class="dt">Text</span>
  ,<span class="ot"> dbpassword   ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span>
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="ot">readConfig ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Config</span>
readConfig cfgFile <span class="fu">=</span> <span class="kw">do</span>
  cfg          <span class="ot">&lt;-</span> C.load [<span class="dt">C.Required</span> cfgFile]
  verbose      <span class="ot">&lt;-</span> C.require cfg <span class="st">&quot;logging.verbose&quot;</span>
  loggingLevel <span class="ot">&lt;-</span> C.require cfg <span class="st">&quot;logging.loggingLevel&quot;</span>
  logFile      <span class="ot">&lt;-</span> C.require cfg <span class="st">&quot;logging.logfile&quot;</span>
  hostname     <span class="ot">&lt;-</span> C.require cfg <span class="st">&quot;database.hostname&quot;</span>
  username     <span class="ot">&lt;-</span> C.require cfg <span class="st">&quot;database.username&quot;</span>
  database     <span class="ot">&lt;-</span> C.require cfg <span class="st">&quot;database.database&quot;</span>
  password     <span class="ot">&lt;-</span> C.lookup cfg <span class="st">&quot;database.password&quot;</span>
  return <span class="fu">$</span> <span class="dt">Config</span> verbose loggingLevel logFile hostname username database password

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  cfg <span class="ot">&lt;-</span>readConfig <span class="st">&quot;example.config&quot;</span>
  print cfg</code></pre></div>
<div class="sourceCode" include="src/24-parsing/example.config"><pre class="sourceCode haskell"><code class="sourceCode haskell">logging 
{
  verbose      <span class="fu">=</span> true
  logfile      <span class="fu">=</span> <span class="st">&quot;/tmp/app.log&quot;</span>
  loggingLevel <span class="fu">=</span> <span class="dv">3</span>
}

database
{
  hostname <span class="fu">=</span> <span class="st">&quot;us-east-1.rds.amazonaws.com&quot;</span>
  username <span class="fu">=</span> <span class="st">&quot;app&quot;</span>
  database <span class="fu">=</span> <span class="st">&quot;booktown&quot;</span>
  password <span class="fu">=</span> <span class="st">&quot;hunter2&quot;</span>
}</code></pre></div>
</hr>
<h1 id="streaming">Streaming</h1>
<h2 id="lazy-io">Lazy IO</h2>
<p>The problem with using the usual monadic approach to processing data accumulated through IO is that the Prelude tools require us to manifest large amounts of data in memory all at once before we can even begin computation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">mapM<span class="ot"> ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [b]
sequence<span class="ot"> ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> [m a] <span class="ot">-&gt;</span> m [a]</code></pre></div>
<p>Reading from the file creates a thunk for the string that forced will then read the file. The problem is then that this method ties the ordering of IO effects to evaluation order which is difficult to reason about in the large.</p>
<p>Consider that normally the monad laws ( in the absence of <code>seq</code> ) guarantee that these computations should be identical. But using lazy IO we can construct a degenerate case.</p>
<div class="sourceCode" include="src/25-streaming/lazyio.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">System.IO</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  withFile <span class="st">&quot;foo.txt&quot;</span> <span class="dt">ReadMode</span> <span class="fu">$</span> \fd <span class="ot">-&gt;</span> <span class="kw">do</span>
    contents <span class="ot">&lt;-</span> hGetContents fd
    print contents
  <span class="co">-- &quot;foo\n&quot;</span>

  contents <span class="ot">&lt;-</span> withFile <span class="st">&quot;foo.txt&quot;</span> <span class="dt">ReadMode</span> hGetContents
  print contents
  <span class="co">-- &quot;&quot;</span></code></pre></div>
<p>So what we need is a system to guarantee deterministic resource handling with constant memory usage. To that end both the Conduits and Pipes libraries solved this problem using different ( though largely equivalent ) approaches.</p>
<h2 id="pipes">Pipes</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">await ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Pipe</span> a y m a
<span class="ot">yield ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Pipe</span> x a m ()

<span class="ot">(&gt;-&gt;) ::</span> <span class="dt">Monad</span> m
      <span class="ot">=&gt;</span> <span class="dt">Pipe</span> a b m r
      <span class="ot">-&gt;</span> <span class="dt">Pipe</span> b c m r
      <span class="ot">-&gt;</span> <span class="dt">Pipe</span> a c m r

<span class="ot">runEffect ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Effect</span> m r <span class="ot">-&gt;</span> m r
<span class="ot">toListM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Producer</span> a m () <span class="ot">-&gt;</span> m [a]</code></pre></div>
<p>Pipes is a stream processing library with a strong emphasis on the static semantics of composition. The simplest usage is to connect &quot;pipe&quot; functions with a <code>(&gt;-&gt;)</code> composition operator, where each component can <code>await</code> and <code>yield</code> to push and pull values along the stream.</p>
<div class="sourceCode" include="src/25-streaming/pipes.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Pipes</span>
<span class="kw">import </span><span class="dt">Pipes.Prelude</span> <span class="kw">as</span> <span class="dt">P</span>
<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Control.Monad.Identity</span>

<span class="ot">a ::</span> <span class="dt">Producer</span> <span class="dt">Int</span> <span class="dt">Identity</span> ()
a <span class="fu">=</span> forM_ [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] yield

<span class="ot">b ::</span> <span class="dt">Pipe</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="dt">Identity</span> ()
b <span class="fu">=</span>  forever <span class="fu">$</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> await
  yield (x<span class="fu">*</span><span class="dv">2</span>)
  yield (x<span class="fu">*</span><span class="dv">3</span>)
  yield (x<span class="fu">*</span><span class="dv">4</span>)

<span class="ot">c ::</span> <span class="dt">Pipe</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="dt">Identity</span> ()
c <span class="fu">=</span> forever <span class="fu">$</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> await
  <span class="kw">if</span> (x <span class="ot">`mod`</span> <span class="dv">2</span>) <span class="fu">==</span> <span class="dv">0</span>
    <span class="kw">then</span> yield x
    <span class="kw">else</span> return ()

<span class="ot">result ::</span> [<span class="dt">Int</span>]
result <span class="fu">=</span> P.toList <span class="fu">$</span> a <span class="fu">&gt;-&gt;</span> b <span class="fu">&gt;-&gt;</span> c</code></pre></div>
<p>For example we could construct a &quot;FizzBuzz&quot; pipe.</p>
<div class="sourceCode" include="src/25-streaming/pipes_io.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE MultiWayIf #-}</span>

<span class="kw">import </span><span class="dt">Pipes</span>
<span class="kw">import qualified</span> <span class="dt">Pipes.Prelude</span> <span class="kw">as</span> <span class="dt">P</span>

<span class="ot">count ::</span> <span class="dt">Producer</span> <span class="dt">Integer</span> <span class="dt">IO</span> ()
count <span class="fu">=</span> each [<span class="dv">1</span><span class="fu">..</span><span class="dv">100</span>]

<span class="ot">fizzbuzz ::</span> <span class="dt">Pipe</span> <span class="dt">Integer</span> <span class="dt">String</span> <span class="dt">IO</span> ()
fizzbuzz <span class="fu">=</span> <span class="kw">do</span>
  n <span class="ot">&lt;-</span> await
  <span class="kw">if</span> <span class="fu">|</span> n <span class="ot">`mod`</span> <span class="dv">15</span> <span class="fu">==</span> <span class="dv">0</span> <span class="ot">-&gt;</span> yield <span class="st">&quot;FizzBuzz&quot;</span>
     <span class="fu">|</span> n <span class="ot">`mod`</span> <span class="dv">5</span>  <span class="fu">==</span> <span class="dv">0</span> <span class="ot">-&gt;</span> yield <span class="st">&quot;Fizz&quot;</span>
     <span class="fu">|</span> n <span class="ot">`mod`</span> <span class="dv">3</span>  <span class="fu">==</span> <span class="dv">0</span> <span class="ot">-&gt;</span> yield <span class="st">&quot;Buzz&quot;</span>
     <span class="fu">|</span> otherwise       <span class="ot">-&gt;</span> return ()
  fizzbuzz

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> runEffect <span class="fu">$</span> count <span class="fu">&gt;-&gt;</span> fizzbuzz <span class="fu">&gt;-&gt;</span> P.stdoutLn</code></pre></div>
<p>To continue with the degenerate case we constructed with Lazy IO, consider than we can now compose and sequence deterministic actions over files without having to worry about effect order.</p>
<div class="sourceCode" include="src/25-streaming/pipes_file.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Pipes</span>
<span class="kw">import </span><span class="dt">Pipes.Prelude</span> <span class="kw">as</span> <span class="dt">P</span>
<span class="kw">import </span><span class="dt">System.IO</span>

<span class="ot">readF ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Producer</span> <span class="dt">String</span> <span class="dt">IO</span> ()
readF file <span class="fu">=</span> <span class="kw">do</span>
    lift <span class="fu">$</span> putStrLn <span class="fu">$</span> <span class="st">&quot;Opened&quot;</span> <span class="fu">++</span> file
    h <span class="ot">&lt;-</span> lift <span class="fu">$</span> openFile file <span class="dt">ReadMode</span>
    fromHandle h
    lift <span class="fu">$</span> putStrLn <span class="fu">$</span> <span class="st">&quot;Closed&quot;</span> <span class="fu">++</span> file
    lift <span class="fu">$</span> hClose h

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> runEffect <span class="fu">$</span> readF <span class="st">&quot;foo.txt&quot;</span> <span class="fu">&gt;-&gt;</span> P.take <span class="dv">3</span> <span class="fu">&gt;-&gt;</span> stdoutLn</code></pre></div>
<p>This is simple a sampling of the functionality of pipes. The documentation for pipes is extensive and great deal of care has been taken make the library extremely thorough. <code>pipes</code> is a shining example of an accessible yet category theoretic driven design.</p>
<p>See: <a href="http://hackage.haskell.org/package/pipes-4.1.0/docs/Pipes-Tutorial.html">Pipes Tutorial</a></p>
<h2 id="safe-pipes">Safe Pipes</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bracket ::</span> <span class="dt">MonadSafe</span> m <span class="ot">=&gt;</span> <span class="dt">Base</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Base</span> m b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m c) <span class="ot">-&gt;</span> m c</code></pre></div>
<p>As a motivating example, ZeroMQ is a network messaging library that abstracts over traditional Unix sockets to a variety of network topologies. Most notably it isn't designed to guarantee any sort of transactional guarantees for delivery or recovery in case of errors so it's necessary to design a layer on top of it to provide the desired behavior at the application layer.</p>
<p>In Haskell we'd like to guarantee that if we're polling on a socket we get messages delivered in a timely fashion or consider the resource in an error state and recover from it. Using <code>pipes-safe</code> we can manage the life cycle of lazy IO resources and can safely handle failures, resource termination and finalization gracefully. In other languages this kind of logic would be smeared across several places, or put in some global context and prone to introduce errors and subtle race conditions. Using pipes we instead get a nice tight abstraction designed exactly to fit this kind of use case.</p>
<p>For instance now we can bracket the ZeroMQ socket creation and finalization within the <code>SafeT</code> monad transformer which guarantees that after successful message delivery we execute the pipes function as expected, or on failure we halt the execution and finalize the socket.</p>
<div class="sourceCode" include="src/25-streaming/pipes_safe.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Pipes</span>
<span class="kw">import </span><span class="dt">Pipes.Safe</span>
<span class="kw">import qualified</span> <span class="dt">Pipes.Prelude</span> <span class="kw">as</span> <span class="dt">P</span>

<span class="kw">import </span><span class="dt">System.Timeout</span> (timeout)
<span class="kw">import </span><span class="dt">Data.ByteString.Char8</span>
<span class="kw">import qualified</span> <span class="dt">System.ZMQ</span> <span class="kw">as</span> <span class="dt">ZMQ</span>

<span class="kw">data</span> <span class="dt">Opts</span> <span class="fu">=</span> <span class="dt">Opts</span>
  { _<span class="ot">addr    ::</span> <span class="dt">String</span>  <span class="co">-- ^ ZMQ socket address</span>
  , _<span class="ot">timeout ::</span> <span class="dt">Int</span>     <span class="co">-- ^ Time in milliseconds for socket timeout</span>
  }

<span class="ot">recvTimeout ::</span> <span class="dt">Opts</span> <span class="ot">-&gt;</span> <span class="dt">ZMQ.Socket</span> a <span class="ot">-&gt;</span> <span class="dt">Producer</span> <span class="dt">ByteString</span> (<span class="dt">SafeT</span> <span class="dt">IO</span>) ()
recvTimeout opts sock <span class="fu">=</span> <span class="kw">do</span>
  body <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> timeout (_timeout opts) (ZMQ.receive sock [])
  <span class="kw">case</span> body <span class="kw">of</span>
    <span class="dt">Just</span> msg <span class="ot">-&gt;</span> <span class="kw">do</span>
      liftIO <span class="fu">$</span> ZMQ.send sock msg []
      yield msg
      recvTimeout opts sock
    <span class="dt">Nothing</span>  <span class="ot">-&gt;</span> liftIO <span class="fu">$</span> print <span class="st">&quot;socket timed out&quot;</span>

<span class="ot">collect ::</span> <span class="dt">ZMQ.Context</span>
        <span class="ot">-&gt;</span> <span class="dt">Opts</span>
        <span class="ot">-&gt;</span> <span class="dt">Producer</span> <span class="dt">ByteString</span> (<span class="dt">SafeT</span> <span class="dt">IO</span>) ()
collect ctx opts <span class="fu">=</span> bracket zinit zclose (recvTimeout opts)
  <span class="kw">where</span>
    <span class="co">-- Initialize the socket</span>
    zinit <span class="fu">=</span> <span class="kw">do</span>
      liftIO <span class="fu">$</span> print <span class="st">&quot;waiting for messages&quot;</span>
      sock <span class="ot">&lt;-</span> ZMQ.socket ctx <span class="dt">ZMQ.Rep</span>
      ZMQ.bind sock (_addr opts)
      return sock

    <span class="co">-- On timeout or completion guarantee the socket get closed.</span>
    zclose sock <span class="fu">=</span> <span class="kw">do</span>
      liftIO <span class="fu">$</span> print <span class="st">&quot;finalizing&quot;</span>
      ZMQ.close sock

<span class="ot">runZmq ::</span> <span class="dt">ZMQ.Context</span> <span class="ot">-&gt;</span> <span class="dt">Opts</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
runZmq ctx opts <span class="fu">=</span> runSafeT <span class="fu">$</span> runEffect <span class="fu">$</span>
  collect ctx opts <span class="fu">&gt;-&gt;</span> P.take <span class="dv">10</span> <span class="fu">&gt;-&gt;</span> P.print

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  ctx <span class="ot">&lt;-</span> ZMQ.init <span class="dv">1</span>
  <span class="kw">let</span> opts <span class="fu">=</span> <span class="dt">Opts</span> {_addr <span class="fu">=</span> <span class="st">&quot;tcp://127.0.0.1:8000&quot;</span>, _timeout <span class="fu">=</span> <span class="dv">1000000</span> }
  runZmq ctx opts
  ZMQ.term ctx</code></pre></div>
<h2 id="conduits">Conduits</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">await ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ConduitM</span> i o m (<span class="dt">Maybe</span> i)
<span class="ot">yield ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> o <span class="ot">-&gt;</span> <span class="dt">ConduitM</span> i o m ()
<span class="ot">($$) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Source</span> m a <span class="ot">-&gt;</span> <span class="dt">Sink</span> a m b <span class="ot">-&gt;</span> m b
<span class="ot">(=$) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Conduit</span> a m b <span class="ot">-&gt;</span> <span class="dt">Sink</span> b m c <span class="ot">-&gt;</span> <span class="dt">Sink</span> a m c

<span class="kw">type</span> <span class="dt">Sink</span> i <span class="fu">=</span> <span class="dt">ConduitM</span> i <span class="dt">Void</span>
<span class="kw">type</span> <span class="dt">Source</span> m o <span class="fu">=</span> <span class="dt">ConduitM</span> () o m ()
<span class="kw">type</span> <span class="dt">Conduit</span> i m o <span class="fu">=</span> <span class="dt">ConduitM</span> i o m ()</code></pre></div>
<p>Conduits are conceptually similar though philosophically different approach to the same problem of constant space deterministic resource handling for IO resources.</p>
<p>The first initial difference is that await function now returns a <code>Maybe</code> which allows different handling of termination. The composition operators are also split into a connecting operator (<code>$$</code>) and a fusing operator (<code>=$</code>) for combining Sources and Sink and a Conduit and a Sink respectively.</p>
<div class="sourceCode" include="src/25-streaming/conduit.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE MultiWayIf #-}</span>

<span class="kw">import </span><span class="dt">Data.Conduit</span>
<span class="kw">import </span><span class="dt">Control.Monad.Trans</span>
<span class="kw">import qualified</span> <span class="dt">Data.Conduit.List</span> <span class="kw">as</span> <span class="dt">CL</span>

<span class="ot">source ::</span> <span class="dt">Source</span> <span class="dt">IO</span> <span class="dt">Int</span>
source <span class="fu">=</span> CL.sourceList [<span class="dv">1</span><span class="fu">..</span><span class="dv">100</span>]

<span class="ot">conduit ::</span> <span class="dt">Conduit</span> <span class="dt">Int</span> <span class="dt">IO</span> <span class="dt">String</span>
conduit <span class="fu">=</span> <span class="kw">do</span>
  val <span class="ot">&lt;-</span> await
  liftIO <span class="fu">$</span> print val
  <span class="kw">case</span> val <span class="kw">of</span>
    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> return ()
    <span class="dt">Just</span> n <span class="ot">-&gt;</span> <span class="kw">do</span>
      <span class="kw">if</span> <span class="fu">|</span> n <span class="ot">`mod`</span> <span class="dv">15</span> <span class="fu">==</span> <span class="dv">0</span> <span class="ot">-&gt;</span> yield <span class="st">&quot;FizzBuzz&quot;</span>
         <span class="fu">|</span> n <span class="ot">`mod`</span> <span class="dv">5</span>  <span class="fu">==</span> <span class="dv">0</span> <span class="ot">-&gt;</span> yield <span class="st">&quot;Fizz&quot;</span>
         <span class="fu">|</span> n <span class="ot">`mod`</span> <span class="dv">3</span>  <span class="fu">==</span> <span class="dv">0</span> <span class="ot">-&gt;</span> yield <span class="st">&quot;Buzz&quot;</span>
         <span class="fu">|</span> otherwise       <span class="ot">-&gt;</span> return ()
      conduit

<span class="ot">sink ::</span> <span class="dt">Sink</span> <span class="dt">String</span> <span class="dt">IO</span> ()
sink <span class="fu">=</span> CL.mapM_ putStrLn

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> source <span class="fu">$$</span> conduit <span class="fu">=$</span> sink</code></pre></div>
<p>See: <a href="https://www.fpcomplete.com/user/snoyberg/library-documentation/conduit-overview">Conduit Overview</a></p>
</hr>
<h1 id="cryptography">Cryptography</h1>
<h2 id="cryptonite">cryptonite</h2>
<h2 id="entropy">entropy</h2>
<h2 id="memory">memory</h2>
<h2 id="crypto-pubkey">crypto-pubkey</h2>
<h2 id="crypto-api">crypto-api</h2>
<h2 id="x509">x509</h2>
<h2 id="ed25519">ed25519</h2>
<hr />
<h1 id="compression">Compression</h1>
<h2 id="lz4">lz4</h2>
<h2 id="zlib">zlib</h2>
<hr />
<h1 id="data-formats">Data Formats</h1>
<h2 id="json">JSON</h2>
<p>Aeson is library for efficient parsing and generating JSON. It is the canonical JSON library for handling JSON.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">decode ::</span> <span class="dt">FromJSON</span> a <span class="ot">=&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
<span class="ot">encode ::</span> <span class="dt">ToJSON</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ByteString</span>
<span class="ot">eitherDecode ::</span> <span class="dt">FromJSON</span> a <span class="ot">=&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> a

<span class="ot">fromJSON ::</span> <span class="dt">FromJSON</span> a <span class="ot">=&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Result</span> a
<span class="ot">toJSON ::</span> <span class="dt">ToJSON</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Value</span></code></pre></div>
<p>A point of some subtlety to beginners is that the return types for Aeson functions are <strong>polymorphic in their return types</strong> meaning that the resulting type of decode is specified only in the context of your programs use of the decode function. So if you use decode in a point your program and bind it to a value <code>x</code> and then use <code>x</code> as if it were and integer throughout the rest of your program, Aeson will select the typeclass instance which parses the given input string into a Haskell integer.</p>
<ul>
<li><a href="https://hackage.haskell.org/package/aeson"><strong>Aeson Library</strong></a></li>
</ul>
<h4 id="value">Value</h4>
<p>Aeson uses several high performance data structures (Vector, Text, HashMap) by default instead of the naive versions so typically using Aeson will require that us import them and use <code>OverloadedStrings</code> when indexing into objects.</p>
<p>The underlying Aeson structure is called <code>Value</code> and encodes a recursive tree structure that models the semantics of untyped JSON objects by mapping them onto a large sum type which embodies all possible JSON values.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Object</span> <span class="fu">=</span> <span class="dt">HashMap</span> <span class="dt">Text</span> <span class="dt">Value</span>

<span class="kw">type</span> <span class="dt">Array</span> <span class="fu">=</span> <span class="dt">Vector</span> <span class="dt">Value</span>

<span class="co">-- | A JSON value represented as a Haskell value.</span>
<span class="kw">data</span> <span class="dt">Value</span>
  <span class="fu">=</span> <span class="dt">Object</span> <span class="fu">!</span><span class="dt">Object</span>
  <span class="fu">|</span> <span class="dt">Array</span> <span class="fu">!</span><span class="dt">Array</span>
  <span class="fu">|</span> <span class="dt">String</span> <span class="fu">!</span><span class="dt">Text</span>
  <span class="fu">|</span> <span class="dt">Number</span> <span class="fu">!</span><span class="dt">Scientific</span>
  <span class="fu">|</span> <span class="dt">Bool</span> <span class="fu">!</span><span class="dt">Bool</span>
  <span class="fu">|</span> <span class="dt">Null</span></code></pre></div>
<p>For instance the Value expansion of the following JSON blob:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="op">{</span>
  <span class="st">&quot;a&quot;</span><span class="op">:</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]<span class="op">,</span>
  <span class="st">&quot;b&quot;</span><span class="op">:</span> <span class="dv">1</span>
<span class="op">}</span></code></pre></div>
<p>Is represented in Aeson as the <code>Value</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Object</span>
   (fromList
      [ ( <span class="st">&quot;a&quot;</span>
        , <span class="dt">Array</span> (fromList [ <span class="dt">Number</span> <span class="fl">1.0</span> , <span class="dt">Number</span> <span class="fl">2.0</span> , <span class="dt">Number</span> <span class="fl">3.0</span> ])
        )
      , ( <span class="st">&quot;b&quot;</span> , <span class="dt">Number</span> <span class="fl">1.0</span> )
      ])</code></pre></div>
<p>Let's consider some larger examples, we'll work with this contrived example JSON:</p>
<div class="sourceCode" include="src/26-data-formats/example.json"><pre class="sourceCode json"><code class="sourceCode json"><span class="fu">{</span>
    <span class="dt">&quot;id&quot;</span><span class="fu">:</span> <span class="dv">1</span><span class="fu">,</span>
    <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;A green door&quot;</span><span class="fu">,</span>
    <span class="dt">&quot;price&quot;</span><span class="fu">:</span> <span class="fl">12.50</span><span class="fu">,</span>
    <span class="dt">&quot;tags&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;home&quot;</span><span class="ot">,</span> <span class="st">&quot;green&quot;</span><span class="ot">]</span><span class="fu">,</span>
    <span class="dt">&quot;refs&quot;</span><span class="fu">:</span> <span class="fu">{</span>
      <span class="dt">&quot;a&quot;</span><span class="fu">:</span> <span class="st">&quot;red&quot;</span><span class="fu">,</span>
      <span class="dt">&quot;b&quot;</span><span class="fu">:</span> <span class="st">&quot;blue&quot;</span>
    <span class="fu">}</span>
<span class="fu">}</span></code></pre></div>
<h4 id="unstructured-json">Unstructured JSON</h4>
<p>In dynamic scripting languages it's common to parse amorphous blobs of JSON without any a priori structure and then handle validation problems by throwing exceptions while traversing it. We can do the same using Aeson and the Maybe monad.</p>
<div class="sourceCode" include="src/26-data-formats/aeson_unstructured.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Data.Text</span>
<span class="kw">import </span><span class="dt">Data.Aeson</span>
<span class="kw">import </span><span class="dt">Data.Vector</span>
<span class="kw">import qualified</span> <span class="dt">Data.HashMap.Strict</span> <span class="kw">as</span> <span class="dt">M</span>
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">BL</span>

<span class="co">-- Pull a key out of an JSON object.</span>
<span class="ot">(^?) ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Value</span>
(<span class="fu">^?</span>) (<span class="dt">Object</span> obj) k <span class="fu">=</span> M.lookup k obj
(<span class="fu">^?</span>) _ _ <span class="fu">=</span> <span class="dt">Nothing</span>

<span class="co">-- Pull the ith value out of a JSON list.</span>
<span class="ot">ix ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Value</span>
ix (<span class="dt">Array</span> arr) i <span class="fu">=</span> arr <span class="fu">!?</span> i
ix _ _ <span class="fu">=</span> <span class="dt">Nothing</span>

readJSON str <span class="fu">=</span> <span class="kw">do</span>
  obj <span class="ot">&lt;-</span> decode str
  price <span class="ot">&lt;-</span> obj <span class="fu">^?</span> <span class="st">&quot;price&quot;</span>
  refs  <span class="ot">&lt;-</span> obj <span class="fu">^?</span> <span class="st">&quot;refs&quot;</span>
  tags  <span class="ot">&lt;-</span> obj <span class="fu">^?</span> <span class="st">&quot;tags&quot;</span>
  aref  <span class="ot">&lt;-</span> refs <span class="fu">^?</span> <span class="st">&quot;a&quot;</span>
  tag1  <span class="ot">&lt;-</span> tags <span class="ot">`ix`</span> <span class="dv">0</span>
  return (price, aref, tag1)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  contents <span class="ot">&lt;-</span> BL.readFile <span class="st">&quot;example.json&quot;</span>
  print <span class="fu">$</span> readJSON contents</code></pre></div>
<h4 id="structured-json">Structured JSON</h4>
<p>This isn't ideal since we've just smeared all the validation logic across our traversal logic instead of separating concerns and handling validation in separate logic. We'd like to describe the structure before-hand and the invalid case separately. Using Generic also allows Haskell to automatically write the serializer and deserializer between our datatype and the JSON string based on the names of record field names.</p>
<div class="sourceCode" include="src/26-data-formats/aeson_structured.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span>

<span class="kw">import </span><span class="dt">Data.Text</span>
<span class="kw">import </span><span class="dt">Data.Aeson</span>
<span class="kw">import </span><span class="dt">GHC.Generics</span>
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">BL</span>

<span class="kw">import </span><span class="dt">Control.Applicative</span>

<span class="kw">data</span> <span class="dt">Refs</span> <span class="fu">=</span> <span class="dt">Refs</span>
  {<span class="ot"> a ::</span> <span class="dt">Text</span>
  ,<span class="ot"> b ::</span> <span class="dt">Text</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Generic</span>)

<span class="kw">data</span> <span class="dt">Data</span> <span class="fu">=</span> <span class="dt">Data</span>
  {<span class="ot"> id    ::</span> <span class="dt">Int</span>
  ,<span class="ot"> name  ::</span> <span class="dt">Text</span>
  ,<span class="ot"> price ::</span> <span class="dt">Int</span>
  ,<span class="ot"> tags  ::</span> [<span class="dt">Text</span>]
  ,<span class="ot"> refs  ::</span> <span class="dt">Refs</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Generic</span>)

<span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Data</span>
<span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Refs</span>
<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Data</span>
<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Refs</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  contents <span class="ot">&lt;-</span> BL.readFile <span class="st">&quot;example.json&quot;</span>
  <span class="kw">let</span> <span class="dt">Just</span> dat <span class="fu">=</span> decode contents
  print <span class="fu">$</span> name dat
  print <span class="fu">$</span> a (refs dat)</code></pre></div>
<p>Now we get our validated JSON wrapped up into a nicely typed Haskell ADT.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Data</span>
  { id <span class="fu">=</span> <span class="dv">1</span>
  , name <span class="fu">=</span> <span class="st">&quot;A green door&quot;</span>
  , price <span class="fu">=</span> <span class="dv">12</span>
  , tags <span class="fu">=</span> [ <span class="st">&quot;home&quot;</span> , <span class="st">&quot;green&quot;</span> ]
  , refs <span class="fu">=</span> <span class="dt">Refs</span> { a <span class="fu">=</span> <span class="st">&quot;red&quot;</span> , b <span class="fu">=</span> <span class="st">&quot;blue&quot;</span> }
  }</code></pre></div>
<p>The functions <code>fromJSON</code> and <code>toJSON</code> can be used to convert between this sum type and regular Haskell types with.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Result</span> a <span class="fu">=</span> <span class="dt">Error</span> <span class="dt">String</span> <span class="fu">|</span> <span class="dt">Success</span> a</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> fromJSON (<span class="dt">Bool</span> <span class="dt">True</span>)<span class="ot"> ::</span> <span class="dt">Result</span> <span class="dt">Bool</span>
<span class="dt">Success</span> <span class="dt">True</span>

λ<span class="fu">:</span> fromJSON (<span class="dt">Bool</span> <span class="dt">True</span>)<span class="ot"> ::</span> <span class="dt">Result</span> <span class="dt">Double</span>
<span class="dt">Error</span> <span class="st">&quot;when expecting a Double, encountered Boolean instead&quot;</span></code></pre></div>
<p>As of 7.10.2 we can use the new -XDeriveAnyClass to automatically derive instances of FromJSON and TOJSON without the need for standalone instance declarations. These are implemented entirely in terms of the default methods which use Generics under the hood.</p>
<div class="sourceCode" include="src/26-data-formats/aeson_derive.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span>
<span class="ot">{-# LANGUAGE DeriveAnyClass #-}</span>

<span class="kw">import </span><span class="dt">Data.Text</span>
<span class="kw">import </span><span class="dt">Data.Aeson</span>
<span class="kw">import </span><span class="dt">GHC.Generics</span>
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">BL</span>

<span class="kw">data</span> <span class="dt">Refs</span> <span class="fu">=</span> <span class="dt">Refs</span>
  {<span class="ot"> a ::</span> <span class="dt">Text</span>
  ,<span class="ot"> b ::</span> <span class="dt">Text</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Generic</span>,<span class="dt">FromJSON</span>,<span class="dt">ToJSON</span>)

<span class="kw">data</span> <span class="dt">Data</span> <span class="fu">=</span> <span class="dt">Data</span>
  {<span class="ot"> id    ::</span> <span class="dt">Int</span>
  ,<span class="ot"> name  ::</span> <span class="dt">Text</span>
  ,<span class="ot"> price ::</span> <span class="dt">Int</span>
  ,<span class="ot"> tags  ::</span> [<span class="dt">Text</span>]
  ,<span class="ot"> refs  ::</span> <span class="dt">Refs</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Generic</span>,<span class="dt">FromJSON</span>,<span class="dt">ToJSON</span>)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  contents <span class="ot">&lt;-</span> BL.readFile <span class="st">&quot;example.json&quot;</span>
  <span class="kw">let</span> <span class="dt">Just</span> dat <span class="fu">=</span> decode contents
  print <span class="fu">$</span> name dat
  print <span class="fu">$</span> a (refs dat)
  BL.putStrLn <span class="fu">$</span> encode dat</code></pre></div>
<h4 id="hand-written-instances">Hand Written Instances</h4>
<p>While it's useful to use generics to derive instances, sometimes you actually want more fine grained control over serialization and de serialization. So we fall back on writing ToJSON and FromJSON instances manually. Using FromJSON we can project into hashmap using the <code>(.:)</code> operator to extract keys. If the key fails to exist the parser will abort with a key failure message. The ToJSON instances can never fail and simply require us to pattern match on our custom datatype and generate an appropriate value.</p>
<p>The law that the FromJSON and ToJSON classes should maintain is that <code>encode . decode</code> and <code>decode . encode</code> should map to the same object. Although in practice there many times when we break this rule and especially if the serialize or de serialize is one way.</p>
<div class="sourceCode" include="src/26-data-formats/aeson_custom.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span>

<span class="kw">import </span><span class="dt">Data.Text</span>
<span class="kw">import </span><span class="dt">Data.Aeson</span>
<span class="kw">import </span><span class="dt">Data.Maybe</span>
<span class="kw">import </span><span class="dt">Data.Aeson.Types</span>
<span class="kw">import </span><span class="dt">Control.Applicative</span>
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">BL</span>

<span class="kw">data</span> <span class="dt">Crew</span> <span class="fu">=</span> <span class="dt">Crew</span>
  {<span class="ot"> name  ::</span> <span class="dt">Text</span>
  ,<span class="ot"> rank  ::</span> <span class="dt">Rank</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="kw">data</span> <span class="dt">Rank</span>
  <span class="fu">=</span> <span class="dt">Captain</span>
  <span class="fu">|</span> <span class="dt">Ensign</span>
  <span class="fu">|</span> <span class="dt">Lieutenant</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="co">-- Custom JSON Deserializer</span>

<span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Crew</span> <span class="kw">where</span>
  parseJSON (<span class="dt">Object</span> o) <span class="fu">=</span> <span class="kw">do</span>
    _name <span class="ot">&lt;-</span> o <span class="fu">.:</span> <span class="st">&quot;name&quot;</span>
    _rank <span class="ot">&lt;-</span> o <span class="fu">.:</span> <span class="st">&quot;rank&quot;</span>
    pure (<span class="dt">Crew</span> _name _rank)

<span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Rank</span> <span class="kw">where</span>
  parseJSON (<span class="dt">String</span> s) <span class="fu">=</span> <span class="kw">case</span> s <span class="kw">of</span>
    <span class="st">&quot;Captain&quot;</span>    <span class="ot">-&gt;</span> pure <span class="dt">Captain</span>
    <span class="st">&quot;Ensign&quot;</span>     <span class="ot">-&gt;</span> pure <span class="dt">Ensign</span>
    <span class="st">&quot;Lieutenant&quot;</span> <span class="ot">-&gt;</span> pure <span class="dt">Lieutenant</span>
    _            <span class="ot">-&gt;</span> typeMismatch <span class="st">&quot;Could not parse Rank&quot;</span> (<span class="dt">String</span> s)
  parseJSON x <span class="fu">=</span> typeMismatch <span class="st">&quot;Expected String&quot;</span> x

<span class="co">-- Custom JSON Serializer</span>

<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Crew</span> <span class="kw">where</span>
  toJSON (<span class="dt">Crew</span> name rank) <span class="fu">=</span> object [
      <span class="st">&quot;name&quot;</span> <span class="fu">.=</span> name
    , <span class="st">&quot;rank&quot;</span> <span class="fu">.=</span> rank
    ]

<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Rank</span> <span class="kw">where</span>
  toJSON <span class="dt">Captain</span>    <span class="fu">=</span> <span class="dt">String</span> <span class="st">&quot;Captain&quot;</span>
  toJSON <span class="dt">Ensign</span>     <span class="fu">=</span> <span class="dt">String</span> <span class="st">&quot;Ensign&quot;</span>
  toJSON <span class="dt">Lieutenant</span> <span class="fu">=</span> <span class="dt">String</span> <span class="st">&quot;Lieutenant&quot;</span>


<span class="ot">roundTrips ::</span> <span class="dt">Crew</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
roundTrips <span class="fu">=</span> isJust <span class="fu">.</span> go
  <span class="kw">where</span>
<span class="ot">    go ::</span> <span class="dt">Crew</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Crew</span>
    go <span class="fu">=</span> decode <span class="fu">.</span> encode


<span class="ot">picard ::</span> <span class="dt">Crew</span>
picard <span class="fu">=</span> <span class="dt">Crew</span> { name <span class="fu">=</span> <span class="st">&quot;Jean-Luc Picard&quot;</span>, rank <span class="fu">=</span> <span class="dt">Captain</span> }

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  contents <span class="ot">&lt;-</span> BL.readFile <span class="st">&quot;crew.json&quot;</span>
  <span class="kw">let</span> (<span class="ot">res ::</span> <span class="dt">Maybe</span> <span class="dt">Crew</span>) <span class="fu">=</span> decode contents
  print res
  print <span class="fu">$</span> roundTrips picard</code></pre></div>
<p>See: <a href="http://hackage.haskell.org/package/aeson">Aeson Documentation</a></p>
<h2 id="yaml">Yaml</h2>
<p>Yaml is a textual serialization format similar to JSON. It uses an indentation sensitive structure to encode nested maps of keys and values. The Yaml interface for Haskell is a precise copy of <code>Data.Aeson</code></p>
<ul>
<li><a href="https://hackage.haskell.org/package/yaml"><strong>Yaml Library</strong></a></li>
</ul>
<div class="sourceCode" include="src/26-data-formats/example.yaml"><pre class="sourceCode haskell"><code class="sourceCode haskell">invoice<span class="fu">:</span> <span class="dv">34843</span>
date   <span class="fu">:</span> <span class="dv">2001</span><span class="fu">-</span><span class="dv">01</span><span class="fu">-</span><span class="dv">23</span>
bill<span class="fu">:</span> 
    given  <span class="fu">:</span> <span class="dt">Chris</span>
    family <span class="fu">:</span> <span class="dt">Dumars</span>
    address<span class="fu">:</span>
        lines<span class="fu">:</span> <span class="fu">|</span>
            <span class="dv">458</span> <span class="dt">Walkman</span> <span class="dt">Dr</span><span class="fu">.</span>
            <span class="dt">Suite</span> <span class="fu">#</span><span class="dv">292</span>
        city    <span class="fu">:</span> <span class="dt">Royal</span> <span class="dt">Oak</span>
        state   <span class="fu">:</span> <span class="dt">MI</span>
        postal  <span class="fu">:</span> <span class="dv">48046</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Object</span>
  (fromList
     [ ( <span class="st">&quot;invoice&quot;</span> , <span class="dt">Number</span> <span class="fl">34843.0</span> )
     , ( <span class="st">&quot;date&quot;</span> , <span class="dt">String</span> <span class="st">&quot;2001-01-23&quot;</span> )
     , ( <span class="st">&quot;bill-to&quot;</span>
       , <span class="dt">Object</span>
           (fromList
              [ ( <span class="st">&quot;address&quot;</span>
                , <span class="dt">Object</span>
                    (fromList
                       [ ( <span class="st">&quot;state&quot;</span> , <span class="dt">String</span> <span class="st">&quot;MI&quot;</span> )
                       , ( <span class="st">&quot;lines&quot;</span> , <span class="dt">String</span> <span class="st">&quot;458 Walkman Dr.\nSuite #292\n&quot;</span> )
                       , ( <span class="st">&quot;city&quot;</span> , <span class="dt">String</span> <span class="st">&quot;Royal Oak&quot;</span> )
                       , ( <span class="st">&quot;postal&quot;</span> , <span class="dt">Number</span> <span class="fl">48046.0</span> )
                       ])
                )
              , ( <span class="st">&quot;family&quot;</span> , <span class="dt">String</span> <span class="st">&quot;Dumars&quot;</span> )
              , ( <span class="st">&quot;given&quot;</span> , <span class="dt">String</span> <span class="st">&quot;Chris&quot;</span> )
              ])
       )
     ])</code></pre></div>
<p>To parse this file we use the following datatypes and functions:</p>
<div class="sourceCode" include="src/26-data-formats/yaml.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span>
<span class="ot">{-# LANGUAGE DeriveAnyClass #-}</span>
<span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span>

<span class="kw">import </span><span class="dt">Data.Yaml</span>

<span class="kw">import </span><span class="dt">Data.Text</span> (<span class="dt">Text</span>)
<span class="kw">import qualified</span> <span class="dt">Data.ByteString</span> <span class="kw">as</span> <span class="dt">BL</span>

<span class="kw">import </span><span class="dt">GHC.Generics</span>

<span class="kw">data</span> <span class="dt">Invoice</span> <span class="fu">=</span> <span class="dt">Invoice</span>
  {<span class="ot"> invoice ::</span> <span class="dt">Int</span>
  ,<span class="ot"> date ::</span> <span class="dt">Text</span>
  ,<span class="ot"> bill ::</span> <span class="dt">Billing</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Generic</span>,<span class="dt">FromJSON</span>)

<span class="kw">data</span> <span class="dt">Billing</span> <span class="fu">=</span> <span class="dt">Billing</span>
  {<span class="ot"> address ::</span> <span class="dt">Address</span>
  ,<span class="ot"> family ::</span> <span class="dt">Text</span>
  ,<span class="ot"> given ::</span> <span class="dt">Text</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Generic</span>,<span class="dt">FromJSON</span>)

<span class="kw">data</span> <span class="dt">Address</span> <span class="fu">=</span> <span class="dt">Address</span>
  {<span class="ot"> lines ::</span> <span class="dt">Text</span>
  ,<span class="ot"> city ::</span> <span class="dt">Text</span>
  ,<span class="ot"> state ::</span> <span class="dt">Text</span>
  ,<span class="ot"> postal ::</span> <span class="dt">Int</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Generic</span>,<span class="dt">FromJSON</span>)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  contents <span class="ot">&lt;-</span> BL.readFile <span class="st">&quot;example.yaml&quot;</span>
  <span class="kw">let</span> (<span class="ot">res ::</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Invoice</span>) <span class="fu">=</span> decodeEither contents
  <span class="kw">case</span> res <span class="kw">of</span>
    <span class="dt">Right</span> val <span class="ot">-&gt;</span> print val
    <span class="dt">Left</span> err <span class="ot">-&gt;</span> putStrLn err</code></pre></div>
<p>Which generates:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Invoice</span>
  { invoice <span class="fu">=</span> <span class="dv">34843</span>
  , date <span class="fu">=</span> <span class="st">&quot;2001-01-23&quot;</span>
  , bill <span class="fu">=</span>
      <span class="dt">Billing</span>
        { address <span class="fu">=</span>
            <span class="dt">Address</span>
              { lines <span class="fu">=</span> <span class="st">&quot;458 Walkman Dr.\nSuite #292\n&quot;</span>
              , city <span class="fu">=</span> <span class="st">&quot;Royal Oak&quot;</span>
              , state <span class="fu">=</span> <span class="st">&quot;MI&quot;</span>
              , postal <span class="fu">=</span> <span class="dv">48046</span>
              }
        , family <span class="fu">=</span> <span class="st">&quot;Dumars&quot;</span>
        , given <span class="fu">=</span> <span class="st">&quot;Chris&quot;</span>
        }
  }</code></pre></div>
<h2 id="csv">CSV</h2>
<p>Cassava is an efficient CSV parser library. We'll work with this tiny snippet from the iris dataset:</p>
<ul>
<li><a href="https://hackage.haskell.org/package/cassava"><strong>Cassava Library</strong></a></li>
</ul>
<div class="sourceCode" include="src/26-data-formats/iris.csv"><pre class="sourceCode perl"><code class="sourceCode perl">sepal_length,sepal_width,petal_length,petal_width,plant_class
<span class="fl">5.1</span>,<span class="fl">3.5</span>,<span class="fl">1.4</span>,<span class="fl">0.2</span>,Iris-setosa
<span class="fl">5.0</span>,<span class="fl">2.0</span>,<span class="fl">3.5</span>,<span class="fl">1.0</span>,Iris-versicolor
<span class="fl">6.3</span>,<span class="fl">3.3</span>,<span class="fl">6.0</span>,<span class="fl">2.5</span>,Iris-virginica</code></pre></div>
<h4 id="unstructured-csv">Unstructured CSV</h4>
<p>Just like with Aeson if we really want to work with unstructured data the library accommodates this.</p>
<div class="sourceCode" include="src/26-data-formats/cassava_unstructured.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Csv</span>

<span class="kw">import </span><span class="dt">Text.Show.Pretty</span>

<span class="kw">import qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">V</span>
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">BL</span>

<span class="kw">type</span> <span class="dt">ErrorMsg</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">CsvData</span> <span class="fu">=</span> <span class="dt">V.Vector</span> (<span class="dt">V.Vector</span> <span class="dt">BL.ByteString</span>)

<span class="ot">example ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">ErrorMsg</span> <span class="dt">CsvData</span>)
example fname <span class="fu">=</span> <span class="kw">do</span>
  contents <span class="ot">&lt;-</span> BL.readFile fname
  return <span class="fu">$</span> decode <span class="dt">NoHeader</span> contents</code></pre></div>
<p>We see we get the nested set of stringy vectors:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[ [ <span class="st">&quot;sepal_length&quot;</span>
  , <span class="st">&quot;sepal_width&quot;</span>
  , <span class="st">&quot;petal_length&quot;</span>
  , <span class="st">&quot;petal_width&quot;</span>
  , <span class="st">&quot;plant_class&quot;</span>
  ]
, [ <span class="st">&quot;5.1&quot;</span> , <span class="st">&quot;3.5&quot;</span> , <span class="st">&quot;1.4&quot;</span> , <span class="st">&quot;0.2&quot;</span> , <span class="st">&quot;Iris-setosa&quot;</span> ]
, [ <span class="st">&quot;5.0&quot;</span> , <span class="st">&quot;2.0&quot;</span> , <span class="st">&quot;3.5&quot;</span> , <span class="st">&quot;1.0&quot;</span> , <span class="st">&quot;Iris-versicolor&quot;</span> ]
, [ <span class="st">&quot;6.3&quot;</span> , <span class="st">&quot;3.3&quot;</span> , <span class="st">&quot;6.0&quot;</span> , <span class="st">&quot;2.5&quot;</span> , <span class="st">&quot;Iris-virginica&quot;</span> ]
]</code></pre></div>
<h4 id="structured-csv">Structured CSV</h4>
<p>Just like with Aeson we can use Generic to automatically write the deserializer between our CSV data and our custom datatype.</p>
<div class="sourceCode" include="src/26-data-formats/cassava_structured.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="ot">{-# LANGUAGE DeriveGeneric #-}</span>

<span class="kw">import </span><span class="dt">Data.Csv</span>
<span class="kw">import </span><span class="dt">GHC.Generics</span>
<span class="kw">import qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">V</span>
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">BL</span>

<span class="kw">data</span> <span class="dt">Plant</span> <span class="fu">=</span> <span class="dt">Plant</span>
  {<span class="ot"> sepal_length ::</span> <span class="dt">Double</span>
  ,<span class="ot"> sepal_width  ::</span> <span class="dt">Double</span>
  ,<span class="ot"> petal_length ::</span> <span class="dt">Double</span>
  ,<span class="ot"> petal_width  ::</span> <span class="dt">Double</span>
  ,<span class="ot"> plant_class ::</span> <span class="dt">String</span>
  } <span class="kw">deriving</span> (<span class="dt">Generic</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">FromNamedRecord</span> <span class="dt">Plant</span>
<span class="kw">instance</span> <span class="dt">ToNamedRecord</span> <span class="dt">Plant</span>

<span class="kw">type</span> <span class="dt">ErrorMsg</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">CsvData</span> <span class="fu">=</span> (<span class="dt">Header</span>, <span class="dt">V.Vector</span> <span class="dt">Plant</span>)

<span class="ot">parseCSV ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">ErrorMsg</span> <span class="dt">CsvData</span>)
parseCSV fname <span class="fu">=</span> <span class="kw">do</span>
  contents <span class="ot">&lt;-</span> BL.readFile fname
  return <span class="fu">$</span> decodeByName contents

main <span class="fu">=</span> parseCSV <span class="st">&quot;iris.csv&quot;</span> <span class="fu">&gt;&gt;=</span> print</code></pre></div>
<p>And again we get a nice typed ADT as a result.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[ <span class="dt">Plant</span>
    { sepal_length <span class="fu">=</span> <span class="fl">5.1</span>
    , sepal_width <span class="fu">=</span> <span class="fl">3.5</span>
    , petal_length <span class="fu">=</span> <span class="fl">1.4</span>
    , petal_width <span class="fu">=</span> <span class="fl">0.2</span>
    , plant_class <span class="fu">=</span> <span class="st">&quot;Iris-setosa&quot;</span>
    }
, <span class="dt">Plant</span>
    { sepal_length <span class="fu">=</span> <span class="fl">5.0</span>
    , sepal_width <span class="fu">=</span> <span class="fl">2.0</span>
    , petal_length <span class="fu">=</span> <span class="fl">3.5</span>
    , petal_width <span class="fu">=</span> <span class="fl">1.0</span>
    , plant_class <span class="fu">=</span> <span class="st">&quot;Iris-versicolor&quot;</span>
    }
, <span class="dt">Plant</span>
    { sepal_length <span class="fu">=</span> <span class="fl">6.3</span>
    , sepal_width <span class="fu">=</span> <span class="fl">3.3</span>
    , petal_length <span class="fu">=</span> <span class="fl">6.0</span>
    , petal_width <span class="fu">=</span> <span class="fl">2.5</span>
    , plant_class <span class="fu">=</span> <span class="st">&quot;Iris-virginica&quot;</span>
    }
]</code></pre></div>
</hr>
<h1 id="network-web-programming">Network &amp; Web Programming</h1>
<h2 id="http">HTTP</h2>
<p>Haskell has a variety of HTTP request and processing libraries. The simplest and most flexible is the <a href="https://hackage.haskell.org/package/HTTP">HTTP library</a>.</p>
<div class="sourceCode" include="src/27-web/http.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Network.HTTP.Types</span>
<span class="kw">import </span><span class="dt">Network.HTTP.Client</span>
<span class="kw">import </span><span class="dt">Control.Applicative</span>
<span class="kw">import </span><span class="dt">Control.Concurrent.Async</span>

<span class="kw">type</span> <span class="dt">URL</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="ot">get ::</span> <span class="dt">Manager</span> <span class="ot">-&gt;</span> <span class="dt">URL</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int</span>
get m url <span class="fu">=</span> <span class="kw">do</span>
  req <span class="ot">&lt;-</span> parseUrl url
  statusCode <span class="fu">&lt;$&gt;</span> responseStatus <span class="fu">&lt;$&gt;</span> httpNoBody req m

<span class="ot">single ::</span> <span class="dt">IO</span> <span class="dt">Int</span>
single <span class="fu">=</span> <span class="kw">do</span>
  withManager defaultManagerSettings <span class="fu">$</span> \m <span class="ot">-&gt;</span> <span class="kw">do</span>
    get m <span class="st">&quot;http://haskell.org&quot;</span>

<span class="ot">parallel ::</span> <span class="dt">IO</span> [<span class="dt">Int</span>]
parallel <span class="fu">=</span> <span class="kw">do</span>
  withManager defaultManagerSettings <span class="fu">$</span> \m <span class="ot">-&gt;</span> <span class="kw">do</span>
    <span class="co">-- Fetch w3.org 10 times concurrently</span>
    <span class="kw">let</span> urls <span class="fu">=</span> replicate <span class="dv">10</span> <span class="st">&quot;http://www.w3.org&quot;</span>
    mapConcurrently (get m) urls

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  print <span class="fu">=&lt;&lt;</span> single
  print <span class="fu">=&lt;&lt;</span> parallel</code></pre></div>
<h2 id="blaze">Blaze</h2>
<p>Blaze is an HTML combinator library that provides that capacity to build composable bits of HTML programmatically. It doesn't string templating libraries like <a href="#hastache">Hastache</a> but instead provides an API for building up HTML documents from logic where the format out of the output is generated procedurally.</p>
<p>For sequencing HTML elements the elements can either be sequenced in a monad or with monoid operations.</p>
<div class="sourceCode" include="src/27-web/blaze.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">module</span> <span class="dt">Html</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Text.Blaze.Html5</span>
<span class="kw">import </span><span class="dt">Text.Blaze.Html.Renderer.Text</span>

<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy.IO</span> <span class="kw">as</span> <span class="dt">T</span>

<span class="ot">example ::</span> <span class="dt">Html</span>
example <span class="fu">=</span> <span class="kw">do</span>
  h1 <span class="st">&quot;First header&quot;</span>
  p <span class="fu">$</span> ul <span class="fu">$</span> mconcat [li <span class="st">&quot;First&quot;</span>, li <span class="st">&quot;Second&quot;</span>]

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  T.putStrLn <span class="fu">$</span> renderHtml example</code></pre></div>
<p>For custom datatypes we can implement the <code>ToMarkup</code>class to convert between Haskell data structures and HTML representation.</p>
<div class="sourceCode" include="src/27-web/blaze_instance.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RecordWildCards #-}</span>
<span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">module</span> <span class="dt">Html</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Text.Blaze.Html5</span>
<span class="kw">import </span><span class="dt">Text.Blaze.Html.Renderer.Text</span>

<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy.IO</span> <span class="kw">as</span> <span class="dt">T</span>

<span class="kw">data</span> <span class="dt">Employee</span> <span class="fu">=</span> <span class="dt">Employee</span>
  {<span class="ot"> name ::</span> <span class="dt">T.Text</span>
  ,<span class="ot"> age ::</span> <span class="dt">Int</span>
  }

<span class="kw">instance</span> <span class="dt">ToMarkup</span> <span class="dt">Employee</span> <span class="kw">where</span>
  toMarkup <span class="dt">Employee</span> {<span class="fu">..</span>} <span class="fu">=</span> ul <span class="fu">$</span> mconcat
    [ li (toHtml name)
    , li (toHtml age)
    ]

<span class="ot">fred ::</span> <span class="dt">Employee</span>
fred <span class="fu">=</span> <span class="dt">Employee</span> { name <span class="fu">=</span> <span class="st">&quot;Fred&quot;</span>, age <span class="fu">=</span> <span class="dv">35</span> }

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  T.putStrLn <span class="fu">$</span> renderHtml (toHtml fred)</code></pre></div>
<h2 id="warp">Warp</h2>
<p>Warp is a efficient web server, it's the backend request engine behind several of popular Haskell web frameworks. The internals have been finely tuned to utilize Haskell's concurrent runtime and is capable of handling a great deal of concurrent requests.</p>
<div class="sourceCode" include="src/27-web/warp.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Network.Wai</span>
<span class="kw">import </span><span class="dt">Network.Wai.Handler.Warp</span> (run)
<span class="kw">import </span><span class="dt">Network.HTTP.Types</span>

<span class="ot">app ::</span> <span class="dt">Application</span>
app req <span class="fu">=</span> return <span class="fu">$</span> responseLBS status200 [] <span class="st">&quot;Engage!&quot;</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> run <span class="dv">8000</span> app</code></pre></div>
<p>See: <a href="http://aosabook.org/en/posa/warp.html">Warp</a></p>
<h2 id="scotty">Scotty</h2>
<p>Continuing with our trek through web libraries, Scotty is a web microframework similar in principle to Flask in Python or Sinatra in Ruby.</p>
<div class="sourceCode" include="src/27-web/scotty.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Web.Scotty</span>

<span class="kw">import qualified</span> <span class="dt">Text.Blaze.Html5</span> <span class="kw">as</span> <span class="dt">H</span>
<span class="kw">import </span><span class="dt">Text.Blaze.Html5</span> (toHtml, <span class="dt">Html</span>)
<span class="kw">import </span><span class="dt">Text.Blaze.Html.Renderer.Text</span> (renderHtml)

<span class="ot">greet ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Html</span>
greet user <span class="fu">=</span> H.html <span class="fu">$</span> <span class="kw">do</span>
  H.head <span class="fu">$</span>
    H.title <span class="st">&quot;Welcome!&quot;</span>
  H.body <span class="fu">$</span> <span class="kw">do</span>
    H.h1 <span class="st">&quot;Greetings!&quot;</span>
    H.p (<span class="st">&quot;Hello &quot;</span> <span class="fu">&gt;&gt;</span> toHtml user <span class="fu">&gt;&gt;</span> <span class="st">&quot;!&quot;</span>)

app <span class="fu">=</span> <span class="kw">do</span>
  get <span class="st">&quot;/&quot;</span> <span class="fu">$</span>
    text <span class="st">&quot;Home Page&quot;</span>

  get <span class="st">&quot;/greet/:name&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
    name <span class="ot">&lt;-</span> param <span class="st">&quot;name&quot;</span>
    html <span class="fu">$</span> renderHtml (greet name)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> scotty <span class="dv">8000</span> app</code></pre></div>
<p>Of importance to note is the Blaze library used here overloads do-notation but is not itself a proper monad so the various laws and invariants that normally apply for monads may break down or fail with error terms.</p>
<p>See: <a href="http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html">Making a Website with Haskell</a></p>
<h2 id="servant">Servant</h2>
<h2 id="hastache">Hastache</h2>
<p>Hastache is string templating based on the &quot;Mustache&quot; style of encoding metavariables with double braces <code>{{ x }}</code>. Hastache supports automatically converting many Haskell types into strings and uses the efficient Text functions for formatting.</p>
<p>The variables loaded into the template are specified in either a function mapping variable names to printable MuType values. For instance using a function.</p>
<div class="sourceCode" include="src/27-web/hastache.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Text.Hastache</span>
<span class="kw">import </span><span class="dt">Text.Hastache.Context</span>

<span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy</span> <span class="kw">as</span> <span class="dt">TL</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy.IO</span> <span class="kw">as</span> <span class="dt">TL</span>

<span class="kw">import </span><span class="dt">Data.Data</span>

<span class="ot">template ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">MuContext</span> <span class="dt">IO</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">TL.Text</span>
template <span class="fu">=</span> hastacheFile defaultConfig

<span class="co">-- Function strContext</span>
<span class="ot">context ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">MuType</span> <span class="dt">IO</span>
context <span class="st">&quot;body&quot;</span>  <span class="fu">=</span> <span class="dt">MuVariable</span> (<span class="st">&quot;Hello World&quot;</span><span class="ot"> ::</span> <span class="dt">TL.Text</span>)
context <span class="st">&quot;title&quot;</span> <span class="fu">=</span> <span class="dt">MuVariable</span> (<span class="st">&quot;Haskell is lovely&quot;</span><span class="ot"> ::</span> <span class="dt">TL.Text</span>)
context _       <span class="fu">=</span> <span class="dt">MuVariable</span> ()

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  output <span class="ot">&lt;-</span> template <span class="st">&quot;templates/home.html&quot;</span> (mkStrContext context)
  TL.putStrLn output</code></pre></div>
<p>Or using Data-Typeable record and <code>mkGenericContext</code>, the Haskell field names are converted into variable names.</p>
<div class="sourceCode" include="src/27-web/hastache_generic.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="ot">{-# LANGUAGE DeriveDataTypeable #-}</span>

<span class="kw">import </span><span class="dt">Text.Hastache</span>
<span class="kw">import </span><span class="dt">Text.Hastache.Context</span>

<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy</span> <span class="kw">as</span> <span class="dt">TL</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy.IO</span> <span class="kw">as</span> <span class="dt">TL</span>

<span class="kw">import </span><span class="dt">Data.Data</span>

<span class="ot">template ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">MuContext</span> <span class="dt">IO</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">TL.Text</span>
template <span class="fu">=</span> hastacheFile defaultConfig

<span class="co">-- Record context</span>
<span class="kw">data</span> <span class="dt">TemplateCtx</span> <span class="fu">=</span> <span class="dt">TemplateCtx</span>
  {<span class="ot"> body ::</span> <span class="dt">TL.Text</span>
  ,<span class="ot"> title ::</span> <span class="dt">TL.Text</span>
  } <span class="kw">deriving</span> (<span class="dt">Data</span>, <span class="dt">Typeable</span>)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> ctx <span class="fu">=</span> <span class="dt">TemplateCtx</span> { body <span class="fu">=</span> <span class="st">&quot;Hello&quot;</span>, title <span class="fu">=</span> <span class="st">&quot;Haskell&quot;</span> }
  output <span class="ot">&lt;-</span> template <span class="st">&quot;templates/home.html&quot;</span> (mkGenericContext ctx)
  TL.putStrLn output</code></pre></div>
<p>The MuType and MuContext types can be parameterized by any monad or transformer that implements <code>MonadIO</code>, not just IO.</p>
</hr>
<h1 id="databases">Databases</h1>
<h2 id="postgres">Postgres</h2>
<p>Postgres is an object-relational database management system with a rich extension of the SQL standard. Consider the following tables specified in DDL.</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">CREATE</span> <span class="kw">TABLE</span> <span class="ot">&quot;books&quot;</span> (
    <span class="ot">&quot;id&quot;</span> <span class="dt">integer</span> <span class="kw">NOT</span> <span class="kw">NULL</span>,
    <span class="ot">&quot;title&quot;</span> text <span class="kw">NOT</span> <span class="kw">NULL</span>,
    <span class="ot">&quot;author_id&quot;</span> <span class="dt">integer</span>,
    <span class="ot">&quot;subject_id&quot;</span> <span class="dt">integer</span>,
    <span class="kw">Constraint</span> <span class="ot">&quot;books_id_pkey&quot;</span> <span class="kw">Primary</span> <span class="kw">Key</span> (<span class="ot">&quot;id&quot;</span>)
);

<span class="kw">CREATE</span> <span class="kw">TABLE</span> <span class="ot">&quot;authors&quot;</span> (
    <span class="ot">&quot;id&quot;</span> <span class="dt">integer</span> <span class="kw">NOT</span> <span class="kw">NULL</span>,
    <span class="ot">&quot;last_name&quot;</span> text,
    <span class="ot">&quot;first_name&quot;</span> text,
    <span class="kw">Constraint</span> <span class="ot">&quot;authors_pkey&quot;</span> <span class="kw">Primary</span> <span class="kw">Key</span> (<span class="ot">&quot;id&quot;</span>)
);</code></pre></div>
<p>The postgresql-simple bindings provide a thin wrapper to various libpq commands to interact a Postgres server. These functions all take a <code>Connection</code> object to the database instance and allow various bytestring queries to be sent and result sets mapped into Haskell datatypes. There are four primary functions for these interactions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">query_ ::</span> <span class="dt">FromRow</span> r <span class="ot">=&gt;</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">Query</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [r]
<span class="ot">query ::</span> (<span class="dt">ToRow</span> q, <span class="dt">FromRow</span> r) <span class="ot">=&gt;</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">Query</span> <span class="ot">-&gt;</span> q <span class="ot">-&gt;</span> <span class="dt">IO</span> [r]
<span class="ot">execute ::</span> <span class="dt">ToRow</span> q <span class="ot">=&gt;</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">Query</span> <span class="ot">-&gt;</span> q <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int64</span>
<span class="ot">execute_ ::</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">Query</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int64</span></code></pre></div>
<p>The result of the <code>query</code> function is a list of elements which implement the FromRow typeclass. This can be many things including a single elemment (Only), a list of tuples where each element implements <code>FromField</code> or a custom datatype that itself implements <code>FromRow</code>. Under the hood the database bindings inspects the Postgres <code>oid</code> objects and then attempts to convert them into the Haskell datatype of the field being scrutinised. This can fail at runtime if the types in the database don't align with the expected types in the logic executing the SQL query.</p>
<h4 id="tuples">Tuples</h4>
<div class="sourceCode" include="src/28-databases/postgres.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span>

<span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import qualified</span> <span class="dt">Database.PostgreSQL.Simple</span> <span class="kw">as</span> <span class="dt">SQL</span>

<span class="ot">creds ::</span> <span class="dt">SQL.ConnectInfo</span>
creds <span class="fu">=</span> SQL.defaultConnectInfo
  { SQL.connectUser <span class="fu">=</span> <span class="st">&quot;example&quot;</span>
  , SQL.connectPassword <span class="fu">=</span> <span class="st">&quot;example&quot;</span>
  , SQL.connectDatabase <span class="fu">=</span> <span class="st">&quot;booktown&quot;</span>
  }

<span class="ot">selectBooks ::</span> <span class="dt">SQL.Connection</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [(<span class="dt">Int</span>, <span class="dt">T.Text</span>, <span class="dt">Int</span>)]
selectBooks conn <span class="fu">=</span> SQL.query_ conn <span class="st">&quot;select id, title, author_id from books&quot;</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  conn <span class="ot">&lt;-</span> SQL.connect creds
  books <span class="ot">&lt;-</span> selectBooks conn
  print books</code></pre></div>
<p>This yields the result set:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[ ( <span class="dv">7808</span> , <span class="st">&quot;The Shining&quot;</span> , <span class="dv">4156</span> )
, ( <span class="dv">4513</span> , <span class="st">&quot;Dune&quot;</span> , <span class="dv">1866</span> )
, ( <span class="dv">4267</span> , <span class="st">&quot;2001: A Space Odyssey&quot;</span> , <span class="dv">2001</span> )
, ( <span class="dv">1608</span> , <span class="st">&quot;The Cat in the Hat&quot;</span> , <span class="dv">1809</span> )
, ( <span class="dv">1590</span> , <span class="st">&quot;Bartholomew and the Oobleck&quot;</span> , <span class="dv">1809</span> )
, ( <span class="dv">25908</span> , <span class="st">&quot;Franklin in the Dark&quot;</span> , <span class="dv">15990</span> )
, ( <span class="dv">1501</span> , <span class="st">&quot;Goodnight Moon&quot;</span> , <span class="dv">2031</span> )
, ( <span class="dv">190</span> , <span class="st">&quot;Little Women&quot;</span> , <span class="dv">16</span> )
, ( <span class="dv">1234</span> , <span class="st">&quot;The Velveteen Rabbit&quot;</span> , <span class="dv">25041</span> )
, ( <span class="dv">2038</span> , <span class="st">&quot;Dynamic Anatomy&quot;</span> , <span class="dv">1644</span> )
, ( <span class="dv">156</span> , <span class="st">&quot;The Tell-Tale Heart&quot;</span> , <span class="dv">115</span> )
, ( <span class="dv">41473</span> , <span class="st">&quot;Programming Python&quot;</span> , <span class="dv">7805</span> )
, ( <span class="dv">41477</span> , <span class="st">&quot;Learning Python&quot;</span> , <span class="dv">7805</span> )
, ( <span class="dv">41478</span> , <span class="st">&quot;Perl Cookbook&quot;</span> , <span class="dv">7806</span> )
, ( <span class="dv">41472</span> , <span class="st">&quot;Practical PostgreSQL&quot;</span> , <span class="dv">1212</span> )
]</code></pre></div>
<h4 id="custom-types">Custom Types</h4>
<div class="sourceCode" include="src/28-databases/postgres_custom.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>

<span class="kw">import qualified</span> <span class="dt">Database.PostgreSQL.Simple</span> <span class="kw">as</span> <span class="dt">SQL</span>
<span class="kw">import </span><span class="dt">Database.PostgreSQL.Simple.FromRow</span> (<span class="dt">FromRow</span>(..), field)

<span class="kw">data</span> <span class="dt">Book</span> <span class="fu">=</span> <span class="dt">Book</span>
  {<span class="ot"> id_ ::</span> <span class="dt">Int</span>
  ,<span class="ot"> title ::</span> <span class="dt">T.Text</span>
  ,<span class="ot"> author_id ::</span> <span class="dt">Int</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">FromRow</span> <span class="dt">Book</span> <span class="kw">where</span>
  fromRow <span class="fu">=</span> <span class="dt">Book</span> <span class="fu">&lt;$&gt;</span> field <span class="fu">&lt;*&gt;</span> field <span class="fu">&lt;*&gt;</span> field

<span class="ot">creds ::</span> <span class="dt">SQL.ConnectInfo</span>
creds <span class="fu">=</span> SQL.defaultConnectInfo
  { SQL.connectUser <span class="fu">=</span> <span class="st">&quot;example&quot;</span>
  , SQL.connectPassword <span class="fu">=</span> <span class="st">&quot;example&quot;</span>
  , SQL.connectDatabase <span class="fu">=</span> <span class="st">&quot;booktown&quot;</span>
  }

<span class="ot">selectBooks ::</span> <span class="dt">SQL.Connection</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">Book</span>]
selectBooks conn <span class="fu">=</span> SQL.query_ conn <span class="st">&quot;select id, title, author_id from books limit 4&quot;</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  conn <span class="ot">&lt;-</span> SQL.connect creds
  books <span class="ot">&lt;-</span> selectBooks conn
  print books</code></pre></div>
<p>This yields the result set:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[ <span class="dt">Book</span> { id_ <span class="fu">=</span> <span class="dv">7808</span> , title <span class="fu">=</span> <span class="st">&quot;The Shining&quot;</span> , author_id <span class="fu">=</span> <span class="dv">4156</span> }
, <span class="dt">Book</span> { id_ <span class="fu">=</span> <span class="dv">4513</span> , title <span class="fu">=</span> <span class="st">&quot;Dune&quot;</span> , author_id <span class="fu">=</span> <span class="dv">1866</span> }
, <span class="dt">Book</span> { id_ <span class="fu">=</span> <span class="dv">4267</span> , title <span class="fu">=</span> <span class="st">&quot;2001: A Space Odyssey&quot;</span> , author_id <span class="fu">=</span> <span class="dv">2001</span> }
, <span class="dt">Book</span> { id_ <span class="fu">=</span> <span class="dv">1608</span> , title <span class="fu">=</span> <span class="st">&quot;The Cat in the Hat&quot;</span> , author_id <span class="fu">=</span> <span class="dv">1809</span> }
]</code></pre></div>
<h4 id="quasiquoter">Quasiquoter</h4>
<p>As SQL expressions grow in complexity they often span multiple lines and sometimes its useful to just drop down to a quasiquoter to embed the whole query. The quoter here is pure, and just generates the <code>Query</code> object behind as a ByteString.</p>
<div class="sourceCode" include="src/28-databases/postgres_qq.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span>
<span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span>

<span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>

<span class="kw">import qualified</span> <span class="dt">Database.PostgreSQL.Simple</span> <span class="kw">as</span> <span class="dt">SQL</span>
<span class="kw">import </span><span class="dt">Database.PostgreSQL.Simple.SqlQQ</span> (sql)
<span class="kw">import </span><span class="dt">Database.PostgreSQL.Simple.FromRow</span> (<span class="dt">FromRow</span>(..), field)

<span class="kw">data</span> <span class="dt">Book</span> <span class="fu">=</span> <span class="dt">Book</span>
  {<span class="ot"> id_ ::</span> <span class="dt">Int</span>
  ,<span class="ot"> title ::</span> <span class="dt">T.Text</span>
  ,<span class="ot"> first_name ::</span> <span class="dt">T.Text</span>
  ,<span class="ot"> last_name ::</span> <span class="dt">T.Text</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">FromRow</span> <span class="dt">Book</span> <span class="kw">where</span>
  fromRow <span class="fu">=</span> <span class="dt">Book</span> <span class="fu">&lt;$&gt;</span> field <span class="fu">&lt;*&gt;</span> field <span class="fu">&lt;*&gt;</span> field <span class="fu">&lt;*&gt;</span> field

<span class="ot">creds ::</span> <span class="dt">SQL.ConnectInfo</span>
creds <span class="fu">=</span> SQL.defaultConnectInfo
  { SQL.connectUser <span class="fu">=</span> <span class="st">&quot;example&quot;</span>
  , SQL.connectPassword <span class="fu">=</span> <span class="st">&quot;example&quot;</span>
  , SQL.connectDatabase <span class="fu">=</span> <span class="st">&quot;booktown&quot;</span>
  }

<span class="ot">selectBooks ::</span> <span class="dt">SQL.Query</span>
selectBooks <span class="fu">=</span> [sql<span class="fu">|</span>
select
  books<span class="fu">.</span>id,
  books<span class="fu">.</span>title,
  authors<span class="fu">.</span>first_name,
  authors<span class="fu">.</span>last_name
from books
join authors on
  authors<span class="fu">.</span>id <span class="fu">=</span> books<span class="fu">.</span>author_id
limit <span class="dv">5</span>
<span class="fu">|</span>]

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  conn <span class="ot">&lt;-</span> SQL.connect creds
  (<span class="ot">books ::</span> [<span class="dt">Book</span>]) <span class="ot">&lt;-</span> SQL.query_ conn selectBooks
  print books</code></pre></div>
<p>This yields the result set:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[ <span class="dt">Book</span>
    { id_ <span class="fu">=</span> <span class="dv">41472</span>
    , title <span class="fu">=</span> <span class="st">&quot;Practical PostgreSQL&quot;</span>
    , first_name <span class="fu">=</span> <span class="st">&quot;John&quot;</span>
    , last_name <span class="fu">=</span> <span class="st">&quot;Worsley&quot;</span>
    }
, <span class="dt">Book</span>
    { id_ <span class="fu">=</span> <span class="dv">25908</span>
    , title <span class="fu">=</span> <span class="st">&quot;Franklin in the Dark&quot;</span>
    , first_name <span class="fu">=</span> <span class="st">&quot;Paulette&quot;</span>
    , last_name <span class="fu">=</span> <span class="st">&quot;Bourgeois&quot;</span>
    }
, <span class="dt">Book</span>
    { id_ <span class="fu">=</span> <span class="dv">1234</span>
    , title <span class="fu">=</span> <span class="st">&quot;The Velveteen Rabbit&quot;</span>
    , first_name <span class="fu">=</span> <span class="st">&quot;Margery Williams&quot;</span>
    , last_name <span class="fu">=</span> <span class="st">&quot;Bianco&quot;</span>
    }
, <span class="dt">Book</span>
    { id_ <span class="fu">=</span> <span class="dv">190</span>
    , title <span class="fu">=</span> <span class="st">&quot;Little Women&quot;</span>
    , first_name <span class="fu">=</span> <span class="st">&quot;Louisa May&quot;</span>
    , last_name <span class="fu">=</span> <span class="st">&quot;Alcott&quot;</span>
    }
]</code></pre></div>
<h2 id="redis">Redis</h2>
<p>Redis is an in-memory key-value store with support for a variety of datastructures. The Haskell exposure is exposed in a <code>Redis</code> monad which sequences a set of <a href="http://redis.io/commands">redis commands</a> taking ByteString arguments and then executes them against a connection object.</p>
<div class="sourceCode" include="src/28-databases/hedis.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Database.Redis</span>
<span class="kw">import </span><span class="dt">Data.ByteString.Char8</span>

<span class="ot">session ::</span> <span class="dt">Redis</span> (<span class="dt">Either</span> <span class="dt">Reply</span> (<span class="dt">Maybe</span> <span class="dt">ByteString</span>))
session <span class="fu">=</span> <span class="kw">do</span>
  set <span class="st">&quot;hello&quot;</span> <span class="st">&quot;haskell&quot;</span>
  get <span class="st">&quot;hello&quot;</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  conn <span class="ot">&lt;-</span> connect defaultConnectInfo
  res <span class="ot">&lt;-</span> runRedis conn session
  print res</code></pre></div>
<p>Redis is quite often used as a lightweight pubsub server, and the bindings integrate with the Haskell concurrency primitives so that listeners can be sparked and shared across threads off without blocking the main thread.</p>
<div class="sourceCode" include="src/28-databases/hedis_pubsub.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Database.Redis</span>

<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Control.Monad.Trans</span>
<span class="kw">import </span><span class="dt">Data.ByteString.Char8</span>

<span class="kw">import </span><span class="dt">Control.Concurrent</span>

<span class="ot">subscriber ::</span> <span class="dt">Redis</span> ()
subscriber <span class="fu">=</span>
 pubSub (subscribe [<span class="st">&quot;news&quot;</span>]) <span class="fu">$</span> \msg <span class="ot">-&gt;</span> <span class="kw">do</span>
   print msg
   return mempty

<span class="ot">publisher ::</span> <span class="dt">Redis</span> ()
publisher <span class="fu">=</span> forM_ [<span class="dv">1</span><span class="fu">..</span><span class="dv">100</span>] <span class="fu">$</span> \n <span class="ot">-&gt;</span> publish <span class="st">&quot;news&quot;</span> (pack (show n))

<span class="co">-- connects to localhost:6379</span>
<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  conn1 <span class="ot">&lt;-</span> connect defaultConnectInfo
  conn2 <span class="ot">&lt;-</span> connect defaultConnectInfo

  <span class="co">-- Fork off a publisher</span>
  forkIO <span class="fu">$</span> runRedis conn1 publisher

  <span class="co">-- Subscribe for messages</span>
  runRedis conn2 subscriber</code></pre></div>
<h2 id="acid-state">Acid State</h2>
<p>Acid-state allows us to build a &quot;database&quot; for around our existing Haskell datatypes that guarantees atomic transactions. For example, we can build a simple key-value store wrapped around the Map type.</p>
<div class="sourceCode" include="src/28-databases/acid.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>
<span class="ot">{-# LANGUAGE DeriveDataTypeable #-}</span>

<span class="kw">import </span><span class="dt">Data.Acid</span>
<span class="kw">import </span><span class="dt">Data.Typeable</span>
<span class="kw">import </span><span class="dt">Data.SafeCopy</span>
<span class="kw">import </span><span class="dt">Control.Monad.Reader</span> (ask)

<span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span>
<span class="kw">import qualified</span> <span class="dt">Control.Monad.State</span> <span class="kw">as</span> <span class="dt">S</span>

<span class="kw">type</span> <span class="dt">Key</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">Value</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="kw">data</span> <span class="dt">Database</span> <span class="fu">=</span> <span class="dt">Database</span> <span class="fu">!</span>(<span class="dt">Map.Map</span> <span class="dt">Key</span> <span class="dt">Value</span>)
    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Ord</span>, <span class="dt">Eq</span>, <span class="dt">Typeable</span>)

<span class="fu">$</span>(deriveSafeCopy <span class="dv">0</span> <span class="ch">&#39;base &#39;&#39;Database)</span>

<span class="ot">insertKey ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Update</span> <span class="dt">Database</span> ()
insertKey key value
    <span class="fu">=</span> <span class="kw">do</span> <span class="dt">Database</span> m <span class="ot">&lt;-</span> S.get
         S.put (<span class="dt">Database</span> (Map.insert key value m))

<span class="ot">lookupKey ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">Query</span> <span class="dt">Database</span> (<span class="dt">Maybe</span> <span class="dt">Value</span>)
lookupKey key
    <span class="fu">=</span> <span class="kw">do</span> <span class="dt">Database</span> m <span class="ot">&lt;-</span> ask
         return (Map.lookup key m)

<span class="ot">deleteKey ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">Update</span> <span class="dt">Database</span> ()
deleteKey key
    <span class="fu">=</span> <span class="kw">do</span> <span class="dt">Database</span> m <span class="ot">&lt;-</span> S.get
         S.put (<span class="dt">Database</span> (Map.delete key m))

<span class="ot">allKeys ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Query</span> <span class="dt">Database</span> [(<span class="dt">Key</span>, <span class="dt">Value</span>)]
allKeys limit
    <span class="fu">=</span> <span class="kw">do</span> <span class="dt">Database</span> m <span class="ot">&lt;-</span> ask
         return <span class="fu">$</span> take limit (Map.toList m)

<span class="fu">$</span>(makeAcidic <span class="ch">&#39;&#39;</span><span class="dt">Database</span> [<span class="ch">&#39;insertKey, &#39;</span>lookupKey, <span class="ch">&#39;allKeys, &#39;</span>deleteKey])

<span class="ot">fixtures ::</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">String</span>
fixtures <span class="fu">=</span> Map.empty

<span class="ot">test ::</span>  <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
test key val <span class="fu">=</span> <span class="kw">do</span>
    database <span class="ot">&lt;-</span> openLocalStateFrom <span class="st">&quot;db/&quot;</span> (<span class="dt">Database</span> fixtures)
    result <span class="ot">&lt;-</span> update database (<span class="dt">InsertKey</span> key val)
    result <span class="ot">&lt;-</span> query database (<span class="dt">AllKeys</span> <span class="dv">10</span>)
    print result</code></pre></div>
<hr />
<h1 id="ghc">GHC</h1>
<div class="alert alert-danger">
<p>This is a <strong>very advanced</strong> section, knowledge of GHC internals is rarely necessary.</p>
</div>
<h2 id="block-diagram">Block Diagram</h2>
<p>The flow of code through GHC is a process of translation between several intermediate languages and optimizations and transformations thereof. A common pattern for many of these AST types is they are parametrized over a binder type and at various stages the binders will be transformed, for example the Renamer pass effectively translates the <code>HsSyn</code> datatype from a AST parametrized over literal strings as the user enters into a <code>HsSyn</code> parameterized over qualified names that includes modules and package names into a higher level Name type.</p>
<h5 id="ghc-compiler">GHC Compiler</h5>
<div class="center">
<div class="figure">
<img src="img/ghc.png" alt="" />

</div>
</div>
<h5 id="ghc-compiler-passes">GHC Compiler Passes</h5>
<ul>
<li><strong>Parser/Frontend</strong>: An enormous AST translated from human syntax that makes explicit possible all expressible syntax ( declarations, do-notation, where clauses, syntax extensions, template haskell, ... ). This is unfiltered Haskell and it is <em>enormous</em>.</li>
<li><strong>Renamer</strong> takes syntax from the frontend and transforms all names to be qualified (<code>base:Prelude.map</code> instead of <code>map</code>) and any shadowed names in lambda binders transformed into unique names.</li>
<li><strong>Typechecker</strong> is a large pass that serves two purposes, first is the core type bidirectional inference engine where most of the work happens and the translation between the frontend <code>Core</code> syntax.</li>
<li><strong>Desugarer</strong> translates several higher level syntactic constructors
<ul>
<li><code>where</code> statements are turned into (possibly recursive) nested <code>let</code> statements.</li>
<li>Nested pattern matches are expanded out into splitting trees of case statements.</li>
<li>do-notation is expanded into explicit bind statements.</li>
<li>Lots of others.</li>
</ul></li>
<li><strong>Simplifier</strong> transforms many Core constructs into forms that are more adaptable to compilation. For example let statements will be floated or raised, pattern matches will simplified, inner loops will be pulled out and transformed into more optimal forms. Non-intuitively the resulting may actually be much more complex (for humans) after going through the simplifier!</li>
<li><strong>Stg</strong> pass translates the resulting Core into STG (Spineless Tagless G-Machine) which effectively makes all laziness explicit and encodes the thunks and update frames that will be handled during evaluation.</li>
<li><strong>Codegen/Cmm</strong> pass will then translate STG into Cmm (flavoured C--) a simple imperative language that manifests the low-level implementation details of runtime types. The runtime closure types and stack frames are made explicit and low-level information about the data and code (arity, updatability, free variables, pointer layout) made manifest in the info tables present on most constructs.</li>
<li><strong>Native Code</strong> The final pass will than translate the resulting code into either LLVM or Assembly via either through GHC's home built native code generator (NCG) or the LLVM backend.</li>
</ul>
<p>Information for each pass can dumped out via a rather large collection of flags. The GHC internals are very accessible although some passes are somewhat easier to understand than others. Most of the time <code>-ddump-simpl</code> and <code>-ddump-stg</code> are sufficient to get an understanding of how the code will compile, unless of course you're dealing with very specialized optimizations or hacking on GHC itself.</p>
<table>
<thead>
<tr class="header">
<th align="left">Flag</th>
<th align="left">Action</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>-ddump-parsed</code></td>
<td align="left">Frontend AST.</td>
</tr>
<tr class="even">
<td align="left"><code>-ddump-rn</code></td>
<td align="left">Output of the rename pass.</td>
</tr>
<tr class="odd">
<td align="left"><code>-ddump-tc</code></td>
<td align="left">Output of the typechecker.</td>
</tr>
<tr class="even">
<td align="left"><code>-ddump-splices</code></td>
<td align="left">Output of TemplateHaskell splices.</td>
</tr>
<tr class="odd">
<td align="left"><code>-ddump-types</code></td>
<td align="left">Typed AST representation.</td>
</tr>
<tr class="even">
<td align="left"><code>-ddump-deriv</code></td>
<td align="left">Output of deriving instances.</td>
</tr>
<tr class="odd">
<td align="left"><code>-ddump-ds</code></td>
<td align="left">Output of the desugar pass.</td>
</tr>
<tr class="even">
<td align="left"><code>-ddump-spec</code></td>
<td align="left">Output of specialisation pass.</td>
</tr>
<tr class="odd">
<td align="left"><code>-ddump-rules</code></td>
<td align="left">Output of applying rewrite rules.</td>
</tr>
<tr class="even">
<td align="left"><code>-ddump-vect</code></td>
<td align="left">Output results of vectorize pass.</td>
</tr>
<tr class="odd">
<td align="left"><code>-ddump-simpl</code></td>
<td align="left">Ouptut of the SimplCore pass.</td>
</tr>
<tr class="even">
<td align="left"><code>-ddump-inlinings</code></td>
<td align="left">Output of the inliner.</td>
</tr>
<tr class="odd">
<td align="left"><code>-ddump-cse</code></td>
<td align="left">Output of the common subexpression elimination pass.</td>
</tr>
<tr class="even">
<td align="left"><code>-ddump-prep</code></td>
<td align="left">The CorePrep pass.</td>
</tr>
<tr class="odd">
<td align="left"><code>-ddump-stg</code></td>
<td align="left">The resulting STG.</td>
</tr>
<tr class="even">
<td align="left"><code>-ddump-cmm</code></td>
<td align="left">The resulting Cmm.</td>
</tr>
<tr class="odd">
<td align="left"><code>-ddump-opt-cmm</code></td>
<td align="left">The resulting Cmm optimization pass.</td>
</tr>
<tr class="even">
<td align="left"><code>-ddump-asm</code></td>
<td align="left">The final assembly generated.</td>
</tr>
<tr class="odd">
<td align="left"><code>-ddump-llvm</code></td>
<td align="left">The final LLVM IR generated.</td>
</tr>
</tbody>
</table>
<!--

GHC Api
-------

GHC is effectively just a very large (and quirky) Haskell library that
transforms Haskell source code into executable code.

```haskell
-- Parse a module.
parseModule :: GhcMonad m => ModSummary -> m ParsedModule

-- Typecheck and rename a parsed module.
typecheckModule :: GhcMonad m => ParsedModule -> m TypecheckedModule

-- Desugar a typechecked module.
desugarModule :: GhcMonad m => TypecheckedModule -> m DesugaredModule

-- Generated ModIface and Generated Code
loadModule :: (TypecheckedMod mod, GhcMonad m) => mod -> m mod
```

```haskell
import GHC
import GHC.Paths (libdir)
import DynFlags

targetFile :: FilePath
targetFile = "B.hs"

example :: IO ()
example =
  defaultErrorHandler defaultFatalMessager defaultFlushOut $ do
    runGhc (Just libdir) $ do
      dflags <- getSessionDynFlags
      setSessionDynFlags dflags

      target <- guessTarget targetFile Nothing
      setTargets [target]
      load LoadAllTargets
      modSum <- getModSummary $ mkModuleName "B"

      p <- parseModule modSum      -- ModuleSummary
      t <- typecheckModule p       -- TypecheckedSource
      d <- desugarModule t         -- DesugaredModule
      l <- loadModule d
      let c = coreModule d         -- CoreModule

      g <- getModuleGraph
      mapM showModule g

      return $ c

main :: IO ()
main = do
   res <- example
   putStrLn $ showSDoc ( ppr res )
```

Artifacts
----------

* ParsedModule
* TypecheckedModule
* DesugaredModule
* CoreModule

Located
-------

Frontend syntax in GHC carries position information along with it that can be
used

```haskell
data GenLocated l e = L l e
type Located e = GenLocated SrcSpan e
```

```haskell
unLoc :: GenLocated l e -> e
unLoc (L _ e) = e

getLoc :: GenLocated l e -> l
getLoc (L l _) = l

noLoc :: e -> Located e
noLoc e = L noSrcSpan e
```

```haskell
instance Functor (GenLocated l) where
  fmap f (L l e) = L l (f e)
```

```haskell
srcSpanStart :: SrcSpan -> SrcLoc
srcSpanEnd :: SrcSpan -> SrcLoc
```

```haskell
showSDoc :: DynFlags -> SDoc -> String
```

```haskell
-- | Show a GHC.Outputable structure
showGhc :: (GHC.Outputable a) => a -> String
showGhc = GHC.showPpr GHC.unsafeGlobalDynFlags
```

* [Outputable](https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/ghc-7.10.3/Outputable.html)

Types
-----

**Monads**

* GHC
* P
* Hsc
* TcRn
* DsM
* SimplM
* MonadUnique

**Session**

* HscEnv
* DynFlags
* Settings
* UniqEnv
* Target
* TargetId
* HscTarget
* GhcMode
* ModSummary
* InteractiveContext
* TypeEnv
* GlobalRdrEnv
* TcGblEnv
* FixityEnv
* Module
* ModuleName
* [ModGuts](https://downloads.haskell.org/~ghc/7.10.2/docs/html/libraries/ghc-7.10.2/HscTypes.html#t:ModGuts)
* [ModuleInfo](https://downloads.haskell.org/~ghc/7.10.2/docs/html/libraries/ghc-7.10.2/GHC.html#t:ModuleInfo)
* [ModDetails](https://downloads.haskell.org/~ghc/7.10.2/docs/html/libraries/ghc-7.10.2/HscTypes.html#t:ModDetails)
* AvailInfo
* Class
* ClsInt
* FamInst
* InstEnv
* TyCon
* DataCon
* TyThing
* RdrName
* Name
* Var
* Type
* DataConRep
* SrcLoc
* SrcSpan
* Located
* GhcException
* Token

**HsSyn**

- HsModule
- HsBind
- HsDecl
- HsExpr
- HsGroup
- HsLit
- Pat
- HsType

**CoreSyn**

- Expr
- Arg
- Alt
- AltCon
- Bind

**StgSyn**

TODO

-->
<h2 id="core">Core</h2>
<p>Core is the explicitly typed System-F family syntax through that all Haskell constructs can be expressed in.</p>
<p>To inspect the core from GHCi we can invoke it using the following flags and the following shell alias. We have explicitly disable the printing of certain metadata and longform names to make the representation easier to read.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">alias</span> ghci-core=<span class="st">&quot;ghci -ddump-simpl -dsuppress-idinfo \</span>
<span class="st">-dsuppress-coercions -dsuppress-type-applications \</span>
<span class="st">-dsuppress-uniques -dsuppress-module-prefixes&quot;</span></code></pre></div>
<p>At the interactive prompt we can then explore the core representation interactively:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">ghci-core</span>
λ: <span class="kw">let</span> f x = x + 2 <span class="kw">;</span> <span class="kw">f</span> :: Int -<span class="kw">&gt;</span> Int

==================== <span class="kw">Simplified</span> expression ====================
<span class="kw">returnIO</span>
  <span class="kw">(:</span> ((<span class="dt">\ </span>(x :: Int<span class="kw">)</span> <span class="kw">-&gt;</span> + <span class="ot">$fNumInt</span> x (I# 2)) <span class="kw">`cast`</span> <span class="kw">...</span>) <span class="kw">(</span>[]<span class="kw">)</span>)

λ: <span class="kw">let</span> f x = (x, x)

==================== <span class="kw">Simplified</span> expression ====================
<span class="kw">returnIO</span> (: ((<span class="dt">\ </span>(@ t) <span class="kw">(x</span> :: t<span class="kw">)</span> <span class="kw">-&gt;</span> (x, x)) <span class="kw">`cast`</span> <span class="kw">...</span>) <span class="kw">(</span>[]<span class="kw">)</span>)</code></pre></div>
<p><a href="http://hackage.haskell.org/package/ghc-core">ghc-core</a> is also very useful for looking at GHC's compilation artifacts.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">ghc-core</span> --no-cast --no-asm</code></pre></div>
<p>Alternatively the major stages of the compiler ( parse tree, core, stg, cmm, asm ) can be manually outputted and inspected by passing several flags to the compiler:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">ghc</span> -ddump-to-file -ddump-parsed -ddump-simpl -ddump-stg -ddump-cmm -ddump-asm</code></pre></div>
<p><strong>Reading Core</strong></p>
<p>Core from GHC is roughly human readable, but it's helpful to look at simple human written examples to get the hang of what's going on.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">id<span class="ot"> ::</span> a <span class="ot">-&gt;</span> a
id x <span class="fu">=</span> x</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">id<span class="ot"> ::</span> forall a<span class="fu">.</span> a <span class="ot">-&gt;</span> a
id <span class="fu">=</span> \ (<span class="fu">@</span> a) (<span class="ot">x ::</span> a) <span class="ot">-&gt;</span> x

<span class="ot">idInt ::</span> <span class="dt">GHC.Types.Int</span> <span class="ot">-&gt;</span> <span class="dt">GHC.Types.Int</span>
idInt <span class="fu">=</span> id <span class="fu">@</span> <span class="dt">GHC.Types.Int</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">compose ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c
compose f g x <span class="fu">=</span> f (g x)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">compose ::</span> forall b c a<span class="fu">.</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c
compose <span class="fu">=</span> \ (<span class="fu">@</span> b) (<span class="fu">@</span> c) (<span class="fu">@</span> a) (<span class="ot">f1 ::</span> b <span class="ot">-&gt;</span> c) (<span class="ot">g ::</span> a <span class="ot">-&gt;</span> b) (<span class="ot">x1 ::</span> a) <span class="ot">-&gt;</span> f1 (g x1)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
map f []     <span class="fu">=</span> []
map f (x<span class="fu">:</span>xs) <span class="fu">=</span> f x <span class="fu">:</span> map f xs</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">map<span class="ot"> ::</span> forall a b<span class="fu">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
map <span class="fu">=</span>
  \ (<span class="fu">@</span> a) (<span class="fu">@</span> b) (<span class="ot">f ::</span> a <span class="ot">-&gt;</span> b) (<span class="ot">xs ::</span> [a]) <span class="ot">-&gt;</span>
    <span class="kw">case</span> xs <span class="kw">of</span> _ {
      []     <span class="ot">-&gt;</span> [] <span class="fu">@</span> b;
      <span class="fu">:</span> y ys <span class="ot">-&gt;</span> <span class="fu">:</span> <span class="fu">@</span> b (f y) (map <span class="fu">@</span> a <span class="fu">@</span> b f ys)
    }</code></pre></div>
<p>Machine generated names are created for a lot of transformation of Core. Generally they consist of a prefix and unique identifier. The prefix is often pass specific ( i.e. <code>ds</code> for desugar generated name s) and sometimes specific names are generated for specific automatically generated code. A list of the common prefixes and their meaning is show below.</p>
<table>
<thead>
<tr class="header">
<th align="left">Prefix</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>$f...</code></td>
<td align="left">Dict-fun identifiers (from inst decls)</td>
</tr>
<tr class="even">
<td align="left"><code>$dmop</code></td>
<td align="left">Default method for 'op'</td>
</tr>
<tr class="odd">
<td align="left"><code>$wf</code></td>
<td align="left">Worker for function 'f'</td>
</tr>
<tr class="even">
<td align="left"><code>$sf</code></td>
<td align="left">Specialised version of f</td>
</tr>
<tr class="odd">
<td align="left"><code>$gdm</code></td>
<td align="left">Generated class method</td>
</tr>
<tr class="even">
<td align="left"><code>$d</code></td>
<td align="left">Dictionary names</td>
</tr>
<tr class="odd">
<td align="left"><code>$s</code></td>
<td align="left">Specialized function name</td>
</tr>
<tr class="even">
<td align="left"><code>$f</code></td>
<td align="left">Foreign export</td>
</tr>
<tr class="odd">
<td align="left"><code>$pnC</code></td>
<td align="left">n'th superclass selector for class C</td>
</tr>
<tr class="even">
<td align="left"><code>T:C</code></td>
<td align="left">Tycon for dictionary for class C</td>
</tr>
<tr class="odd">
<td align="left"><code>D:C</code></td>
<td align="left">Data constructor for dictionary for class C</td>
</tr>
<tr class="even">
<td align="left"><code>NTCo:T</code></td>
<td align="left">Coercion for newtype T to its underlying runtime representation</td>
</tr>
</tbody>
</table>
<p>Of important note is that the Λ and λ for type-level and value-level lambda abstraction are represented by the same symbol (<code>\</code>) in core, which is a simplifying detail of the GHC's implementation but a source of some confusion when starting.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- System-F Notation</span>
Λ b c a<span class="fu">.</span> λ (f1 <span class="fu">:</span> b <span class="ot">-&gt;</span> c) (g <span class="fu">:</span> a <span class="ot">-&gt;</span> b) (x1 <span class="fu">:</span> a)<span class="fu">.</span> f1 (g x1)

<span class="co">-- Haskell Core</span>
\ (<span class="fu">@</span> b) (<span class="fu">@</span> c) (<span class="fu">@</span> a) (<span class="ot">f1 ::</span> b <span class="ot">-&gt;</span> c) (<span class="ot">g ::</span> a <span class="ot">-&gt;</span> b) (<span class="ot">x1 ::</span> a) <span class="ot">-&gt;</span> f1 (g x1)</code></pre></div>
<p>The <code>seq</code> function has an intuitive implementation in the Core language.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">x <span class="ot">`seq`</span> y</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">case</span> x <span class="kw">of</span> _ {
  __<span class="dt">DEFAULT</span> <span class="ot">-&gt;</span> y
}</code></pre></div>
<p>One particularly notable case of the Core desugaring process is that pattern matching on overloaded numbers implicitly translates into equality test (i.e. <code>Eq</code>).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f <span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span>
f <span class="dv">1</span> <span class="fu">=</span> <span class="dv">2</span>
f <span class="dv">2</span> <span class="fu">=</span> <span class="dv">3</span>
f <span class="dv">3</span> <span class="fu">=</span> <span class="dv">4</span>
f <span class="dv">4</span> <span class="fu">=</span> <span class="dv">5</span>
f _ <span class="fu">=</span> <span class="dv">0</span>


<span class="ot">f ::</span> forall a b<span class="fu">.</span> (<span class="dt">Eq</span> a, <span class="dt">Num</span> a, <span class="dt">Num</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b
f <span class="fu">=</span>
  \ (<span class="fu">@</span> a)
    (<span class="fu">@</span> b)
    (<span class="fu">$</span><span class="ot">dEq ::</span> <span class="dt">Eq</span> a)
    (<span class="fu">$</span><span class="ot">dNum ::</span> <span class="dt">Num</span> a)
    (<span class="fu">$</span><span class="ot">dNum1 ::</span> <span class="dt">Num</span> b)
    (<span class="ot">ds ::</span> a) <span class="ot">-&gt;</span>
    <span class="kw">case</span> <span class="fu">==</span> <span class="fu">$</span>dEq ds (fromInteger <span class="fu">$</span>dNum (__integer <span class="dv">0</span>)) <span class="kw">of</span> _ {
      <span class="dt">False</span> <span class="ot">-&gt;</span>
        <span class="kw">case</span> <span class="fu">==</span> <span class="fu">$</span>dEq ds (fromInteger <span class="fu">$</span>dNum (__integer <span class="dv">1</span>)) <span class="kw">of</span> _ {
          <span class="dt">False</span> <span class="ot">-&gt;</span>
            <span class="kw">case</span> <span class="fu">==</span> <span class="fu">$</span>dEq ds (fromInteger <span class="fu">$</span>dNum (__integer <span class="dv">2</span>)) <span class="kw">of</span> _ {
              <span class="dt">False</span> <span class="ot">-&gt;</span>
                <span class="kw">case</span> <span class="fu">==</span> <span class="fu">$</span>dEq ds (fromInteger <span class="fu">$</span>dNum (__integer <span class="dv">3</span>)) <span class="kw">of</span> _ {
                  <span class="dt">False</span> <span class="ot">-&gt;</span>
                    <span class="kw">case</span> <span class="fu">==</span> <span class="fu">$</span>dEq ds (fromInteger <span class="fu">$</span>dNum (__integer <span class="dv">4</span>)) <span class="kw">of</span> _ {
                      <span class="dt">False</span> <span class="ot">-&gt;</span> fromInteger <span class="fu">$</span>dNum1 (__integer <span class="dv">0</span>);
                      <span class="dt">True</span> <span class="ot">-&gt;</span> fromInteger <span class="fu">$</span>dNum1 (__integer <span class="dv">5</span>)
                    };
                  <span class="dt">True</span> <span class="ot">-&gt;</span> fromInteger <span class="fu">$</span>dNum1 (__integer <span class="dv">4</span>)
                };
              <span class="dt">True</span> <span class="ot">-&gt;</span> fromInteger <span class="fu">$</span>dNum1 (__integer <span class="dv">3</span>)
            };
          <span class="dt">True</span> <span class="ot">-&gt;</span> fromInteger <span class="fu">$</span>dNum1 (__integer <span class="dv">2</span>)
        };
      <span class="dt">True</span> <span class="ot">-&gt;</span> fromInteger <span class="fu">$</span>dNum1 (__integer <span class="dv">1</span>)
    }</code></pre></div>
<p>Of course, adding a concrete type signature changes the desugar just matching on the unboxed values.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
f <span class="fu">=</span>
  \ (<span class="ot">ds ::</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span>
    <span class="kw">case</span> ds <span class="kw">of</span> _ { <span class="dt">I</span><span class="fu">#</span> ds1 <span class="ot">-&gt;</span>
    <span class="kw">case</span> ds1 <span class="kw">of</span> _ {
      __<span class="dt">DEFAULT</span> <span class="ot">-&gt;</span> <span class="dt">I</span><span class="fu">#</span> <span class="dv">0</span>;
      <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="dt">I</span><span class="fu">#</span> <span class="dv">1</span>;
      <span class="dv">1</span> <span class="ot">-&gt;</span> <span class="dt">I</span><span class="fu">#</span> <span class="dv">2</span>;
      <span class="dv">2</span> <span class="ot">-&gt;</span> <span class="dt">I</span><span class="fu">#</span> <span class="dv">3</span>;
      <span class="dv">3</span> <span class="ot">-&gt;</span> <span class="dt">I</span><span class="fu">#</span> <span class="dv">4</span>;
      <span class="dv">4</span> <span class="ot">-&gt;</span> <span class="dt">I</span><span class="fu">#</span> <span class="dv">5</span>
    }
    }</code></pre></div>
<p>See:</p>
<ul>
<li><a href="https://github.com/ghc/ghc/blob/master/docs/core-spec/core-spec.pdf">Core Spec</a></li>
<li><a href="http://alpmestan.com/2013/06/27/ghc-core-by-example-episode-1/">Core By Example</a></li>
<li><a href="../../ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType.html">CoreSynType</a></li>
</ul>
<h2 id="inliner">Inliner</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">infixr</span> <span class="dv">0</span>  <span class="fu">$</span>

<span class="ot">($)::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b
f <span class="fu">$</span> x <span class="fu">=</span>  f x</code></pre></div>
<p>Having to enter a secondary closure every time we used <code>($)</code> would introduce an enormous overhead. Fortunately GHC has a pass to eliminate small functions like this by simply replacing the function call with the body of its definition at appropriate call-sites. The compiler contains a variety of heuristics for determining when this kind of substitution is appropriate and the potential costs involved.</p>
<p>In addition to the automatic inliner, manual pragmas are provided for more granular control over inlining. It's important to note that naive inlining quite often results in significantly worse performance and longer compilation times.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# INLINE func #-}</span>
<span class="ot">{-# INLINABLE func #-}</span>
<span class="ot">{-# NOINLINE func #-}</span></code></pre></div>
<p>For example the contrived case where we apply a binary function to two arguments. The function body is small and instead of entering another closure just to apply the given function, we could in fact just inline the function application at the call site.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# INLINE foo #-}</span>
<span class="ot">{-# NOINLINE bar #-}</span>

<span class="ot">foo ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c
foo f x y <span class="fu">=</span> f x y

<span class="ot">bar ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c
bar f x y <span class="fu">=</span> f x y

<span class="ot">test1 ::</span> <span class="dt">Int</span>
test1 <span class="fu">=</span> foo (<span class="fu">+</span>) <span class="dv">10</span> <span class="dv">20</span>

<span class="ot">test2 ::</span> <span class="dt">Int</span>
test2 <span class="fu">=</span> bar (<span class="fu">+</span>) <span class="dv">20</span> <span class="dv">30</span></code></pre></div>
<p>Looking at the core, we can see that in <code>test1</code> the function has indeed been expanded at the call site and simply performs the addition there instead of another indirection.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">test1 ::</span> <span class="dt">Int</span>
test1 <span class="fu">=</span>
  <span class="kw">let</span> {
<span class="ot">    f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
    f <span class="fu">=</span> <span class="fu">+</span> <span class="fu">$</span>fNumInt } <span class="kw">in</span>
  <span class="kw">let</span> {
<span class="ot">    x ::</span> <span class="dt">Int</span>
    x <span class="fu">=</span> <span class="dt">I</span><span class="fu">#</span> <span class="dv">10</span> } <span class="kw">in</span>
  <span class="kw">let</span> {
<span class="ot">    y ::</span> <span class="dt">Int</span>
    y <span class="fu">=</span> <span class="dt">I</span><span class="fu">#</span> <span class="dv">20</span> } <span class="kw">in</span>
  f x y

<span class="ot">test2 ::</span> <span class="dt">Int</span>
test2 <span class="fu">=</span> bar (<span class="fu">+</span> <span class="fu">$</span>fNumInt) (<span class="dt">I</span><span class="fu">#</span> <span class="dv">20</span>) (<span class="dt">I</span><span class="fu">#</span> <span class="dv">30</span>)</code></pre></div>
<p>Cases marked with <code>NOINLINE</code> generally indicate that the logic in the function is using something like <code>unsafePerformIO</code> or some other unholy function. In these cases naive inlining might duplicate effects at multiple call-sites throughout the program which would be undesirable.</p>
<p>See:</p>
<ul>
<li><a href="https://research.microsoft.com/en-us/um/people/simonpj/Papers/inlining/inline.pdf">Secrets of the Glasgow Haskell Compiler inliner</a></li>
</ul>
<!--

Rewrite Rules
-------------

<div class="alert alert-danger">
This is an advanced section, and is not typically necessary to write Haskell.
</div>

TODO

* [Using Rules](https://wiki.haskell.org/GHC/Using_rules)
* [Rewrite Rules](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/rewrite-rules.html)

Fusion
------

<div class="alert alert-danger">
This is an advanced section, and is not typically necessary to write Haskell.
</div>

TODO

* [List Fusion](https://downloads.haskell.org/~ghc/7.10.3/docs/html/users_guide/rewrite-rules.html)

-->
<h2 id="dictionaries">Dictionaries</h2>
<p>The Haskell language defines the notion of Typeclasses but is agnostic to how they are implemented in a Haskell compiler. GHC's particular implementation uses a pass called the <em>dictionary passing translation</em> part of the elaboration phase of the typechecker which translates Core functions with typeclass constraints into implicit parameters of which record-like structures containing the function implementations are passed.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Num</span> a <span class="kw">where</span>
<span class="ot">  (+) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">  (*) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">  negate ::</span> a <span class="ot">-&gt;</span> a</code></pre></div>
<p>This class can be thought as the implementation equivalent to the following parameterized record of functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">DNum</span> a <span class="fu">=</span> <span class="dt">DNum</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) (a <span class="ot">-&gt;</span> a)

add (<span class="dt">DNum</span> a m n) <span class="fu">=</span> a
mul (<span class="dt">DNum</span> a m n) <span class="fu">=</span> m
neg (<span class="dt">DNum</span> a m n) <span class="fu">=</span> n

<span class="ot">numDInt ::</span> <span class="dt">DNum</span> <span class="dt">Int</span>
numDInt <span class="fu">=</span> <span class="dt">DNum</span> plusInt timesInt negateInt

<span class="ot">numDFloat ::</span> <span class="dt">DNum</span> <span class="dt">Float</span>
numDFloat <span class="fu">=</span> <span class="dt">DNum</span> plusFloat timesFloat negateFloat</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">+</span><span class="ot"> ::</span> forall a<span class="fu">.</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="fu">+</span> <span class="fu">=</span> \ (<span class="fu">@</span> a) (<span class="ot">tpl ::</span> <span class="dt">Num</span> a) <span class="ot">-&gt;</span>
  <span class="kw">case</span> tpl <span class="kw">of</span> _ { <span class="dt">D</span><span class="fu">:</span><span class="dt">Num</span> tpl _ _ <span class="ot">-&gt;</span> tpl }

<span class="fu">*</span><span class="ot"> ::</span> forall a<span class="fu">.</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="fu">*</span> <span class="fu">=</span> \ (<span class="fu">@</span> a) (<span class="ot">tpl ::</span> <span class="dt">Num</span> a) <span class="ot">-&gt;</span>
  <span class="kw">case</span> tpl <span class="kw">of</span> _ { <span class="dt">D</span><span class="fu">:</span><span class="dt">Num</span> _ tpl _ <span class="ot">-&gt;</span> tpl }

negate<span class="ot"> ::</span> forall a<span class="fu">.</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a
negate <span class="fu">=</span> \ (<span class="fu">@</span> a) (<span class="ot">tpl ::</span> <span class="dt">Num</span> a) <span class="ot">-&gt;</span>
  <span class="kw">case</span> tpl <span class="kw">of</span> _ { <span class="dt">D</span><span class="fu">:</span><span class="dt">Num</span> _ _ tpl <span class="ot">-&gt;</span> tpl }</code></pre></div>
<p><code>Num</code> and <code>Ord</code> have simple translation but for monads with existential type variables in their signatures, the only way to represent the equivalent dictionary is using <code>RankNTypes</code>. In addition a typeclass may also include superclasses which would be included in the typeclass dictionary and parameterized over the same arguments and an implicit superclass constructor function is created to pull out functions from the superclass for the current monad.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">DMonad</span> m <span class="fu">=</span> <span class="dt">DMonad</span>
  {<span class="ot"> bind   ::</span> forall a b<span class="fu">.</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b
  ,<span class="ot"> return ::</span> forall a<span class="fu">.</span> a <span class="ot">-&gt;</span> m a
  }</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Functor</span> t, <span class="dt">Foldable</span> t) <span class="ot">=&gt;</span> <span class="dt">Traversable</span> t <span class="kw">where</span>
<span class="ot">    traverse ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> f (t b)
    traverse f <span class="fu">=</span> sequenceA <span class="fu">.</span> fmap f</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">DTraversable</span> t <span class="fu">=</span> <span class="dt">DTraversable</span>
  {<span class="ot"> dFunctorTraversable ::</span> <span class="dt">DFunctor</span> t  <span class="co">-- superclass dictionary</span>
  ,<span class="ot"> dFoldableTraversable ::</span> <span class="dt">DFoldable</span> t <span class="co">-- superclass dictionary</span>
  ,<span class="ot"> traverse ::</span> forall a<span class="fu">.</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> f (t b)
  }</code></pre></div>
<p>Indeed this is not that far from how GHC actually implements typeclasses. It elaborates into projection functions and data constructors nearly identical to this, and are expanded out to a dictionary argument for each typeclass constraint of every polymorphic function.</p>
<h2 id="specialization">Specialization</h2>
<p>Overloading in Haskell is normally not entirely free by default, although with an optimization called specialization it can be made to have zero cost at specific points in the code where performance is crucial. This is not enabled by default by virtue of the fact that GHC is not a whole-program optimizing compiler and most optimizations ( not all ) stop at module boundaries.</p>
<p>GHC's method of implementing typeclasses means that explicit dictionaries are threaded around implicitly throughout the call sites. This is normally the most natural way to implement this functionality since it preserves separate compilation. A function can be compiled independently of where it is declared, not recompiled at every point in the program where it's called. The dictionary passing allows the caller to thread the implementation logic for the types to the call-site where it can then be used throughout the body of the function.</p>
<p>Of course this means that in order to get at a specific typeclass function we need to project ( possibly multiple times ) into the dictionary structure to pluck out the function reference. The runtime makes this very cheap but not entirely free.</p>
<p>Many C++ compilers or whole program optimizing compilers do the opposite however, they explicitly specialize each and every function at the call site replacing the overloaded function with its type-specific implementation. We can selectively enable this kind of behavior using class specialization.</p>
<div class="sourceCode" include="src/29-ghc/specialize.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Specialize</span> (spec, nonspec, f) <span class="kw">where</span>

<span class="ot">{-# SPECIALIZE INLINE f :: Double -&gt; Double -&gt; Double #-}</span>

<span class="ot">f ::</span> <span class="dt">Floating</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
f x y <span class="fu">=</span> exp (x <span class="fu">+</span> y) <span class="fu">*</span> exp (x <span class="fu">+</span> y)

<span class="ot">nonspec ::</span> <span class="dt">Float</span>
nonspec <span class="fu">=</span> f (<span class="dv">10</span><span class="ot"> ::</span> <span class="dt">Float</span>) (<span class="dv">20</span><span class="ot"> ::</span> <span class="dt">Float</span>)

<span class="ot">spec ::</span> <span class="dt">Double</span>
spec <span class="fu">=</span> f (<span class="dv">10</span><span class="ot"> ::</span> <span class="dt">Double</span>) (<span class="dv">20</span><span class="ot"> ::</span> <span class="dt">Double</span>)</code></pre></div>
<p><strong>Non-specialized</strong></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> forall a<span class="fu">.</span> <span class="dt">Floating</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
f <span class="fu">=</span>
  \ (<span class="fu">@</span> a) (<span class="fu">$</span><span class="ot">dFloating ::</span> <span class="dt">Floating</span> a) (<span class="ot">eta ::</span> a) (<span class="ot">eta1 ::</span> a) <span class="ot">-&gt;</span>
    <span class="kw">let</span> {
<span class="ot">      a ::</span> <span class="dt">Fractional</span> a
      a <span class="fu">=</span> <span class="fu">$</span>p1Floating <span class="fu">@</span> a <span class="fu">$</span>dFloating } <span class="kw">in</span>
    <span class="kw">let</span> {
      <span class="fu">$</span><span class="ot">dNum ::</span> <span class="dt">Num</span> a
      <span class="fu">$</span>dNum <span class="fu">=</span> <span class="fu">$</span>p1Fractional <span class="fu">@</span> a a } <span class="kw">in</span>
    <span class="fu">*</span> <span class="fu">@</span> a
      <span class="fu">$</span>dNum
      (exp <span class="fu">@</span> a <span class="fu">$</span>dFloating (<span class="fu">+</span> <span class="fu">@</span> a <span class="fu">$</span>dNum eta eta1))
      (exp <span class="fu">@</span> a <span class="fu">$</span>dFloating (<span class="fu">+</span> <span class="fu">@</span> a <span class="fu">$</span>dNum eta eta1))</code></pre></div>
<p>In the specialized version the typeclass operations placed directly at the call site and are simply unboxed arithmetic. This will map to a tight set of sequential CPU instructions and is very likely the same code generated by C.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">spec ::</span> <span class="dt">Double</span>
spec <span class="fu">=</span> <span class="dt">D</span><span class="fu">#</span> (<span class="fu">*##</span> (expDouble<span class="fu">#</span> <span class="fl">30.0</span>) (expDouble<span class="fu">#</span> <span class="fl">30.0</span>))</code></pre></div>
<p>The non-specialized version has to project into the typeclass dictionary (<code>$fFloatingFloat</code>) 6 times and likely go through around 25 branches to perform the same operation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">nonspec ::</span> <span class="dt">Float</span>
nonspec <span class="fu">=</span>
  f <span class="fu">@</span> <span class="dt">Float</span> <span class="fu">$</span>fFloatingFloat (<span class="dt">F</span><span class="fu">#</span> (__float <span class="fl">10.0</span>)) (<span class="dt">F</span><span class="fu">#</span> (__float <span class="fl">20.0</span>))</code></pre></div>
<p>For a tight loop over numeric types specializing at the call site can result in orders of magnitude performance increase. Although the cost in compile-time can often be non-trivial and when used function used at many call-sites this can slow GHC's simplifier pass to a crawl.</p>
<p>The best advice is profile and look for large uses of dictionary projection in tight loops and then specialize and inline in these places.</p>
<p>Using the <code>SPECIALISE INLINE</code> pragma can unintentionally cause GHC to diverge if applied over a recursive function, it will try to specialize itself infinitely.</p>
<h2 id="static-compilation">Static Compilation</h2>
<p>On Linux, Haskell programs can be compiled into a standalone statically linked binary that includes the runtime statically linked into it.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">ghc</span> -O2 --make -static -optc-static -optl-static -optl-pthread Example.hs
$ <span class="kw">file</span> Example
<span class="kw">Example</span>: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), <span class="kw">statically</span> linked, for GNU/Linux 2.6.32, not stripped
$ <span class="kw">ldd</span> Example
        <span class="kw">not</span> a dynamic executable</code></pre></div>
<p>In addition the file size of the resulting binary can be reduced by stripping unneeded symbols.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">strip</span> Example</code></pre></div>
<p><a href="http://upx.sourceforge.net/">upx</a> can additionally be used to compress the size of the executable down further.</p>
<h2 id="unboxed-types">Unboxed Types</h2>
<p>The usual numerics types in Haskell can be considered to be a regular algebraic datatype with special constructor arguments for their underlying unboxed values. Normally unboxed types and explicit unboxing are not used in normal code, they are wired-in to the compiler.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Int</span> <span class="fu">=</span> <span class="dt">I</span><span class="fu">#</span> <span class="dt">Int</span><span class="fu">#</span>

<span class="kw">data</span> <span class="dt">Integer</span>
  <span class="fu">=</span> <span class="dt">S</span><span class="fu">#</span> <span class="dt">Int</span><span class="fu">#</span>              <span class="co">-- Small integers</span>
  <span class="fu">|</span> <span class="dt">J</span><span class="fu">#</span> <span class="dt">Int</span><span class="fu">#</span> <span class="dt">ByteArray</span><span class="fu">#</span>   <span class="co">-- Large GMP integers</span>

<span class="kw">data</span> <span class="dt">Float</span> <span class="fu">=</span> <span class="dt">F</span><span class="fu">#</span> <span class="dt">Float</span><span class="fu">#</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">Syntax</th>
<th align="left">Primitive Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>3#</code></td>
<td align="left">GHC.Prim.Int#</td>
</tr>
<tr class="even">
<td align="left"><code>3##</code></td>
<td align="left">GHC.Prim.Word#</td>
</tr>
<tr class="odd">
<td align="left"><code>3.14#</code></td>
<td align="left">GHC.Prim.Float#</td>
</tr>
<tr class="even">
<td align="left"><code>3.14##</code></td>
<td align="left">GHC.Prim.Double#</td>
</tr>
<tr class="odd">
<td align="left"><code>'c'#</code></td>
<td align="left">GHC.Prim.Char#</td>
</tr>
<tr class="even">
<td align="left"><code>&quot;Haskell&quot;##</code></td>
<td align="left">GHC.Prim.Addr#</td>
</tr>
</tbody>
</table>
<p>An unboxed type with kind <code>#</code> and will never unify a type variable of kind <code>*</code>. Intuitively a type with kind <code>*</code> indicates a type with a uniform runtime representation that can be used polymorphically.</p>
<ul>
<li><em>Lifted</em> - Can contain a bottom term, represented by a pointer. ( <code>Int</code>, <code>Any</code>, <code>(,)</code> )</li>
<li><em>Unlited</em> - Cannot contain a bottom term, represented by a value on the stack. ( <code>Int#</code>, <code>(#, #)</code> )</li>
</ul>
<div class="sourceCode" include="src/29-ghc/prim.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE BangPatterns, MagicHash, UnboxedTuples #-}</span>

<span class="kw">import </span><span class="dt">GHC.Exts</span>
<span class="kw">import </span><span class="dt">GHC.Prim</span>

<span class="ot">ex1 ::</span> <span class="dt">Bool</span>
ex1 <span class="fu">=</span> gtChar<span class="fu">#</span> a<span class="fu">#</span> b<span class="fu">#</span>
  <span class="kw">where</span>
    <span class="fu">!</span>(<span class="dt">C</span><span class="fu">#</span> a<span class="fu">#</span>) <span class="fu">=</span> <span class="ch">&#39;a&#39;</span>
    <span class="fu">!</span>(<span class="dt">C</span><span class="fu">#</span> b<span class="fu">#</span>) <span class="fu">=</span> <span class="ch">&#39;b&#39;</span>

<span class="ot">ex2 ::</span> <span class="dt">Int</span>
ex2 <span class="fu">=</span> <span class="dt">I</span><span class="fu">#</span> (a<span class="fu">#</span> <span class="fu">+#</span> b<span class="fu">#</span>)
  <span class="kw">where</span>
    <span class="fu">!</span>(<span class="dt">I</span><span class="fu">#</span> a<span class="fu">#</span>) <span class="fu">=</span> <span class="dv">1</span>
    <span class="fu">!</span>(<span class="dt">I</span><span class="fu">#</span> b<span class="fu">#</span>) <span class="fu">=</span> <span class="dv">2</span>

<span class="ot">ex3 ::</span> <span class="dt">Int</span>
ex3 <span class="fu">=</span> (<span class="dt">I</span><span class="fu">#</span> (<span class="dv">1</span><span class="fu">#</span> <span class="fu">+#</span> <span class="dv">2</span><span class="fu">#</span> <span class="fu">*#</span> <span class="dv">3</span><span class="fu">#</span> <span class="fu">+#</span> <span class="dv">4</span><span class="fu">#</span>))

<span class="ot">ex4 ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
ex4 <span class="fu">=</span> (<span class="dt">I</span><span class="fu">#</span> (dataToTag<span class="fu">#</span> <span class="dt">False</span>), <span class="dt">I</span><span class="fu">#</span> (dataToTag<span class="fu">#</span> <span class="dt">True</span>))</code></pre></div>
<p>The function for integer arithmetic used in the <code>Num</code> typeclass for <code>Int</code> is just pattern matching on this type to reveal the underlying unboxed value, performing the builtin arithmetic and then performing the packing up into <code>Int</code> again.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">plusInt ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
(<span class="dt">I</span><span class="fu">#</span> x) <span class="ot">`plusInt`</span> (<span class="dt">I</span><span class="fu">#</span> y) <span class="fu">=</span> <span class="dt">I</span><span class="fu">#</span> (x <span class="fu">+#</span> y)</code></pre></div>
<p>Where <code>(+#)</code> is a low level function built into GHC that maps to intrinsic integer addition instruction for the CPU.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">plusInt ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
plusInt a b <span class="fu">=</span> <span class="kw">case</span> a <span class="kw">of</span> {
    (<span class="dt">I</span><span class="fu">#</span> a_) <span class="ot">-&gt;</span> <span class="kw">case</span> b <span class="kw">of</span> {
      (<span class="dt">I</span><span class="fu">#</span> b_) <span class="ot">-&gt;</span> <span class="dt">I</span><span class="fu">#</span> (<span class="fu">+#</span> a_ b_);
    };
};</code></pre></div>
<p>Runtime values in Haskell are by default represented uniformly by a boxed <code>StgClosure*</code> struct which itself contains several payload values, which can themselves either be pointers to other boxed values or to unboxed literal values that fit within the system word size and are stored directly within the closure in memory. The layout of the box is described by a bitmap in the header for the closure which describes which values in the payload are either pointers or non-pointers.</p>
<p>The <code>unpackClosure#</code> primop can be used to extract this information at runtime by reading off the bitmap on the closure.</p>
<div class="sourceCode" include="src/29-ghc/closure_size.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE MagicHash, UnboxedTuples #-}</span>
<span class="ot">{-# OPTIONS_GHC -O1 #-}</span>

<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">GHC.Exts</span>
<span class="kw">import </span><span class="dt">GHC.Base</span>
<span class="kw">import </span><span class="dt">Foreign</span>

<span class="kw">data</span> <span class="dt">Size</span> <span class="fu">=</span> <span class="dt">Size</span>
  {<span class="ot"> ptrs  ::</span> <span class="dt">Int</span>
  ,<span class="ot"> nptrs ::</span> <span class="dt">Int</span>
  ,<span class="ot"> size  ::</span> <span class="dt">Int</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="ot">unsafeSizeof ::</span> a <span class="ot">-&gt;</span> <span class="dt">Size</span>
unsafeSizeof a <span class="fu">=</span>
  <span class="kw">case</span> unpackClosure<span class="fu">#</span> a <span class="kw">of</span>
    (<span class="fu">#</span> x, ptrs, nptrs <span class="fu">#</span>) <span class="ot">-&gt;</span>
      <span class="kw">let</span> header  <span class="fu">=</span> sizeOf (undefined<span class="ot"> ::</span> <span class="dt">Int</span>)
          ptr_c   <span class="fu">=</span> <span class="dt">I</span><span class="fu">#</span> (sizeofArray<span class="fu">#</span> ptrs)
          nptr_c  <span class="fu">=</span> <span class="dt">I</span><span class="fu">#</span> (sizeofByteArray<span class="fu">#</span> nptrs) <span class="ot">`div`</span> sizeOf (undefined<span class="ot"> ::</span> <span class="dt">Word</span>)
          payload <span class="fu">=</span> <span class="dt">I</span><span class="fu">#</span> (sizeofArray<span class="fu">#</span> ptrs <span class="fu">+#</span> sizeofByteArray<span class="fu">#</span> nptrs)
          size    <span class="fu">=</span> header <span class="fu">+</span> payload
      <span class="kw">in</span> <span class="dt">Size</span> ptr_c nptr_c size

<span class="kw">data</span> <span class="dt">A</span> <span class="fu">=</span> <span class="dt">A</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span>
<span class="kw">data</span> <span class="dt">B</span> <span class="fu">=</span> <span class="dt">B</span> <span class="dt">Int</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  print (unsafeSizeof (<span class="dt">A</span> <span class="dv">42</span>))
  print (unsafeSizeof (<span class="dt">B</span> <span class="dv">42</span>))</code></pre></div>
<p>For example the datatype with the <code>UNPACK</code> pragma contains 1 non-pointer and 0 pointers.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">A</span> <span class="fu">=</span> <span class="dt">A</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span>
<span class="dt">Size</span> {ptrs <span class="fu">=</span> <span class="dv">0</span>, nptrs <span class="fu">=</span> <span class="dv">1</span>, size <span class="fu">=</span> <span class="dv">16</span>}</code></pre></div>
<p>While the default packed datatype contains 1 pointer and 0 non-pointers.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">B</span> <span class="fu">=</span> <span class="dt">B</span> <span class="dt">Int</span>
<span class="dt">Size</span> {ptrs <span class="fu">=</span> <span class="dv">1</span>, nptrs <span class="fu">=</span> <span class="dv">0</span>, size <span class="fu">=</span> <span class="dv">9</span>}</code></pre></div>
<p>The closure representation for data constructors are also &quot;tagged&quot; at the runtime with the tag of the specific constructor. This is however not a runtime type tag since there is no way to recover the type from the tag as all constructor simply use the sequence (0, 1, 2, ...). The tag is used to discriminate cases in pattern matching. The builtin <code>dataToTag#</code> can be used to pluck off the tag for an arbitrary datatype. This is used in some cases when desugaring pattern matches.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">dataToTag<span class="fu">#</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span><span class="fu">#</span></code></pre></div>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- data Bool = False | True</span>
<span class="co">-- False ~ 0</span>
<span class="co">-- True  ~ 1</span>

<span class="ot">a ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
a <span class="fu">=</span> (<span class="dt">I</span><span class="fu">#</span> (dataToTag<span class="fu">#</span> <span class="dt">False</span>), <span class="dt">I</span><span class="fu">#</span> (dataToTag<span class="fu">#</span> <span class="dt">True</span>))
<span class="co">-- (0, 1)</span>

<span class="co">-- data Ordering = LT | EQ | GT</span>
<span class="co">-- LT ~ 0</span>
<span class="co">-- EQ ~ 1</span>
<span class="co">-- GT ~ 2</span>

<span class="ot">b ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>)
b <span class="fu">=</span> (<span class="dt">I</span><span class="fu">#</span> (dataToTag<span class="fu">#</span> <span class="dt">LT</span>), <span class="dt">I</span><span class="fu">#</span> (dataToTag<span class="fu">#</span> <span class="dt">EQ</span>), <span class="dt">I</span><span class="fu">#</span> (dataToTag<span class="fu">#</span> <span class="dt">GT</span>))
<span class="co">-- (0, 1, 2)</span>

<span class="co">-- data Either a b = Left a | Right b</span>
<span class="co">-- Left ~ 0</span>
<span class="co">-- Right ~ 1</span>

<span class="ot">c ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
c <span class="fu">=</span> (<span class="dt">I</span><span class="fu">#</span> (dataToTag<span class="fu">#</span> (<span class="dt">Left</span> <span class="dv">0</span>)), <span class="dt">I</span><span class="fu">#</span> (dataToTag<span class="fu">#</span> (<span class="dt">Right</span> <span class="dv">1</span>)))
<span class="co">-- (0, 1)</span></code></pre></div>
<p>String literals included in the source code are also translated into several primop operations. The <code>Addr#</code> type in Haskell stands for a static contagious buffer pre-allocated on the Haskell heap that can hold a <code>char*</code> sequence. The operation <code>unpackCString#</code> can scan this buffer and fold it up into a list of Chars from inside Haskell.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">unpackCString<span class="fu">#</span><span class="ot"> ::</span> <span class="dt">Addr</span><span class="fu">#</span> <span class="ot">-&gt;</span> [<span class="dt">Char</span>]</code></pre></div>
<p>This is done in the early frontend desugarer phase, where literals are translated into <code>Addr#</code> inline instead of giant chain of Cons'd characters. So our &quot;Hello World&quot; translates into the following Core:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- print &quot;Hello World&quot;</span>
print (unpackCString<span class="fu">#</span> <span class="st">&quot;Hello World&quot;</span><span class="fu">#</span>)</code></pre></div>
<p>See:</p>
<ul>
<li><a href="http://www.haskell.org/ghc/docs/papers/unboxed-values.ps.gz">Unboxed Values as First-Class Citizens</a></li>
</ul>
<h2 id="iost">IO/ST</h2>
<p>Both the IO and the ST monad have special state in the GHC runtime and share a very similar implementation. Both <code>ST a</code> and <code>IO a</code> are passing around an unboxed tuple of the form:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="fu">#</span> token, a <span class="fu">#</span>)</code></pre></div>
<p>The <code>RealWorld#</code> token is &quot;deeply magical&quot; and doesn't actually expand into any code when compiled, but simply threaded around through every bind of the IO or ST monad and has several properties of being unique and not being able to be duplicated to ensure sequential IO actions are actually sequential. <code>unsafePerformIO</code> can thought of as the unique operation which discards the world token and plucks the <code>a</code> out, and is as the name implies not normally safe.</p>
<p>The <code>PrimMonad</code> abstracts over both these monads with an associated data family for the world token or ST thread, and can be used to write operations that generic over both ST and IO. This is used extensively inside of the vector package to allow vector algorithms to be written generically either inside of IO or ST.</p>
<div class="sourceCode" include="src/29-ghc/io_impl.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE MagicHash #-}</span>
<span class="ot">{-# LANGUAGE UnboxedTuples #-}</span>

<span class="kw">import </span><span class="dt">GHC.IO</span> ( <span class="dt">IO</span>(..) )
<span class="kw">import </span><span class="dt">GHC.Prim</span> ( <span class="dt">State</span>#, <span class="dt">RealWorld</span> )
<span class="kw">import </span><span class="dt">GHC.Base</span> ( realWorld# )

<span class="kw">instance</span>  <span class="dt">Monad</span> <span class="dt">IO</span>  <span class="kw">where</span>
    m <span class="fu">&gt;&gt;</span> k    <span class="fu">=</span> m <span class="fu">&gt;&gt;=</span> \ _ <span class="ot">-&gt;</span> k
    return    <span class="fu">=</span> returnIO
    (<span class="fu">&gt;&gt;=</span>)     <span class="fu">=</span> bindIO
    fail s    <span class="fu">=</span> failIO s

<span class="ot">returnIO ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
returnIO x <span class="fu">=</span> <span class="dt">IO</span> <span class="fu">$</span> \ s <span class="ot">-&gt;</span> (<span class="fu">#</span> s, x <span class="fu">#</span>)

<span class="ot">bindIO ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b
bindIO (<span class="dt">IO</span> m) k <span class="fu">=</span> <span class="dt">IO</span> <span class="fu">$</span> \ s <span class="ot">-&gt;</span> <span class="kw">case</span> m s <span class="kw">of</span> (<span class="fu">#</span> new_s, a <span class="fu">#</span>) <span class="ot">-&gt;</span> unIO (k a) new_s

<span class="ot">thenIO ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> b
thenIO (<span class="dt">IO</span> m) k <span class="fu">=</span> <span class="dt">IO</span> <span class="fu">$</span> \ s <span class="ot">-&gt;</span> <span class="kw">case</span> m s <span class="kw">of</span> (<span class="fu">#</span> new_s, _ <span class="fu">#</span>) <span class="ot">-&gt;</span> unIO k new_s

<span class="ot">unIO ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (<span class="dt">State</span><span class="fu">#</span> <span class="dt">RealWorld</span> <span class="ot">-&gt;</span> (<span class="fu">#</span> <span class="dt">State</span><span class="fu">#</span> <span class="dt">RealWorld</span>, a <span class="fu">#</span>))
unIO (<span class="dt">IO</span> a) <span class="fu">=</span> a</code></pre></div>
<div class="sourceCode" include="src/29-ghc/monad_prim.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE MagicHash #-}</span>
<span class="ot">{-# LANGUAGE UnboxedTuples #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>

<span class="kw">import </span><span class="dt">GHC.IO</span> ( <span class="dt">IO</span>(..) )
<span class="kw">import </span><span class="dt">GHC.ST</span> ( <span class="dt">ST</span>(..) )
<span class="kw">import </span><span class="dt">GHC.Prim</span> ( <span class="dt">State</span>#, <span class="dt">RealWorld</span> )
<span class="kw">import </span><span class="dt">GHC.Base</span> ( realWorld# )

<span class="kw">class</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">PrimMonad</span> m <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">PrimState</span> m
<span class="ot">  primitive ::</span> (<span class="dt">State</span><span class="fu">#</span> (<span class="dt">PrimState</span> m) <span class="ot">-&gt;</span> (<span class="fu">#</span> <span class="dt">State</span><span class="fu">#</span> (<span class="dt">PrimState</span> m), a <span class="fu">#</span>)) <span class="ot">-&gt;</span> m a
<span class="ot">  internal ::</span> m a <span class="ot">-&gt;</span> <span class="dt">State</span><span class="fu">#</span> (<span class="dt">PrimState</span> m) <span class="ot">-&gt;</span> (<span class="fu">#</span> <span class="dt">State</span><span class="fu">#</span> (<span class="dt">PrimState</span> m), a <span class="fu">#</span>)

<span class="kw">instance</span> <span class="dt">PrimMonad</span> <span class="dt">IO</span> <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">PrimState</span> <span class="dt">IO</span> <span class="fu">=</span> <span class="dt">RealWorld</span>
  <span class="kw">primitive</span> <span class="fu">=</span> <span class="dt">IO</span>
  internal (<span class="dt">IO</span> p) <span class="fu">=</span> p

<span class="kw">instance</span> <span class="dt">PrimMonad</span> (<span class="dt">ST</span> s) <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">PrimState</span> (<span class="dt">ST</span> s) <span class="fu">=</span> s
  <span class="kw">primitive</span> <span class="fu">=</span> <span class="dt">ST</span>
  internal (<span class="dt">ST</span> p) <span class="fu">=</span> p</code></pre></div>
<p>See:</p>
<ul>
<li><a href="https://www.fpcomplete.com/user/snoyberg/general-haskell/advanced/evaluation-order-and-state-tokens">Evaluation order and state tokens</a></li>
</ul>
<h2 id="ghc-heap-view">ghc-heap-view</h2>
<p>Through some dark runtime magic we can actually inspect the <code>StgClosure</code> structures at runtime using various C and Cmm hacks to probe at the fields of the structure's representation to the runtime. The library <code>ghc-heap-view</code> can be used to introspect such things, although there is really no use for this kind of thing in everyday code it is very helpful when studying the GHC internals to be able to inspect the runtime implementation details and get at the raw bits underlying all Haskell types.</p>
<div class="sourceCode" include="src/29-ghc/heapview.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE MagicHash #-}</span>

<span class="kw">import </span><span class="dt">GHC.Exts</span>
<span class="kw">import </span><span class="dt">GHC.HeapView</span>

<span class="kw">import </span><span class="dt">System.Mem</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- Constr</span>
  clo <span class="ot">&lt;-</span> getClosureData <span class="fu">$!</span> ([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]<span class="ot"> ::</span> [<span class="dt">Int</span>])
  print clo

  <span class="co">-- Thunk</span>
  <span class="kw">let</span> thunk <span class="fu">=</span> id (<span class="dv">1</span><span class="fu">+</span><span class="dv">1</span>)
  clo <span class="ot">&lt;-</span> getClosureData thunk
  print clo

  <span class="co">-- evaluate to WHNF</span>
  thunk <span class="ot">`seq`</span> return ()

  <span class="co">-- Indirection</span>
  clo <span class="ot">&lt;-</span> getClosureData thunk
  print clo

  <span class="co">-- force garbage collection</span>
  performGC

  <span class="co">-- Value</span>
  clo <span class="ot">&lt;-</span> getClosureData thunk
  print clo</code></pre></div>
<p>A constructor (in this for cons constructor of list type) is represented by a <code>CONSTR</code> closure that holds two pointers to the head and the tail. The integer in the head argument is a static reference to the pre-allocated number and we see a single static reference in the SRT (static reference table).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">ConsClosure</span> {
  info <span class="fu">=</span> <span class="dt">StgInfoTable</span> {
    ptrs <span class="fu">=</span> <span class="dv">2</span>,
    nptrs <span class="fu">=</span> <span class="dv">0</span>,
    tipe <span class="fu">=</span> <span class="dt">CONSTR_2_0</span>,
    srtlen <span class="fu">=</span> <span class="dv">1</span>
  },
  ptrArgs <span class="fu">=</span> [<span class="bn">0x000000000074aba8</span><span class="fu">/</span><span class="dv">1</span>,<span class="bn">0x00007fca10504260</span><span class="fu">/</span><span class="dv">2</span>],
  dataArgs <span class="fu">=</span> [],
  pkg <span class="fu">=</span> <span class="st">&quot;ghc-prim&quot;</span>,
  modl <span class="fu">=</span> <span class="st">&quot;GHC.Types&quot;</span>,
  name <span class="fu">=</span> <span class="st">&quot;:&quot;</span>
}</code></pre></div>
<p>We can also observe the evaluation and update of a thunk in process ( <code>id (1+1)</code> ). The initial thunk is simply a thunk type with a pointer to the code to evaluate it to a value.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">ThunkClosure</span> {
  info <span class="fu">=</span> <span class="dt">StgInfoTable</span> {
    ptrs <span class="fu">=</span> <span class="dv">0</span>,
    nptrs <span class="fu">=</span> <span class="dv">0</span>,
    tipe <span class="fu">=</span> <span class="dt">THUNK</span>,
    srtlen <span class="fu">=</span> <span class="dv">9</span>
  },
  ptrArgs <span class="fu">=</span> [],
  dataArgs <span class="fu">=</span> []
}</code></pre></div>
<p>When forced it is then evaluated and replaced with an Indirection closure which points at the computed value.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">BlackholeClosure</span> {
  info <span class="fu">=</span> <span class="dt">StgInfoTable</span> {
    ptrs <span class="fu">=</span> <span class="dv">1</span>,
    nptrs <span class="fu">=</span> <span class="dv">0</span>,
    tipe <span class="fu">=</span> <span class="dt">BLACKHOLE</span>,
    srtlen <span class="fu">=</span> <span class="dv">0</span>
  },
  indirectee <span class="fu">=</span> <span class="bn">0x00007fca10511e88</span><span class="fu">/</span><span class="dv">1</span>
}</code></pre></div>
<p>When the copying garbage collector passes over the indirection, it then simply replaces the indirection with a reference to the actual computed value computed by <code>indirectee</code> so that future access does need to chase a pointer through the indirection pointer to get the result.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">ConsClosure</span> {
  info <span class="fu">=</span> <span class="dt">StgInfoTable</span> {
    ptrs <span class="fu">=</span> <span class="dv">0</span>,
    nptrs <span class="fu">=</span> <span class="dv">1</span>,
    tipe <span class="fu">=</span> <span class="dt">CONSTR_0_1</span>,
    srtlen <span class="fu">=</span> <span class="dv">0</span>
  },
  ptrArgs <span class="fu">=</span> [],
  dataArgs <span class="fu">=</span> [<span class="dv">2</span>],
  pkg <span class="fu">=</span> <span class="st">&quot;integer-gmp&quot;</span>,
  modl <span class="fu">=</span> <span class="st">&quot;GHC.Integer.Type&quot;</span>,
  name <span class="fu">=</span> <span class="st">&quot;S#&quot;</span>
}</code></pre></div>
<h2 id="stg">STG</h2>
<p>After being compiled into Core, a program is translated into a very similar intermediate form known as STG ( Spineless Tagless G-Machine ) an abstract machine model that makes all laziness explicit. The spineless indicates that function applications in the language do not have a spine of applications of functions are collapsed into a sequence of arguments. Currying is still present in the semantics since arity information is stored and partially applied functions will evaluate differently than saturated functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Spine</span>
f x y z <span class="fu">=</span> <span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">App</span> f x) y) z

<span class="co">-- Spineless</span>
f x y z <span class="fu">=</span> <span class="dt">App</span> f [x, y, z]</code></pre></div>
<p>All let statements in STG bind a name to a <em>lambda form</em>. A lambda form with no arguments is a thunk, while a lambda-form with arguments indicates that a closure is to be allocated that captures the variables explicitly mentioned.</p>
<p>Thunks themselves are either reentrant (<code>\r</code>) or updatable (<code>\u</code>) indicating that the thunk and either yields a value to the stack or is allocated on the heap after the update frame is evaluated All subsequent entry's of the thunk will yield the already-computed value without needing to redo the same work.</p>
<p>A lambda form also indicates the <em>static reference table</em> a collection of references to static heap allocated values referred to by the body of the function.</p>
<p>For example turning on <code>-ddump-stg</code> we can see the expansion of the following compose function.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Frontend</span>
compose f g <span class="fu">=</span> \x <span class="ot">-&gt;</span> f (g x)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Core</span>
<span class="ot">compose ::</span> forall t t1 t2<span class="fu">.</span> (t1 <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> (t2 <span class="ot">-&gt;</span> t1) <span class="ot">-&gt;</span> t2 <span class="ot">-&gt;</span> t
compose <span class="fu">=</span>
  \ (<span class="fu">@</span> t) (<span class="fu">@</span> t1) (<span class="fu">@</span> t2) (<span class="ot">f ::</span> t1 <span class="ot">-&gt;</span> t) (<span class="ot">g ::</span> t2 <span class="ot">-&gt;</span> t1) (<span class="ot">x ::</span> t2) <span class="ot">-&gt;</span>
    f (g x)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- STG</span>
<span class="ot">compose ::</span> forall t t1 t2<span class="fu">.</span> (t1 <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> (t2 <span class="ot">-&gt;</span> t1) <span class="ot">-&gt;</span> t2 <span class="ot">-&gt;</span> t <span class="fu">=</span>
    \r [f g x] <span class="kw">let</span> {<span class="ot"> sat ::</span> t1 <span class="fu">=</span> \u [] g x; } <span class="kw">in</span>  f sat;
<span class="dt">SRT</span>(compose)<span class="fu">:</span> []</code></pre></div>
<p>For a more sophisticated example, let's trace the compilation of the factorial function.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Frontend</span>
<span class="ot">fac ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
fac a <span class="dv">0</span> <span class="fu">=</span> a
fac a n <span class="fu">=</span> fac (n<span class="fu">*</span>a) (n<span class="fu">-</span><span class="dv">1</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Core</span>
<span class="dt">Rec</span> {
<span class="ot">fac ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
fac <span class="fu">=</span>
  \ (<span class="ot">a ::</span> <span class="dt">Int</span>) (<span class="ot">ds ::</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span>
    <span class="kw">case</span> ds <span class="kw">of</span> wild { <span class="dt">I</span><span class="fu">#</span> ds1 <span class="ot">-&gt;</span>
    <span class="kw">case</span> ds1 <span class="kw">of</span> _ {
      __<span class="dt">DEFAULT</span> <span class="ot">-&gt;</span>
        fac (<span class="fu">*</span> <span class="fu">@</span> <span class="dt">Int</span> <span class="fu">$</span>fNumInt wild a) (<span class="fu">-</span> <span class="fu">@</span> <span class="dt">Int</span> <span class="fu">$</span>fNumInt wild (<span class="dt">I</span><span class="fu">#</span> <span class="dv">1</span>));
      <span class="dv">0</span> <span class="ot">-&gt;</span> a
    }
    }
end <span class="dt">Rec</span> }</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- STG</span>
<span class="ot">fac ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="fu">=</span>
    \r srt<span class="fu">:</span>(<span class="dv">0</span>,<span class="fu">*</span>bitmap<span class="fu">*</span>) [a ds]
        <span class="kw">case</span> ds <span class="kw">of</span> wild {
          <span class="dt">I</span><span class="fu">#</span> ds1 <span class="ot">-&gt;</span>
              <span class="kw">case</span> ds1 <span class="kw">of</span> _ {
                __<span class="dt">DEFAULT</span> <span class="ot">-&gt;</span>
                    <span class="kw">let</span> {
<span class="ot">                      sat ::</span> <span class="dt">Int</span> <span class="fu">=</span>
                          \u srt<span class="fu">:</span>(<span class="dv">1</span>,<span class="fu">*</span>bitmap<span class="fu">*</span>) []
                              <span class="kw">let</span> {<span class="ot"> sat ::</span> <span class="dt">Int</span> <span class="fu">=</span> <span class="dt">NO_CCS</span> <span class="dt">I</span><span class="fu">#!</span> [<span class="dv">1</span>]; } <span class="kw">in</span>  <span class="fu">-</span> <span class="fu">$</span>fNumInt wild sat; } <span class="kw">in</span>
                    <span class="kw">let</span> {<span class="ot"> sat ::</span> <span class="dt">Int</span> <span class="fu">=</span> \u srt<span class="fu">:</span>(<span class="dv">1</span>,<span class="fu">*</span>bitmap<span class="fu">*</span>) [] <span class="fu">*</span> <span class="fu">$</span>fNumInt wild a;
                    } <span class="kw">in</span>  fac sat sat;
                <span class="dv">0</span> <span class="ot">-&gt;</span> a;
              };
        };
<span class="dt">SRT</span>(fac)<span class="fu">:</span> [fac, <span class="fu">$</span>fNumInt]</code></pre></div>
<p>Notice that the factorial function allocates two thunks ( look for <code>\u</code>) inside of the loop which are updated when computed. It also includes static references to both itself (for recursion) and the dictionary for instance of <code>Num</code> typeclass over the type <code>Int</code>.</p>
<h2 id="workerwrapper">Worker/Wrapper</h2>
<p>With <code>-O2</code> turned on GHC will perform a special optimization known as the Worker-Wrapper transformation which will split the logic of the factorial function across two definitions, the worker will operate over stack unboxed allocated machine integers which compiles into a tight inner loop while the wrapper calls into the worker and collects the end result of the loop and packages it back up into a boxed heap value. This can often be an order of of magnitude faster than the naive implementation which needs to pack and unpack the boxed integers on every iteration.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Worker</span>
<span class="fu">$</span><span class="ot">wfac ::</span> <span class="dt">Int</span><span class="fu">#</span> <span class="ot">-&gt;</span> <span class="dt">Int</span><span class="fu">#</span> <span class="ot">-&gt;</span> <span class="dt">Int</span><span class="fu">#</span> <span class="fu">=</span>
    \r [ww ww1]
        <span class="kw">case</span> ww1 <span class="kw">of</span> ds {
          __<span class="dt">DEFAULT</span> <span class="ot">-&gt;</span>
              <span class="kw">case</span> <span class="fu">-#</span> [ds <span class="dv">1</span>] <span class="kw">of</span> sat {
                __<span class="dt">DEFAULT</span> <span class="ot">-&gt;</span>
                    <span class="kw">case</span> <span class="fu">*#</span> [ds ww] <span class="kw">of</span> sat { __<span class="dt">DEFAULT</span> <span class="ot">-&gt;</span> <span class="fu">$</span>wfac sat sat; };
              };
          <span class="dv">0</span> <span class="ot">-&gt;</span> ww;
        };
<span class="dt">SRT</span>(<span class="fu">$</span>wfac)<span class="fu">:</span> []

<span class="co">-- Wrapper</span>
<span class="ot">fac ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="fu">=</span>
    \r [w w1]
        <span class="kw">case</span> w <span class="kw">of</span> _ {
          <span class="dt">I</span><span class="fu">#</span> ww <span class="ot">-&gt;</span>
              <span class="kw">case</span> w1 <span class="kw">of</span> _ {
                <span class="dt">I</span><span class="fu">#</span> ww1 <span class="ot">-&gt;</span> <span class="kw">case</span> <span class="fu">$</span>wfac ww ww1 <span class="kw">of</span> ww2 { __<span class="dt">DEFAULT</span> <span class="ot">-&gt;</span> <span class="dt">I</span><span class="fu">#</span> [ww2]; };
              };
        };
<span class="dt">SRT</span>(fac)<span class="fu">:</span> []</code></pre></div>
<p>See:</p>
<ul>
<li><a href="https://donsbot.wordpress.com/2008/05/06/write-haskell-as-fast-as-c-exploiting-strictness-laziness-and-recursion/">Writing Haskell as Fast as C</a></li>
</ul>
<h2 id="z-encoding">Z-Encoding</h2>
<p>The Z-encoding is Haskell's convention for generating names that are safely represented in the compiler target language. Simply put the z-encoding renames many symbolic characters into special sequences of the z character.</p>
<table>
<thead>
<tr class="header">
<th align="left">String</th>
<th align="left">Z-Encoded String</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>foo</code></td>
<td align="left"><code>foo</code></td>
</tr>
<tr class="even">
<td align="left"><code>z</code></td>
<td align="left"><code>zz</code></td>
</tr>
<tr class="odd">
<td align="left"><code>Z</code></td>
<td align="left"><code>ZZ</code></td>
</tr>
<tr class="even">
<td align="left"><code>()</code></td>
<td align="left"><code>Z0T</code></td>
</tr>
<tr class="odd">
<td align="left"><code>(,)</code></td>
<td align="left"><code>Z2T</code></td>
</tr>
<tr class="even">
<td align="left"><code>(,,)</code></td>
<td align="left"><code>Z3T</code></td>
</tr>
<tr class="odd">
<td align="left"><code>_</code></td>
<td align="left"><code>zu</code></td>
</tr>
<tr class="even">
<td align="left"><code>(</code></td>
<td align="left"><code>ZL</code></td>
</tr>
<tr class="odd">
<td align="left"><code>)</code></td>
<td align="left"><code>ZR</code></td>
</tr>
<tr class="even">
<td align="left"><code>:</code></td>
<td align="left"><code>ZC</code></td>
</tr>
<tr class="odd">
<td align="left"><code>#</code></td>
<td align="left"><code>zh</code></td>
</tr>
<tr class="even">
<td align="left"><code>.</code></td>
<td align="left"><code>zi</code></td>
</tr>
<tr class="odd">
<td align="left"><code>(#,#)</code></td>
<td align="left"><code>Z2H</code></td>
</tr>
<tr class="even">
<td align="left"><code>(-&gt;)</code></td>
<td align="left"><code>ZLzmzgZR</code></td>
</tr>
</tbody>
</table>
<p>In this way we don't have to generate unique unidentifiable names for character rich names and can simply have a straightforward way to translate them into something unique but identifiable.</p>
<p>So for some example names from GHC generated code:</p>
<table>
<thead>
<tr class="header">
<th align="left">Z-Encoded String</th>
<th align="left">Decoded String</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>ZCMain_main_closure</code></td>
<td align="left"><code>:Main_main_closure</code></td>
</tr>
<tr class="even">
<td align="left"><code>base_GHCziBase_map_closure</code></td>
<td align="left"><code>base_GHC.Base_map_closure</code></td>
</tr>
<tr class="odd">
<td align="left"><code>base_GHCziInt_I32zh_con_info</code></td>
<td align="left"><code>base_GHC.Int_I32#_con_info</code></td>
</tr>
<tr class="even">
<td align="left"><code>ghczmprim_GHCziTuple_Z3T_con_info</code></td>
<td align="left"><code>ghc-prim_GHC.Tuple_(,,)_con_in</code></td>
</tr>
<tr class="odd">
<td align="left"><code>ghczmprim_GHCziTypes_ZC_con_info</code></td>
<td align="left"><code>ghc-prim_GHC.Types_:_con_info</code></td>
</tr>
</tbody>
</table>
<h2 id="cmm">Cmm</h2>
<p>Cmm is GHC's complex internal intermediate representation that maps directly onto the generated code for the compiler target. Cmm code generated from Haskell is CPS-converted, all functions never return a value, they simply call the next frame in the continuation stack. All evaluation of functions proceed by indirectly jumping to a code object with its arguments placed on the stack by the caller.</p>
<p>This is drastically different than C's evaluation model, where are placed on the stack and a function yields a value to the stack after it returns.</p>
<p>There are several common suffixes you'll see used in all closures and function names:</p>
<table>
<thead>
<tr class="header">
<th align="left">Symbol</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>0</code></td>
<td align="left">No argument</td>
</tr>
<tr class="even">
<td align="left"><code>p</code></td>
<td align="left">Garage Collected Pointer</td>
</tr>
<tr class="odd">
<td align="left"><code>n</code></td>
<td align="left">Word-sized non-pointer</td>
</tr>
<tr class="even">
<td align="left"><code>l</code></td>
<td align="left">64-bit non-pointer (long)</td>
</tr>
<tr class="odd">
<td align="left"><code>v</code></td>
<td align="left">Void</td>
</tr>
<tr class="even">
<td align="left"><code>f</code></td>
<td align="left">Float</td>
</tr>
<tr class="odd">
<td align="left"><code>d</code></td>
<td align="left">Double</td>
</tr>
<tr class="even">
<td align="left"><code>v16</code></td>
<td align="left">16-byte vector</td>
</tr>
<tr class="odd">
<td align="left"><code>v32</code></td>
<td align="left">32-byte vector</td>
</tr>
<tr class="even">
<td align="left"><code>v64</code></td>
<td align="left">64-byte vector</td>
</tr>
</tbody>
</table>
<p><strong>Cmm Registers</strong></p>
<p>There are 10 registers that described in the machine model. <strong>Sp</strong> is the pointer to top of the stack, <strong>SpLim</strong> is the pointer to last element in the stack. <strong>Hp</strong> is the heap pointer, used for allocation and garbage collection with <strong>HpLim</strong> the current heap limit.</p>
<p>The <strong>R1</strong> register always holds the active closure, and subsequent registers are arguments passed in registers. Functions with more than 10 values spill into memory.</p>
<ul>
<li>Sp</li>
<li>SpLim</li>
<li>Hp</li>
<li>HpLim</li>
<li>HpAlloc</li>
<li>R1</li>
<li>R2</li>
<li>R3</li>
<li>R4</li>
<li>R5</li>
<li>R6</li>
<li>R7</li>
<li>R8</li>
<li>R9</li>
<li>R10</li>
</ul>
<p><strong>Examples</strong></p>
<p>To understand Cmm it is useful to look at the code generated by the equivalent Haskell and slowly understand the equivalence and mechanical translation maps one to the other.</p>
<p>There are generally two parts to every Cmm definition, the <strong>info table</strong> and the <strong>entry code</strong>. The info table maps directly <code>StgInfoTable</code> struct and contains various fields related to the type of the closure, its payload, and references. The code objects are basic blocks of generated code that correspond to the logic of the Haskell function/constructor.</p>
<p>For the simplest example consider a constant static constructor. Simply a function which yields the Unit value. In this case the function is simply a constructor with no payload, and is statically allocated.</p>
<p>Haskell:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">unit <span class="fu">=</span> ()</code></pre></div>
<p>Cmm:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[section <span class="st">&quot;data&quot;</span> {
     unit_closure:
         <span class="dt">const</span> ()_static_info;
 }]</code></pre></div>
<p>Consider a static constructor with an argument.</p>
<p>Haskell:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">con ::</span> <span class="dt">Maybe</span> ()
con <span class="fu">=</span> <span class="dt">Just</span> ()</code></pre></div>
<p>Cmm:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[section <span class="st">&quot;data&quot;</span> {
     con_closure:
         <span class="dt">const</span> Just_static_info;
         <span class="dt">const</span> ()_closure<span class="dv">+1</span>;
         <span class="dt">const</span> <span class="dv">1</span>;
 }]</code></pre></div>
<p>Consider a literal constant. This is a static value.</p>
<p>Haskell:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lit ::</span> <span class="dt">Int</span>
lit <span class="fu">=</span> <span class="dv">1</span></code></pre></div>
<p>Cmm:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[section <span class="st">&quot;data&quot;</span> {
     lit_closure:
         <span class="dt">const</span> I<span class="er">#</span>_static_info;
         <span class="dt">const</span> <span class="dv">1</span>;
 }]</code></pre></div>
<p>Consider the identity function.</p>
<p>Haskell:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">id x <span class="fu">=</span> x</code></pre></div>
<p>Cmm:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[section <span class="st">&quot;data&quot;</span> {
     id_closure:
         <span class="dt">const</span> id_info;
 },
 id_info()
         { label: id_info
           rep:HeapRep <span class="dt">static</span> { Fun {arity: <span class="dv">1</span> fun_type: ArgSpec <span class="dv">5</span>} }
         }
     ch1:
         R1 = R2;
         jump stg_ap_0_fast; <span class="co">// [R1]</span>
 }]</code></pre></div>
<p>Consider the constant function.</p>
<p>Haskell:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">constant x y <span class="fu">=</span> x</code></pre></div>
<p>Cmm:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[section <span class="st">&quot;data&quot;</span> {
     constant_closure:
         <span class="dt">const</span> constant_info;
 },
 constant_info()
         { label: constant_info
           rep:HeapRep <span class="dt">static</span> { Fun {arity: <span class="dv">2</span> fun_type: ArgSpec <span class="dv">12</span>} }
         }
     cgT:
         R1 = R2;
         jump stg_ap_0_fast; <span class="co">// [R1]</span>
 }]</code></pre></div>
<p>Consider a function where application of a function ( of unknown arity ) occurs.</p>
<p>Haskell:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">compose f g x <span class="fu">=</span> f (g x)</code></pre></div>
<p>Cmm:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[section <span class="st">&quot;data&quot;</span> {
     compose_closure:
         <span class="dt">const</span> compose_info;
 },
 compose_info()
         { label: compose_info
           rep:HeapRep <span class="dt">static</span> { Fun {arity: <span class="dv">3</span> fun_type: ArgSpec <span class="dv">20</span>} }
         }
     ch9:
         Hp = Hp + <span class="dv">32</span>;
         <span class="kw">if</span> (Hp &gt; HpLim) <span class="kw">goto</span> chd;
         I64[Hp - <span class="dv">24</span>] = stg_ap_2_upd_info;
         I64[Hp - <span class="dv">8</span>] = R3;
         I64[Hp + <span class="dv">0</span>] = R4;
         R1 = R2;
         R2 = Hp - <span class="dv">24</span>;
         jump stg_ap_p_fast; <span class="co">// [R1, R2]</span>
     che:
         R1 = compose_closure;
         jump stg_gc_fun; <span class="co">// [R1, R4, R3, R2]</span>
     chd:
         HpAlloc = <span class="dv">32</span>;
         <span class="kw">goto</span> che;
 }]</code></pre></div>
<p>Consider a function which branches using pattern matching:</p>
<p>Haskell:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">match ::</span> <span class="dt">Either</span> a a <span class="ot">-&gt;</span> a
match x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span>
  <span class="dt">Left</span> a <span class="ot">-&gt;</span> a
  <span class="dt">Right</span> b <span class="ot">-&gt;</span> b</code></pre></div>
<p>Cmm:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[section <span class="st">&quot;data&quot;</span> {
     match_closure:
         <span class="dt">const</span> match_info;
 },
 sio_ret()
         { label: sio_info
           rep:StackRep []
         }
     ciL:
         _ciM::I64 = R1 &amp; <span class="dv">7</span>;
         <span class="kw">if</span> (_ciM::I64 &gt;= <span class="dv">2</span>) <span class="kw">goto</span> ciN;
         R1 = I64[R1 + <span class="dv">7</span>];
         Sp = Sp + <span class="dv">8</span>;
         jump stg_ap_0_fast; <span class="co">// [R1]</span>
     ciN:
         R1 = I64[R1 + <span class="dv">6</span>];
         Sp = Sp + <span class="dv">8</span>;
         jump stg_ap_0_fast; <span class="co">// [R1]</span>
 },
 match_info()
         { label: match_info
           rep:HeapRep <span class="dt">static</span> { Fun {arity: <span class="dv">1</span> fun_type: ArgSpec <span class="dv">5</span>} }
         }
     ciP:
         <span class="kw">if</span> (Sp - <span class="dv">8</span> &lt; SpLim) <span class="kw">goto</span> ciR;
         R1 = R2;
         I64[Sp - <span class="dv">8</span>] = sio_info;
         Sp = Sp - <span class="dv">8</span>;
         <span class="kw">if</span> (R1 &amp; <span class="dv">7</span> != <span class="dv">0</span>) <span class="kw">goto</span> ciU;
         jump I64[R1]; <span class="co">// [R1]</span>
     ciR:
         R1 = match_closure;
         jump stg_gc_fun; <span class="co">// [R1, R2]</span>
     ciU: jump sio_info; <span class="co">// [R1]</span>
 }]</code></pre></div>
<p><strong>Macros</strong></p>
<p>Cmm itself uses many macros to stand for various constructs, many of which are defined in an external C header file. A short reference for the common types:</p>
<table>
<thead>
<tr class="header">
<th align="left">Cmm</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>C_</code></td>
<td align="left">char</td>
</tr>
<tr class="even">
<td align="left"><code>D_</code></td>
<td align="left">double</td>
</tr>
<tr class="odd">
<td align="left"><code>F_</code></td>
<td align="left">float</td>
</tr>
<tr class="even">
<td align="left"><code>W_</code></td>
<td align="left">word</td>
</tr>
<tr class="odd">
<td align="left"><code>P_</code></td>
<td align="left">garbage collected pointer</td>
</tr>
<tr class="even">
<td align="left"><code>I_</code></td>
<td align="left">int</td>
</tr>
<tr class="odd">
<td align="left"><code>L_</code></td>
<td align="left">long</td>
</tr>
<tr class="even">
<td align="left"><code>FN_</code></td>
<td align="left">function pointer (no arguments)</td>
</tr>
<tr class="odd">
<td align="left"><code>EF_</code></td>
<td align="left">extern function pointer</td>
</tr>
<tr class="even">
<td align="left"><code>I8</code></td>
<td align="left">8-bit integer</td>
</tr>
<tr class="odd">
<td align="left"><code>I16</code></td>
<td align="left">16-bit integer</td>
</tr>
<tr class="even">
<td align="left"><code>I32</code></td>
<td align="left">32-bit integer</td>
</tr>
<tr class="odd">
<td align="left"><code>I64</code></td>
<td align="left">64-bit integer</td>
</tr>
</tbody>
</table>
<p>Many of the predefined closures (<code>stg_ap_p_fast</code>, etc) are themselves mechanically generated and more or less share the same form ( a giant switch statement on closure type, update frame, stack adjustment). Inside of GHC is a file named <code>GenApply.hs</code> that generates most of these functions. See the Gist link in the reading section for the current source file that GHC generates. For example the output for <code>stg_ap_p_fast</code>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">stg_ap_p_fast
{   W_ info;
    W_ arity;
    <span class="kw">if</span> (GETTAG(R1)==<span class="dv">1</span>) {
        Sp_adj(<span class="dv">0</span>);
        jump %GET_ENTRY(R1<span class="dv">-1</span>) [R1,R2];
    }
    <span class="kw">if</span> (Sp - WDS(<span class="dv">2</span>) &lt; SpLim) {
        Sp_adj(<span class="dv">-2</span>);
        W_[Sp+WDS(<span class="dv">1</span>)] = R2;
        Sp(<span class="dv">0</span>) = stg_ap_p_info;
        jump __stg_gc_enter_1 [R1];
    }
    R1 = UNTAG(R1);
    info = %GET_STD_INFO(R1);
    <span class="kw">switch</span> [INVALID_OBJECT .. N_CLOSURE_TYPES] (TO_W_(%INFO_TYPE(info))) {
        <span class="kw">case</span> FUN,
             FUN_1_0,
             FUN_0_1,
             FUN_2_0,
             FUN_1_1,
             FUN_0_2,
             FUN_STATIC: {
            arity = TO_W_(StgFunInfoExtra_arity(%GET_FUN_INFO(R1)));
            ASSERT(arity &gt; <span class="dv">0</span>);
            <span class="kw">if</span> (arity == <span class="dv">1</span>) {
                Sp_adj(<span class="dv">0</span>);
                R1 = R1 + <span class="dv">1</span>;
                jump %GET_ENTRY(UNTAG(R1)) [R1,R2];
            } <span class="kw">else</span> {
                Sp_adj(<span class="dv">-2</span>);
                W_[Sp+WDS(<span class="dv">1</span>)] = R2;
                <span class="kw">if</span> (arity &lt; <span class="dv">8</span>) {
                  R1 = R1 + arity;
                }
                BUILD_PAP(<span class="dv">1</span>,<span class="dv">1</span>,stg_ap_p_info,FUN);
            }
        }
        <span class="kw">default</span>: {
            Sp_adj(<span class="dv">-2</span>);
            W_[Sp+WDS(<span class="dv">1</span>)] = R2;
            jump RET_LBL(stg_ap_p) [];
        }
    }
}</code></pre></div>
<p>Handwritten Cmm can be included in a module manually by first compiling it through GHC into an object and then using a special FFI invocation.</p>
<div class="sourceCode" include="src/29-ghc/factorial.cmm"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &quot;Cmm.h&quot;</span>

factorial {
  entry:
      W_ n  ;
      W_ acc;
      n = R1 ;
      acc = n ;
      n = n - <span class="dv">1</span> ;
    
  <span class="kw">for</span>:
      <span class="kw">if</span> (n &lt;= <span class="dv">0</span> ) {
          RET_N(acc);
      } <span class="kw">else</span> {
          acc = acc * n  ;
          n = n - <span class="dv">1</span> ;
          <span class="kw">goto</span> <span class="kw">for</span> ;
      }
      RET_N(<span class="dv">0</span>);
}</code></pre></div>
<div class="sourceCode" include="src/29-ghc/cmm_include.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- ghc -c factorial.cmm -o factorial.o</span>
<span class="co">-- ghc factorial.o Example.hs -o Example</span>

<span class="ot">{-# LANGUAGE MagicHash #-}</span>
<span class="ot">{-# LANGUAGE UnliftedFFITypes #-}</span>
<span class="ot">{-# LANGUAGE GHCForeignImportPrim #-}</span>
<span class="ot">{-# LANGUAGE ForeignFunctionInterface #-}</span>

<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">GHC.Prim</span>
<span class="kw">import </span><span class="dt">GHC.Word</span>

foreign <span class="kw">import </span>prim &quot;factorial&quot; factorial_cmm  :: <span class="dt">Word</span># -&gt; <span class="dt">Word</span>#

<span class="ot">factorial ::</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span>
factorial (<span class="dt">W64</span><span class="fu">#</span> n) <span class="fu">=</span>  <span class="dt">W64</span><span class="fu">#</span> (factorial_cmm n)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> print (factorial <span class="dv">5</span>)</code></pre></div>
<p>See:</p>
<ul>
<li><a href="http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/CmmType">CmmType</a></li>
<li><a href="https://github.com/ghc/ghc/blob/master/includes/stg/MiscClosures.h">MiscClosures</a></li>
<li><a href="https://github.com/ghc/ghc/blob/master/compiler/codeGen/StgCmmArgRep.hs">StgCmmArgRep</a></li>
</ul>
<p>Cmm Runtime:</p>
<ul>
<li><a href="https://github.com/ghc/ghc/blob/master/rts/Apply.cmm">Apply.cmm</a></li>
<li><a href="https://github.com/ghc/ghc/blob/master/rts/StgStdThunks.cmm">StgStdThunks.cmm</a></li>
<li><a href="https://github.com/ghc/ghc/blob/master/rts/StgMiscClosures.cmm">StgMiscClosures.cmm</a></li>
<li><a href="https://github.com/ghc/ghc/blob/master/rts/PrimOps.cmm">PrimOps.cmm</a></li>
<li><a href="https://github.com/ghc/ghc/blob/master/rts/Updates.cmm">Updates.cmm</a></li>
<li><a href="https://gist.github.com/sdiehl/e5c9daab7a6d1da0ede7">Precompiled Closures ( Autogenerated Output )</a></li>
</ul>
<h2 id="optimization-hacks">Optimization Hacks</h2>
<h4 id="tables-next-to-code">Tables Next to Code</h4>
<p>GHC will place the info table for a toplevel closure directly next to the entry-code for the objects in memory such that the fields from the info table can be accessed by pointer arithmetic on the function pointer to the code itself. Not performing this optimization would involve chasing through one more pointer to get to the info table. Given how often info-tables are accessed using the tables-next-to-code optimization results in a tractable speedup.</p>
<h4 id="pointer-tagging">Pointer Tagging</h4>
<p>Depending on the type of the closure involved, GHC will utilize the last few bits in a pointer to the closure to store information that can be read off from the bits of pointer itself before jumping into or access the info tables. For thunks this can be information like whether it is evaluated to WHNF or not, for constructors it contains the constructor tag (if it fits) to avoid an info table lookup.</p>
<p>Depending on the architecture the tag bits are either the last 2 or 3 bits of a pointer.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 32 bit arch</span>
TAG_BITS = <span class="dv">2</span>

<span class="co">// 64-bit arch</span>
TAG_BITS = <span class="dv">3</span></code></pre></div>
<p>These occur in Cmm most frequently via the following macro definitions:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define TAG_MASK ((1 &lt;&lt; TAG_BITS) - 1)</span>
<span class="ot">#define UNTAG(p) (p &amp; ~TAG_MASK)</span>
<span class="ot">#define GETTAG(p) (p &amp; TAG_MASK)</span></code></pre></div>
<p>So for instance in many of the precompiled functions, there will be a test for whether the active closure <code>R1</code> is already evaluated.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">if</span> (GETTAG(R1)==<span class="dv">1</span>) {
    Sp_adj(<span class="dv">0</span>);
    jump %GET_ENTRY(R1<span class="dv">-1</span>) [R1,R2];
}</code></pre></div>
<h2 id="interface-files">Interface Files</h2>
<p>During compilation GHC will produce interface files for each module that are the binary encoding of specific symbols (functions, typeclasses, etc) exported by that modules as well as any package dependencies it itself depends on. This is effectively the serialized form of the ModGuts structure used internally in the compiler. The internal structure of this file can be dumped using the <code>--show-iface</code> flag. The precise structure changes between versions of GHC.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">ghc</span> --show-iface let.hi
<span class="kw">Magic</span>: Wanted 33214052,
       <span class="kw">got</span>    33214052
<span class="kw">Version</span>: Wanted [7, 0, 8, 4],
         <span class="kw">got</span>    [7, 0, 8, 4]
<span class="kw">Way</span>: Wanted [],
     <span class="kw">got</span>    []
<span class="kw">interface</span> main:Main 7084
  <span class="kw">interface</span> hash: 1991c3e0edf3e849aeb53783fb616df2
  <span class="kw">ABI</span> hash: 0b7173fb01d2226a2e61df72371034ee
  <span class="kw">export-list</span> hash: 0f26147773230f50ea3b06fe20c9c66c
  <span class="kw">orphan</span> hash: 693e9af84d3dfcc71e640e005bdc5e2e
  <span class="kw">flag</span> hash: 9b3dfba8e3209c5b5c132a214b6b9bd3
  <span class="kw">used</span> TH splices: False
  <span class="kw">where</span>
<span class="kw">exports</span>:
  <span class="kw">Main.main</span>
<span class="kw">module</span> dependencies:
<span class="kw">package</span> dependencies: base* ghc-prim integer-gmp
<span class="kw">orphans</span>: base:GHC.Base base:GHC.Float base:GHC.Real
<span class="kw">family</span> instance modules: base:Data.Either base:Data.Monoid
                         <span class="kw">base</span>:Data.Type.Equality base:GHC.Generics
<span class="kw">import</span>  -/  base:GHC.Num 5e7786970581cacc802bf850d458a30b
<span class="kw">import</span>  -/  base:Prelude 74043f272d60acec1777d3461cfe5ef4
<span class="kw">import</span>  -/  base:System.IO cadd0efb01c47ddd8f52d750739fdbdf
<span class="kw">import</span>  -/  ghc-prim:GHC.Types dcba736fa3dfba12d307ab18354845d2
<span class="kw">4cfa03293a8356d627c0c5fec26936e2</span>
  <span class="kw">main</span> :: GHC.Types.IO ()
<span class="kw">vectorised</span> variables:
<span class="kw">vectorised</span> tycons:
<span class="kw">vectorised</span> reused tycons:
<span class="kw">parallel</span> variables:
<span class="kw">parallel</span> tycons:
<span class="kw">trusted</span>: safe-inferred
<span class="kw">require</span> own pkg trusted: False</code></pre></div>
</hr>
<h1 id="profiling">Profiling</h1>
<h2 id="ekg">EKG</h2>
<p>EKG is a monitoring tool that can monitor various aspect of GHC's runtime alongside an active process. The interface for the output is viewable within a browser interface. The monitoring process is forked off (in a system thread) from the main process.</p>
<div class="sourceCode" include="src/29-ghc/ekg.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# Language OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">System.Remote.Monitoring</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  ekg <span class="ot">&lt;-</span> forkServer <span class="st">&quot;localhost&quot;</span> <span class="dv">8000</span>
  putStrLn <span class="st">&quot;Started server on http://localhost:8000&quot;</span>
  forever <span class="fu">$</span> getLine <span class="fu">&gt;&gt;=</span> putStrLn</code></pre></div>
<div class="figure">
<img src="img/ekg.png" alt="" />

</div>
<h2 id="rts-profiling">RTS Profiling</h2>
<p>The GHC runtime system can be asked to dump information about allocations and percentage of wall time spent in various portions of the runtime system.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">$</span> <span class="fu">./</span>program <span class="fu">+</span><span class="dt">RTS</span> <span class="fu">-</span>s

       <span class="dv">1</span>,<span class="dv">939</span>,<span class="dv">784</span> bytes allocated <span class="kw">in</span> the heap
          <span class="dv">11</span>,<span class="dv">160</span> bytes copied during <span class="dt">GC</span>
          <span class="dv">44</span>,<span class="dv">416</span> bytes maximum residency (<span class="dv">2</span> sample(s))
          <span class="dv">21</span>,<span class="dv">120</span> bytes maximum slop
               <span class="dv">1</span> <span class="dt">MB</span> total memory <span class="kw">in</span> use (<span class="dv">0</span> <span class="dt">MB</span> lost due to fragmentation)

                                    <span class="dt">Tot</span> time (elapsed)  <span class="dt">Avg</span> pause  <span class="dt">Max</span> pause
  <span class="dt">Gen</span>  <span class="dv">0</span>         <span class="dv">2</span> colls,     <span class="dv">0</span> par    <span class="fl">0.00</span>s    <span class="fl">0.00</span>s     <span class="fl">0.0000</span>s    <span class="fl">0.0000</span>s
  <span class="dt">Gen</span>  <span class="dv">1</span>         <span class="dv">2</span> colls,     <span class="dv">0</span> par    <span class="fl">0.00</span>s    <span class="fl">0.00</span>s     <span class="fl">0.0002</span>s    <span class="fl">0.0003</span>s

  <span class="dt">INIT</span>    time    <span class="fl">0.00</span>s  (  <span class="fl">0.00</span>s elapsed)
  <span class="dt">MUT</span>     time    <span class="fl">0.00</span>s  (  <span class="fl">0.01</span>s elapsed)
  <span class="dt">GC</span>      time    <span class="fl">0.00</span>s  (  <span class="fl">0.00</span>s elapsed)
  <span class="dt">EXIT</span>    time    <span class="fl">0.00</span>s  (  <span class="fl">0.00</span>s elapsed)
  <span class="dt">Total</span>   time    <span class="fl">0.01</span>s  (  <span class="fl">0.01</span>s elapsed)

  <span class="fu">%</span><span class="dt">GC</span>     time       <span class="fl">5.0</span><span class="fu">%</span>  (<span class="fl">7.1</span><span class="fu">%</span> elapsed)

  <span class="dt">Alloc</span> rate    <span class="dv">398</span>,<span class="dv">112</span>,<span class="dv">898</span> bytes per <span class="dt">MUT</span> second

  <span class="dt">Productivity</span>  <span class="fl">91.4</span><span class="fu">%</span> <span class="kw">of</span> total user, <span class="fl">128.8</span><span class="fu">%</span> <span class="kw">of</span> total elapsed</code></pre></div>
<p>Productivity indicates the amount of time spent during execution compared to the time spent garbage collecting. Well tuned CPU bound programs are often in the 90-99% range of productivity range.</p>
<p>In addition individual function profiling information can be generated by compiling the program with <code>-prof</code> flag. The resulting information is outputted to a <code>.prof</code> file of the same name as the module. This is useful for tracking down hotspots in the program.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">$</span> ghc <span class="fu">-</span><span class="dt">O2</span> program<span class="fu">.</span>hs <span class="fu">-</span>prof <span class="fu">-</span>auto<span class="fu">-</span>all
<span class="fu">$</span> <span class="fu">./</span>program <span class="fu">+</span><span class="dt">RTS</span> <span class="fu">-</span>p
<span class="fu">$</span> cat program<span class="fu">.</span>prof
        <span class="dt">Mon</span> <span class="dt">Oct</span> <span class="dv">27</span> <span class="dv">23</span><span class="fu">:</span><span class="dv">00</span> <span class="dv">2014</span> <span class="dt">Time</span> and <span class="dt">Allocation</span> <span class="dt">Profiling</span> <span class="dt">Report</span>  (<span class="dt">Final</span>)

           program <span class="fu">+</span><span class="dt">RTS</span> <span class="fu">-</span>p <span class="fu">-</span><span class="dt">RTS</span>

        total time  <span class="fu">=</span>        <span class="fl">0.01</span> secs   (<span class="dv">7</span> ticks <span class="fu">@</span> <span class="dv">1000</span> us, <span class="dv">1</span> processor)
        total alloc <span class="fu">=</span>   <span class="dv">1</span>,<span class="dv">937</span>,<span class="dv">336</span> bytes  (excludes profiling overheads)

<span class="dt">COST</span> <span class="dt">CENTRE</span> <span class="dt">MODULE</span>           <span class="fu">%</span>time <span class="fu">%</span>alloc

<span class="dt">CAF</span>         <span class="dt">Main</span>             <span class="fl">100.0</span>   <span class="fl">97.2</span>
<span class="dt">CAF</span>         <span class="dt">GHC.IO.Handle.FD</span>   <span class="fl">0.0</span>    <span class="fl">1.8</span>


                                                      individual     inherited
<span class="dt">COST</span> <span class="dt">CENTRE</span> <span class="dt">MODULE</span>                  no<span class="fu">.</span>     entries  <span class="fu">%</span>time <span class="fu">%</span>alloc   <span class="fu">%</span>time <span class="fu">%</span>alloc

<span class="dt">MAIN</span>        <span class="dt">MAIN</span>                     <span class="dv">42</span>           <span class="dv">0</span>    <span class="fl">0.0</span>    <span class="fl">0.7</span>   <span class="fl">100.0</span>  <span class="fl">100.0</span>
 <span class="dt">CAF</span>        <span class="dt">Main</span>                     <span class="dv">83</span>           <span class="dv">0</span>  <span class="fl">100.0</span>   <span class="fl">97.2</span>   <span class="fl">100.0</span>   <span class="fl">97.2</span>
 <span class="dt">CAF</span>        <span class="dt">GHC.IO.Encoding</span>          <span class="dv">78</span>           <span class="dv">0</span>    <span class="fl">0.0</span>    <span class="fl">0.1</span>     <span class="fl">0.0</span>    <span class="fl">0.1</span>
 <span class="dt">CAF</span>        <span class="dt">GHC.IO.Handle.FD</span>         <span class="dv">77</span>           <span class="dv">0</span>    <span class="fl">0.0</span>    <span class="fl">1.8</span>     <span class="fl">0.0</span>    <span class="fl">1.8</span>
 <span class="dt">CAF</span>        <span class="dt">GHC.Conc.Signal</span>          <span class="dv">74</span>           <span class="dv">0</span>    <span class="fl">0.0</span>    <span class="fl">0.0</span>     <span class="fl">0.0</span>    <span class="fl">0.0</span>
 <span class="dt">CAF</span>        <span class="dt">GHC.IO.Encoding.Iconv</span>    <span class="dv">69</span>           <span class="dv">0</span>    <span class="fl">0.0</span>    <span class="fl">0.0</span>     <span class="fl">0.0</span>    <span class="fl">0.0</span>
 <span class="dt">CAF</span>        <span class="dt">GHC.Show</span>                 <span class="dv">60</span>           <span class="dv">0</span>    <span class="fl">0.0</span>    <span class="fl">0.0</span>     <span class="fl">0.0</span>    <span class="fl">0.0</span></code></pre></div>
</hr>
<h1 id="languages">Languages</h1>
<h2 id="unbound">unbound</h2>
<p>Several libraries exist to mechanize the process of writing name capture and substitution, since it is largely mechanical. Probably the most robust is the <code>unbound</code> library. For example we can implement the infer function for a small Hindley-Milner system over a simple typed lambda calculus without having to write the name capture and substitution mechanics ourselves.</p>
<div class="sourceCode" include="src/30-languages/unbound.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>
<span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">module</span> <span class="dt">Infer</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.String</span>
<span class="kw">import </span><span class="dt">Data.Map</span> (<span class="dt">Map</span>)
<span class="kw">import </span><span class="dt">Control.Monad.Error</span>
<span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span>

<span class="kw">import qualified</span> <span class="dt">Unbound.LocallyNameless</span> <span class="kw">as</span> <span class="dt">NL</span>
<span class="kw">import </span><span class="dt">Unbound.LocallyNameless</span> <span class="kw">hiding</span> (<span class="dt">Subst</span>, compose)

<span class="kw">data</span> <span class="dt">Type</span>
  <span class="fu">=</span> <span class="dt">TVar</span> (<span class="dt">Name</span> <span class="dt">Type</span>)
  <span class="fu">|</span> <span class="dt">TArr</span> <span class="dt">Type</span> <span class="dt">Type</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="dt">Var</span> (<span class="dt">Name</span> <span class="dt">Expr</span>)
  <span class="fu">|</span> <span class="dt">Lam</span> (<span class="dt">Bind</span> (<span class="dt">Name</span> <span class="dt">Expr</span>) <span class="dt">Expr</span>)
  <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Let</span> (<span class="dt">Bind</span> (<span class="dt">Name</span> <span class="dt">Expr</span>) <span class="dt">Expr</span>)
  <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="fu">$</span>(derive [<span class="ch">&#39;&#39;</span><span class="dt">Type</span>, <span class="ch">&#39;&#39;</span><span class="dt">Expr</span>])


<span class="kw">instance</span> <span class="dt">IsString</span> <span class="dt">Expr</span> <span class="kw">where</span>
    fromString <span class="fu">=</span> <span class="dt">Var</span> <span class="fu">.</span> fromString
<span class="kw">instance</span> <span class="dt">IsString</span> <span class="dt">Type</span> <span class="kw">where</span>
    fromString <span class="fu">=</span> <span class="dt">TVar</span> <span class="fu">.</span> fromString
<span class="kw">instance</span> <span class="dt">IsString</span> (<span class="dt">Name</span> <span class="dt">Expr</span>) <span class="kw">where</span>
    fromString <span class="fu">=</span> string2Name
<span class="kw">instance</span> <span class="dt">IsString</span> (<span class="dt">Name</span> <span class="dt">Type</span>) <span class="kw">where</span>
    fromString <span class="fu">=</span> string2Name

<span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Type</span> <span class="kw">where</span>
    (<span class="fu">==</span>) <span class="fu">=</span> eqType

<span class="ot">eqType ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
eqType (<span class="dt">TVar</span> v1) (<span class="dt">TVar</span> v2) <span class="fu">=</span> v1 <span class="fu">==</span> v2
eqType _ _ <span class="fu">=</span> <span class="dt">False</span>

<span class="ot">uvar ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span>
uvar x <span class="fu">=</span> <span class="dt">Var</span> (s2n x)

<span class="ot">tvar ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>
tvar x <span class="fu">=</span> <span class="dt">TVar</span> (s2n x)

<span class="kw">instance</span> <span class="dt">Alpha</span> <span class="dt">Type</span>
<span class="kw">instance</span> <span class="dt">Alpha</span> <span class="dt">Expr</span>

<span class="kw">instance</span> <span class="dt">NL.Subst</span> <span class="dt">Type</span> <span class="dt">Type</span> <span class="kw">where</span>
  isvar (<span class="dt">TVar</span> v) <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">SubstName</span> v)
  isvar _ <span class="fu">=</span> <span class="dt">Nothing</span>

<span class="kw">instance</span> <span class="dt">NL.Subst</span> <span class="dt">Expr</span> <span class="dt">Expr</span> <span class="kw">where</span>
  isvar (<span class="dt">Var</span> v) <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">SubstName</span> v)
  isvar _ <span class="fu">=</span> <span class="dt">Nothing</span>

<span class="kw">instance</span> <span class="dt">NL.Subst</span> <span class="dt">Expr</span> <span class="dt">Type</span> <span class="kw">where</span>


<span class="kw">data</span> <span class="dt">TypeError</span>
  <span class="fu">=</span> <span class="dt">UnboundVariable</span> (<span class="dt">Name</span> <span class="dt">Expr</span>)
  <span class="fu">|</span> <span class="dt">GenericTypeError</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Error</span> <span class="dt">TypeError</span> <span class="kw">where</span>
  noMsg <span class="fu">=</span> <span class="dt">GenericTypeError</span>


<span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> <span class="dt">Map</span> (<span class="dt">Name</span> <span class="dt">Expr</span>) <span class="dt">Type</span>
<span class="kw">type</span> <span class="dt">Constraint</span> <span class="fu">=</span> (<span class="dt">Type</span>, <span class="dt">Type</span>)
<span class="kw">type</span> <span class="dt">Infer</span> <span class="fu">=</span> <span class="dt">ErrorT</span> <span class="dt">TypeError</span> <span class="dt">FreshM</span>

<span class="ot">empty ::</span> <span class="dt">Env</span>
empty <span class="fu">=</span> Map.empty

<span class="ot">freshtv ::</span> <span class="dt">Infer</span> <span class="dt">Type</span>
freshtv <span class="fu">=</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> fresh <span class="st">&quot;_t&quot;</span>
  return <span class="fu">$</span> <span class="dt">TVar</span> x

<span class="ot">infer ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Infer</span> (<span class="dt">Type</span>, [<span class="dt">Constraint</span>])
infer env expr <span class="fu">=</span> <span class="kw">case</span> expr  <span class="kw">of</span>

  <span class="dt">Lam</span> b <span class="ot">-&gt;</span> <span class="kw">do</span>
    (n,e) <span class="ot">&lt;-</span> unbind b
    tv <span class="ot">&lt;-</span> freshtv
    <span class="kw">let</span> env&#39; <span class="fu">=</span> Map.insert n tv env
    (t, cs) <span class="ot">&lt;-</span> infer env&#39; e
    return (<span class="dt">TArr</span> tv t, cs)

  <span class="dt">App</span> e1 e2 <span class="ot">-&gt;</span> <span class="kw">do</span>
     (t1, cs1) <span class="ot">&lt;-</span> infer env e1
     (t2, cs2) <span class="ot">&lt;-</span> infer env e2
     tv <span class="ot">&lt;-</span> freshtv
     return (tv, (t1, <span class="dt">TArr</span> t2 tv) <span class="fu">:</span> cs1 <span class="fu">++</span> cs2)

  <span class="dt">Var</span> n <span class="ot">-&gt;</span> <span class="kw">do</span>
     <span class="kw">case</span> Map.lookup n env <span class="kw">of</span>
        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> throwError <span class="fu">$</span> <span class="dt">UnboundVariable</span> n
        <span class="dt">Just</span> t  <span class="ot">-&gt;</span> return (t, [])

  <span class="dt">Let</span> b <span class="ot">-&gt;</span> <span class="kw">do</span>
     (n, e) <span class="ot">&lt;-</span> unbind b
     (tBody, csBody) <span class="ot">&lt;-</span> infer env e
     <span class="kw">let</span> env&#39; <span class="fu">=</span> Map.insert n tBody env
     (t, cs) <span class="ot">&lt;-</span> infer env&#39; e
     return (t, cs <span class="fu">++</span> csBody)</code></pre></div>
<h2 id="unbound-generics">unbound-generics</h2>
<p>Recently unbound was ported to use GHC.Generics instead of Template Haskell. The API is effectively the same, so for example a simple lambda calculus could be written as:</p>
<div class="sourceCode" include="src/30-languages/unbound-generics.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span>
<span class="ot">{-# LANGUAGE DeriveDataTypeable #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE FlexibleContexts #-}</span>
<span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span>

<span class="kw">module</span> <span class="dt">LC</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Unbound.Generics.LocallyNameless</span>
<span class="kw">import </span><span class="dt">Unbound.Generics.LocallyNameless.Internal.Fold</span> (toListOf)

<span class="kw">import </span><span class="dt">GHC.Generics</span>

<span class="kw">import </span><span class="dt">Data.Typeable</span> (<span class="dt">Typeable</span>)
<span class="kw">import </span><span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">S</span>

<span class="kw">import </span><span class="dt">Control.Monad.Reader</span> (<span class="dt">Reader</span>, runReader)

<span class="kw">data</span> <span class="dt">Exp</span>
  <span class="fu">=</span> <span class="dt">Var</span> (<span class="dt">Name</span> <span class="dt">Exp</span>)
  <span class="fu">|</span> <span class="dt">Lam</span> (<span class="dt">Bind</span> (<span class="dt">Name</span> <span class="dt">Exp</span>) <span class="dt">Exp</span>)
  <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>, <span class="dt">Typeable</span>)

<span class="kw">instance</span> <span class="dt">Alpha</span> <span class="dt">Exp</span>

<span class="kw">instance</span> <span class="dt">Subst</span> <span class="dt">Exp</span> <span class="dt">Exp</span> <span class="kw">where</span>
  isvar (<span class="dt">Var</span> x) <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">SubstName</span> x)
  isvar _       <span class="fu">=</span> <span class="dt">Nothing</span>

<span class="ot">fvSet ::</span> (<span class="dt">Alpha</span> a, <span class="dt">Typeable</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S.Set</span> (<span class="dt">Name</span> b)
fvSet <span class="fu">=</span> S.fromList <span class="fu">.</span> toListOf fv

<span class="kw">type</span> <span class="dt">M</span> a <span class="fu">=</span> <span class="dt">FreshM</span> a

<span class="ot">(=~) ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">M</span> <span class="dt">Bool</span>
e1 <span class="fu">=~</span> e2 <span class="fu">|</span> e1 <span class="ot">`aeq`</span> e2 <span class="fu">=</span> return <span class="dt">True</span>
e1 <span class="fu">=~</span> e2 <span class="fu">=</span> <span class="kw">do</span>
    e1&#39; <span class="ot">&lt;-</span> red e1
    e2&#39; <span class="ot">&lt;-</span> red e2
    <span class="kw">if</span> e1&#39; <span class="ot">`aeq`</span> e1 <span class="fu">&amp;&amp;</span> e2&#39; <span class="ot">`aeq`</span> e2
      <span class="kw">then</span> return <span class="dt">False</span>
      <span class="kw">else</span> e1&#39; <span class="fu">=~</span> e2&#39;

<span class="co">-- Reduction</span>
<span class="ot">red ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">M</span> <span class="dt">Exp</span>
red (<span class="dt">App</span> e1 e2) <span class="fu">=</span> <span class="kw">do</span>
  e1&#39; <span class="ot">&lt;-</span> red e1
  e2&#39; <span class="ot">&lt;-</span> red e2
  <span class="kw">case</span> e1&#39; <span class="kw">of</span>
    <span class="dt">Lam</span> bnd <span class="ot">-&gt;</span> <span class="kw">do</span>
        (x, e1&#39;&#39;) <span class="ot">&lt;-</span> unbind bnd
        return <span class="fu">$</span> subst x e2&#39; e1&#39;&#39;
    otherwise <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">App</span> e1&#39; e2&#39;
red (<span class="dt">Lam</span> bnd) <span class="fu">=</span> <span class="kw">do</span>
   (x, e) <span class="ot">&lt;-</span> unbind bnd
   e&#39; <span class="ot">&lt;-</span> red e
   <span class="kw">case</span> e <span class="kw">of</span>
     <span class="dt">App</span> e1 (<span class="dt">Var</span> y) <span class="fu">|</span> y <span class="fu">==</span> x <span class="fu">&amp;&amp;</span> x <span class="ot">`S.notMember`</span> fvSet e1 <span class="ot">-&gt;</span> return e1
     otherwise <span class="ot">-&gt;</span> return (<span class="dt">Lam</span> (bind x e&#39;))
red (<span class="dt">Var</span> x) <span class="fu">=</span> return <span class="fu">$</span> (<span class="dt">Var</span> x)


<span class="ot">x ::</span> <span class="dt">Name</span> <span class="dt">Exp</span>
x <span class="fu">=</span> string2Name <span class="st">&quot;x&quot;</span>

<span class="ot">y ::</span> <span class="dt">Name</span> <span class="dt">Exp</span>
y <span class="fu">=</span> string2Name <span class="st">&quot;y&quot;</span>

<span class="ot">z ::</span> <span class="dt">Name</span> <span class="dt">Exp</span>
z <span class="fu">=</span> string2Name <span class="st">&quot;z&quot;</span>

<span class="ot">s ::</span> <span class="dt">Name</span> <span class="dt">Exp</span>
s <span class="fu">=</span> string2Name <span class="st">&quot;s&quot;</span>

<span class="ot">lam ::</span> <span class="dt">Name</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
lam x y <span class="fu">=</span> <span class="dt">Lam</span> (bind x y)

zero  <span class="fu">=</span> lam s (lam z (<span class="dt">Var</span> z))
one   <span class="fu">=</span> lam s (lam z (<span class="dt">App</span> (<span class="dt">Var</span> s) (<span class="dt">Var</span> z)))
two   <span class="fu">=</span> lam s (lam z (<span class="dt">App</span> (<span class="dt">Var</span> s) (<span class="dt">App</span> (<span class="dt">Var</span> s) (<span class="dt">Var</span> z))))
three <span class="fu">=</span> lam s (lam z (<span class="dt">App</span> (<span class="dt">Var</span> s) (<span class="dt">App</span> (<span class="dt">Var</span> s) (<span class="dt">App</span> (<span class="dt">Var</span> s) (<span class="dt">Var</span> z)))))

plus <span class="fu">=</span> lam x (lam y (lam s (lam z (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Var</span> x) (<span class="dt">Var</span> s)) (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Var</span> y) (<span class="dt">Var</span> s)) (<span class="dt">Var</span> z))))))

true <span class="fu">=</span> lam x (lam y (<span class="dt">Var</span> x))
false <span class="fu">=</span> lam x (lam y (<span class="dt">Var</span> y))
if_ x y z <span class="fu">=</span> (<span class="dt">App</span> (<span class="dt">App</span> x y) z)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  print <span class="fu">$</span> lam x (<span class="dt">Var</span> x) <span class="ot">`aeq`</span> lam y (<span class="dt">Var</span> y)
  print <span class="fu">$</span> not (lam x (<span class="dt">Var</span> y) <span class="ot">`aeq`</span> lam x (<span class="dt">Var</span> x))
  print <span class="fu">$</span> lam x (<span class="dt">App</span> (lam y (<span class="dt">Var</span> x)) (lam y (<span class="dt">Var</span> y))) <span class="fu">=~</span> (lam y (<span class="dt">Var</span> y))
  print <span class="fu">$</span> lam x (<span class="dt">App</span> (<span class="dt">Var</span> y) (<span class="dt">Var</span> x)) <span class="fu">=~</span> <span class="dt">Var</span> y
  print <span class="fu">$</span> if_ true (<span class="dt">Var</span> x) (<span class="dt">Var</span> y) <span class="fu">=~</span> <span class="dt">Var</span> x
  print <span class="fu">$</span> if_ false (<span class="dt">Var</span> x) (<span class="dt">Var</span> y) <span class="fu">=~</span> <span class="dt">Var</span> y
  print <span class="fu">$</span> <span class="dt">App</span> (<span class="dt">App</span> plus one) two <span class="fu">=~</span> three</code></pre></div>
<p>See:</p>
<ul>
<li><a href="https://github.com/lambdageek/unbound-generics">unbound-generics</a></li>
</ul>
<h2 id="llvm-general">llvm-general</h2>
<p>LLVM is a library for generating machine code. The llvm-general bindings provide a way to model, compile and execute LLVM bytecode from within the Haskell runtime.</p>
<div class="sourceCode" include="src/30-languages/llvm-general.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Standalone</span> <span class="kw">where</span>

<span class="co">-- Pretty Printer</span>
<span class="kw">import </span><span class="dt">LLVM.General.Pretty</span> (ppllvm)

<span class="co">-- AST</span>
<span class="kw">import qualified</span> <span class="dt">LLVM.General.AST</span> <span class="kw">as</span> <span class="dt">AST</span>
<span class="kw">import qualified</span> <span class="dt">LLVM.General.AST.Linkage</span> <span class="kw">as</span> <span class="dt">Linkage</span>
<span class="kw">import qualified</span> <span class="dt">LLVM.General.AST.Visibility</span> <span class="kw">as</span> <span class="dt">Visibility</span>
<span class="kw">import qualified</span> <span class="dt">LLVM.General.AST.CallingConvention</span> <span class="kw">as</span> <span class="dt">Convention</span>

<span class="kw">import </span><span class="dt">Data.Text.Lazy.IO</span> <span class="kw">as</span> <span class="dt">TIO</span>

<span class="ot">astModule ::</span> <span class="dt">AST.Module</span>
astModule <span class="fu">=</span> <span class="dt">AST.Module</span>
    { AST.moduleName         <span class="fu">=</span> <span class="st">&quot;example-llvm-module&quot;</span>
    , AST.moduleDataLayout   <span class="fu">=</span> <span class="dt">Nothing</span>
    , AST.moduleTargetTriple <span class="fu">=</span> <span class="dt">Nothing</span>
    , AST.moduleDefinitions  <span class="fu">=</span>
        [ <span class="dt">AST.GlobalDefinition</span>
            (<span class="dt">AST.Function</span>
                <span class="dt">Linkage.External</span>
                <span class="dt">Visibility.Default</span>
                <span class="dt">Nothing</span>
                <span class="dt">Convention.C</span>
                []
                (<span class="dt">AST.IntegerType</span> <span class="dv">8</span>)
                (<span class="dt">AST.Name</span> <span class="st">&quot;f&quot;</span>)
                ([<span class="dt">AST.Parameter</span> (<span class="dt">AST.IntegerType</span> <span class="dv">8</span>) (<span class="dt">AST.Name</span> <span class="st">&quot;x&quot;</span>) []], <span class="dt">False</span>)
                []
                <span class="dt">Nothing</span>
                <span class="dt">Nothing</span>
                <span class="dv">0</span>
                <span class="dt">Nothing</span>
                <span class="dt">Nothing</span>
                [ <span class="dt">AST.BasicBlock</span>
                    (<span class="dt">AST.Name</span> <span class="st">&quot;entry&quot;</span>)
                    []
                    (<span class="dt">AST.Do</span>
                        (<span class="dt">AST.Ret</span>
                            (<span class="dt">Just</span>
                                (<span class="dt">AST.LocalReference</span>
                                    (<span class="dt">AST.IntegerType</span> <span class="dv">8</span>)
                                    (<span class="dt">AST.Name</span> <span class="st">&quot;x&quot;</span>)
                                )
                            )
                            []
                        )
                    )
                ]
            )
        ]
    }

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> TIO.putStrLn (ppllvm astModule)</code></pre></div>
<p>Generates the following textual LLVM IR which can them be executed using the JIT in the <code>llvm-general</code> package or passed to the various llvm commandline utilities.</p>
<div class="sourceCode"><pre class="sourceCode llvm"><code class="sourceCode llvm"><span class="co">; ModuleID = &#39;example-llvm-module&#39;</span>

<span class="kw">define</span> <span class="dt">i8</span> <span class="fu">@f</span>(<span class="dt">i8</span> <span class="fu">%x</span>){
<span class="fu">entry:</span>
  <span class="kw">ret</span> <span class="dt">i8</span> <span class="fu">%x</span>
}</code></pre></div>
<p>See:</p>
<ul>
<li><a href="https://github.com/sdiehl/llvm-tutorial-standalone">Minimal Example of LLVM Haskell JIT</a></li>
<li><a href="../../www.stephendiehl.com/llvm/index.html">Implementing a JIT Compiled Language with Haskell and LLVM</a></li>
</ul>
<h2 id="pretty">pretty</h2>
<p>Pretty printer combinators compose logic to print strings.</p>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">Combinators</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>&lt;&gt;</code></td>
<td align="left">Concatenation</td>
</tr>
<tr class="even">
<td align="left"><code>&lt;+&gt;</code></td>
<td align="left">Spaced concatenation</td>
</tr>
<tr class="odd">
<td align="left"><code>char</code></td>
<td align="left">Renders a character as a <code>Doc</code></td>
</tr>
<tr class="even">
<td align="left"><code>text</code></td>
<td align="left">Renders a string as a <code>Doc</code></td>
</tr>
</tbody>
</table>
<div class="sourceCode" include="src/30-languages/pretty.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>

<span class="kw">import </span><span class="dt">Text.PrettyPrint</span>
<span class="kw">import </span><span class="dt">Text.Show.Pretty</span> (ppShow)

<span class="ot">parensIf ::</span>  <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Doc</span> <span class="ot">-&gt;</span> <span class="dt">Doc</span>
parensIf <span class="dt">True</span> <span class="fu">=</span> parens
parensIf <span class="dt">False</span> <span class="fu">=</span> id

<span class="kw">type</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="dt">Var</span> <span class="dt">String</span>
  <span class="fu">|</span> <span class="dt">Lit</span> <span class="dt">Ground</span>
  <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Lam</span> <span class="dt">Name</span> <span class="dt">Expr</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">data</span> <span class="dt">Ground</span>
  <span class="fu">=</span> <span class="dt">LInt</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">LBool</span> <span class="dt">Bool</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)


<span class="kw">class</span> <span class="dt">Pretty</span> p <span class="kw">where</span>
<span class="ot">  ppr ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> p <span class="ot">-&gt;</span> <span class="dt">Doc</span>

<span class="kw">instance</span> <span class="dt">Pretty</span> <span class="dt">String</span> <span class="kw">where</span>
  ppr _ x <span class="fu">=</span> text x

<span class="kw">instance</span> <span class="dt">Pretty</span> <span class="dt">Expr</span> <span class="kw">where</span>
  ppr _ (<span class="dt">Var</span> x)         <span class="fu">=</span> text x
  ppr _ (<span class="dt">Lit</span> (<span class="dt">LInt</span> a))  <span class="fu">=</span> text (show a)
  ppr _ (<span class="dt">Lit</span> (<span class="dt">LBool</span> b)) <span class="fu">=</span> text (show b)

  ppr p e<span class="fu">@</span>(<span class="dt">App</span> _ _) <span class="fu">=</span>
    <span class="kw">let</span> (f, xs) <span class="fu">=</span> viewApp e <span class="kw">in</span>
    <span class="kw">let</span> args <span class="fu">=</span> sep <span class="fu">$</span> map (ppr (p<span class="fu">+</span><span class="dv">1</span>)) xs <span class="kw">in</span>
    parensIf (p<span class="fu">&gt;</span><span class="dv">0</span>) <span class="fu">$</span> ppr p f <span class="fu">&lt;+&gt;</span> args

  ppr p e<span class="fu">@</span>(<span class="dt">Lam</span> _ _) <span class="fu">=</span>
    <span class="kw">let</span> body <span class="fu">=</span> ppr (p<span class="fu">+</span><span class="dv">1</span>) (viewBody e) <span class="kw">in</span>
    <span class="kw">let</span> vars <span class="fu">=</span> map (ppr <span class="dv">0</span>) (viewVars e) <span class="kw">in</span>
    parensIf (p<span class="fu">&gt;</span><span class="dv">0</span>) <span class="fu">$</span> char <span class="ch">&#39;\\&#39;</span> <span class="fu">&lt;&gt;</span> hsep vars <span class="fu">&lt;+&gt;</span> text <span class="st">&quot;.&quot;</span> <span class="fu">&lt;+&gt;</span> body

<span class="ot">viewVars ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> [<span class="dt">Name</span>]
viewVars (<span class="dt">Lam</span> n a) <span class="fu">=</span> n <span class="fu">:</span> viewVars a
viewVars _ <span class="fu">=</span> []

<span class="ot">viewBody ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span>
viewBody (<span class="dt">Lam</span> _ a) <span class="fu">=</span> viewBody a
viewBody x <span class="fu">=</span> x

<span class="ot">viewApp ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> (<span class="dt">Expr</span>, [<span class="dt">Expr</span>])
viewApp (<span class="dt">App</span> e1 e2) <span class="fu">=</span> go e1 [e2]
  <span class="kw">where</span>
    go (<span class="dt">App</span> a b) xs <span class="fu">=</span> go a (b <span class="fu">:</span> xs)
    go f xs <span class="fu">=</span> (f, xs)

<span class="ot">ppexpr ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
ppexpr <span class="fu">=</span> render <span class="fu">.</span> ppr <span class="dv">0</span>


s, k,<span class="ot"> example ::</span> <span class="dt">Expr</span>
s <span class="fu">=</span> <span class="dt">Lam</span> <span class="st">&quot;f&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;g&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;f&quot;</span>) (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;g&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>)))))
k <span class="fu">=</span> <span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;y&quot;</span> (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>))
example <span class="fu">=</span> <span class="dt">App</span> s k

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  putStrLn <span class="fu">$</span> ppexpr s
  putStrLn <span class="fu">$</span> ppShow example</code></pre></div>
<p>The pretty printed form of the <code>k</code> combinator:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">\f g x <span class="fu">.</span> (f (g x))</code></pre></div>
<p>The <code>Text.Show.Pretty</code> library can be used to pretty print nested data structures in a more human readable form for any type that implements <code>Show</code>. For example a dump of the structure for the AST of SK combinator with <code>ppShow</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">App</span>
  (<span class="dt">Lam</span>
     <span class="st">&quot;f&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;g&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;f&quot;</span>) (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;g&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>))))))
  (<span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;y&quot;</span> (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>)))</code></pre></div>
<p>Adding the following to your ghci.conf can be useful for working with deeply nested structures interactively.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Text.Show.Pretty</span> (ppShow)
<span class="kw">let</span> pprint x <span class="fu">=</span> putStrLn <span class="fu">$</span> ppShow x</code></pre></div>
<p>See:</p>
<ul>
<li><a href="http://belle.sourceforge.net/doc/hughes95design.pdf">The Design of a Pretty-printing Library</a></li>
</ul>
<h2 id="wl-pprint-text">wl-pprint-text</h2>
<p><code>wl-pprint-text</code> is a Wadler-style pretty printing library that uses Text builder objects for efficient generation under the hood. It exposes effectively the same interface as the String-based <code>pretty</code> library but is much more performant.</p>
<h5 id="combinators">Combinators</h5>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">renderPretty ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Doc</span> <span class="ot">-&gt;</span> <span class="dt">SimpleDoc</span>
<span class="ot">renderCompact ::</span> <span class="dt">Doc</span> <span class="ot">-&gt;</span> <span class="dt">SimpleDoc</span>
<span class="ot">renderOneLine ::</span> <span class="dt">Doc</span> <span class="ot">-&gt;</span> <span class="dt">SimpleDoc</span></code></pre></div>
<p>See:</p>
<h4 id="monadic-api">Monadic API</h4>
<ul>
<li><a href="https://hackage.haskell.org/package/wl-pprint-text">wl-pprint-text</a></li>
</ul>
<h2 id="pretty-show">pretty-show</h2>
<p>TODO</p>
<h2 id="haskeline">Haskeline</h2>
<p>Haskeline is cross-platform readline support which plays nice with GHCi as well.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runInputT ::</span> <span class="dt">Settings</span> <span class="dt">IO</span> <span class="ot">-&gt;</span> <span class="dt">InputT</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
<span class="ot">getInputLine ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">InputT</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">String</span>)</code></pre></div>
<div class="sourceCode" include="src/30-languages/haskelline.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Trans</span>
<span class="kw">import </span><span class="dt">System.Console.Haskeline</span>

<span class="kw">type</span> <span class="dt">Repl</span> a <span class="fu">=</span> <span class="dt">InputT</span> <span class="dt">IO</span> a

<span class="ot">process ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
process <span class="fu">=</span> putStrLn

<span class="ot">repl ::</span> <span class="dt">Repl</span> ()
repl <span class="fu">=</span> <span class="kw">do</span>
  minput <span class="ot">&lt;-</span> getInputLine <span class="st">&quot;Repl&gt; &quot;</span>
  <span class="kw">case</span> minput <span class="kw">of</span>
    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> outputStrLn <span class="st">&quot;Goodbye.&quot;</span>
    <span class="dt">Just</span> input <span class="ot">-&gt;</span> (liftIO <span class="fu">$</span> process input) <span class="fu">&gt;&gt;</span> repl

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> runInputT defaultSettings repl</code></pre></div>
<h2 id="repline">Repline</h2>
<p>Certain sets of tasks in building command line REPL interfaces are so common that is becomes useful to abstract them out into a library. While haskeline provides a sensible lower-level API for interfacing with GNU readline, it is somewhat tedious to implement tab completion logic and common command logic over and over. To that end Repline assists in building interactive shells that that resemble GHCi's default behavior.</p>
<div class="sourceCode" include="src/30-languages/repline.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Monad.Trans</span>
<span class="kw">import </span><span class="dt">System.Console.Repline</span>

<span class="kw">import </span><span class="dt">Data.List</span> (isPrefixOf)
<span class="kw">import </span><span class="dt">System.Process</span> (callCommand)

<span class="kw">type</span> <span class="dt">Repl</span> a <span class="fu">=</span> <span class="dt">HaskelineT</span> <span class="dt">IO</span> a

<span class="co">-- Evaluation : handle each line user inputs</span>
<span class="ot">cmd ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Repl</span> ()
cmd input <span class="fu">=</span> liftIO <span class="fu">$</span> print input

<span class="co">-- Tab Completion: return a completion for partial words entered</span>
<span class="ot">completer ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">WordCompleter</span> m
completer n <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> names <span class="fu">=</span> [<span class="st">&quot;kirk&quot;</span>, <span class="st">&quot;spock&quot;</span>, <span class="st">&quot;mccoy&quot;</span>]
  return <span class="fu">$</span> filter (isPrefixOf n) names

<span class="co">-- Commands</span>
<span class="ot">help ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Repl</span> ()
help args <span class="fu">=</span> liftIO <span class="fu">$</span> print <span class="fu">$</span> <span class="st">&quot;Help: &quot;</span> <span class="fu">++</span> show args

<span class="ot">say ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Repl</span> ()
say args <span class="fu">=</span> <span class="kw">do</span>
  _ <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> callCommand <span class="fu">$</span> <span class="st">&quot;cowsay&quot;</span> <span class="fu">++</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> (unwords args)
  return ()

<span class="ot">options ::</span> [(<span class="dt">String</span>, [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Repl</span> ())]
options <span class="fu">=</span> [
    (<span class="st">&quot;help&quot;</span>, help)  <span class="co">-- :help</span>
  , (<span class="st">&quot;say&quot;</span>, say)    <span class="co">-- :say</span>
  ]

<span class="ot">ini ::</span> <span class="dt">Repl</span> ()
ini <span class="fu">=</span> liftIO <span class="fu">$</span> putStrLn <span class="st">&quot;Welcome!&quot;</span>

<span class="ot">repl ::</span> <span class="dt">IO</span> ()
repl <span class="fu">=</span> evalRepl <span class="st">&quot;&gt;&gt;&gt; &quot;</span> cmd options (<span class="dt">Word0</span> completer) ini

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> repl</code></pre></div>
<p>Trying it out. (<code>&lt;TAB&gt;</code> indicates a user keypress )</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">runhaskell</span> Simple.hs
<span class="co"># Or if in a sandbox: cabal exec runhaskell Simple.hs</span>
<span class="kw">Welcome</span>!
<span class="kw">&gt;&gt;&gt;</span> <span class="kw">&lt;TAB&gt;</span>
<span class="kw">kirk</span> spock mccoy

<span class="kw">&gt;&gt;&gt;</span> <span class="kw">k&lt;</span>TAB<span class="kw">&gt;</span>
<span class="kw">kirk</span>

<span class="kw">&gt;&gt;&gt;</span> <span class="kw">spam</span>
<span class="st">&quot;spam&quot;</span>

<span class="kw">&gt;&gt;&gt;</span> :<span class="kw">say</span> Hello Haskell
 <span class="kw">_______________</span>
<span class="kw">&lt;</span> <span class="kw">Hello</span> Haskell <span class="kw">&gt;</span>
 <span class="kw">---------------</span>
        <span class="kw">\ </span>  ^__^
         <span class="kw">\ </span> (oo)\<span class="kw">_______</span>
            <span class="kw">(__)\ </span>      )\/<span class="kw">\</span>
                <span class="kw">||----w</span> <span class="kw">|</span>
                <span class="kw">||</span>     <span class="kw">||</span></code></pre></div>
<p>See:</p>
<ul>
<li><a href="https://github.com/sdiehl/repline">repline</a></li>
</ul>
</hr>
<h1 id="template-haskell">Template Haskell</h1>
<div class="alert alert-danger">
<p>This is an advanced section, knowledge of TemplateHaskell is not typically necessary to write Haskell.</p>
</div>
<h2 id="perils-of-metaprogramming">Perils of Metaprogramming</h2>
<p>Template Haskell is a very powerful set of abstractions, some might say <strong>too</strong> powerful. It effectively allows us to run arbitrary code at compile-time to generate other Haskell code. You can some absolutely crazy things, like going off and reading from the filesystem or doing network calls that informs how your code compiles leading to non-deterministic builds.</p>
<p>While in some extreme cases TH is useful, some discretion is required when using this in production setting. TemplateHaskell can cause your build times to grow without bound, force you to manually sort all definitions your modules, and generally produce unmaintainable code. If you find yourself falling back on metaprogramming ask yourself, what in my abstractions has failed me such that my only option is to <em>write code that writes code</em>.</p>
<div class="alert alert-danger">
<p>Consideration should be used before enabling TemplateHaskell. Consider an idiomatic solution first.</p>
</div>
<h2 id="quasiquotation">Quasiquotation</h2>
<p>Quasiquotation allows us to express &quot;quoted&quot; blocks of syntax that need not necessarily be be the syntax of the host language, but unlike just writing a giant string it is instead parsed into some AST datatype in the host language. Notably values from the host languages can be injected into the custom language via user-definable logic allowing information to flow between the two languages.</p>
<p>In practice quasiquotation can be used to implement custom domain specific languages or integrate with other general languages entirely via code-generation.</p>
<p>We've already seen how to write a Parsec parser, now let's write a quasiquoter for it.</p>
<div class="sourceCode" include="src/31-template-haskell/Quasiquote.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span>
<span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>

<span class="kw">module</span> <span class="dt">Quasiquote</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Language.Haskell.TH</span>
<span class="kw">import </span><span class="dt">Language.Haskell.TH.Syntax</span>
<span class="kw">import </span><span class="dt">Language.Haskell.TH.Quote</span>

<span class="kw">import </span><span class="dt">Text.Parsec</span>
<span class="kw">import </span><span class="dt">Text.Parsec.String</span> (<span class="dt">Parser</span>)
<span class="kw">import </span><span class="dt">Text.Parsec.Language</span> (emptyDef)

<span class="kw">import qualified</span> <span class="dt">Text.Parsec.Expr</span> <span class="kw">as</span> <span class="dt">Ex</span>
<span class="kw">import qualified</span> <span class="dt">Text.Parsec.Token</span> <span class="kw">as</span> <span class="dt">Tok</span>

<span class="kw">import </span><span class="dt">Control.Monad.Identity</span>

<span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="dt">Tr</span>
  <span class="fu">|</span> <span class="dt">Fl</span>
  <span class="fu">|</span> <span class="dt">Zero</span>
  <span class="fu">|</span> <span class="dt">Succ</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Pred</span> <span class="dt">Expr</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Lift</span> <span class="dt">Expr</span> <span class="kw">where</span>
  lift <span class="dt">Tr</span>         <span class="fu">=</span> [<span class="fu">|</span> <span class="dt">Tr</span> <span class="fu">|</span>]
  lift <span class="dt">Fl</span>         <span class="fu">=</span> [<span class="fu">|</span> <span class="dt">Tr</span> <span class="fu">|</span>]
  lift <span class="dt">Zero</span>       <span class="fu">=</span> [<span class="fu">|</span> <span class="dt">Zero</span> <span class="fu">|</span>]
  lift (<span class="dt">Succ</span> a)   <span class="fu">=</span> [<span class="fu">|</span> <span class="dt">Succ</span> a <span class="fu">|</span>]
  lift (<span class="dt">Pred</span> a)   <span class="fu">=</span> [<span class="fu">|</span> <span class="dt">Pred</span> a <span class="fu">|</span>]

<span class="kw">type</span> <span class="dt">Op</span> <span class="fu">=</span> <span class="dt">Ex.Operator</span> <span class="dt">String</span> () <span class="dt">Identity</span>

<span class="ot">lexer ::</span> <span class="dt">Tok.TokenParser</span> ()
lexer <span class="fu">=</span> Tok.makeTokenParser emptyDef

<span class="ot">parens ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
parens <span class="fu">=</span> Tok.parens lexer

<span class="ot">reserved ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> ()
reserved <span class="fu">=</span> Tok.reserved lexer

<span class="ot">semiSep ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> [a]
semiSep <span class="fu">=</span> Tok.semiSep lexer

<span class="ot">reservedOp ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> ()
reservedOp <span class="fu">=</span> Tok.reservedOp lexer

<span class="ot">prefixOp ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Op</span> a
prefixOp x f <span class="fu">=</span> <span class="dt">Ex.Prefix</span> (reservedOp x <span class="fu">&gt;&gt;</span> return f)

<span class="ot">table ::</span> [[<span class="dt">Op</span> <span class="dt">Expr</span>]]
table <span class="fu">=</span> [
    [ prefixOp <span class="st">&quot;succ&quot;</span> <span class="dt">Succ</span>
    , prefixOp <span class="st">&quot;pred&quot;</span> <span class="dt">Pred</span>
    ]
  ]

<span class="ot">expr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
expr <span class="fu">=</span> Ex.buildExpressionParser table factor

true, false,<span class="ot"> zero ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
true  <span class="fu">=</span> reserved <span class="st">&quot;true&quot;</span> <span class="fu">&gt;&gt;</span> return <span class="dt">Tr</span>
false <span class="fu">=</span> reserved <span class="st">&quot;false&quot;</span> <span class="fu">&gt;&gt;</span> return <span class="dt">Fl</span>
zero  <span class="fu">=</span> reservedOp <span class="st">&quot;0&quot;</span> <span class="fu">&gt;&gt;</span> return <span class="dt">Zero</span>

<span class="ot">factor ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
factor <span class="fu">=</span>
      true
  <span class="fu">&lt;|&gt;</span> false
  <span class="fu">&lt;|&gt;</span> zero
  <span class="fu">&lt;|&gt;</span> parens expr

<span class="ot">contents ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
contents p <span class="fu">=</span> <span class="kw">do</span>
  Tok.whiteSpace lexer
  r <span class="ot">&lt;-</span> p
  eof
  return r

<span class="ot">toplevel ::</span> <span class="dt">Parser</span> [<span class="dt">Expr</span>]
toplevel <span class="fu">=</span> semiSep expr

<span class="ot">parseExpr ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ParseError</span> <span class="dt">Expr</span>
parseExpr s <span class="fu">=</span> parse (contents expr) <span class="st">&quot;&lt;stdin&gt;&quot;</span> s

<span class="ot">parseToplevel ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ParseError</span> [<span class="dt">Expr</span>]
parseToplevel s <span class="fu">=</span> parse (contents toplevel) <span class="st">&quot;&lt;stdin&gt;&quot;</span> s

<span class="ot">calcExpr ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span>
calcExpr str <span class="fu">=</span> <span class="kw">do</span>
  filename <span class="ot">&lt;-</span> loc_filename <span class="ot">`fmap`</span> location
  <span class="kw">case</span> parse (contents expr) filename str <span class="kw">of</span>
    <span class="dt">Left</span> err <span class="ot">-&gt;</span> error (show err)
    <span class="dt">Right</span> tag <span class="ot">-&gt;</span> [<span class="fu">|</span> tag <span class="fu">|</span>]

<span class="ot">calc ::</span> <span class="dt">QuasiQuoter</span>
calc <span class="fu">=</span> <span class="dt">QuasiQuoter</span> calcExpr err err err
  <span class="kw">where</span> err <span class="fu">=</span> error <span class="st">&quot;Only defined for values&quot;</span></code></pre></div>
<p>Testing it out:</p>
<div class="sourceCode" include="src/31-template-haskell/quasiquote_use.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span>

<span class="kw">import </span><span class="dt">Quasiquote</span>

<span class="ot">a ::</span> <span class="dt">Expr</span>
a <span class="fu">=</span> [calc<span class="fu">|</span>true<span class="fu">|</span>]
<span class="co">-- Tr</span>

<span class="ot">b ::</span> <span class="dt">Expr</span>
b <span class="fu">=</span> [calc<span class="fu">|</span>succ (succ <span class="dv">0</span>)<span class="fu">|</span>]
<span class="co">-- Succ (Succ Zero)</span>

<span class="ot">c ::</span> <span class="dt">Expr</span>
c <span class="fu">=</span> [calc<span class="fu">|</span>pred (succ <span class="dv">0</span>)<span class="fu">|</span>]
<span class="co">-- Pred (Succ Zero)</span></code></pre></div>
<p>One extremely important feature is the ability to preserve position information so that errors in the embedded language can be traced back to the line of the host syntax.</p>
<h2 id="language-c-quote">language-c-quote</h2>
<p>Of course since we can provide an arbitrary parser for the quoted expression, one might consider embedding the AST of another language entirely. For example C or CUDA C.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">hello ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">C.Func</span>
hello msg <span class="fu">=</span> [cfun<span class="fu">|</span>

int main(int argc, const char <span class="fu">*</span>argv[])
{
    printf(<span class="fu">$</span>msg);
    return <span class="dv">0</span>;
}

<span class="fu">|</span>]</code></pre></div>
<p>Evaluating this we get back an AST representation of the quoted C program which we can manipulate or print back out to textual C code using <code>ppr</code> function.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Func</span>
  (<span class="dt">DeclSpec</span> [] [] (<span class="dt">Tint</span> <span class="dt">Nothing</span>))
  (<span class="dt">Id</span> <span class="st">&quot;main&quot;</span>)
  <span class="dt">DeclRoot</span>
  (<span class="dt">Params</span>
     [ <span class="dt">Param</span> (<span class="dt">Just</span> (<span class="dt">Id</span> <span class="st">&quot;argc&quot;</span>)) (<span class="dt">DeclSpec</span> [] [] (<span class="dt">Tint</span> <span class="dt">Nothing</span>)) <span class="dt">DeclRoot</span>
     , <span class="dt">Param</span>
         (<span class="dt">Just</span> (<span class="dt">Id</span> <span class="st">&quot;argv&quot;</span>))
         (<span class="dt">DeclSpec</span> [] [ <span class="dt">Tconst</span> ] (<span class="dt">Tchar</span> <span class="dt">Nothing</span>))
         (<span class="dt">Array</span> [] <span class="dt">NoArraySize</span> (<span class="dt">Ptr</span> [] <span class="dt">DeclRoot</span>))
     ]
     <span class="dt">False</span>)
  [ <span class="dt">BlockStm</span>
      (<span class="dt">Exp</span>
         (<span class="dt">Just</span>
            (<span class="dt">FnCall</span>
               (<span class="dt">Var</span> (<span class="dt">Id</span> <span class="st">&quot;printf&quot;</span>))
               [ <span class="dt">Const</span> (<span class="dt">StringConst</span> [ <span class="st">&quot;\&quot;Hello Haskell!\&quot;&quot;</span> ] <span class="st">&quot;Hello Haskell!&quot;</span>)
               ])))
  , <span class="dt">BlockStm</span> (<span class="dt">Return</span> (<span class="dt">Just</span> (<span class="dt">Const</span> (<span class="dt">IntConst</span> <span class="st">&quot;0&quot;</span> <span class="dt">Signed</span> <span class="dv">0</span>))))
  ]</code></pre></div>
<p>In this example we just spliced in the anti-quoted Haskell string in the printf statement, but we can pass many other values to and from the quoted expressions including identifiers, numbers, and other quoted expressions which implement the <code>Lift</code> type class.</p>
<p>For example now if we wanted programmatically generate the source for a CUDA kernel to run on a GPU we can switch over the CUDA C dialect to emit the C code.</p>
<div class="sourceCode" include="src/31-template-haskell/cquote.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span>
<span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>

<span class="kw">import </span><span class="dt">Text.PrettyPrint.Mainland</span>
<span class="kw">import qualified</span> <span class="dt">Language.C.Syntax</span> <span class="kw">as</span> <span class="dt">C</span>
<span class="kw">import qualified</span> <span class="dt">Language.C.Quote.CUDA</span> <span class="kw">as</span> <span class="dt">Cuda</span>

<span class="ot">cuda_fun ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">C.Func</span>
cuda_fun fn n a <span class="fu">=</span> [Cuda.cfun<span class="fu">|</span>

__global__ void <span class="fu">$</span>id<span class="fu">:</span>fn (float <span class="fu">*</span>x, float <span class="fu">*</span>y) {
  int i <span class="fu">=</span> blockIdx<span class="fu">.</span>x<span class="fu">*</span>blockDim<span class="fu">.</span>x <span class="fu">+</span> threadIdx<span class="fu">.</span>x;
  <span class="kw">if</span> ( i<span class="fu">&lt;$</span>n ) { y[i] <span class="fu">=</span> <span class="fu">$</span>a<span class="fu">*</span>x[i] <span class="fu">+</span> y[i]; }
}

<span class="fu">|</span>]

<span class="ot">cuda_driver ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">C.Func</span>
cuda_driver fn n <span class="fu">=</span> [Cuda.cfun<span class="fu">|</span>

void driver (float <span class="fu">*</span>x, float <span class="fu">*</span>y) {
  float <span class="fu">*</span>d_x, <span class="fu">*</span>d_y;

  cudaMalloc(<span class="fu">&amp;</span>d_x, <span class="fu">$</span>n<span class="fu">*</span>sizeof(float));
  cudaMalloc(<span class="fu">&amp;</span>d_y, <span class="fu">$</span>n<span class="fu">*</span>sizeof(float));

  cudaMemcpy(d_x, x, <span class="fu">$</span>n, cudaMemcpyHostToDevice);
  cudaMemcpy(d_y, y, <span class="fu">$</span>n, cudaMemcpyHostToDevice);

  <span class="fu">$</span>id<span class="fu">:</span>fn<span class="fu">&lt;&lt;&lt;</span>(<span class="fu">$</span>n<span class="fu">+</span><span class="dv">255</span>)<span class="fu">/</span><span class="dv">256</span>, <span class="dv">256</span><span class="fu">&gt;&gt;&gt;</span>(d_x, d_y);

  cudaFree(d_x);
  cudaFree(d_y);
  return <span class="dv">0</span>;
}

<span class="fu">|</span>]

<span class="ot">makeKernel ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">C.Func</span>]
makeKernel fn a n <span class="fu">=</span> [
    cuda_fun fn n a
  , cuda_driver fn n
  ]

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> ker <span class="fu">=</span> makeKernel <span class="st">&quot;saxpy&quot;</span> <span class="dv">2</span> <span class="dv">65536</span>
  mapM_ (print <span class="fu">.</span> ppr) ker</code></pre></div>
<p>Running this we generate:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">__global__ <span class="dt">void</span> saxpy(<span class="dt">float</span>* x, <span class="dt">float</span>* y)
{
    <span class="dt">int</span> i = blockIdx.x * blockDim.x + threadIdx.x;

    <span class="kw">if</span> (i &lt; <span class="dv">65536</span>) {
        y[i] = <span class="fl">2.0</span> * x[i] + y[i];
    }
}
<span class="dt">int</span> driver(<span class="dt">float</span>* x, <span class="dt">float</span>* y)
{
    <span class="dt">float</span>* d_x, * d_y;

    cudaMalloc(&amp;d_x, <span class="dv">65536</span> * <span class="kw">sizeof</span>(<span class="dt">float</span>));
    cudaMalloc(&amp;d_y, <span class="dv">65536</span> * <span class="kw">sizeof</span>(<span class="dt">float</span>));
    cudaMemcpy(d_x, x, <span class="dv">65536</span>, cudaMemcpyHostToDevice);
    cudaMemcpy(d_y, y, <span class="dv">65536</span>, cudaMemcpyHostToDevice);
    saxpy&lt;&lt;&lt;(<span class="dv">65536</span> + <span class="dv">255</span>) / <span class="dv">256</span>, <span class="dv">256</span>&gt;&gt;&gt;(d_x, d_y);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>Run the resulting output through <code>nvcc -ptx -c</code> to get the PTX associated with the outputted code.</p>
<h2 id="template-haskell-1">Template Haskell</h2>
<p>Of course the most useful case of quasiquotation is the ability to procedurally generate Haskell code itself from inside of Haskell. The <code>template-haskell</code> framework provides four entry points for the quotation to generate various types of Haskell declarations and expressions.</p>
<table>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Quasiquoted</th>
<th align="left">Class</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>Q Exp</code></td>
<td align="left"><code>[e| ... |]</code></td>
<td align="left">expression</td>
</tr>
<tr class="even">
<td align="left"><code>Q Pat</code></td>
<td align="left"><code>[p| ... |]</code></td>
<td align="left">pattern</td>
</tr>
<tr class="odd">
<td align="left"><code>Q Type</code></td>
<td align="left"><code>[t| ... |]</code></td>
<td align="left">type</td>
</tr>
<tr class="even">
<td align="left"><code>Q [Dec]</code></td>
<td align="left"><code>[d| ... |]</code></td>
<td align="left">declaration</td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">QuasiQuoter</span> <span class="fu">=</span> <span class="dt">QuasiQuoter</span>
  {<span class="ot"> quoteExp  ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span>
  ,<span class="ot"> quotePat  ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Pat</span>
  ,<span class="ot"> quoteType ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Type</span>
  ,<span class="ot"> quoteDec  ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> [<span class="dt">Dec</span>]
  }</code></pre></div>
<p>The logic evaluating, splicing, and introspecting compile-time values is embedded within the Q monad, which has a <code>runQ</code> which can be used to evaluate its context. These functions of this monad is deeply embedded in the implementation of GHC.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runQ ::</span> <span class="dt">Quasi</span> m <span class="ot">=&gt;</span> <span class="dt">Q</span> a <span class="ot">-&gt;</span> m a
<span class="ot">runIO ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">Q</span> a</code></pre></div>
<p>Just as before, TemplateHaskell provides the ability to lift Haskell values into the their AST quantities within the quoted expression using the Lift type class.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Lift</span> t <span class="kw">where</span>
<span class="ot">  lift ::</span> t <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span>

<span class="kw">instance</span> <span class="dt">Lift</span> <span class="dt">Integer</span> <span class="kw">where</span>
  lift x <span class="fu">=</span> return (<span class="dt">LitE</span> (<span class="dt">IntegerL</span> x))

<span class="kw">instance</span> <span class="dt">Lift</span> <span class="dt">Int</span> <span class="kw">where</span>
  lift x<span class="fu">=</span> return (<span class="dt">LitE</span> (<span class="dt">IntegerL</span> (fromIntegral x)))

<span class="kw">instance</span> <span class="dt">Lift</span> <span class="dt">Char</span> <span class="kw">where</span>
  lift x <span class="fu">=</span> return (<span class="dt">LitE</span> (<span class="dt">CharL</span> x))

<span class="kw">instance</span> <span class="dt">Lift</span> <span class="dt">Bool</span> <span class="kw">where</span>
  lift <span class="dt">True</span>  <span class="fu">=</span> return (<span class="dt">ConE</span> trueName)
  lift <span class="dt">False</span> <span class="fu">=</span> return (<span class="dt">ConE</span> falseName)

<span class="kw">instance</span> <span class="dt">Lift</span> a <span class="ot">=&gt;</span> <span class="dt">Lift</span> (<span class="dt">Maybe</span> a) <span class="kw">where</span>
  lift <span class="dt">Nothing</span>  <span class="fu">=</span> return (<span class="dt">ConE</span> nothingName)
  lift (<span class="dt">Just</span> x) <span class="fu">=</span> liftM (<span class="dt">ConE</span> justName <span class="ot">`AppE`</span>) (lift x)

<span class="kw">instance</span> <span class="dt">Lift</span> a <span class="ot">=&gt;</span> <span class="dt">Lift</span> [a] <span class="kw">where</span>
  lift xs <span class="fu">=</span> <span class="kw">do</span> { xs&#39; <span class="ot">&lt;-</span> mapM lift xs; return (<span class="dt">ListE</span> xs&#39;) }</code></pre></div>
<p>In many cases Template Haskell can be used interactively to explore the AST form of various Haskell syntax.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> runQ [e<span class="fu">|</span> \x <span class="ot">-&gt;</span> x <span class="fu">|</span>]
<span class="dt">LamE</span> [<span class="dt">VarP</span> x_2] (<span class="dt">VarE</span> x_2)

λ<span class="fu">:</span> runQ [d<span class="fu">|</span> <span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Nat</span> <span class="fu">|</span>]
[<span class="dt">DataD</span> [] <span class="dt">Nat_0</span> [] [<span class="dt">NormalC</span> <span class="dt">Z_2</span> [],<span class="dt">NormalC</span> <span class="dt">S_1</span> [(<span class="dt">NotStrict</span>,<span class="dt">ConT</span> <span class="dt">Nat_0</span>)]] []]

λ<span class="fu">:</span> runQ [p<span class="fu">|</span> <span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>)<span class="fu">|</span>]
<span class="dt">ConP</span> <span class="dt">Singleton.S</span> [<span class="dt">ConP</span> <span class="dt">Singleton.S</span> [<span class="dt">ConP</span> <span class="dt">Singleton.Z</span> []]]

λ<span class="fu">:</span> runQ [t<span class="fu">|</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="fu">|</span>]
<span class="dt">AppT</span> (<span class="dt">AppT</span> <span class="dt">ArrowT</span> (<span class="dt">ConT</span> <span class="dt">GHC.Types.Int</span>)) (<span class="dt">AppT</span> <span class="dt">ListT</span> (<span class="dt">ConT</span> <span class="dt">GHC.Types.Int</span>))

λ<span class="fu">:</span> <span class="kw">let</span> g <span class="fu">=</span> <span class="fu">$</span>(runQ [<span class="fu">|</span> \x <span class="ot">-&gt;</span> x <span class="fu">|</span>])

λ<span class="fu">:</span> g <span class="dv">3</span>
<span class="dv">3</span></code></pre></div>
<p>Using <a href="http://hackage.haskell.org/package/template-haskell-2.4.0.0/docs/Language-Haskell-TH-Syntax.html#t:Dec">Language.Haskell.TH</a> we can piece together Haskell AST element by element but subject to our own custom logic to generate the code. This can be somewhat painful though as the source-language (called <code>HsSyn</code>) to Haskell is enormous, consisting of around 100 nodes in its AST many of which are dependent on the state of language pragmas.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- builds the function (f = \(a,b) -&gt; a)</span>
<span class="ot">f ::</span> <span class="dt">Q</span> [<span class="dt">Dec</span>]
f <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> f <span class="fu">=</span> mkName <span class="st">&quot;f&quot;</span>
  a <span class="ot">&lt;-</span> newName <span class="st">&quot;a&quot;</span>
  b <span class="ot">&lt;-</span> newName <span class="st">&quot;b&quot;</span>
  return [ <span class="dt">FunD</span> f [ <span class="dt">Clause</span> [<span class="dt">TupP</span> [<span class="dt">VarP</span> a, <span class="dt">VarP</span> b]] (<span class="dt">NormalB</span> (<span class="dt">VarE</span> a)) [] ] ]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">my_id ::</span> a <span class="ot">-&gt;</span> a
my_id x <span class="fu">=</span> <span class="fu">$</span>( [<span class="fu">|</span> x <span class="fu">|</span>] )

main <span class="fu">=</span> print (my_id <span class="st">&quot;Hello Haskell!&quot;</span>)</code></pre></div>
<p>As a debugging tool it is useful to be able to dump the reified information out for a given symbol interactively, to do so there is a simple little hack.</p>
<div class="sourceCode" include="src/31-template-haskell/template_info.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span>
<span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>

<span class="kw">import </span><span class="dt">Text.Show.Pretty</span> (ppShow)
<span class="kw">import </span><span class="dt">Language.Haskell.TH</span>

<span class="ot">introspect ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span>
introspect n <span class="fu">=</span> <span class="kw">do</span>
  t <span class="ot">&lt;-</span> reify n
  runIO <span class="fu">$</span> putStrLn <span class="fu">$</span> ppShow t
  [<span class="fu">|</span> return () <span class="fu">|</span>]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> <span class="fu">$</span>(introspect <span class="ch">&#39;id)</span>
<span class="dt">VarI</span>
  GHC.Base.id
  (<span class="dt">ForallT</span>
     [ <span class="dt">PlainTV</span> a_1627405383 ]
     []
     (<span class="dt">AppT</span> (<span class="dt">AppT</span> <span class="dt">ArrowT</span> (<span class="dt">VarT</span> a_1627405383)) (<span class="dt">VarT</span> a_1627405383)))
  <span class="dt">Nothing</span>
  (<span class="dt">Fixity</span> <span class="dv">9</span> <span class="dt">InfixL</span>)


λ<span class="fu">:</span> <span class="fu">$</span>(introspect <span class="ch">&#39;&#39;</span><span class="dt">Maybe</span>)
<span class="dt">TyConI</span>
  (<span class="dt">DataD</span>
     []
     <span class="dt">Data.Maybe.Maybe</span>
     [ <span class="dt">PlainTV</span> a_1627399528 ]
     [ <span class="dt">NormalC</span> <span class="dt">Data.Maybe.Nothing</span> []
     , <span class="dt">NormalC</span> <span class="dt">Data.Maybe.Just</span> [ ( <span class="dt">NotStrict</span> , <span class="dt">VarT</span> a_1627399528 ) ]
     ]
     [])</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Language.Haskell.TH</span>

<span class="ot">foo ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
foo x <span class="fu">=</span> x <span class="fu">+</span> <span class="dv">1</span>

<span class="kw">data</span> <span class="dt">Bar</span>

<span class="ot">fooInfo ::</span> <span class="dt">InfoQ</span>
fooInfo <span class="fu">=</span> reify <span class="ch">&#39;foo</span>

<span class="ot">barInfo ::</span> <span class="dt">InfoQ</span>
barInfo <span class="fu">=</span> reify <span class="ch">&#39;&#39;</span><span class="dt">Bar</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">$</span>( [d<span class="fu">|</span> <span class="kw">data</span> <span class="dt">T</span> <span class="fu">=</span> <span class="dt">T1</span> <span class="fu">|</span> <span class="dt">T2</span> <span class="fu">|</span>] )

main <span class="fu">=</span> print [<span class="dt">T1</span>, <span class="dt">T2</span>]</code></pre></div>
<p>Splices are indicated by <code>$(f)</code> syntax for the expression level and at the toplevel simply by invocation of the template Haskell function. Running GHC with <code>-ddump-splices</code> shows our code being spliced in at the specific location in the AST at compile-time.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">$</span>(f)

template_haskell_show<span class="fu">.</span>hs<span class="fu">:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span> <span class="dt">Splicing</span> declarations
    f
  <span class="fu">======&gt;</span>
    template_haskell_show<span class="fu">.</span>hs<span class="fu">:</span><span class="dv">8</span><span class="fu">:</span><span class="dv">3</span><span class="fu">-</span><span class="dv">10</span>
    f (a_a5bd, b_a5be) <span class="fu">=</span> a_a5bd</code></pre></div>
<div class="sourceCode" include="src/31-template-haskell/Splice.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span>
<span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>

<span class="kw">module</span> <span class="dt">Splice</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Language.Haskell.TH</span>
<span class="kw">import </span><span class="dt">Language.Haskell.TH.Syntax</span>

<span class="ot">spliceF ::</span> <span class="dt">Q</span> [<span class="dt">Dec</span>]
spliceF <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> f <span class="fu">=</span> mkName <span class="st">&quot;f&quot;</span>
  a <span class="ot">&lt;-</span> newName <span class="st">&quot;a&quot;</span>
  b <span class="ot">&lt;-</span> newName <span class="st">&quot;b&quot;</span>
  return [ <span class="dt">FunD</span> f [ <span class="dt">Clause</span> [<span class="dt">VarP</span> a, <span class="dt">VarP</span> b] (<span class="dt">NormalB</span> (<span class="dt">VarE</span> a)) [] ] ]

<span class="ot">spliceG ::</span> <span class="dt">Lift</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Q</span> [<span class="dt">Dec</span>]
spliceG n <span class="fu">=</span> runQ [d<span class="fu">|</span> g a <span class="fu">=</span> n <span class="fu">|</span>]</code></pre></div>
<div class="sourceCode" include="src/31-template-haskell/Insert.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>

<span class="kw">import </span><span class="dt">Splice</span>

spliceF
spliceG <span class="st">&quot;argument&quot;</span>

main <span class="fu">=</span> <span class="kw">do</span>
  print <span class="fu">$</span> f <span class="dv">1</span> <span class="dv">2</span>
  print <span class="fu">$</span> g ()</code></pre></div>
<p>At the point of the splice all variables and types used must be in scope, so it must appear after their declarations in the module. As a result we often have to mentally topologically sort our code when using TemplateHaskell such that declarations are defined in order.</p>
<p>See: <a href="http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH.html#t:Exp">Template Haskell AST</a></p>
<h2 id="antiquotation">Antiquotation</h2>
<p>Extending our quasiquotation from above now that we have TemplateHaskell machinery we can implement the same class of logic that it uses to pass Haskell values in and pull Haskell values out via pattern matching on templated expressions.</p>
<div class="sourceCode" include="src/31-template-haskell/Antiquote.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span>
<span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>
<span class="ot">{-# LANGUAGE DeriveDataTypeable #-}</span>

<span class="kw">module</span> <span class="dt">Antiquote</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Generics</span>
<span class="kw">import </span><span class="dt">Language.Haskell.TH</span>
<span class="kw">import </span><span class="dt">Language.Haskell.TH.Quote</span>

<span class="kw">import </span><span class="dt">Text.Parsec</span>
<span class="kw">import </span><span class="dt">Text.Parsec.String</span> (<span class="dt">Parser</span>)
<span class="kw">import </span><span class="dt">Text.Parsec.Language</span> (emptyDef)

<span class="kw">import qualified</span> <span class="dt">Text.Parsec.Expr</span> <span class="kw">as</span> <span class="dt">Ex</span>
<span class="kw">import qualified</span> <span class="dt">Text.Parsec.Token</span> <span class="kw">as</span> <span class="dt">Tok</span>

<span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="dt">Tr</span>
  <span class="fu">|</span> <span class="dt">Fl</span>
  <span class="fu">|</span> <span class="dt">Zero</span>
  <span class="fu">|</span> <span class="dt">Succ</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Pred</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Antiquote</span> <span class="dt">String</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Data</span>, <span class="dt">Typeable</span>)

<span class="ot">lexer ::</span> <span class="dt">Tok.TokenParser</span> ()
lexer <span class="fu">=</span> Tok.makeTokenParser emptyDef

<span class="ot">parens ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
parens <span class="fu">=</span> Tok.parens lexer

<span class="ot">reserved ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> ()
reserved <span class="fu">=</span> Tok.reserved lexer

<span class="ot">identifier ::</span> <span class="dt">Parser</span> <span class="dt">String</span>
identifier <span class="fu">=</span> Tok.identifier lexer

<span class="ot">semiSep ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> [a]
semiSep <span class="fu">=</span> Tok.semiSep lexer

<span class="ot">reservedOp ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> ()
reservedOp <span class="fu">=</span> Tok.reservedOp lexer

oper s f assoc <span class="fu">=</span> <span class="dt">Ex.Prefix</span> (reservedOp s <span class="fu">&gt;&gt;</span> return f)

table <span class="fu">=</span> [ oper <span class="st">&quot;succ&quot;</span> <span class="dt">Succ</span> <span class="dt">Ex.AssocLeft</span>
        , oper <span class="st">&quot;pred&quot;</span> <span class="dt">Pred</span> <span class="dt">Ex.AssocLeft</span>
        ]

<span class="ot">expr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
expr <span class="fu">=</span> Ex.buildExpressionParser [table] factor

true, false,<span class="ot"> zero ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
true  <span class="fu">=</span> reserved <span class="st">&quot;true&quot;</span> <span class="fu">&gt;&gt;</span> return <span class="dt">Tr</span>
false <span class="fu">=</span> reserved <span class="st">&quot;false&quot;</span> <span class="fu">&gt;&gt;</span> return <span class="dt">Fl</span>
zero  <span class="fu">=</span> reservedOp <span class="st">&quot;0&quot;</span> <span class="fu">&gt;&gt;</span> return <span class="dt">Zero</span>

<span class="ot">antiquote ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
antiquote <span class="fu">=</span> <span class="kw">do</span>
  char <span class="ch">&#39;$&#39;</span>
  var <span class="ot">&lt;-</span> identifier
  return <span class="fu">$</span> <span class="dt">Antiquote</span> var

<span class="ot">factor ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
factor <span class="fu">=</span> true
      <span class="fu">&lt;|&gt;</span> false
      <span class="fu">&lt;|&gt;</span> zero
      <span class="fu">&lt;|&gt;</span> antiquote
      <span class="fu">&lt;|&gt;</span> parens expr

<span class="ot">contents ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
contents p <span class="fu">=</span> <span class="kw">do</span>
  Tok.whiteSpace lexer
  r <span class="ot">&lt;-</span> p
  eof
  return r

<span class="ot">parseExpr ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ParseError</span> <span class="dt">Expr</span>
parseExpr s <span class="fu">=</span> parse (contents expr) <span class="st">&quot;&lt;stdin&gt;&quot;</span> s


<span class="kw">class</span> <span class="dt">Expressible</span> a <span class="kw">where</span>
<span class="ot">  express ::</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span>

<span class="kw">instance</span> <span class="dt">Expressible</span> <span class="dt">Expr</span> <span class="kw">where</span>
  express <span class="fu">=</span> id

<span class="kw">instance</span> <span class="dt">Expressible</span> <span class="dt">Bool</span> <span class="kw">where</span>
  express <span class="dt">True</span> <span class="fu">=</span> <span class="dt">Tr</span>
  express <span class="dt">False</span> <span class="fu">=</span> <span class="dt">Fl</span>

<span class="kw">instance</span> <span class="dt">Expressible</span> <span class="dt">Integer</span> <span class="kw">where</span>
  express <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Zero</span>
  express n <span class="fu">=</span> <span class="dt">Succ</span> (express (n <span class="fu">-</span> <span class="dv">1</span>))


<span class="ot">exprE ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span>
exprE s <span class="fu">=</span> <span class="kw">do</span>
  filename <span class="ot">&lt;-</span> loc_filename <span class="ot">`fmap`</span> location
  <span class="kw">case</span> parse (contents expr) filename s <span class="kw">of</span>
    <span class="dt">Left</span> err <span class="ot">-&gt;</span> error (show err)
    <span class="dt">Right</span> exp <span class="ot">-&gt;</span> dataToExpQ (const <span class="dt">Nothing</span> <span class="ot">`extQ`</span> antiExpr) exp

<span class="ot">exprP ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Pat</span>
exprP s <span class="fu">=</span> <span class="kw">do</span>
  filename <span class="ot">&lt;-</span> loc_filename <span class="ot">`fmap`</span> location
  <span class="kw">case</span> parse (contents expr) filename s <span class="kw">of</span>
    <span class="dt">Left</span> err <span class="ot">-&gt;</span> error (show err)
    <span class="dt">Right</span> exp <span class="ot">-&gt;</span> dataToPatQ (const <span class="dt">Nothing</span> <span class="ot">`extQ`</span> antiExprPat) exp

<span class="co">-- antiquote RHS</span>
<span class="ot">antiExpr ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Q</span> <span class="dt">Exp</span>)
antiExpr (<span class="dt">Antiquote</span> v) <span class="fu">=</span> <span class="dt">Just</span> embed
  <span class="kw">where</span> embed <span class="fu">=</span> [<span class="fu">|</span> express <span class="fu">$</span>(varE (mkName v)) <span class="fu">|</span>]
antiExpr _ <span class="fu">=</span> <span class="dt">Nothing</span>

<span class="co">-- antiquote LHS</span>
<span class="ot">antiExprPat ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Q</span> <span class="dt">Pat</span>)
antiExprPat (<span class="dt">Antiquote</span> v) <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> varP (mkName v)
antiExprPat _ <span class="fu">=</span> <span class="dt">Nothing</span>

<span class="ot">mini ::</span> <span class="dt">QuasiQuoter</span>
mini <span class="fu">=</span> <span class="dt">QuasiQuoter</span> exprE exprP undefined undefined</code></pre></div>
<div class="sourceCode" include="src/31-template-haskell/use_antiquote.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span>

<span class="kw">import </span><span class="dt">Antiquote</span>

<span class="co">-- extract</span>
<span class="ot">a ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span>
a [mini<span class="fu">|</span>succ <span class="fu">$</span>x<span class="fu">|</span>] <span class="fu">=</span> x

<span class="ot">b ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span>
b [mini<span class="fu">|</span>succ <span class="fu">$</span>x<span class="fu">|</span>] <span class="fu">=</span> [mini<span class="fu">|</span>pred <span class="fu">$</span>x<span class="fu">|</span>]

<span class="ot">c ::</span> <span class="dt">Expressible</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span>
c x <span class="fu">=</span> [mini<span class="fu">|</span>succ <span class="fu">$</span>x<span class="fu">|</span>]

<span class="ot">d ::</span> <span class="dt">Expr</span>
d <span class="fu">=</span> c (<span class="dv">8</span><span class="ot"> ::</span> <span class="dt">Integer</span>)
<span class="co">-- Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ Zero)))))))</span>

<span class="ot">e ::</span> <span class="dt">Expr</span>
e <span class="fu">=</span> c <span class="dt">True</span>
<span class="co">-- Succ Tr</span></code></pre></div>
<h2 id="templated-type-families">Templated Type Families</h2>
<div class="alert alert-danger">
<p>This is an advanced section, knowledge of TemplateHaskell is not typically necessary to write Haskell.</p>
</div>
<p>Just like at the value-level we can construct type-level constructions by piecing together their AST.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Type</span>          <span class="dt">AST</span>
<span class="fu">----------</span>    <span class="fu">----------</span>
t1 <span class="ot">-&gt;</span> t2      <span class="dt">ArrowT</span> <span class="ot">`AppT`</span> t2 <span class="ot">`AppT`</span> t2
[t]           <span class="dt">ListT</span> <span class="ot">`AppT`</span> t
(t1,t2)       <span class="dt">TupleT</span> <span class="dv">2</span> <span class="ot">`AppT`</span> t1 <span class="ot">`AppT`</span> t2</code></pre></div>
<p>For example consider that type-level arithmetic is still somewhat incomplete in GHC 7.6, but there often cases where the span of typelevel numbers is not full set of integers but is instead some bounded set of numbers. We can instead define operations with a type-family instead of using an inductive definition ( which often requires manual proofs ) and simply enumerates the entire domain of arguments to the type-family and maps them to some result computed at compile-time.</p>
<p>For example the modulus operator would be non-trivial to implement at type-level but instead we can use the <code>enumFamily</code> function to splice in type-family which simply enumerates all possible pairs of numbers up to a desired depth.</p>
<div class="sourceCode" include="src/31-template-haskell/EnumFamily.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">EnumFamily</span> <span class="kw">where</span>
<span class="kw">import </span><span class="dt">Language.Haskell.TH</span>

<span class="ot">enumFamily ::</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>)
           <span class="ot">-&gt;</span> <span class="dt">Name</span>
           <span class="ot">-&gt;</span> <span class="dt">Integer</span>
           <span class="ot">-&gt;</span> <span class="dt">Q</span> [<span class="dt">Dec</span>]
enumFamily f bop upper <span class="fu">=</span> return decls
  <span class="kw">where</span>
    decls <span class="fu">=</span> <span class="kw">do</span>
      i <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span>upper]
      j <span class="ot">&lt;-</span> [<span class="dv">2</span><span class="fu">..</span>upper]
      return <span class="fu">$</span> <span class="dt">TySynInstD</span> bop (rhs i j)

    rhs i j <span class="fu">=</span> <span class="dt">TySynEqn</span>
      [<span class="dt">LitT</span> (<span class="dt">NumTyLit</span> i), <span class="dt">LitT</span> (<span class="dt">NumTyLit</span> j)]
      (<span class="dt">LitT</span> (<span class="dt">NumTyLit</span> (i <span class="ot">`f`</span> j)))</code></pre></div>
<div class="sourceCode" include="src/31-template-haskell/enum_family_splice.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>

<span class="kw">import </span><span class="dt">EnumFamily</span>

<span class="kw">import </span><span class="dt">Data.Proxy</span>
<span class="kw">import </span><span class="dt">GHC.TypeLits</span>

<span class="kw">type</span> family <span class="dt">Mod</span> (<span class="ot">m ::</span> <span class="dt">Nat</span>) (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span>
<span class="kw">type</span> family <span class="dt">Add</span> (<span class="ot">m ::</span> <span class="dt">Nat</span>) (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span>
<span class="kw">type</span> family <span class="dt">Pow</span> (<span class="ot">m ::</span> <span class="dt">Nat</span>) (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span>

enumFamily mod <span class="ch">&#39;&#39;</span><span class="dt">Mod</span> <span class="dv">10</span>
enumFamily (<span class="fu">+</span>) <span class="ch">&#39;&#39;</span><span class="dt">Add</span> <span class="dv">10</span>
enumFamily (<span class="fu">^</span>) <span class="ch">&#39;&#39;</span><span class="dt">Pow</span> <span class="dv">10</span>

<span class="ot">a ::</span> <span class="dt">Integer</span>
a <span class="fu">=</span> natVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Mod</span> <span class="dv">6</span> <span class="dv">4</span>))
<span class="co">-- 2</span>

<span class="ot">b ::</span> <span class="dt">Integer</span>
b <span class="fu">=</span> natVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Pow</span> <span class="dv">3</span> (<span class="dt">Mod</span> <span class="dv">6</span> <span class="dv">4</span>)))
<span class="co">-- 9</span>

<span class="co">--    enumFamily mod &#39;&#39;Mod 3</span>
<span class="co">--  ======&gt;</span>
<span class="co">--    template_typelevel_splice.hs:7:1-14</span>
<span class="co">--    type instance Mod 2 1 = 0</span>
<span class="co">--    type instance Mod 2 2 = 0</span>
<span class="co">--    type instance Mod 2 3 = 2</span>
<span class="co">--    type instance Mod 3 1 = 0</span>
<span class="co">--    type instance Mod 3 2 = 1</span>
<span class="co">--    type instance Mod 3 3 = 0</span>
<span class="co">--    ...</span></code></pre></div>
<p>In practice GHC seems fine with enormous type-family declarations although compile-time may increase a bit as a result.</p>
<p>The singletons library also provides a way to automate this process by letting us write seemingly value-level declarations inside of a quasiquoter and then promoting the logic to the type-level. For example if we wanted to write a value-level and type-level map function for our HList this would normally involve quite a bit of boilerplate, now it can stated very concisely.</p>
<div class="sourceCode" include="src/31-template-haskell/singleton_promote.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE PolyKinds #-}</span>
<span class="ot">{-# LANGUAGE QuasiQuotes #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>
<span class="ot">{-# LANGUAGE KindSignatures #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE StandaloneDeriving #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE FlexibleContexts #-}</span>
<span class="ot">{-# LANGUAGE TypeSynonymInstances #-}</span>

<span class="kw">import </span><span class="dt">Data.Singletons</span>
<span class="kw">import </span><span class="dt">Data.Singletons.TH</span>

<span class="fu">$</span>(promote [d<span class="fu">|</span>
<span class="ot">  map ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
  map _ [] <span class="fu">=</span> []
  map f (x<span class="fu">:</span>xs) <span class="fu">=</span> f x <span class="fu">:</span> map f xs
  <span class="fu">|</span>])

<span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">::</span><span class="fu">:</span>

<span class="kw">data</span> <span class="dt">HList</span> (<span class="ot">ts ::</span> [ <span class="fu">*</span> ]) <span class="kw">where</span>
  <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">HList</span> <span class="ch">&#39;[]</span>
<span class="ot">  (:::) ::</span> t <span class="ot">-&gt;</span> <span class="dt">HList</span> ts <span class="ot">-&gt;</span> <span class="dt">HList</span> (t <span class="ch">&#39;: ts)</span>

<span class="co">-- TypeLevel</span>
<span class="co">-- MapJust :: [*] -&gt; [Maybe *]</span>
<span class="kw">type</span> <span class="dt">MapJust</span> xs <span class="fu">=</span> <span class="dt">Map</span> <span class="dt">Maybe</span> xs

<span class="co">-- Value Level</span>
<span class="co">-- mapJust :: [a] -&gt; [Maybe a]</span>
<span class="ot">mapJust ::</span> <span class="dt">HList</span> xs <span class="ot">-&gt;</span> <span class="dt">HList</span> (<span class="dt">MapJust</span> xs)
mapJust <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nil</span>
mapJust (x <span class="ot">::</span><span class="fu">:</span> xs) <span class="fu">=</span> (<span class="dt">Just</span> x) <span class="ot">::</span><span class="fu">:</span> mapJust xs

<span class="kw">type</span> <span class="dt">A</span> <span class="fu">=</span> [<span class="dt">Bool</span>, <span class="dt">String</span> , <span class="dt">Double</span> , ()]

<span class="ot">a ::</span> <span class="dt">HList</span> <span class="dt">A</span>
a <span class="fu">=</span> <span class="dt">True</span> <span class="ot">::</span><span class="fu">:</span> <span class="st">&quot;foo&quot;</span> <span class="ot">::</span><span class="fu">:</span> <span class="fl">3.14</span> <span class="ot">::</span><span class="fu">:</span> () <span class="ot">::</span><span class="fu">:</span> <span class="dt">Nil</span>


<span class="ot">example1 ::</span> <span class="dt">HList</span> (<span class="dt">MapJust</span> <span class="dt">A</span>)
example1 <span class="fu">=</span> mapJust a

<span class="co">-- example1 reduces to example2 when expanded</span>
<span class="ot">example2 ::</span> <span class="dt">HList</span> ([<span class="dt">Maybe</span> <span class="dt">Bool</span>, <span class="dt">Maybe</span> <span class="dt">String</span> , <span class="dt">Maybe</span> <span class="dt">Double</span> , <span class="dt">Maybe</span> ()])
example2 <span class="fu">=</span> <span class="dt">Just</span> <span class="dt">True</span> <span class="ot">::</span><span class="fu">:</span> <span class="dt">Just</span> <span class="st">&quot;foo&quot;</span> <span class="ot">::</span><span class="fu">:</span> <span class="dt">Just</span> <span class="fl">3.14</span> <span class="ot">::</span><span class="fu">:</span> <span class="dt">Just</span> () <span class="ot">::</span><span class="fu">:</span> <span class="dt">Nil</span></code></pre></div>
<h2 id="templated-type-classes">Templated Type Classes</h2>
<div class="alert alert-danger">
<p>This is an advanced section, knowledge of TemplateHaskell is not typically necessary to write Haskell.</p>
</div>
<p>Probably the most common use of Template Haskell is the automatic generation of type-class instances. Consider if we wanted to write a simple Pretty printing class for a flat data structure that derived the ppr method in terms of the names of the constructors in the AST we could write a simple instance.</p>
<div class="sourceCode" include="src/31-template-haskell/Class.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span>
<span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE FlexibleContexts #-}</span>

<span class="kw">module</span> <span class="dt">Class</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Language.Haskell.TH</span>

<span class="kw">class</span> <span class="dt">Pretty</span> a <span class="kw">where</span>
<span class="ot">  ppr ::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>

<span class="ot">normalCons ::</span> <span class="dt">Con</span> <span class="ot">-&gt;</span> <span class="dt">Name</span>
normalCons (<span class="dt">NormalC</span> n _) <span class="fu">=</span> n

<span class="ot">getCons ::</span> <span class="dt">Info</span> <span class="ot">-&gt;</span> [<span class="dt">Name</span>]
getCons cons <span class="fu">=</span> <span class="kw">case</span> cons <span class="kw">of</span>
    <span class="dt">TyConI</span> (<span class="dt">DataD</span>    _ _ _ tcons _) <span class="ot">-&gt;</span> map normalCons tcons
    con <span class="ot">-&gt;</span> error <span class="fu">$</span> <span class="st">&quot;Can&#39;t derive for:&quot;</span> <span class="fu">++</span> (show con)

<span class="ot">pretty ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> [<span class="dt">Dec</span>]
pretty dt <span class="fu">=</span> <span class="kw">do</span>
  info <span class="ot">&lt;-</span> reify dt
  <span class="dt">Just</span> cls <span class="ot">&lt;-</span> lookupTypeName <span class="st">&quot;Pretty&quot;</span>
  <span class="kw">let</span> datatypeStr <span class="fu">=</span> nameBase dt
  <span class="kw">let</span> cons <span class="fu">=</span> getCons info
  <span class="kw">let</span> dtype <span class="fu">=</span> mkName (datatypeStr)
  <span class="kw">let</span> mkInstance xs <span class="fu">=</span>
        <span class="dt">InstanceD</span>
        []                              <span class="co">-- Context</span>
        (<span class="dt">AppT</span>
          (<span class="dt">ConT</span> cls)                    <span class="co">-- Instance</span>
          (<span class="dt">ConT</span> dtype))                 <span class="co">-- Head</span>
        [(<span class="dt">FunD</span> (mkName <span class="st">&quot;ppr&quot;</span>) xs)]      <span class="co">-- Methods</span>
  <span class="kw">let</span> methods <span class="fu">=</span> map cases cons
  return <span class="fu">$</span> [mkInstance methods]

<span class="co">-- Pattern matches on the ``ppr`` method</span>
<span class="ot">cases ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Clause</span>
cases a <span class="fu">=</span> <span class="dt">Clause</span> [<span class="dt">ConP</span> a []] (<span class="dt">NormalB</span> (<span class="dt">LitE</span> (<span class="dt">StringL</span> (nameBase a)))) []</code></pre></div>
<p>In a separate file invoke the pretty instance at the toplevel, and with <code>--ddump-splice</code> if we want to view the spliced class instance.</p>
<div class="sourceCode" include="src/31-template-haskell/splice_class.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span>
<span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>

<span class="kw">import </span><span class="dt">Class</span>

<span class="kw">data</span> <span class="dt">PlatonicSolid</span>
  <span class="fu">=</span> <span class="dt">Tetrahedron</span>
  <span class="fu">|</span> <span class="dt">Cube</span>
  <span class="fu">|</span> <span class="dt">Octahedron</span>
  <span class="fu">|</span> <span class="dt">Dodecahedron</span>
  <span class="fu">|</span> <span class="dt">Icosahedron</span>

pretty <span class="ch">&#39;&#39;</span><span class="dt">PlatonicSolid</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  putStrLn (ppr <span class="dt">Octahedron</span>)
  putStrLn (ppr <span class="dt">Dodecahedron</span>)</code></pre></div>
<h2 id="multiline-strings">Multiline Strings</h2>
<p>Haskell no language support for multiline strings literals, although we can emulate this by using a quasiquoter. The resulting String literal is then converted using toString into whatever result type is desired.</p>
<div class="sourceCode" include="src/31-template-haskell/Multiline.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>

<span class="kw">module</span> <span class="dt">Multiline</span> (s) <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.String</span>
<span class="kw">import </span><span class="dt">Language.Haskell.TH.Quote</span>

<span class="ot">s ::</span> <span class="dt">QuasiQuoter</span>
s <span class="fu">=</span> <span class="dt">QuasiQuoter</span>
  { quoteExp  <span class="fu">=</span> (\a <span class="ot">-&gt;</span> [<span class="fu">|</span>fromString a<span class="fu">|</span>]) <span class="fu">.</span> trim
  , quotePat  <span class="fu">=</span> \_ <span class="ot">-&gt;</span> fail <span class="st">&quot;illegal raw string QuasiQuote&quot;</span>
  , quoteType <span class="fu">=</span> \_ <span class="ot">-&gt;</span> fail <span class="st">&quot;illegal raw string QuasiQuote&quot;</span>
  , quoteDec  <span class="fu">=</span> \_ <span class="ot">-&gt;</span> fail <span class="st">&quot;illegal raw string QuasiQuote&quot;</span>
  }

<span class="ot">trim ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
trim (<span class="ch">&#39;\n&#39;</span><span class="fu">:</span>xs) <span class="fu">=</span> xs
trim xs <span class="fu">=</span> xs</code></pre></div>
<p>In a separate module we can then enable Quasiquotes and embed the string.</p>
<div class="sourceCode" include="src/31-template-haskell/multiline_example.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span>

<span class="kw">import </span><span class="dt">Multiline</span> (s)
<span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>

<span class="ot">foo ::</span> <span class="dt">T.Text</span>
foo <span class="fu">=</span> [s<span class="fu">|</span>
<span class="dt">This</span>
is
my
multiline
string
<span class="fu">|</span>]</code></pre></div>
<h2 id="git-embed">git-embed</h2>
<p>Often times it is neccessary to embed the specific Git version hash of a build inside the exectuable. Using git-embed the compiler will effectivelly shell out to the command line to retrieve the version information of the CWD Git repostory and use Template Haskell to define embed this information at compile-time. This is often useful for embedding in <code>--version</code> information in the command line interface to your program or service.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>

<span class="kw">import </span><span class="dt">Git.Embed</span>
<span class="kw">import </span><span class="dt">Data.Version</span>
<span class="kw">import </span><span class="dt">Paths_myprog</span>

<span class="ot">gitRev ::</span> <span class="dt">String</span>
gitRev <span class="fu">=</span> <span class="fu">$</span>(embedGitShortRevision)

<span class="ot">gitBranch ::</span> <span class="dt">String</span>
gitBranch <span class="fu">=</span> <span class="fu">$</span>(embedGitBranch)

<span class="ot">ver ::</span> <span class="dt">String</span>
ver <span class="fu">=</span> showVersion Paths_myprog.version</code></pre></div>
<p>See: <a href="https://hackage.haskell.org/package/git-embed">git-embed</a></p>
<hr/>
<h1 id="categories">Categories</h1>
<div class="alert alert-danger">
<p>This is an advanced section, knowledge of category theory is not typically necessary to write Haskell.</p>
</div>
<p>Alas we come to the topic of category theory. Some might say all discussion of Haskell eventually leads here at one point or another.</p>
<p>Nevertheless the overall importance of category theory in the context of Haskell has been somewhat overstated and unfortunately mystified to some extent. The reality is that amount of category theory which is directly applicable to Haskell roughly amounts to a subset of the first chapter of any undergraduate text. And even then, <em>no actual knowledge of category theory is required to use Haskell at all</em>.</p>
<h2 id="algebraic-relations">Algebraic Relations</h2>
<p>Grossly speaking category theory is not terribly important to Haskell programming, and although some libraries derive some inspiration from the subject; most do not. What is more important is a general understanding of equational reasoning and a familiarity with various algebraic relations.</p>
<p>Certain relations show up so frequently we typically refer to their properties by name ( often drawn from an equivalent abstract algebra concept ). Consider a binary operation <code>a `op` b</code> and a unary operation <code>f</code>.</p>
<p><strong>Associativity</strong></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">a <span class="ot">`op`</span> (b <span class="ot">`op`</span> c) <span class="fu">=</span> (a <span class="ot">`op`</span> b) <span class="ot">`op`</span> c</code></pre></div>
<p><strong>Commutativity</strong></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">a <span class="ot">`op`</span> b <span class="fu">=</span> b <span class="ot">`op`</span> a</code></pre></div>
<p><strong>Units</strong></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">a <span class="ot">`op`</span> e <span class="fu">=</span> a
e <span class="ot">`op`</span> a <span class="fu">=</span> a</code></pre></div>
<p><strong>Inversion</strong></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(inv a) <span class="ot">`op`</span> a <span class="fu">=</span> e
a <span class="ot">`op`</span> (inv a) <span class="fu">=</span> e</code></pre></div>
<p><strong>Zeros</strong></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">a <span class="ot">`op`</span> e <span class="fu">=</span> e
e <span class="ot">`op`</span> a <span class="fu">=</span> e</code></pre></div>
<p><strong>Linearity</strong></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f (x <span class="ot">`op`</span> y) <span class="fu">=</span> f x <span class="ot">`op`</span> f y</code></pre></div>
<p><strong>Idempotency</strong></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f (f x) <span class="fu">=</span> f x</code></pre></div>
<p><strong>Distributivity</strong></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">a <span class="ot">`f`</span> (b <span class="ot">`g`</span> c) <span class="fu">=</span> (a <span class="ot">`f`</span> b) <span class="ot">`g`</span> (a <span class="ot">`f`</span> c)
(b <span class="ot">`g`</span> c) <span class="ot">`f`</span> a <span class="fu">=</span> (b <span class="ot">`f`</span> a) <span class="ot">`g`</span> (c <span class="ot">`f`</span> a)</code></pre></div>
<p><strong>Anticommutativity</strong></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">a <span class="ot">`op`</span> b <span class="fu">=</span> inv (b <span class="ot">`op`</span> a)</code></pre></div>
<p>And of course combinations of these properties over multiple functions gives rise to higher order systems of relations that occur over and over again throughout functional programming, and once we recognize them we can abstract over them. For instance a monoid is a combination of a unit and a single associative operation over a set of values.</p>
<table>
<thead>
<tr class="header">
<th align="left">Structure</th>
<th align="left">Notation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Monoid</td>
<td align="left"><span class="math inline">(<em>M</em>, •)</span></td>
</tr>
<tr class="even">
<td align="left">Monad</td>
<td align="left"><span class="math inline">(<em>T</em>, <em>μ</em>, <em>η</em>)</span></td>
</tr>
</tbody>
</table>
<h2 id="categories-1">Categories</h2>
<p>The most basic structure is a category which is an algebraic structure of objects (<code>Obj</code>) and morphisms (<code>Hom</code>) with the structure that morphisms compose associatively and the existence of an identity morphism for each object.</p>
<p>With kind polymorphism enabled we can write down the general category parameterized by a type variable &quot;c&quot; for category, and the instance <code>Hask</code> the category of Haskell types with functions between types as morphisms.</p>
<div class="sourceCode" include="src/33-categories/categories.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE PolyKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE TypeSynonymInstances #-}</span>

<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> ((.), id)

<span class="co">-- Morphisms</span>
<span class="kw">type</span> (a <span class="fu">~&gt;</span> b) c <span class="fu">=</span> c a b

<span class="kw">class</span> <span class="dt">Category</span> (<span class="ot">c ::</span> k <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="kw">where</span>
<span class="ot">  id ::</span> (a <span class="fu">~&gt;</span> a) c
<span class="ot">  (.) ::</span> (y <span class="fu">~&gt;</span> z) c <span class="ot">-&gt;</span> (x <span class="fu">~&gt;</span> y) c <span class="ot">-&gt;</span> (x <span class="fu">~&gt;</span> z) c

<span class="kw">type</span> <span class="dt">Hask</span> <span class="fu">=</span> (<span class="ot">-&gt;</span>)

<span class="kw">instance</span> <span class="dt">Category</span> <span class="dt">Hask</span> <span class="kw">where</span>
  id x <span class="fu">=</span> x
  (f <span class="fu">.</span> g) x <span class="fu">=</span> f (g x)</code></pre></div>
<p>Categories are interesting since they exhibit various composition properties and ways in which various elements in the category can be composed and rewritten while preserving several invariants about the program.</p>
<h2 id="isomorphisms">Isomorphisms</h2>
<p>Two objects of a category are said to be isomorphic if we can construct a morphism with 2-sided inverse that takes the structure of an object to another form and back to itself when inverted.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f  ::</span> a <span class="ot">-&gt;</span> b
<span class="ot">f&#39; ::</span> b <span class="ot">-&gt;</span> a</code></pre></div>
<p>Such that:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f <span class="fu">.</span> f&#39; <span class="fu">=</span> id
f&#39;<span class="fu">.</span> f  <span class="fu">=</span> id</code></pre></div>
<p>For example the types <code>Either () a</code> and <code>Maybe a</code> are isomorphic.</p>
<div class="sourceCode" include="src/33-categories/iso.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ExplicitForAll #-}</span>

<span class="kw">data</span> <span class="dt">Iso</span> a b <span class="fu">=</span> <span class="dt">Iso</span> {<span class="ot"> to ::</span> a <span class="ot">-&gt;</span> b,<span class="ot"> from ::</span> b <span class="ot">-&gt;</span> a }

<span class="ot">f ::</span> forall a<span class="fu">.</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> () a
f (<span class="dt">Just</span> a) <span class="fu">=</span> <span class="dt">Right</span> a
f <span class="dt">Nothing</span>  <span class="fu">=</span> <span class="dt">Left</span> ()

<span class="ot">f&#39; ::</span> forall a<span class="fu">.</span> <span class="dt">Either</span> () a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
f&#39; (<span class="dt">Left</span> _)  <span class="fu">=</span> <span class="dt">Nothing</span>
f&#39; (<span class="dt">Right</span> a) <span class="fu">=</span> <span class="dt">Just</span> a

<span class="ot">iso ::</span> <span class="dt">Iso</span> (<span class="dt">Maybe</span> a) (<span class="dt">Either</span> () a)
iso <span class="fu">=</span> <span class="dt">Iso</span> f f&#39;

<span class="kw">data</span> <span class="dt">V</span> <span class="fu">=</span> <span class="dt">V</span> <span class="kw">deriving</span> <span class="dt">Eq</span>

ex1 <span class="fu">=</span> f  (f&#39; (<span class="dt">Right</span> <span class="dt">V</span>)) <span class="fu">==</span> <span class="dt">Right</span> <span class="dt">V</span>
ex2 <span class="fu">=</span> f&#39; (f  (<span class="dt">Just</span> <span class="dt">V</span>))  <span class="fu">==</span> <span class="dt">Just</span> <span class="dt">V</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Iso</span> a b <span class="fu">=</span> <span class="dt">Iso</span> {<span class="ot"> to ::</span> a <span class="ot">-&gt;</span> b,<span class="ot"> from ::</span> b <span class="ot">-&gt;</span> a }

<span class="kw">instance</span> <span class="dt">Category</span> <span class="dt">Iso</span> <span class="kw">where</span>
  id <span class="fu">=</span> <span class="dt">Iso</span> id id
  (<span class="dt">Iso</span> f f&#39;) <span class="fu">.</span> (<span class="dt">Iso</span> g g&#39;) <span class="fu">=</span> <span class="dt">Iso</span> (f <span class="fu">.</span> g) (g&#39; <span class="fu">.</span> f&#39;)</code></pre></div>
<h2 id="duality">Duality</h2>
<p>One of the central ideas is the notion of duality, that reversing some internal structure yields a new structure with a &quot;mirror&quot; set of theorems. The dual of a category reverse the direction of the morphisms forming the category C<sup>Op</sup>.</p>
<div class="sourceCode" include="src/33-categories/dual.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Category</span>
<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> ((.), id)

<span class="kw">newtype</span> <span class="dt">Op</span> a b <span class="fu">=</span> <span class="dt">Op</span> (b <span class="ot">-&gt;</span> a)

<span class="kw">instance</span> <span class="dt">Category</span> <span class="dt">Op</span> <span class="kw">where</span>
  id <span class="fu">=</span> <span class="dt">Op</span> id
  (<span class="dt">Op</span> f) <span class="fu">.</span> (<span class="dt">Op</span> g) <span class="fu">=</span> <span class="dt">Op</span> (g <span class="fu">.</span> f)</code></pre></div>
<p>See:</p>
<ul>
<li><a href="http://blog.ezyang.com/2012/10/duality-for-haskellers/">Duality for Haskellers</a></li>
</ul>
<h2 id="functors">Functors</h2>
<p>Functors are mappings between the objects and morphisms of categories that preserve identities and composition.</p>
<div class="sourceCode" include="src/33-categories/functors.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class="ot">{-# LANGUAGE TypeSynonymInstances #-}</span>

<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (<span class="dt">Functor</span>, fmap, id)

<span class="kw">class</span> (<span class="dt">Category</span> c, <span class="dt">Category</span> d) <span class="ot">=&gt;</span> <span class="dt">Functor</span> c d t <span class="kw">where</span>
<span class="ot">  fmap ::</span> c a b <span class="ot">-&gt;</span> d (t a) (t b)

<span class="kw">type</span> <span class="dt">Hask</span> <span class="fu">=</span> (<span class="ot">-&gt;</span>)

<span class="kw">instance</span> <span class="dt">Category</span> <span class="dt">Hask</span> <span class="kw">where</span>
  id x <span class="fu">=</span> x
  (f <span class="fu">.</span> g) x <span class="fu">=</span> f (g x)

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Hask</span> <span class="dt">Hask</span> [] <span class="kw">where</span>
  fmap f [] <span class="fu">=</span> []
  fmap f (x<span class="fu">:</span>xs) <span class="fu">=</span> f x <span class="fu">:</span> (fmap f xs)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap id ≡ id
fmap (a <span class="fu">.</span> b) ≡ (fmap a) <span class="fu">.</span> (fmap b)</code></pre></div>
<h2 id="natural-transformations">Natural Transformations</h2>
<p>Natural transformations are mappings between functors that are invariant under interchange of morphism composition order.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Nat</span> f g <span class="fu">=</span> forall a<span class="fu">.</span> f a <span class="ot">-&gt;</span> g a</code></pre></div>
<p>Such that for a natural transformation <code>h</code> we have:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap f <span class="fu">.</span> h ≡ h <span class="fu">.</span> fmap f</code></pre></div>
<p>The simplest example is between (f = List) and (g = Maybe) types.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">headMay ::</span> forall a<span class="fu">.</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
headMay []     <span class="fu">=</span> <span class="dt">Nothing</span>
headMay (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Just</span> x</code></pre></div>
<p>Regardless of how we chase <code>safeHead</code>, we end up with the same result.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap f (headMay xs) ≡ headMay (fmap f xs)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap f (headMay [])
<span class="fu">=</span> fmap f <span class="dt">Nothing</span>
<span class="fu">=</span> <span class="dt">Nothing</span>

headMay (fmap f [])
<span class="fu">=</span> headMay []
<span class="fu">=</span> <span class="dt">Nothing</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap f (headMay (x<span class="fu">:</span>xs))
<span class="fu">=</span> fmap f (<span class="dt">Just</span> x)
<span class="fu">=</span> <span class="dt">Just</span> (f x)

headMay (fmap f (x<span class="fu">:</span>xs))
<span class="fu">=</span> headMay [f x]
<span class="fu">=</span> <span class="dt">Just</span> (f x)</code></pre></div>
<p>Or consider the Functor <code>(-&gt;)</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> (<span class="dt">Functor</span> t)
  <span class="ot">=&gt;</span> (<span class="ot">-&gt;</span>) a b
  <span class="ot">-&gt;</span> (<span class="ot">-&gt;</span>) (t a) (t b)
f <span class="fu">=</span> fmap

<span class="ot">g ::</span> (b <span class="ot">-&gt;</span> c)
  <span class="ot">-&gt;</span> (<span class="ot">-&gt;</span>) a b
  <span class="ot">-&gt;</span> (<span class="ot">-&gt;</span>) a c
g <span class="fu">=</span> (<span class="fu">.</span>)

<span class="ot">c ::</span> (<span class="dt">Functor</span> t)
  <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> c)
  <span class="ot">-&gt;</span> (<span class="ot">-&gt;</span>) (t a) (t b)
  <span class="ot">-&gt;</span> (<span class="ot">-&gt;</span>) (t a) (t c)
c <span class="fu">=</span> f <span class="fu">.</span> g</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f <span class="fu">.</span> g x <span class="fu">=</span> c x <span class="fu">.</span> g</code></pre></div>
<p>A lot of the expressive power of Haskell types comes from the interesting fact that, with a few caveats, polymorphic Haskell functions are natural transformations.</p>
<p>See: <a href="http://blog.sigfpe.com/2008/05/you-could-have-defined-natural.html">You Could Have Defined Natural Transformations</a></p>
<h2 id="adjunctions">Adjunctions</h2>
<p>TODO</p>
<h2 id="yoneda-lemma">Yoneda Lemma</h2>
<p>The Yoneda lemma is an elementary, but deep result in Category theory. The Yoneda lemma states that for any functor <code>F</code>, the types <code>F a</code> and <code>∀ b. (a -&gt; b) -&gt; F b</code> are isomorphic.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RankNTypes #-}</span>

<span class="ot">embed ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> (forall b <span class="fu">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f b)
embed x f <span class="fu">=</span> fmap f x

<span class="ot">unembed ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (forall b <span class="fu">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> f a
unembed f <span class="fu">=</span> f id</code></pre></div>
<p>So that we have:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">embed <span class="fu">.</span> unembed ≡ id
unembed <span class="fu">.</span> embed ≡ id</code></pre></div>
<p>The most broad hand-wavy statement of the theorem is that an object in a category can be represented by the set of morphisms into it, and that the information about these morphisms alone sufficiently determines all properties of the object itself.</p>
<p>In terms of Haskell types, given a fixed type <code>a</code> and a functor <code>f</code>, if we have some a higher order polymorphic function <code>g</code> that when given a function of type <code>a -&gt; b</code> yields <code>f b</code> then the behavior <code>g</code> is entirely determined by <code>a -&gt; b</code> and the behavior of <code>g</code> can written purely in terms of <code>f a</code>.</p>
<p><strong>DeMorgan's Law</strong></p>
<p>See:</p>
<ul>
<li><a href="http://blog.sigfpe.com/2006/11/yoneda-lemma.html">Reverse Engineering Machines with the Yoneda Lemma</a></li>
</ul>
<h2 id="kleisli-category">Kleisli Category</h2>
<p>Kleisli composition (i.e. Kleisli Fish) is defined to be:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&gt;=&gt;) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> m c) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m c
f <span class="fu">&gt;=&gt;</span> g ≡ \x <span class="ot">-&gt;</span> f x <span class="fu">&gt;&gt;=</span> g

<span class="ot">(&lt;=&lt;) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> m c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m c
(<span class="fu">&lt;=&lt;</span>) <span class="fu">=</span> flip (<span class="fu">&gt;=&gt;</span>)</code></pre></div>
<p>The monad laws stated in terms of the Kleisli category of a monad <code>m</code> are stated much more symmetrically as one associativity law and two identity laws.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(f <span class="fu">&gt;=&gt;</span> g) <span class="fu">&gt;=&gt;</span> h ≡ f <span class="fu">&gt;=&gt;</span> (g <span class="fu">&gt;=&gt;</span> h)
return <span class="fu">&gt;=&gt;</span> f ≡ f
f <span class="fu">&gt;=&gt;</span> return ≡  f</code></pre></div>
<p>Stated simply that the monad laws above are just the category laws in the Kleisli category.</p>
<div class="sourceCode" include="src/33-categories/kleisli.hs"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE ExplicitForAll #-}</span>

<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Control.Category</span>
<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> ((.))

<span class="co">-- Kleisli category</span>
<span class="kw">newtype</span> <span class="dt">Kleisli</span> m a b <span class="fu">=</span> <span class="dt">K</span> (a <span class="ot">-&gt;</span> m b)

<span class="co">-- Kleisli morphisms ( a -&gt; m b )</span>
<span class="kw">type</span> (a <span class="fu">:~&gt;</span> b) m <span class="fu">=</span> <span class="dt">Kleisli</span> m a b

<span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Category</span> (<span class="dt">Kleisli</span> m) <span class="kw">where</span>
  id            <span class="fu">=</span> <span class="dt">K</span> return
  (<span class="dt">K</span> f) <span class="fu">.</span> (<span class="dt">K</span> g) <span class="fu">=</span> <span class="dt">K</span> (f <span class="fu">&lt;=&lt;</span> g)


<span class="ot">just ::</span> (a <span class="fu">:~&gt;</span> a) <span class="dt">Maybe</span>
just <span class="fu">=</span> <span class="dt">K</span> <span class="dt">Just</span>

<span class="ot">left ::</span> forall a b<span class="fu">.</span> (a <span class="fu">:~&gt;</span> b) <span class="dt">Maybe</span> <span class="ot">-&gt;</span> (a <span class="fu">:~&gt;</span> b) <span class="dt">Maybe</span>
left f <span class="fu">=</span> just <span class="fu">.</span> f

<span class="ot">right ::</span> forall a b<span class="fu">.</span> (a <span class="fu">:~&gt;</span> b) <span class="dt">Maybe</span> <span class="ot">-&gt;</span> (a <span class="fu">:~&gt;</span> b) <span class="dt">Maybe</span>
right f <span class="fu">=</span> f <span class="fu">.</span> just</code></pre></div>
<p>For example, <code>Just</code> is just an identity morphism in the Kleisli category of the <code>Maybe</code> monad.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Just</span> <span class="fu">&gt;=&gt;</span> f ≡ f
f <span class="fu">&gt;=&gt;</span> <span class="dt">Just</span> ≡ f</code></pre></div>
<h2 id="resources">Resources</h2>
<ul>
<li><a href="http://www.amazon.com/Category-Theory-Oxford-Logic-Guides/dp/0199237182">Category Theory, Awodey</a></li>
<li><a href="https://www.youtube.com/watch?v=ZKmodCApZwk">Category Theory Foundations</a></li>
<li><a href="https://www.youtube.com/watch?v=I8LbkfSSR58&amp;list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_">Category Theory for Programmers</a></li>
<li><a href="http://www.youtube.com/user/TheCatsters">The Catsters</a></li>
</ul>
<hr/>
<h1 id="other-languages">Other Languages</h1>
<p>Let us attempt to objectively compare Haskell to other programming languages with regards to which language principles they share and in what respects they differ. These comparisons are not advisements to use or avoid any of these languages, but rather statements of the similarities and differences between them at the language level.</p>
<p>No notion of &quot;weak&quot; or &quot;strong&quot; typing will be discussed because the terms have no universal meaning.</p>
<p>No notion of &quot;object-oriented&quot; or &quot;functional&quot; paradigms will be discussed because the terms have no universal meaning.</p>
<h2 id="haskell">Haskell</h2>
<p>Haskell's genesis happened in 1987 at the <a href="https://www.haskell.org/onlinereport/preface-jfp.html">Functional Programming Languages and Computer Architecture</a> conference in Portland, OR. Participants had achieved a consensus that there was a profusion of non-strict, pure languages and concluded that this excess was hampering the development and wider use of such languages. Subsequently, a committee was formed to design a new pure, lazy, general purpose programming language. Out of this collaboration emerged Haskell, named for logician <a href="../../en.wikipedia.org/wiki/Haskell_Curry.html">Haskell B. Curry</a>, upon whose research the logical underpinnings of the Haskell language rest.</p>
<p>Since 1987, the Haskell language standard has continued to evolve. Haskell 1.0 was released in April of 1990, with particularly significant updates to the standard released in <a href="https://www.haskell.org/onlinereport/">1998</a> and <a href="https://www.haskell.org/onlinereport/haskell2010/">2010</a>.</p>
<p>Haskell's main implementation is <a href="https://www.haskell.org/ghc/"><em>ghc</em></a>. GHC is licenced under a permissive, non-copyleft, 3-clause BSD-style licence.</p>
<p>Haskell is a <em>general purpose language</em>.</p>
<p>Haskell is <em>garbage collected</em>.</p>
<p>Haskell is <em>compiled</em> through a custom native code generator.</p>
<p>Haskell is <em>statically</em> typed.</p>
<p>Haskell allows polymorphism by means of <em>parametric polymorphism</em> and <em>ad-hoc polymorphism</em> through typeclasses.</p>
<p>Haskell is <em>pure</em> and statically tracks effects.</p>
<p>Haskell employs <em>lazy evaluation</em> by default using <em>call-by-need</em>.</p>
<p>Haskell's package manager is cabal-install or stack.</p>
<h2 id="ocaml">OCaml</h2>
<p>OCaml, originally known as Objective Caml, is the main implementation of the Caml programming language. The type system of OCaml is significantly less advanced than modern GHC Haskell and does not supported higher-kinded types or type-level programming to the extent that has become prevalent in portions of recent Haskell. The OCaml compiler is also significantly less advanced than modern GHC runtime and largely does not perform any compiler optimizations or program transformations. The language itself does have several advantages over Haskell in that is has a module system. Although it is possible to write pure OCaml, there is no language-integrated support, and the current engineering practice around the language encourages ubiquitous impurity in third-party libraries.</p>
<p><strong>Main difference</strong>: Both have fairly modern type systems, but OCaml does not enforce purity and uses call-by-value.</p>
<p>OCaml's main implementation is <a href="http://ocaml.org/"><em>ocamlc</em></a>. The OCaml compiler is distributed under <a href="http://www.gnu.org/licenses/license-list.html#QPL">the Q Public licence</a>, a permissive, non-copyleft FLOSS licence. Some portions of the OCaml libaries are licensed under the <a href="http://www.gnu.org/licenses/gpl.html">GPLv2</a>. See the <a href="https://github.com/ocaml/ocaml/blob/trunk/LICENSE">OCaml GitHub page</a> for more information about licensing specifics.</p>
<p>OCaml is a <em>general purpose language</em>.</p>
<p>OCaml is a <em>statically typed</em> language.</p>
<p>OCaml is <em>garbage collected</em>.</p>
<p>OCaml allows polymorphism by means of <em>parametric polymorphism</em> and <em>ad-hoc polymorphism</em> through modular implicits.</p>
<p>OCaml has a module system and functors.</p>
<p>OCaml is not an optimizing compiler.</p>
<p>OCaml is <em>impure</em> by default and does not statically track effects.</p>
<p>OCaml's evaluation is <em>call-by-value</em>.</p>
<p>OCaml has a package manager called <a href="https://opam.ocaml.org/">OPAM</a>.</p>
<h2 id="standard-ml">Standard ML</h2>
<p>Standard ML was a general-purpose, modular, functional programming language with compile-time type checking and type inference.</p>
<p><a href="../../en.wikipedia.org/wiki/Standard_ML.html">Standard ML</a> was traditionally a general purpose language, although it's lack of a modern compiler largely only makes it useful for work on pure type theory and proof assistants and not in industrial settings. Standard ML has been largely abandoned in recent years and is a good example of a promising language that withered on the vine from a lack of engineering effort devoted toward the backend compiler.</p>
<p><strong>Main difference</strong>: Standard ML is no longer actively developed, Haskell is.</p>
<p>Standard ML's main implementation is <a href="http://smlnj.org/"><em>smlnj</em></a>. Other implementations existed in <a href="http://mlton.org/"><em>mlton</em></a> and <a href="http://www.polyml.org/"><em>polyml</em></a>.</p>
<p>Standard ML has no package manager.</p>
<p>Standard ML allows polymorphism by means of <em>parametric polymorphism</em>.</p>
<p>Standard ML has a module system and functors.</p>
<p>Standard ML is a <em>statically typed</em> language.</p>
<p>Standard ML is <em>impure</em> by default and does not statically track effects.</p>
<p>Standard ML implementations are typically <em>garbage collected</em>.</p>
<p>Standard ML's evaluation is <em>call-by-value</em>.</p>
<p>Standard ML employs strict evaluation.</p>
<h2 id="agda">Agda</h2>
<p>Agda is a dependently typed functional programming language used in type theory research. Unlike Coq, has no support for tactics, and proofs are written in a functional programming style.</p>
<p><strong>Main difference</strong>: Agda is not a general purpose language, Haskell is. Agda is not used to write executable programs for practical uses outside of research.</p>
<p>Agda's main implementation is <em>agda</em>.</p>
<p>Agda is not a general purpose language, it is largely used as a proof environment and tool for constructive mathematics.</p>
<p>Agda has no package manager.</p>
<p>Agda is a <em>statically typed</em> language.</p>
<h2 id="coq">Coq</h2>
<p>Coq is an interactive theorem prover based on the calculus of inductive constructions. It compiles into a Core language called Gallina whose defining feature is that it is weakly normalizing (i.e. all programs terminate ). Although Coq allows limited extraction of some programs to other languages, it is not by itself a programming language in the traditional sense, most Coq programs are not run or compiled.</p>
<p><strong>Main difference</strong>: Coq is not a general purpose language, Haskell is.</p>
<p>Coq's main implementation is <em>coq</em>.</p>
<p>Coq is <em>not a general purpose language</em>, it is largely used as a proof environment.</p>
<p>Coq is a <em>statically typed</em> language.</p>
<h2 id="idris">Idris</h2>
<p>Idris is a general-purpose purely functional programming language with dependent types.</p>
<p><strong>Main difference</strong>: Idris has dependent types and call-by-value semantics, Haskell does not have dependent types and uses call-by-need.</p>
<p>Idris's main implementation is <em>idris</em>.</p>
<p>Idris is a <em>general purpose language</em>.</p>
<p>Idris allows polymorphism by means of <em>parametric polymorphism</em> and <em>ad-hoc polymorphism</em>.</p>
<p>Idris's evaluation is <em>call-by-value</em>.</p>
<p>Idris is a <em>statically typed</em> language.</p>
<p>Idris is <em>garbage collected</em> by default, although there is some novel work on <a href="http://docs.idris-lang.org/en/latest/reference/uniqueness-types.html">uniqueness types</a> which can statically guarantee aliasing properties of references.</p>
<p>Idris is <em>pure</em> and statically tracks effects.</p>
<h2 id="rust">Rust</h2>
<p>Rust is a general-purpose, multi-paradigm, compiled programming language developed by Mozilla Research. It incorporates many of the foundational ideas of Haskell's type system but uses a more traditional imperative evaluation model. Rust includes type inference, ad-hoc polymorphism, sum types, and option chaining as safe exception handling. Notably Rust lacks higher-kinded types which does not allow many modern functional abstractions to be encoded in the language. Rust does not enforce purity or track effects, but has a system for statically analyzing lifetimes of references informing the efficient compilation of many language constructs to occur without heap allocation.</p>
<p><strong>Main difference</strong>: Rust is a modern imperative typed language, Haskell is a modern functional typed language with recent type system. Rust does not have the capacity to distinguish between pure and impure functions at the language level.</p>
<p>Rust's main implementation is <em>rustc</em>.</p>
<p>Rust is a <em>statically typed</em> language.</p>
<p>Rust is a <em>general purpose language</em>.</p>
<p>Rust's package manager is Cargo.</p>
<p>Rust allows polymorphism by means of <em>parametric polymorphism</em> and <em>ad-hoc polymorphism</em>.</p>
<p>Rust is <em>not garbage collected</em> by default, instead uses static semantics to analyze lifetimes. Optionally supports garbage collection.</p>
<p>Rust is <em>impure</em> by default and does not statically track effects. It does however have static tracking of memory allocations and lifetimes.</p>
<h2 id="purescript">Purescript</h2>
<p>Purescript is a Haskell-like language that compiles into Javascript for evaluation within a web browser. Semantically it is very close to Haskell except that is uses a call-by-value model instead of Haksell's call-by-need. The type system is a superset of Haskell 2010 and includes ad-hoc polymorphism, parametric polymorphism, rank-n polymorphism, row-polymorphism, higher-kinded types and full algebraic data types.</p>
<p><strong>Main difference</strong>: Purescript targets Javascript in the browser, while GHC Haskell is designed to work on top of the GHC managed runtime.</p>
<p>Purescript's main implementation is <em>purescript</em>.</p>
<p>Purescript is a <em>statically typed</em> language.</p>
<p>Purescript's evaluation is <em>call-by-value</em>.</p>
<p>Purescript is <em>pure</em> and statically tracks effects using an extensible record system embedded in the Eff monad.</p>
<h2 id="elm">Elm</h2>
<p>Elm is a ML-like language that compiles into Javascript for evaluation within a web browser.</p>
<p><strong>Main difference</strong>: Elm targets Javascript in the browser, while GHC Haskell is designed to work on top of the GHC managed runtime. Elm lacks any semblance of a modern ML type system features, and has no coherent story for overloading, modules or higher polymorphism.</p>
<p>Elm's main implementation is <em>elm</em>.</p>
<p>Elm is a <em>statically typed</em> language.</p>
<p>Elm targets Javascript and is &quot;transpiled&quot; to Javascript source code to be run exclusively in a browser or Javascript interpreter.</p>
<p>Elm allows polymorphism by means of <em>parametric polymorphism</em>.</p>
<p>Elm is <em>pure</em> and statically tracks effects.</p>
<h2 id="python">Python</h2>
<p>Python is a widely used general-purpose, high-level programming language. It is based on object-style of programming constructions and allows first class functions and higher order functions. Python is unityped and is notable for it's simplistic runtime and global mutex preventing concurrency.</p>
<p><strong>Main difference</strong>: Python is unityped and imperative, Haskell is statically typed.</p>
<p>Python's main implementation is <em>cpython</em>.</p>
<p>Python is a <em>unityped</em> language.</p>
<p>Python is <em>impure</em> by default and does not statically track effects.</p>
<p>Python internally refers to runtime value tags as <em>types</em>, which differs from the Haskell notion of types.</p>
<p>Python allows polymorphism by means of unityping, all functions can take any type.</p>
<h2 id="r">R</h2>
<p>R is a programming language and software environment for statistical computing and graphics. The R language is widely used among statisticians and data miners for developing statistical software and data analysis</p>
<p><strong>Main difference</strong>: R is unityped and domain specific language, Haskell is statically typed and general purpose.</p>
<p>R's main implementation is <em>r</em>.</p>
<p>R is a <em>unityped</em> language.</p>
<p>R allows polymorphism by means of <em>unityping</em>.</p>
<p>R internally refers to runtime value tags as <em>types</em>, which differs from the Haskell notion of types.</p>
<p>R is <em>interpreted</em>.</p>
<h2 id="julia">Julia</h2>
<p>Julia is a high-level dynamic programming language designed to address the requirements of high-performance numerical and scientific computing.</p>
<p><strong>Main difference</strong>: Julia is unityped and imperative, Haskell is statically typed.</p>
<p>Julia's main implementation is <em>juliia</em>.</p>
<p>Julia is a <em>unityped</em> language.</p>
<p>Julia allows polymorphism by means of <em>unityping</em>.</p>
<p>Julia internally refers to runtime value tags as <em>types</em>, which differs from the Haskell notion of types.</p>
<p>Julia is <em>compiled</em> through the LLVM framework.</p>
<h2 id="erlang">Erlang</h2>
<p>Erlang is a general-purpose programming language and runtime environment. Erlang has built-in support for concurrency, distribution and fault tolerance.</p>
<p><strong>Main difference</strong>: Erlang is unityped and imperative, Haskell is statically typed and functional.</p>
<p>Erlang's main implementation is <em>erl</em>.</p>
<p>Erlang is a <em>unityped</em> language.</p>
<p>Erlang is interpreted.</p>
<p>Erlang allows polymorphism by means of <em>unityping</em>.</p>
<p>Erlang's evaluation is <em>call-by-value</em>.</p>
<p>Erlang internally refers to runtime value tags as <em>types</em>, which differs from the Haskell notion of types.</p>
<p>Erlang is <em>impure</em> by default and does not statically track effects.</p>
<h2 id="elixer">Elixer</h2>
<h2 id="java">Java</h2>
<p>Java is a general purpose programming language. It is an object-oriented, concurrent language which is statically typed. It is one of the most frequently used languages in the industry, as well as a common language used in academia to teach the fundamentals of object oriented programming.</p>
<p><strong>Main difference</strong>: Java is an object-oriented language, compared to Haskell which is functional.</p>
<p>Java is <em>statically compiled</em> to Java Bytecode which can be ran on a Java Virtual Machine.</p>
<p>Java's most recent version is Java8</p>
<p>Java is cross-platform. It can be ran on Linux, Windows and Mac.</p>
<h2 id="clojure">Clojure</h2>
<p>Clojure is a modern LISP dialect that emphasizes immutability. It does not enforce safety and idiomatic clojure often includes mutable references and destructive updates. There are some efforts toward an optional typing system provided by the <a href="https://github.com/clojure/core.typed">core.typed</a>.</p>
<p><strong>Main difference</strong>: Clojure is a unityped typed Lisp dialect, while Haskell is in the ML family.</p>
<p>Clojure's main implementation is <em>clojure</em>.</p>
<p>Clojure is a <em>unityped</em> language.</p>
<p>Clojure allows polymorphism by means of <em>unityping</em>.</p>
<p>Clojure is <em>garbage collected</em>.</p>
<p>Clojure internally refers to runtime value tags as <em>types</em>, which differs from the Haskell notion of types.</p>
<p>Clojure is <em>compiled</em> to Java Virtual Machine bytecode.</p>
<h2 id="swift">Swift</h2>
<p>Swift is a multi-paradigm language created for iOS and OS X development by Apple. Swift incorporates recent developments in language design and uncommonly includes return type polymorphism, type inference, ad-hoc polymorphism, sum types, and option chaining as safe exception handling. Swift does not enforce purity or track effects, and allows mutable and destructive updates.</p>
<p><strong>Main difference</strong>: Swift is reasonably modern imperative typed language, Haskell is a modern functional typed language.</p>
<p>Swift's main implementation is <em>swiftc</em>.</p>
<p>Swift allows polymorphism by means of <em>parametric polymorphism</em> and <em>ad-hoc polymorphism</em> through through inheritance, interfaces, and reflection.</p>
<p>Swift is <em>garbage collected</em>.</p>
<p>Swift is a <em>statically typed</em> language.</p>
<p>Swift is <em>compiled</em> through the LLVM framework.</p>
<p>Swift <em>does not</em> have an effect system.</p>
<h2 id="scheme">Scheme</h2>
<h2 id="racket">Racket</h2>
<h2 id="c">C#</h2>
<p>C# is a typed, class-based, single-inheritance object-oriented programming language originally developed at Microsoft as the flagship language for the .NET framework. Early versions closely resemble <em>Java</em>, but the language has since picked up a few influences from declarative and functional programming paradigms. .NET is Windows-only, but a cross-platform replacement, <em>Mono</em>, exists, that makes it possible to run .NET code on OS X and Linux.</p>
<p><strong>Main difference</strong>: C# is an impure object-oriented language, Haskell is a pure functional language.</p>
<p>C#'s main implementation is <em>C#.NET</em>.</p>
<p>C# is a <em>general purpose</em> programming language.</p>
<p>C# is <em>garbage collected</em> (but allows opting out of GC through the use of <code>unsafe</code> blocks)</p>
<p>C# is a <em>statically typed</em> language with limited <em>type inference</em> and some support for <em>dynamic typing</em>.</p>
<p>C# allows polymorphism by means of <em>parametric polymorphism</em> through generics, <em>ad-hoc polymorphism</em> through inheritance, interfaces, and reflection.</p>
<p>C# is impure and <em>does not</em> track effects.</p>
<p>C# is typically <em>compiled</em> to .NET IL, which is then interpreted by the .NET runtime.</p>
<h2 id="f">F#</h2>
<h2 id="c-1">C++</h2>
<p>C++ is a typed multi-paradigm (imperative, structured/procedural, class-based multiple-inheritance object-oriented, template metaprogramming) programming language developed by Bjarne Stroustrup in the early 1980s. The philosophy strongly favors zero-cost abstractions, and values performance higher than convenience. This has made the language extremely large and complex, and the culture and ecosystem diverse and fractured. Today, C++ is mainly found in legacy projects, but remains popular in areas where realtime performance and deterministic memory allocation are critical, such as embedded, audio/video, games, HFT, etc.</p>
<p><strong>Main difference</strong>: C++ is impure and uses RAII, Haskell is pure and garbage-collected.</p>
<p>C++ has no canonical implementation; notable compilers include <em>gcc</em>, <em>clang</em>, and <em>MSVC++</em>.</p>
<p>C++ is a <em>general purpose</em> programming language, with a bias towards <em>systems programming</em>.</p>
<p>C++ is <em>not garbage collected</em>. Manual memory management (as in C) is supported, but the recommended paradigm is <em>RAII</em>.</p>
<p>C++ is a <em>statically typed</em> language with limited <em>type inference</em> and many backdoors to bypass the type checker.</p>
<p>C++ allows polymorphism by means of <em>parametric polymorphism</em> through template metaprogramming, and <em>ad-hoc polymorphism</em> through inheritance.</p>
<p>C++ is <em>compiled</em>, the typical compilation target is native machine code.</p>
<p>C++ <em>does not</em> track effects. It has limited support for tracking mutability at the type level.</p>
<h2 id="go">Go</h2>
<p><a href="https://golang.org/">Go</a> is a programming language developed at Google. Although Go is statically typed, it has failed to integrate most modern advances in programming language design done after the 1970s and instead chooses a seemingly regressive design. Most notably, it lacks any notion of generics, while polymorphism is achieved either by manual code duplication or unsafe coercions.</p>
<p><strong>Main difference</strong>: Go is a language designed around the idea that language design has not advanced since 1970, while Haskell incorporates many ideas from modern research.</p>
<p>Go's main implementation is <a href="https://go.googlesource.com/go"><em>go</em></a>.</p>
<p>Go is a <em>statically typed</em> language.</p>
<p>Go has <em>no safe polymorphism</em>.</p>
<p>Go is statically <em>compiled</em> with a custom toolchain.</p>
<p>Go is <em>garbage collected</em>.</p>
<p>Go <em>does not</em> have an effect system.</p>
<h2 id="scala">Scala</h2>
<p>Scala is a general purpose multi-paradigm language. Like Java, Scala is object-oriented, and uses a curly-brace syntax reminiscent of the C programming language. Unlike Java, Scala has many features of functional programming languages like Scheme, Standard ML and Haskell, including currying, type inference, immutability, lazy evaluation, and pattern matching.</p>
<p><strong>Main difference</strong>: Scala mixes functional programming with imperative programming and does not take a language-integrated stance on purity or effect tracking which breaks equational reasoning. External libraries and frameworks exist that embrace functional programming more effectively, but it is not enforced and imperative code and thin wrappers around Java libs quite often leaks industrial codebases.</p>
<p>Scala's main implementation is <a href="http://www.scala-lang.org/"><em>scala</em></a>.</p>
<p>Scala is a <em>statically typed</em> language.</p>
<p>Scala allows polymorphism by means of <em>parametric polymorphism</em> and <em>ad-hoc polymorphism</em> through implicits.</p>
<p>Scala is <em>garbage collected</em>.</p>
<p>Scala language <em>does not</em> have an effect system.</p>
<p>Scala is statically <em>compiled</em> to Java Virtual Machien bytecode.</p>
<h2 id="javascript">Javascript</h2>
<p>JavaScript is a high-level, dynamic, untyped, and interpreted programming language that was ubiquitous in web development during the 90s and 00s. Javascript is most kindly described as a language that &quot;just happened&quot; and an enduring testament to human capacity to route around problems.</p>
<p><strong>Main difference</strong>: Like many web technologies Javascript &quot;just happened&quot; and it's design was dominated by economic factors. Haskell was designed with some insight into the end result.</p>
<p>Javascripts implementations include <em>NodeJS</em>, <em>V8</em> and <em>spidermoneky</em>.</p>
<p>Javascript is a <em>unityped</em> language.</p>
<p>Javascript is <em>interpreted</em>, tracing JIT specialization is common.</p>
<p>Javascript allows polymorphism by means of <em>unityping</em>.</p>
<p>Javascript internally refers to runtime value tags as <em>types</em>, which differs from the Haskell notion of types.</p>
<p>The majority of Javascript implementations are garbage collected.</p>
<h2 id="kotlin">Kotlin</h2>
<h2 id="php">PHP</h2>
<h2 id="perl">Perl</h2>
<h2 id="lua">Lua</h2>
<hr/>
<h1 id="code">Code</h1>
<ul>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/01-basics/">01-basics/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/02-monads/">02-monads/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/03-monad-transformers/">03-monad-transformers/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/04-extensions/">04-extensions/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/05-laziness/">05-laziness/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/06-prelude/">06-prelude/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/07-text-bytestring/">07-text-bytestring/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/08-applicatives/">08-applicatives/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/09-errors/">09-errors/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/10-advanced-monads/">10-advanced-monads/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/11-quantification/">11-quantification/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/12-gadts/">12-gadts/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/13-lambda-calculus/">13-lambda-calculus/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/14-interpreters/">14-interpreters/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/15-testing/">15-testing/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/16-type-families/">16-type-families/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/17-promotion/">17-promotion/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/18-generics/">18-generics/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/19-numbers/">19-numbers/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/20-data-structures/">20-data-structures/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/21-ffi/">21-ffi/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/22-concurrency/">22-concurrency/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/23-graphics/">23-graphics/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/24-parsing/">24-parsing/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/25-streaming/">25-streaming/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/26-data-formats/">26-data-formats/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/27-web/">27-web/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/28-databases/">28-databases/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/29-ghc/">29-ghc/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/30-languages/">30-languages/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/31-template-haskell/">31-template-haskell/</a></li>
<li><a href="https://github.com/sdiehl/wiwinwlh/tree/master/src/33-categories/">33-categories/</a></li>
</ul>
      </div>
    </div>

    <script src="https://code.jquery.com/jquery.js"></script>
    <script src="js/nav.js"></script>
  </body>

<!-- Mirrored from dev.stephendiehl.com/hask/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 23 Dec 2016 06:18:12 GMT -->
</html>
