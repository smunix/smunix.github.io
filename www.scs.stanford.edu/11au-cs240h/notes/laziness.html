<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<!-- Mirrored from www.scs.stanford.edu/11au-cs240h/notes/laziness.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 25 Dec 2016 16:59:09 GMT -->
<head>
  <title>Phantoms and mutants</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre 
   { margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none; }
td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; }
td.sourceCode { padding-left: 5px; }
pre.sourceCode span.kw { color: #007020; font-weight: bold; } 
pre.sourceCode span.dt { color: #902000; }
pre.sourceCode span.dv { color: #40a070; }
pre.sourceCode span.bn { color: #40a070; }
pre.sourceCode span.fl { color: #40a070; }
pre.sourceCode span.ch { color: #4070a0; }
pre.sourceCode span.st { color: #4070a0; }
pre.sourceCode span.co { color: #60a0b0; font-style: italic; }
pre.sourceCode span.ot { color: #007020; }
pre.sourceCode span.al { color: red; font-weight: bold; }
pre.sourceCode span.fu { color: #06287e; }
pre.sourceCode span.re { }
pre.sourceCode span.er { color: red; font-weight: bold; }
  </style>
</head>
<body>
<h1 class="title">Phantoms and mutants</h1>
<h1 id="language-hacking"
>Language hacking</h1
><p
>Let's create a very small fragment of a programming language:</p
><pre class="sourceCode haskell"
><code
  ><span class="kw"
    >data</span
    > <span class="dt"
    >Expr</span
    > <span class="fu"
    >=</span
    > <span class="kw"
    >Num</span
    > <span class="dt"
    >Int</span
    >             <span class="co"
    >-- atom</span
    ><br
     />          <span class="fu"
    >|</span
    > <span class="dt"
    >Str</span
    > <span class="dt"
    >String</span
    >          <span class="co"
    >-- atom</span
    ><br
     />          <span class="fu"
    >|</span
    > <span class="dt"
    >Op</span
    > <span class="dt"
    >BinOp</span
    > <span class="dt"
    >Expr</span
    > <span class="dt"
    >Expr</span
    >  <span class="co"
    >-- compound</span
    ><br
     />            <span class="kw"
    >deriving</span
    > (<span class="kw"
    >Show</span
    >)<br
     /><br
     /><span class="kw"
    >data</span
    > <span class="dt"
    >BinOp</span
    > <span class="fu"
    >=</span
    > <span class="dt"
    >Add</span
    > <span class="fu"
    >|</span
    > <span class="dt"
    >Concat</span
    ><br
     />             <span class="kw"
    >deriving</span
    > (<span class="kw"
    >Show</span
    >)<br
     /></code
  ></pre
><p
>And an interpreter for it:</p
><pre class="sourceCode haskell"
><code
  >interp x<span class="fu"
    >@</span
    >(<span class="kw"
    >Num</span
    > _)                     <span class="fu"
    >=</span
    > x<br
     />interp x<span class="fu"
    >@</span
    >(<span class="dt"
    >Str</span
    > _)                     <span class="fu"
    >=</span
    > x<br
     />interp (<span class="dt"
    >Op</span
    > <span class="dt"
    >Add</span
    > a b)                  <span class="fu"
    >=</span
    > <span class="kw"
    >Num</span
    > (i a <span class="fu"
    >+</span
    > i b)<br
     />  <span class="kw"
    >where</span
    > i x <span class="fu"
    >=</span
    > <span class="kw"
    >case</span
    > interp x <span class="kw"
    >of</span
    > <span class="kw"
    >Num</span
    > a -&gt; a<br
     />interp (<span class="dt"
    >Op</span
    > <span class="dt"
    >Concat</span
    > (<span class="dt"
    >Str</span
    > a) (<span class="dt"
    >Str</span
    > b))   <span class="fu"
    >=</span
    > <span class="dt"
    >Str</span
    > (a <span class="fu"
    >++</span
    > b)<br
     /></code
  ></pre
><h1 id="does-it-work"
>Does it work?</h1
><p
>Our very quick round of prototyping gave us a tiny interpreter that actually seems to work:</p
><pre class="sourceCode haskell"
><code
  ><span class="fu"
    >&gt;&gt;</span
    > interp (<span class="dt"
    >Op</span
    > <span class="dt"
    >Add</span
    > (<span class="kw"
    >Num</span
    > <span class="dv"
    >2</span
    >) (<span class="kw"
    >Num</span
    > <span class="dv"
    >3</span
    >))<br
     /><span class="kw"
    >Num</span
    > <span class="dv"
    >5</span
    ><br
     /></code
  ></pre
><p
>Please help me to spot some problems with my interpreter!</p
><h1 id="two-sides-of-the-same-problem"
>Two sides of the same problem</h1
><ol style="list-style-type: decimal;"
><li
  ><p
    >We can construct ill-formed expressions (&quot;add a <code
      >Num</code
      > to a <code
      >Str</code
      >&quot;).</p
    ></li
  ><li
  ><p
    >Our interpreter crashes on these expressions, because we (quite reasonably) didn't take their possible existence into account.</p
    ></li
  ></ol
><h1 id="watch-your-language"
>Watch your language!</h1
><p
>Here's a slightly modified version of our language:</p
><pre class="sourceCode haskell"
><code
  ><span class="kw"
    >data</span
    > <span class="dt"
    >Expr</span
    > a <span class="fu"
    >=</span
    > <span class="kw"
    >Num</span
    > <span class="dt"
    >Int</span
    ><br
     />            <span class="fu"
    >|</span
    > <span class="dt"
    >Str</span
    > <span class="dt"
    >String</span
    ><br
     />            <span class="fu"
    >|</span
    > <span class="dt"
    >Op</span
    > <span class="dt"
    >BinOp</span
    > (<span class="dt"
    >Expr</span
    > a) (<span class="dt"
    >Expr</span
    > a)<br
     />              <span class="kw"
    >deriving</span
    > (<span class="kw"
    >Show</span
    >)<br
     /><br
     /><span class="co"
    >-- This is unchanged.</span
    ><br
     /><span class="kw"
    >data</span
    > <span class="dt"
    >BinOp</span
    > <span class="fu"
    >=</span
    > <span class="dt"
    >Add</span
    > <span class="fu"
    >|</span
    > <span class="dt"
    >Concat</span
    ><br
     />             <span class="kw"
    >deriving</span
    > (<span class="kw"
    >Show</span
    >)<br
     /></code
  ></pre
><p
>We've introduced a type parameter here...</p
><p
>...But we never actually use it to represent a <em
  >value</em
  > of whatever type <code
  >a</code
  > is.</p
><p
>Let's see where that takes us.</p
><h1 id="some-modifications-to-our-interpreter"
>Some modifications to our interpreter</h1
><p
>Here is our modified interpreter.</p
><pre class="sourceCode haskell"
><code
  >interp x<span class="fu"
    >@</span
    >(<span class="kw"
    >Num</span
    > _)       <span class="fu"
    >=</span
    > x<br
     />interp x<span class="fu"
    >@</span
    >(<span class="dt"
    >Str</span
    > _)       <span class="fu"
    >=</span
    > x<br
     />interp (<span class="dt"
    >Op</span
    > <span class="dt"
    >Add</span
    > a b)    <span class="fu"
    >=</span
    > <span class="kw"
    >Num</span
    > (i a <span class="fu"
    >+</span
    > i b)<br
     />  <span class="kw"
    >where</span
    > i x <span class="fu"
    >=</span
    > <span class="kw"
    >case</span
    > interp x <span class="kw"
    >of</span
    > <span class="kw"
    >Num</span
    > a -&gt; a<br
     />interp (<span class="dt"
    >Op</span
    > <span class="dt"
    >Concat</span
    > a b) <span class="fu"
    >=</span
    > <span class="dt"
    >Str</span
    > (i a <span class="fu"
    >++</span
    > i b)<br
     />  <span class="kw"
    >where</span
    > i x <span class="fu"
    >=</span
    > <span class="kw"
    >case</span
    > interp x <span class="kw"
    >of</span
    > <span class="dt"
    >Str</span
    > y -&gt; y<br
     /></code
  ></pre
><p
>Our only change is to apply <code
  >interp</code
  > recursively if we're asked to perform a <code
  >Concat</code
  >.</p
><p
>We could have done this in our original interpreter, so that can't be the real fix. But what <em
  >is</em
  >?</p
><p
>What's the type of the rewritten <code
  >interp</code
  >?</p
><h1 id="our-new-type"
>Our new type</h1
><p
>The interpreter function now has this type:</p
><pre class="sourceCode haskell"
><code
  >interp :: <span class="dt"
    >Expr</span
    > a -&gt; <span class="dt"
    >Expr</span
    > a<br
     /></code
  ></pre
><p
>But we know from the definitions of <code
  >Expr</code
  > and <code
  >BinOp</code
  > that we never use a value of type <code
  >a</code
  >. Then what purpose does this type parameter serve?</p
><p
>Recall the type of <code
  >Expr</code
  >:</p
><pre class="sourceCode haskell"
><code
  ><span class="kw"
    >data</span
    > <span class="dt"
    >Expr</span
    > a <span class="fu"
    >=</span
    > <span class="fu"
    >...</span
    ><br
     />            <span class="fu"
    >|</span
    > <span class="dt"
    >Op</span
    > <span class="dt"
    >BinOp</span
    > (<span class="dt"
    >Expr</span
    > a) (<span class="dt"
    >Expr</span
    > a)<br
     /></code
  ></pre
><h1 id="some-context"
>Some context</h1
><p
>Let's think of that <code
  >a</code
  > parameter as expressing our <em
  >intent</em
  > that:</p
><ul
><li
  ><p
    >The operands of an <code
      >Op</code
      > expression should have the same types.</p
    ></li
  ><li
  ><p
    >The resulting <code
      >Expr</code
      > value should <em
      >also</em
      > have this type.</p
    ></li
  ></ul
><pre class="sourceCode haskell"
><code
  ><span class="kw"
    >data</span
    > <span class="dt"
    >Expr</span
    > a <span class="fu"
    >=</span
    > <span class="fu"
    >...</span
    ><br
     />            <span class="fu"
    >|</span
    > <span class="dt"
    >Op</span
    > <span class="dt"
    >BinOp</span
    > (<span class="dt"
    >Expr</span
    > a) (<span class="dt"
    >Expr</span
    > a)<br
     /></code
  ></pre
><p
>In fact, the type system will enforce these constraints for us.</p
><h1 id="building-blocks"
>Building blocks</h1
><p
>The first step in making all of this machinery work is to define some functions with the right types.</p
><p
>These two functions will construct atoms (values that can't be reduced any further) in our language:</p
><pre class="sourceCode haskell"
><code
  >num :: <span class="dt"
    >Int</span
    > -&gt; <span class="dt"
    >Expr</span
    > <span class="dt"
    >Int</span
    ><br
     />num <span class="fu"
    >=</span
    > <span class="kw"
    >Num</span
    ><br
     /><br
     />str :: <span class="dt"
    >String</span
    > -&gt; <span class="dt"
    >Expr</span
    > <span class="dt"
    >String</span
    ><br
     />str <span class="fu"
    >=</span
    > <span class="dt"
    >Str</span
    ><br
     /></code
  ></pre
><h1 id="applying-operators-safely"
>Applying operators safely</h1
><p
>These two functions construct compound expressions:</p
><pre class="sourceCode haskell"
><code
  >add :: <span class="dt"
    >Expr</span
    > <span class="dt"
    >Int</span
    > -&gt; <span class="dt"
    >Expr</span
    > <span class="dt"
    >Int</span
    > -&gt; <span class="dt"
    >Expr</span
    > <span class="dt"
    >Int</span
    ><br
     />add <span class="fu"
    >=</span
    > <span class="dt"
    >Op</span
    > <span class="dt"
    >Add</span
    ><br
     /><br
     />cat :: <span class="dt"
    >Expr</span
    > <span class="dt"
    >String</span
    > -&gt; <span class="dt"
    >Expr</span
    > <span class="dt"
    >String</span
    > -&gt; <span class="dt"
    >Expr</span
    > <span class="dt"
    >String</span
    ><br
     />cat <span class="fu"
    >=</span
    > <span class="dt"
    >Op</span
    > <span class="dt"
    >Concat</span
    ><br
     /></code
  ></pre
><p
>Notice that each one enforces the restriction that its parameters must be compatible.</p
><h1 id="a-trusted-computing-base"
>A trusted computing base</h1
><p
>One we have our functions defined, the last step is to lock our world down.</p
><p
>Here's what the beginning of my module looks like:</p
><pre class="sourceCode haskell"
><code
  ><span class="kw"
    >module</span
    > <span class="dt"
    >Interp</span
    ><br
     />    (<br
     />      <span class="dt"
    >Expr</span
    >,       <span class="co"
    >-- type constructor</span
    ><br
     />      interp,     <span class="co"
    >-- interpreter</span
    ><br
     />      num, str,   <span class="co"
    >-- atom constructors</span
    ><br
     />      add, cat,   <span class="co"
    >-- expression constructors</span
    ><br
     />    ) <span class="kw"
    >where</span
    ><br
     /></code
  ></pre
><p
>Notice that we've exercised <em
  >careful control</em
  > over what we're exporting.</p
><ul
><li
  ><p
    >We export the <code
      >Expr</code
      > type constructor, but <em
      >none</em
      > of its value constructors.</p
    ></li
  ><li
  ><p
    >Users of our module don't need <code
      >BinOp</code
      >, so we don't export that at all.</p
    ></li
  ></ul
><h1 id="more-about-our-type-and-export-choices"
>More about our type and export choices</h1
><p
>Consequences of exporting only the type constructor for <code
  >Expr</code
  >:</p
><ul
><li
  ><p
    >Clients cannot use the value constructors to create new values.</p
    ></li
  ><li
  ><p
    >The <em
      >only</em
      > way for a client to construct expressions is using our handwritten &quot;smart constructor&quot; functions with their carefully chosen types.</p
    ></li
  ><li
  ><p
    >Clients cannot pattern-match on an <code
      >Expr</code
      > value. Our internals are opaque; we could change our implementation without clients being able to tell.</p
    ></li
  ></ul
><p
>These are in fact the completely standard techniques for creating abstract data types in Haskell. So where does the type parameter come in?</p
><h1 id="consequences-of-that-type-parameter"
>Consequences of that type parameter</h1
><p
>Due to our judicious use of both abstraction and that type parameter:</p
><ul
><li
  >Clients cannot construct ill-formed expressions. Any attempts will be rejected by the type checker.</li
  ></ul
><p
>This additional safety comes &quot;for free&quot;:</p
><ul
><li
  ><p
    >We don't need runtime checks for ill-formed expressions, because they cannot occur.</p
    ></li
  ><li
  ><p
    >Our added type parameter never represents data at runtime, so it has zero cost when the program runs.</p
    ></li
  ></ul
><h1 id="phantom-types"
>Phantom types</h1
><p
>When we refer to a type parameter on the left of a type definition, without ever using <em
  >values</em
  > of that type on the right, we call it a <em
  >phantom type</em
  >.</p
><p
>We're essentially encoding <em
  >compile-time data</em
  > using types, and the compiler computes with this data before our program is ever run.</p
><h1 id="mutable-variables"
>Mutable variables</h1
><p
>We've already seen the very handy <code
  >MVar</code
  > type, which represents a &quot;blocking mutable box&quot;: we can put a value in or take one out, but we'll block if we put when full or take when empty.</p
><p
>Even though <code
  >MVar</code
  >s are the fastest blocking concurrent structure in the industry (they made the the Kessel Run in less than twelve parsecs!), we don't always want blocking semantics.</p
><p
>For cases where we want <em
  >non-</em
  >blocking updates, there's the <code
  >IORef</code
  > type, which gives us mutable references.</p
><pre class="sourceCode haskell"
><code
  ><span class="kw"
    >import</span
    > <span class="dt"
    >Data.IORef</span
    ><br
     /><br
     />newIORef    :: a -&gt; <span class="dt"
    >IO</span
    > (<span class="dt"
    >IORef</span
    > a)<br
     /><br
     />readIORef   :: <span class="dt"
    >IORef</span
    > a -&gt; <span class="dt"
    >IO</span
    > a<br
     />writeIORef  :: <span class="dt"
    >IORef</span
    > a -&gt; a -&gt; <span class="dt"
    >IO</span
    > ()<br
     /><br
     />modifyIORef :: <span class="dt"
    >IORef</span
    > a -&gt; (a -&gt; a) -&gt; <span class="dt"
    >IO</span
    > ()<br
     /></code
  ></pre
><h1 id="managing-mutation"
>Managing mutation</h1
><p
>Application writers are often faced with a question like this:</p
><ul
><li
  >I have a big app, and parts of it need their behaviour tweaked by an administrator at runtime.</li
  ></ul
><p
>There are of course many ways to address this sort of problem.</p
><p
>Let's consider one where we use a reference to a piece of config data.</p
><p
>Any code that's executing in the <code
  >IO</code
  > monad can, if it knows the name of the config reference, retrieve the current config:</p
><pre class="sourceCode haskell"
><code
  >curCfg &lt;- readIORef cfgRef<br
     /></code
  ></pre
><p
>The trouble is, ill-behaved code could clearly also <em
  >modify</em
  > the current configuration, and leave us with a debugging nightmare.</p
><h1 id="phantom-types-to-the-rescue"
>Phantom types to the rescue!</h1
><p
>Let's create a new type of mutable reference.</p
><p
>We use a phantom type <code
  >t</code
  > to statically track whether a piece of code is allowed to modify the reference or not.</p
><pre class="sourceCode haskell"
><code
  ><span class="kw"
    >import</span
    > <span class="dt"
    >Data.IORef</span
    ><br
     /><br
     /><span class="kw"
    >newtype</span
    > <span class="dt"
    >Ref</span
    > t a <span class="fu"
    >=</span
    > <span class="dt"
    >Ref</span
    > (<span class="dt"
    >IORef</span
    > a)<br
     /></code
  ></pre
><p
>Remember, our use of <code
  >newtype</code
  > here means that the <code
  >Ref</code
  > type only exists at compile time: it imposes <em
  >no</em
  > runtime cost.</p
><p
>Since we are using a phantom type, we don't even need values of our access control types:</p
><pre class="sourceCode haskell"
><code
  ><span class="kw"
    >data</span
    > <span class="dt"
    >ReadOnly</span
    ><br
     /><span class="kw"
    >data</span
    > <span class="dt"
    >ReadWrite</span
    ><br
     /></code
  ></pre
><p
>We're already in a good spot! Not only are we creating compiler-enforced access control, but it will have <em
  >zero</em
  > runtime cost.</p
><h1 id="creating-a-mutable-reference"
>Creating a mutable reference</h1
><p
>To create a new reference, we just have to ensure that it has the right type.</p
><pre class="sourceCode haskell"
><code
  >newRef :: a -&gt; <span class="dt"
    >IO</span
    > (<span class="dt"
    >Ref</span
    > <span class="dt"
    >ReadWrite</span
    > a)<br
     />newRef a <span class="fu"
    >=</span
    > <span class="dt"
    >Ref</span
    > <span class="ot"
    >`fmap`</span
    > newIORef a<br
     /></code
  ></pre
><h1 id="reading-and-writing-a-mutable-reference"
>Reading and writing a mutable reference</h1
><p
>Since we want to be able to read both read-only and read-write references, we don't need to mention the access mode when writing a type signature for <code
  >readRef</code
  >.</p
><pre class="sourceCode haskell"
><code
  >readRef :: <span class="dt"
    >Ref</span
    > t a -&gt; <span class="dt"
    >IO</span
    > a<br
     />readRef (<span class="dt"
    >Ref</span
    > ref) <span class="fu"
    >=</span
    > readIORef ref<br
     /></code
  ></pre
><p
>Of course, code can only write to a reference if the compiler can statically prove (via the type system) that it has write access.</p
><pre class="sourceCode haskell"
><code
  >writeRef :: <span class="dt"
    >Ref</span
    > <span class="dt"
    >ReadWrite</span
    > a -&gt; a -&gt; <span class="dt"
    >IO</span
    > ()<br
     />writeRef (<span class="dt"
    >Ref</span
    > ref) v <span class="fu"
    >=</span
    > writeIORef ref v<br
     /></code
  ></pre
><h1 id="converting-a-reference-to-read-only"
>Converting a reference to read-only</h1
><p
>This function allows us to convert any kind of reference into a read-only reference:</p
><pre class="sourceCode haskell"
><code
  >readOnly :: <span class="dt"
    >Ref</span
    > t a -&gt; <span class="dt"
    >Ref</span
    > <span class="dt"
    >ReadOnly</span
    > a<br
     />readOnly (<span class="dt"
    >Ref</span
    > ref) <span class="fu"
    >=</span
    > <span class="dt"
    >Ref</span
    > ref<br
     /></code
  ></pre
><p
>In order to prevent clients from promoting a reference from read-only to read-write, we do <em
  >not</em
  > provide a function that goes in the opposite direction.</p
><p
>We also use the familiar technique of constructor hiding at the top of our source file:</p
><pre class="sourceCode haskell"
><code
  ><span class="kw"
    >module</span
    > <span class="dt"
    >Ref</span
    ><br
     />    (<br
     />      <span class="dt"
    >Ref</span
    >, <span class="co"
    >-- export type ctor, but not value ctor</span
    ><br
     />      newRef, readOnly,<br
     />      readRef, writeRef<br
     />    ) <span class="kw"
    >where</span
    ><br
     /></code
  ></pre
><h1 id="meaning-that-slippery-thing"
>Meaning: that slippery thing</h1
><p
>What does this type signature mean?</p
><pre class="sourceCode haskell"
><code
  >something :: a -&gt; a<br
     /></code
  ></pre
><p
>What are all of the possible behaviours of a code with this type?</p
><p
>What about this signature?</p
><pre class="sourceCode haskell"
><code
  >another :: [a]<br
     /></code
  ></pre
><h1 id="being-more-explicit"
>Being more explicit</h1
><p
>What does this type signature mean?</p
><pre class="sourceCode haskell"
><code
  >something :: a -&gt; a<br
     /></code
  ></pre
><p
>We know that for <em
  >all possible types</em
  > <code
  >a</code
  >, this function accepts a value of that type, and returns a value of that type.</p
><p
>We <em
  >clearly</em
  > cannot enumerate all possible types, so we equally clearly cannot create all (or indeed <em
  >any</em
  >) values of these types.</p
><p
>Therefore, if we exclude crashes and infinite loops, the only possible behaviour for this function is to return its input.</p
><h1 id="being-even-more-explicit-quantifiers"
>Being even more explicit: quantifiers</h1
><p
>In fact, Haskell provides a keyword, <code
  >forall</code
  >, to make this quantification over type parameters more explicit:</p
><pre class="sourceCode haskell"
><code
  >something :: forall a<span class="fu"
    >.</span
    > a -&gt; a<br
     /></code
  ></pre
><p
>The same &quot;universal quantification&quot; syntax works with typeclass constraints:</p
><pre class="sourceCode haskell"
><code
  >something :: forall a<span class="fu"
    >.</span
    > (<span class="kw"
    >Show</span
    > a) -&gt; <span class="dt"
    >String</span
    ><br
     /></code
  ></pre
><p
>Here, our quantifier is &quot;for all types <code
  >a</code
  >, where the <em
  >only thing we know about</em
  > <code
  >a</code
  > is what the <code
  >Show</code
  > typeclass tells us we can do&quot;.</p
><p
>These <code
  >forall</code
  > keywords are implied if they're not explicitly written.</p
><h1 id="building-blocks-1"
>Building blocks</h1
><p
>Love 'em or hate 'em, everybody has to deal with databases.</p
><p
>Here are some typical functions that a low-level database library will provide, for clients that have to modify data concurrently:</p
><pre class="sourceCode haskell"
><code
  >begin    :: <span class="dt"
    >Connection</span
    > -&gt; <span class="dt"
    >IO</span
    > <span class="dt"
    >Transaction</span
    ><br
     />commit   :: <span class="dt"
    >Transaction</span
    > -&gt; <span class="dt"
    >IO</span
    > ()<br
     />rollback :: <span class="dt"
    >Transaction</span
    > -&gt; <span class="dt"
    >IO</span
    > ()<br
     /></code
  ></pre
><p
>We can create a new transaction with <code
  >begin</code
  >, finish an existing one with <code
  >commit</code
  >, or cancel one with <code
  >rollback</code
  >.</p
><p
>Typically, once a transaction has been committed or rolled back, accessing it afterwards will result in an exception.</p
><h1 id="shaky-foundations-build-a-shaky-house"
>Shaky foundations build a shaky house</h1
><p
>Clearly, these constructs make it easy to inadvertantly write bad code.</p
><pre class="sourceCode haskell"
><code
  >oops conn <span class="fu"
    >=</span
    > <span class="kw"
    >do</span
    ><br
     />  txn &lt;- begin conn<br
     />  throwIO (<span class="dt"
    >AssertionFailed</span
    > <span class="st"
    >&quot;forgot to roll back!&quot;</span
    >)<br
     />  <span class="co"
    >-- also forgot to commit!</span
    ><br
     /></code
  ></pre
><p
>We can avoid <code
  >rollback</code
  > and <code
  >commit</code
  > forgetfulness with a suitable combinator:</p
><pre class="sourceCode haskell"
><code
  >withTxn :: <span class="dt"
    >Connection</span
    > -&gt; <span class="dt"
    >IO</span
    > a -&gt; <span class="dt"
    >IO</span
    > a<br
     />withTxn conn act <span class="fu"
    >=</span
    > <span class="kw"
    >do</span
    ><br
     />  txn &lt;- begin conn<br
     />  r &lt;- act <span class="ot"
    >`onException`</span
    > rollback txn<br
     />  commit txn<br
     />  <span class="fu"
    >return</span
    > r<br
     /></code
  ></pre
><p
>All right! The code running in <code
  >act</code
  > never sees a <code
  >Transaction</code
  > value, so it can't leak a committed or rolled back transaction.</p
><h1 id="but-still..."
>But still...</h1
><p
>We're not out of the woods yet!</p
><p
>High-performance web apps typically use a dynamically managed pool of database connections.</p
><pre class="sourceCode haskell"
><code
  >getConn :: <span class="dt"
    >Pool</span
    > -&gt; <span class="dt"
    >IO</span
    > <span class="dt"
    >Connection</span
    ><br
     />returnConn :: <span class="dt"
    >Pool</span
    > -&gt; <span class="dt"
    >Connection</span
    > -&gt; <span class="dt"
    >IO</span
    > ()<br
     /></code
  ></pre
><p
>It's a major bug if a database connection is not returned to the pool at the end of a handler.</p
><p
>So we write a combinator to handle this for us:</p
><pre class="sourceCode haskell"
><code
  >withConn :: <span class="dt"
    >Pool</span
    > -&gt; (<span class="dt"
    >Connection</span
    > -&gt; <span class="dt"
    >IO</span
    > a) -&gt; <span class="dt"
    >IO</span
    > a<br
     />withConn pool act <span class="fu"
    >=</span
    ><br
     />  bracket (getConn pool) (returnConn pool) act<br
     /></code
  ></pre
><p
>Nice and elegant. But correct? Read on!</p
><h1 id="connections-vs-transactions"
>Connections vs transactions</h1
><p
>In a typical database API, once we enter a transaction, we don't need to refer to the handle we got until we either commit or roll back the transaction.</p
><p
>So it was fine for us to write a transaction wrapper like this:</p
><pre class="sourceCode haskell"
><code
  >withTxn :: <span class="dt"
    >Connection</span
    > -&gt; <span class="dt"
    >IO</span
    > a -&gt; <span class="dt"
    >IO</span
    > a<br
     /></code
  ></pre
><p
>On other other hand, if we're talking to a database, we definitely need a connection handle.</p
><pre class="sourceCode haskell"
><code
  >query :: <span class="dt"
    >Connection</span
    > -&gt; <span class="dt"
    >String</span
    > -&gt; <span class="dt"
    >IO</span
    > [<span class="dt"
    >String</span
    >]<br
     /></code
  ></pre
><p
>So we have to pass that handle into our combinator:</p
><pre class="sourceCode haskell"
><code
  >withConn :: <span class="dt"
    >Pool</span
    > -&gt; (<span class="dt"
    >Connection</span
    > -&gt; <span class="dt"
    >IO</span
    > a) -&gt; <span class="dt"
    >IO</span
    > a<br
     /></code
  ></pre
><h1 id="ouch-sorry-about-that"
>&quot;Ouch, sorry about that!&quot;</h1
><p
>Unfortunately, since <code
  >withConn</code
  > gives us a connection handle, we can defeat the intention of the combinator (sometimes accidentally).</p
><p
>What is the type of this function?</p
><pre class="sourceCode haskell"
><code
  >evil pool <span class="fu"
    >=</span
    > withConn pool <span class="fu"
    >return</span
    ><br
     /></code
  ></pre
><h1 id="phantom-types-theyll-save-us-again"
>Phantom types! They'll save us again!</h1
><p
>Here, we are using the <code
  >newtype</code
  > keyword to associate a phantom type with the <code
  >IO</code
  > monad.</p
><pre class="sourceCode haskell"
><code
  ><span class="kw"
    >newtype</span
    > <span class="dt"
    >DB</span
    > c a <span class="fu"
    >=</span
    > <span class="dt"
    >DB</span
    > {<br
     />      fromDB :: <span class="dt"
    >IO</span
    > a<br
     />    }<br
     /></code
  ></pre
><p
>We're going to run some code in the <code
  >IO</code
  > monad, and pass around a little extra bit of type information at compile time.</p
><p
>Let's create a phantom-typed wrapper for our earlier <code
  >Connection</code
  > type:</p
><pre class="sourceCode haskell"
><code
  ><span class="kw"
    >newtype</span
    > <span class="dt"
    >SafeConn</span
    > c <span class="fu"
    >=</span
    > <span class="dt"
    >Safe</span
    > <span class="dt"
    >Connection</span
    ><br
     /></code
  ></pre
><p
>Where are these phantom types taking us?</p
><h1 id="safe-querying"
>Safe querying</h1
><p
>The easiest place to start to understand with a little use of our new code, in the form of a function we'll export to clients.</p
><p
>This is just a wrapper around the <code
  >query</code
  > function we saw earlier, making sure that our <code
  >newtype</code
  > machinery is in the right places to keep the type checker happy.</p
><pre class="sourceCode haskell"
><code
  >safeQuery :: <span class="dt"
    >SafeConn</span
    > c -&gt; <span class="dt"
    >String</span
    > -&gt; <span class="dt"
    >DB</span
    > c [<span class="dt"
    >String</span
    >]<br
     />safeQuery (<span class="dt"
    >Safe</span
    > conn) str <span class="fu"
    >=</span
    > <span class="dt"
    >DB</span
    > (query conn str)<br
     /></code
  ></pre
><p
>Notice that our phantom type <code
  >c</code
  > is mentioned in both our uses of <code
  >SafeConn c</code
  > and <code
  >DB c</code
  >: we're treating it as a token that we have to pass around.</p
><p
>Our library will <em
  >not</em
  > be exporting the value constructors for <code
  >SafeConn</code
  > or <code
  >DB</code
  > to clients. Once again, this <code
  >newtype</code
  > machinery is internal to us!</p
><h1 id="giving-a-client-a-connection-from-a-pool"
>Giving a client a connection from a pool</h1
><p
>Here, we'll use our earlier exception-safe <code
  >withConn</code
  > combinator. Recall its type:</p
><pre class="sourceCode haskell"
><code
  >withConn :: <span class="dt"
    >Pool</span
    > -&gt; (<span class="dt"
    >Connection</span
    > -&gt; <span class="dt"
    >IO</span
    > a) -&gt; <span class="dt"
    >IO</span
    > a<br
     /></code
  ></pre
><p
>To make it useful in our new setting, we have to wrap the <code
  >Connection</code
  >, and unwrap the <code
  >DB c</code
  > that is our <code
  >act</code
  > to get an action in the <code
  >IO</code
  > monad.</p
><pre class="sourceCode haskell"
><code
  >withSafeConn pool act <span class="fu"
    >=</span
    ><br
     />  withConn pool <span class="fu"
    >$</span
    > \conn -&gt;<br
     />    fromDB (act (<span class="dt"
    >Safe</span
    > conn))<br
     /></code
  ></pre
><p
>It's not at all obvious what this is doing for us until we see the type of <code
  >withSafeConn</code
  >.</p
><h1 id="scariness"
>Scariness</h1
><p
>Here's a burly type for you:</p
><pre class="sourceCode haskell"
><code
  ><span class="ot"
    >{-# LANGUAGE Rank2Types #-}</span
    ><br
     /><br
     />withConnection :: <span class="dt"
    >Pool</span
    ><br
     />               -&gt; (forall c<span class="fu"
    >.</span
    > <span class="dt"
    >SafeConn</span
    > c -&gt; <span class="dt"
    >DB</span
    > c a) <br
     />               -&gt; <span class="dt"
    >IO</span
    > a<br
     /></code
  ></pre
><p
>We've introduced a universal quantifier (that <code
  >forall</code
  >) into our type signature. And we've added a <code
  >LANGUAGE</code
  > pragma! Whoa. Duuude.</p
><p
>Relax! Let's not worry about those details just yet. What does our signature seem to want to tell us?</p
><ul
><li
  ><p
    >We accept a <code
      >Pool</code
      >.</p
    ></li
  ><li
  ><p
    >And an &quot;I have a connection, so I can talk to the database now&quot; action that accepts a <code
      >SafeConn c</code
      >, returning a value <code
      >a</code
      > embedded in the type <code
      >DB c</code
      >.</p
    ></li
  ></ul
><p
>Not so scary after all. Well, except for the details we're ignoring.</p
><h1 id="universal-quantification-to-the-rescue"
>Universal quantification to the rescue!</h1
><p
>Let's start with the obviously bothersome part of the type signature.</p
><pre class="sourceCode haskell"
><code
  >(forall c<span class="fu"
    >.</span
    > <span class="dt"
    >SafeConn</span
    > c -&gt; <span class="dt"
    >DB</span
    > c a)<br
     /></code
  ></pre
><p
>This is the same universal quantification we've seen before, meaning:</p
><ul
><li
  ><p
    >Our &quot;I can haz connection&quot; action must work <em
      >over all types</em
      > <code
      >c</code
      >.</p
    ></li
  ><li
  ><p
    >The <em
      >scope</em
      > of <code
      >c</code
      > extends only to the rightmost parenthesis here.</p
    ></li
  ></ul
><p
>Putting it back into context:</p
><pre class="sourceCode haskell"
><code
  >withConnection :: <span class="dt"
    >Pool</span
    ><br
     />               -&gt; (forall c<span class="fu"
    >.</span
    > <span class="dt"
    >SafeConn</span
    > c -&gt; <span class="dt"
    >DB</span
    > c a) <br
     />               -&gt; <span class="dt"
    >IO</span
    > a<br
     /></code
  ></pre
><p
>The type variable <code
  >c</code
  > can't escape from its scope, so <code
  >a</code
  > <em
  >cannot be related</em
  > to <code
  >c</code
  >.</p
><h1 id="wait-wait.-what-exactly-got-rescued"
>Wait, wait. What, exactly, got rescued?</h1
><pre class="sourceCode haskell"
><code
  >withConnection :: <span class="dt"
    >Pool</span
    ><br
     />               -&gt; (forall c<span class="fu"
    >.</span
    > <span class="dt"
    >SafeConn</span
    > c -&gt; <span class="dt"
    >DB</span
    > c a) <br
     />               -&gt; <span class="dt"
    >IO</span
    > a<br
     /></code
  ></pre
><p
>Because <code
  >SafeConn c</code
  > shares the same phantom type as <code
  >DB c</code
  >, and the quantified <code
  >c</code
  > type cannot escape to the outer <code
  >IO</code
  >, there is no way for a <code
  >SafeConn c</code
  > <em
  >value</em
  > to escape, either!</p
><p
>In other words, we have ensured that a user of <code
  >withConnection</code
  > cannot either accidentally allow or force a connection to escape from the place where we've deemed them legal to use.</p
><h1 id="rank-2-types"
>Rank-2 types</h1
><p
>Standard Haskell types and functions have just one scope for universal quantification.</p
><pre class="sourceCode haskell"
><code
  >foo :: forall a b<span class="fu"
    >.</span
    > a -&gt; b -&gt; a<br
     /></code
  ></pre
><p
>When an extra level of scoping for universal quantification is introduced, this is called a rank-2 type.</p
><pre class="sourceCode haskell"
><code
  >fnord :: forall b<span class="fu"
    >.</span
    > (forall a<span class="fu"
    >.</span
    > a -&gt; a) -&gt; b<br
     /></code
  ></pre
><p
>(Normal types are thus called rank-1 types.)</p
><p
>Although widely used, rank-2 types are not yet a part of the Haskell standard, hence our use of a pragma earlier:</p
><pre class="sourceCode haskell"
><code
  ><span class="ot"
    >{-# LANGUAGE Rank2Types #-}</span
    ><br
     /></code
  ></pre
><h1 id="bonus-question-1"
>Bonus question 1</h1
><p
>What expressions can we write that have this type?</p
><pre class="sourceCode haskell"
><code
  >[forall a<span class="fu"
    >.</span
    > a]<br
     /></code
  ></pre
><p
>What about this one?</p
><pre class="sourceCode haskell"
><code
  >[forall a<span class="fu"
    >.</span
    > (<span class="kw"
    >Enum</span
    > a) =&gt; a]<br
     /></code
  ></pre
><p
>Or this?</p
><pre class="sourceCode haskell"
><code
  >[forall a<span class="fu"
    >.</span
    > (<span class="kw"
    >Num</span
    > a) =&gt; a]<br
     /></code
  ></pre
><h1 id="bonus-question-2"
>Bonus question 2</h1
><p
>Do we have time to talk about how to write a <code
  >Monad</code
  > instance for <code
  >DB</code
  >?</p
><h1 id="purity-in-the-face-of-change"
>Purity in the face of change</h1
><p
>We've now seen several cases where phantom types and rank-2 types let us use the compiler to automatically prevent ourselves from writing bad code.</p
><p
>We can also use them to introduce safe, controlled mutation into our programs.</p
><h1 id="sad-face"
>Sad face</h1
><p
>A typical lament of a functional programmer:</p
><ul
><li
  >&quot;Alas! Woe is me! Etc., etc.! There is no known purely functional algorithm for my problem that performs as well as this seductive imperative code!&quot;</li
  ></ul
><p
>:-(</p
><p
>:-(</p
><p
>Of course, in the worst case, we can emulate a flat, mutable memory with a purely functional map, thus incurring only <span class="math"
  ><em
    >O</em
    >(log <em
    >n</em
    >)</span
  > of additional overhead.</p
><h1 id="cake-having-and-eating"
>Cake: having and eating</h1
><p
>Enter the <code
  >ST</code
  > monad!</p
><pre class="sourceCode haskell"
><code
  ><span class="kw"
    >import</span
    > <span class="dt"
    >Control.Monad.ST</span
    ><br
     /></code
  ></pre
><p
>This defines for us a function with a glorious rank-2 type:</p
><pre class="sourceCode haskell"
><code
  ><span class="fu"
    >&gt;&gt;</span
    > <span class="fu"
    >:</span
    >t runST<br
     />runST :: (forall s<span class="fu"
    >.</span
    > <span class="dt"
    >ST</span
    > s a) -&gt; a<br
     /></code
  ></pre
><p
>Since we've only just been introduced to rank-2 types, we know exactly what this implies:</p
><ul
><li
  ><p
    >What happens in the <code
      >ST</code
      > monad <em
      >stays</em
      > in the <code
      >ST</code
      > monad.</p
    ></li
  ><li
  ><p
    >Nevertheles, we can obtain a pure result when we run an action in this monad. That's an exciting prospect!</p
    ></li
  ></ul
><h1 id="mutable-references-st-style"
>Mutable references, ST style</h1
><p
>The <code
  >STRef</code
  > type gives us the same mutable references as <code
  >IORef</code
  >, but in the <code
  >ST</code
  > monad.</p
><pre class="sourceCode haskell"
><code
  ><span class="kw"
    >import</span
    > <span class="dt"
    >Control.Monad.ST</span
    ><br
     /><span class="kw"
    >import</span
    > <span class="dt"
    >Data.STRef</span
    ><br
     /><br
     />whee :: <span class="dt"
    >ST</span
    > s <span class="dt"
    >Int</span
    ><br
     />whee z <span class="fu"
    >=</span
    > <span class="kw"
    >do</span
    ><br
     />  r &lt;- newSTRef z<br
     />  modifySTRef r (<span class="fu"
    >+</span
    ><span class="dv"
    >1</span
    >)<br
     />  readSTRef r<br
     /></code
  ></pre
><p
>Let's try this in <code
  >ghci</code
  >:</p
><pre class="sourceCode haskell"
><code
  ><span class="fu"
    >&gt;&gt;</span
    > runST (whee <span class="dv"
    >1</span
    >)<br
     /><span class="dv"
    >2</span
    ><br
     /></code
  ></pre
><p
>Thanks to chaining of the universally quantified <code
  >s</code
  >, there is no way for an <code
  >STRef</code
  > to escape from the <code
  >ST</code
  > monad, save by the approved route of reading its current value with <code
  >readSTRef</code
  >.</p
><pre class="sourceCode haskell"
><code
  >newSTRef  :: a -&gt; <span class="dt"
    >ST</span
    > s (<span class="dt"
    >STRef</span
    > s a)<br
     />readSTRef :: <span class="dt"
    >STRef</span
    > s a -&gt; <span class="dt"
    >ST</span
    > s a<br
     /></code
  ></pre
><h1 id="arrays-and-vectors"
>Arrays and vectors</h1
><p
>For working with large collections of uniform data, the usual representation in most languages is an array.</p
><p
>The longtime standard for working with arrays in Haskell is the <code
  >Array</code
  > type, from the <code
  >array</code
  > package, but I don't like it: it has an API that is simultaneously bizarre, too general, and puny.</p
><p
>I much prefer its modern cousin, the <code
  >vector</code
  > package:</p
><ul
><li
  ><p
    ><code
      >vector</code
      > provides a <em
      >vastly</em
      > richer API than <code
      >array</code
      >.</p
    ></li
  ><li
  ><p
    >A <code
      >Vector</code
      > is one-dimensional and indexed by <code
      >Int</code
      >s counting from zero, so it's easy to reason about.</p
    ></li
  ><li
  ><p
    >An <code
      >Array</code
      > is indexed by an instance of the <code
      >Ix</code
      > class, can have arbitrary bounds, and makes my brain hurt.</p
    ></li
  ></ul
><h1 id="families-and-flavours-of-vectors"
>Families and flavours of vectors</h1
><p
>The <code
  >vector</code
  > package provides two &quot;flavours&quot; of vector type:</p
><ul
><li
  ><p
    ><code
      >Vector</code
      > types are immutable.</p
    ></li
  ><li
  ><p
    ><code
      >MVector</code
      > types can be modified in either the <code
      >ST</code
      > or <code
      >IO</code
      > monad, and cannot be read by purely functional code.</p
    ></li
  ></ul
><p
>Within these flavours, there are two &quot;families&quot; of vector type:</p
><ul
><li
  ><p
    >Unboxed vectors are tightly packed in contiguous memory. They are very fast, but it is only possible to create unboxed vectors of certain types, and an unboxed vector can't store thunks.</p
    ></li
  ><li
  ><p
    >Normal vectors are boxed, just like ordinary Haskell values. Any value can be stored in a plain old vector, at the cost of an additional level of indirection.</p
    ></li
  ></ul
><p
>We can thus have an immutable unboxed vector, a mutable boxed vector, and so on.</p
><h1 id="mutable-vectors-in-action"
>Mutable vectors in action</h1
><p
>The classic Haskell implementation of a &quot;quicksort&quot;:</p
><pre class="sourceCode haskell"
><code
  ><span class="kw"
    >import</span
    > <span class="dt"
    >Data.List</span
    > (partition)<br
     /><br
     />qsort (p<span class="fu"
    >:</span
    >xs) <span class="fu"
    >=</span
    > qsort lt <span class="fu"
    >++</span
    > [p] <span class="fu"
    >++</span
    > qsort ge<br
     />  <span class="kw"
    >where</span
    > (lt,ge) <span class="fu"
    >=</span
    > partition (<span class="fu"
    >&lt;</span
    >p) xs<br
     />qsort _      <span class="fu"
    >=</span
    > []<br
     /></code
  ></pre
><p
>This isn't <em
  >really</em
  > a quicksort, because it doesn't operate in-place.</p
><p
>We can apply our newfound knowledge to this problem:</p
><pre class="sourceCode haskell"
><code
  ><span class="kw"
    >import</span
    > <span class="kw"
    >qualified</span
    > <span class="dt"
    >Data.Vector.Unboxed.Mutable</span
    > <span class="kw"
    >as</span
    > <span class="dt"
    >V</span
    ><br
     /><span class="kw"
    >import</span
    > <span class="dt"
    >Control.Monad.ST</span
    > (<span class="dt"
    >ST</span
    >)<br
     /><br
     />quicksort :: <span class="dt"
    >V.MVector</span
    > s <span class="dt"
    >Int</span
    > -&gt; <span class="dt"
    >ST</span
    > s ()<br
     />quicksort vec <span class="fu"
    >=</span
    > go <span class="dv"
    >0</span
    > (V.length vec)<br
     />  <span class="kw"
    >where</span
    ><br
     />    <span class="co"
    >{- ... -}</span
    ><br
     /></code
  ></pre
><h1 id="the-recursive-step"
>The recursive step</h1
><pre class="sourceCode haskell"
><code
  >    recur left right<br
     />      <span class="fu"
    >|</span
    > left <span class="fu"
    >&gt;=</span
    > right <span class="fu"
    >=</span
    > <span class="fu"
    >return</span
    > ()<br
     />      <span class="fu"
    >|</span
    > <span class="fu"
    >otherwise</span
    >     <span class="fu"
    >=</span
    > <span class="kw"
    >do</span
    ><br
     />      idx &lt;- partition left right<br
     />             (left <span class="fu"
    >+</span
    > (right<span class="fu"
    >-</span
    >left) <span class="ot"
    >`div`</span
    > <span class="dv"
    >2</span
    >)<br
     />      recur left (idx<span class="fu"
    >-</span
    ><span class="dv"
    >1</span
    >)<br
     />      recur (idx<span class="fu"
    >+</span
    ><span class="dv"
    >1</span
    >) right<br
     /></code
  ></pre
><h1 id="partitioning-the-vector"
>Partitioning the vector</h1
><p
>(Remember, <code
  >vec</code
  > is in scope here.)</p
><pre class="sourceCode haskell"
><code
  >    partition left right pivotIdx <span class="fu"
    >=</span
    > <span class="kw"
    >do</span
    ><br
     />      pivot &lt;- V.read vec pivotIdx<br
     />      V.swap vec pivotIdx right<br
     />      <span class="kw"
    >let</span
    > loop i k<br
     />            <span class="fu"
    >|</span
    > i <span class="fu"
    >==</span
    > right <span class="fu"
    >=</span
    > V.swap vec k right <span class="fu"
    >&gt;&gt;</span
    ><br
     />                           <span class="fu"
    >return</span
    > k<br
     />            <span class="fu"
    >|</span
    > <span class="fu"
    >otherwise</span
    > <span class="fu"
    >=</span
    > <span class="kw"
    >do</span
    ><br
     />            v &lt;- V.read vec i<br
     />            <span class="kw"
    >if</span
    > v <span class="fu"
    >&lt;</span
    > pivot<br
     />              <span class="kw"
    >then</span
    > V.swap vec i k <span class="fu"
    >&gt;&gt;</span
    ><br
     />                   loop (i<span class="fu"
    >+</span
    ><span class="dv"
    >1</span
    >) (k<span class="fu"
    >+</span
    ><span class="dv"
    >1</span
    >)<br
     />              <span class="kw"
    >else</span
    > loop (i<span class="fu"
    >+</span
    ><span class="dv"
    >1</span
    >) k<br
     />      loop left left<br
     /></code
  ></pre
><h1 id="from-immutable-to-mutable-and-back"
>From immutable to mutable, and back</h1
><p
>We can even use this in-place sort to efficiently perform an in-place sort of an immutable array!</p
><p
>Our building blocks:</p
><pre class="sourceCode haskell"
><code
  >thaw   :: <span class="dt"
    >Vector</span
    > a -&gt; <span class="dt"
    >ST</span
    > s (<span class="dt"
    >MVector</span
    > s a)<br
     />create :: (forall s<span class="fu"
    >.</span
    > <span class="dt"
    >ST</span
    > s (<span class="dt"
    >MVector</span
    > s a)) -&gt; <span class="dt"
    >Vector</span
    > a<br
     /></code
  ></pre
><ul
><li
  ><p
    ><code
      >thaw</code
      > creates a new mutable vector, and copies the contents of the immutable vector into it.</p
    ></li
  ><li
  ><p
    ><code
      >create</code
      > runs an <code
      >ST</code
      > action that returns a mutable vector, and &quot;freezes&quot; its result to be immutable, and hence usable in pure code.</p
    ></li
  ></ul
><pre class="sourceCode haskell"
><code
  ><span class="kw"
    >import</span
    > <span class="kw"
    >qualified</span
    > <span class="dt"
    >Data.Vector.Unboxed</span
    > <span class="kw"
    >as</span
    > <span class="dt"
    >U</span
    ><br
     /><br
     />vsort :: <span class="dt"
    >U.Vector</span
    > <span class="dt"
    >Int</span
    > -&gt; <span class="dt"
    >U.Vector</span
    > <span class="dt"
    >Int</span
    ><br
     />vsort v <span class="fu"
    >=</span
    > U.create <span class="fu"
    >$</span
    > <span class="kw"
    >do</span
    ><br
     />            vec &lt;- U.thaw v<br
     />            quicksort vec<br
     />            <span class="fu"
    >return</span
    > vec<br
     /></code
  ></pre
><h1 id="mutability-purity-and-determinism"
>Mutability, purity, and determinism</h1
><p
>The big advantage of the <code
  >ST</code
  > monad is that it gives us the ability to efficiently run computations that require mutability, while both the inputs to and results of our computations remain pure.</p
><p
>In order to achieve this, we sacrifice some power:</p
><ul
><li
  ><p
    >We can't run arbitrary <code
      >IO</code
      > actions. No database accesses, no filesystem, etc.</p
    ></li
  ><li
  ><p
    >Other potential sources of nondeterminism (e.g. threads) are thus also off limits.</p
    ></li
  ></ul
><h1 id="laziness"
>Laziness</h1
><p
>Originally, this lecture was supposed to be all about the joys of lazy evaluation, but we hijacked much of our time to serve other purposes.</p
><p
>I'm going to talk a little bit about it anyway.</p
><p
>In a minute.</p
><h1 id="a-digression"
>A digression</h1
><p
>How can we use random numbers to approximate the value of <span class="math"
  >π</span
  >?</p
><h1 id="a-digression-1"
>A digression</h1
><p
>How can we use random numbers to approximate the value of pi?</p
><ul
><li
  ><p
    >Take two random numbers, <span class="math"
      ><em
	>x</em
	></span
      > and <span class="math"
      ><em
	>y</em
	></span
      >, on the interval <span class="math"
      >[0, 1]</span
      ></p
    ></li
  ><li
  ><p
    >Add their squares: <span class="math"
      ><em
	>r</em
	> = <em
	>x</em
	><sup
	>2</sup
	> + <em
	>y</em
	><sup
	>2</sup
	></span
      ></p
    ></li
  ><li
  ><p
    >We have a <span class="math"
      >π / 4</span
      > probability of <span class="math"
      ><em
	>r</em
	> ≤ 1</span
      ></p
    ></li
  ></ul
><p
>What can we do with this knowledge?</p
><h1 id="purely-functional-random-numbers"
>Purely functional random numbers</h1
><p
>Haskell supplies a <code
  >random</code
  > package that we can use in a purely functional setting.</p
><pre class="sourceCode haskell"
><code
  ><span class="kw"
    >class</span
    > <span class="dt"
    >Random</span
    > a <span class="kw"
    >where</span
    ><br
     />    random :: <span class="dt"
    >RandomGen</span
    > g =&gt; g -&gt; (a, g)<br
     /><br
     /><span class="kw"
    >class</span
    > <span class="dt"
    >RandomGen</span
    > g <span class="kw"
    >where</span
    ><br
     />    next   :: g -&gt; (<span class="dt"
    >Int</span
    >, g)<br
     />    split  :: g -&gt; (g, g)<br
     /></code
  ></pre
><h1 id="randomgen"
>RandomGen</h1
><p
>The <code
  >RandomGen</code
  > class is a building block: it specifies an interface for a generator that can generate uniformly distributed pseudo-random <code
  >Int</code
  >s.</p
><p
>There is one default instance of this class:</p
><pre class="sourceCode haskell"
><code
  ><span class="kw"
    >data</span
    > <span class="dt"
    >StdGen</span
    > <span class="co"
    >{- opaque -}</span
    ><br
     /><br
     /><span class="kw"
    >instance</span
    > <span class="dt"
    >RandomGen</span
    > <span class="dt"
    >StdGen</span
    ><br
     /></code
  ></pre
><h1 id="random"
>Random</h1
><p
>The <code
  >Random</code
  > class specifies how to generate a pseudo-random value of some type, given the random numbers generated by a <code
  >Gen</code
  > instance.</p
><p
>Quite a few common types have <code
  >Random</code
  > instances.</p
><ul
><li
  ><p
    >For <code
      >Int</code
      >, the instance will generate any representable value.</p
    ></li
  ><li
  ><p
    >For <code
      >Double</code
      >, the instance will generate a value in the range <span class="math"
      >[0, 1]</span
      >.</p
    ></li
  ></ul
><h1 id="generators-are-pure"
>Generators are pure</h1
><p
>Since we want to use a PRNG in pure code, we obviously can't modify the state of a PRNG when we generate a new value.</p
><p
>This is why <code
  >next</code
  > and <code
  >random</code
  > return a <em
  >new</em
  > state for the PRNG every time we generate a new pseudo-random value.</p
><h1 id="throwing-darts-at-the-board"
>Throwing darts at the board</h1
><p
>Here's how we can generate a guess at <span class="math"
  ><em
    >x</em
    ><sup
    >2</sup
    > + <em
    >y</em
    ><sup
    >2</sup
    ></span
  >:</p
><pre class="sourceCode haskell"
><code
  >guess :: (<span class="dt"
    >RandomGen</span
    > g) =&gt; (<span class="dt"
    >Double</span
    >,g) -&gt; (<span class="dt"
    >Double</span
    >,g)<br
     />guess (_,g) <span class="fu"
    >=</span
    > (z, g'')<br
     />    <span class="kw"
    >where</span
    > z        <span class="fu"
    >=</span
    > x<span class="fu"
    >^</span
    ><span class="dv"
    >2</span
    > <span class="fu"
    >+</span
    > y<span class="fu"
    >^</span
    ><span class="dv"
    >2</span
    ><br
     />          (x, g')  <span class="fu"
    >=</span
    > random g<br
     />          (y, g'') <span class="fu"
    >=</span
    > random g'<br
     /></code
  ></pre
><p
>Note that we have to hand back the <em
  >final</em
  > state of the PRNG along with our result!</p
><p
>If we handed back <code
  >g</code
  > or <code
  >g'</code
  > instead, our numbers would either be all identical or disastrously correlated (every <code
  >x</code
  > would just be a repeat of the previous <code
  >y</code
  >).</p
><h1 id="global-state"
>Global state</h1
><p
>We can use the <code
  >getStdGen</code
  > function to get a handy global PRNG state:</p
><pre class="sourceCode haskell"
><code
  >getStdGen :: <span class="dt"
    >IO</span
    > <span class="dt"
    >StdGen</span
    ><br
     /></code
  ></pre
><p
>This does <em
  >not</em
  > modify the state, though. If we use <code
  >getStdGen</code
  > twice in succession, we'll get the same result each time.</p
><p
>To be safe, we should update the global PRNG state with the final PRNG state returned by our pure code:</p
><pre class="sourceCode haskell"
><code
  >setStdGen :: <span class="dt"
    >StdGen</span
    > -&gt; <span class="dt"
    >IO</span
    > ()<br
     /></code
  ></pre
><h1 id="ugh---lets-split"
>Ugh - let's split!</h1
><p
>Calling <code
  >getStdGen</code
  > and <code
  >setStdGen</code
  > from <code
  >ghci</code
  > is a pain, so let's write a combinator to help us.</p
><p
>Remember that <code
  >split</code
  > method from earlier?</p
><pre class="sourceCode haskell"
><code
  ><span class="kw"
    >class</span
    > <span class="dt"
    >RandomGen</span
    > g <span class="kw"
    >where</span
    ><br
     />    split  :: g -&gt; (g, g)<br
     /></code
  ></pre
><p
>This &quot;forks&quot; the PRNG, creating two children with different states.</p
><p
>The hope is that the states will be different enough that pseudo-random values generated from each will not be obviously correlated.</p
><pre class="sourceCode haskell"
><code
  >withGen :: (<span class="dt"
    >StdGen</span
    > -&gt; a) -&gt; <span class="dt"
    >IO</span
    > a<br
     />withGen f <span class="fu"
    >=</span
    > <span class="kw"
    >do</span
    ><br
     />  g &lt;- getStdGen<br
     />  <span class="kw"
    >let</span
    > (g',g'') <span class="fu"
    >=</span
    > split g<br
     />  setStdGen g'<br
     />  <span class="fu"
    >return</span
    > (f g'')<br
     /></code
  ></pre
><h1 id="living-in-ghci"
>Living in ghci</h1
><p
>Now we can use our <code
  >guess</code
  > function reasonably easily.</p
><pre class="sourceCode haskell"
><code
  ><span class="fu"
    >&gt;&gt;</span
    > <span class="kw"
    >let</span
    > f <span class="fu"
    >=</span
    > <span class="fu"
    >fst</span
    > <span class="ot"
    >`fmap`</span
    > withGen (guess <span class="fu"
    >.</span
    > ((,) <span class="dv"
    >0</span
    >))<br
     /><span class="fu"
    >&gt;&gt;</span
    > f<br
     /><span class="dv"
    >1</span
    ><span class="fu"
    >.</span
    ><span class="dv"
    >2397265526054513</span
    ><br
     /><span class="fu"
    >&gt;&gt;</span
    > f<br
     /><span class="dv"
    >0</span
    ><span class="fu"
    >.</span
    ><span class="dv"
    >9506331164887969</span
    ><br
     /></code
  ></pre
><h1 id="lets-iterate"
>Let's iterate</h1
><p
>Here's a useful function from the <code
  >Prelude</code
  >:</p
><pre class="sourceCode haskell"
><code
  ><span class="fu"
    >iterate</span
    > :: (a -&gt; a) -&gt; a -&gt; [a]<br
     /><span class="fu"
    >iterate</span
    > f x <span class="fu"
    >=</span
    > x <span class="fu"
    >:</span
    > <span class="fu"
    >iterate</span
    > f (f x)<br
     /></code
  ></pre
><p
>Obviously that list is infinite.</p
><p
>Let's use <code
  >iterate</code
  > and <code
  >guess</code
  >, and as much other <code
  >Prelude</code
  > machinery as we can think of, to write a function that can approximate <span class="math"
  >π</span
  >.</p
><p
>By the way, in case you don't recognize this technique, it's a famous example of the family of <a href="http://en.wikipedia.org/wiki/Monte_Carlo_method"
  >Monte Carlo methods</a
  >.</p
><h1 id="wheres-the-connection-to-laziness"
>Where's the connection to laziness?</h1
><p
>What aspects of laziness were important in developing our solution?</p
>
</body>

<!-- Mirrored from www.scs.stanford.edu/11au-cs240h/notes/laziness.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 25 Dec 2016 16:59:09 GMT -->
</html>
