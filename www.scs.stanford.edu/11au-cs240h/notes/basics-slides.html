<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<!-- Mirrored from www.scs.stanford.edu/11au-cs240h/notes/basics-slides.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 23 Dec 2016 12:49:39 GMT -->
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">
/*<![CDATA[*/
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre 
   { margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none; }
td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; }
td.sourceCode { padding-left: 5px; }
code.sourceCode span.kw { color: #007020; font-weight: bold; } 
code.sourceCode span.dt { color: #902000; }
code.sourceCode span.dv { color: #40a070; }
code.sourceCode span.bn { color: #40a070; }
code.sourceCode span.fl { color: #40a070; }
code.sourceCode span.ch { color: #4070a0; }
code.sourceCode span.st { color: #4070a0; }
code.sourceCode span.co { color: #60a0b0; font-style: italic; }
code.sourceCode span.ot { color: #007020; }
code.sourceCode span.al { color: red; font-weight: bold; }
code.sourceCode span.fu { color: #06287e; }
code.sourceCode span.re { }
code.sourceCode span.er { color: red; font-weight: bold; }
/*]]>*/
  </style>
  <style type="text/css">
/*<![CDATA[*/
/* slidy.css

   Copyright (c) 2005-2010 W3C (MIT, ERCIM, Keio), All Rights Reserved.
   W3C liability, trademark, document use and software licensing
   rules apply, see:

   http://www.w3.org/Consortium/Legal/copyright-documents
   http://www.w3.org/Consortium/Legal/copyright-software
*/
body
{
  margin: 0 0 0 0;
  padding: 0 0 0 0;
  width: 100%;
  height: 100%;
  color: black;
  background-color: white;
  font-family: "URW Palladio L", "Palatino Linotype", sans-serif;
  font-size: 14pt;
}

code
{
  font-family: "DejaVu Sans Mono", monospace;
}

div.toolbar {
  position: fixed; z-index: 200;
  top: auto; bottom: 0; left: 0; right: 0;
  height: 1.2em; text-align: right;
  padding-left: 1em;
  padding-right: 1em; 
  font-size: 60%;
  color: red;
  background-color: rgb(240,240,240);
  border-top: solid 1px rgb(180,180,180);
}

div.toolbar span.copyright {
  color: black;
  margin-left: 0.5em;
}

div.initial_prompt {
  position: absolute;
  z-index: 1000;
  bottom: 1.2em;
  width: 100%;
  background-color: rgb(200,200,200);
  opacity: 0.35;
  background-color: rgb(200,200,200, 0.35);
  cursor: pointer;
}

div.initial_prompt p.help {
  text-align: center;
}

div.initial_prompt p.close {
  text-align: right;
  font-style: italic;
}

div.slidy_toc {
  position: absolute;
  z-index: 300;
  width: 60%;
  max-width: 30em;
  height: 30em;
  overflow: auto;
  top: auto;
  right: auto;
  left: 4em;
  bottom: 4em;
  padding: 1em;
  background: rgb(240,240,240);
  border-style: solid;
  border-width: 2px;
  font-size: 60%;
}

div.slidy_toc .toc_heading {
  text-align: center;
  width: 100%;
  margin: 0;
  margin-bottom: 1em;
  border-bottom-style: solid;
  border-bottom-color: rgb(180,180,180);
  border-bottom-width: 1px;
}

div.slide {
  z-index: 20;
  margin: 0 0 0 0;
  padding-top: 0;
  padding-bottom: 0;
  padding-left: 20px;
  padding-right: 20px;
  border-width: 0;
  clear: both;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  line-height: 120%;
  background-color: transparent;
}

div.slide > div.figure {
  text-align: center
}

div.background {
  display: none;
}

div.handout {
  margin-left: 20px;
  margin-right: 20px;
}

div.slide.titlepage {
  text-align: center;
}

div.slide.titlepage h1 {
  padding-top: 10%;
  margin-right: 0;
}

div.slide h1 {
  padding-left: 0;
  padding-right: 20pt;
  padding-top: 4pt;
  padding-bottom: 4pt;
  margin-top: 0;
  margin-left: 0;
  margin-right: 60pt;
  margin-bottom: 0.5em;
  display: block; 
  font-size: 160%;
  line-height: 1.2em;
  background: transparent;
}

div.toc {
  position: absolute;
  top: auto;
  bottom: 4em;
  left: 4em;
  right: auto;
  width: 60%;
  max-width: 30em;
  height: 30em;
  border: solid thin black;
  padding: 1em;
  background: rgb(240,240,240);
  color: black;
  z-index: 300;
  overflow: auto;
  display: block;
  visibility: visible;
}

div.toc-heading {
  width: 100%;
  border-bottom: solid 1px rgb(180,180,180);
  margin-bottom: 1em;
  text-align: center;
}

pre {
 font-size: 80%;
 font-weight: bold;
 line-height: 120%;
 padding-top: 0.2em;
 padding-bottom: 0.2em;
 padding-left: 1em;
 padding-right: 1em;
 border-style: solid;
 border-left-width: 1em;
 border-top-width: thin;
 border-right-width: thin;
 border-bottom-width: thin;
 border-color: #95ABD0;
 color: #00428C;
 background-color: #E4E5E7;
}

li pre { margin-left: 0; }

blockquote { font-style: italic }

img { background-color: transparent }

p.copyright { font-size: smaller }

.center { text-align: center }
.footnote { font-size: smaller; margin-left: 2em; }

a img { border-width: 0; border-style: none }

a:visited { color: navy }
a:link { color: navy }
a:hover { color: red; text-decoration: underline }
a:active { color: red; text-decoration: underline }

a {text-decoration: none}
.navbar a:link {color: white}
.navbar a:visited {color: yellow}
.navbar a:active {color: red}
.navbar a:hover {color: red}

ul { list-style-type: square; }
ul ul { list-style-type: disc; }
ul ul ul { list-style-type: circle; }
ul ul ul ul { list-style-type: disc; }
li { margin-left: 0.5em; margin-top: 0.5em; font-weight: bold }
li li { font-size: 85%; font-weight: normal }
li li li { font-size: 85%; font-weight: normal }
strong { color: red; }
li li strong { color: black; }
/* pandoc's rules about when to insert paragraphs don't interact well
with the requirement for blank lines around code blocks.  Let's just
neutralize the effects of p in bullets.  */
li > p { margin: 0em; }

div dt
{
  margin-left: 0;
  margin-top: 1em;
  margin-bottom: 0.5em;
  font-weight: bold;
}
div dd
{
  margin-left: 2em;
  margin-bottom: 0.5em;
}


p,pre,ul,ol,blockquote,h2,h3,h4,h5,h6,dl,table {
  margin-left: 1em;
  margin-right: 1em;
}

p.subhead { font-weight: bold; margin-top: 2em; }

.smaller { font-size: smaller }
.bigger { font-size: 130% }

td,th { padding: 0.2em }

ul {
  margin: 0.5em 1.5em 0.5em 1.5em;
  padding: 0;
}

ol {
  margin: 0.5em 1.5em 0.5em 1.5em;
  padding: 0;
}

ul { list-style-type: square; }
ul ul { list-style-type: disc; }
ul ul ul { list-style-type: circle; }
ul ul ul ul { list-style-type: disc; }

ul li { 
  list-style: square;
  margin: 0.1em 0em 0.6em 0;
  padding: 0 0 0 0;
  line-height: 140%;
}

ol li { 
  margin: 0.1em 0em 0.6em 1.5em;
  padding: 0 0 0 0px;
  line-height: 140%;
  list-style-type: decimal;
}

li ul li { 
  font-size: 85%; 
  font-style: normal;
  list-style-type: disc;
  background: transparent;
  padding: 0 0 0 0;
}
li li ul li { 
  font-size: 85%; 
  font-style: normal;
  list-style-type: circle;
  background: transparent;
  padding: 0 0 0 0;
}
li li li ul li {
  list-style-type: disc;
  background: transparent;
  padding: 0 0 0 0;
}

li ol li {
  list-style-type: decimal;
}


li li ol li {
  list-style-type: decimal;
}

/*
 setting class="outline on ol or ul makes it behave as an
 ouline list where blocklevel content in li elements is
 hidden by default and can be expanded or collapsed with
 mouse click. Set class="expand" on li to override default
*/

ol.outline li:hover { cursor: pointer }
ol.outline li.nofold:hover { cursor: default }

ul.outline li:hover { cursor: pointer }
ul.outline li.nofold:hover { cursor: default }

ol.outline { list-style:decimal; }
ol.outline ol { list-style-type:lower-alpha }

ol.outline li.nofold {
  padding: 0 0 0 20px;
  background: transparent url(http://www.scs.stanford.edu/11au-cs240h/graphics/nofold-dim.gif) no-repeat 0px 0.5em;
}
ol.outline li.unfolded {
  padding: 0 0 0 20px;
  background: transparent url(http://www.scs.stanford.edu/11au-cs240h/graphics/fold-dim.gif) no-repeat 0px 0.5em;
}
ol.outline li.folded {
  padding: 0 0 0 20px;
  background: transparent url(http://www.scs.stanford.edu/11au-cs240h/graphics/unfold-dim.gif) no-repeat 0px 0.5em;
}
ol.outline li.unfolded:hover {
  padding: 0 0 0 20px;
  background: transparent url(http://www.scs.stanford.edu/11au-cs240h/graphics/fold.gif) no-repeat 0px 0.5em;
}
ol.outline li.folded:hover {
  padding: 0 0 0 20px;
  background: transparent url(http://www.scs.stanford.edu/11au-cs240h/graphics/unfold.gif) no-repeat 0px 0.5em;
}

ul.outline li.nofold {
  padding: 0 0 0 20px;
  background: transparent url(http://www.scs.stanford.edu/11au-cs240h/graphics/nofold-dim.gif) no-repeat 0px 0.5em;
}
ul.outline li.unfolded {
  padding: 0 0 0 20px;
  background: transparent url(http://www.scs.stanford.edu/11au-cs240h/graphics/fold-dim.gif) no-repeat 0px 0.5em;
}
ul.outline li.folded {
  padding: 0 0 0 20px;
  background: transparent url(http://www.scs.stanford.edu/11au-cs240h/graphics/unfold-dim.gif) no-repeat 0px 0.5em;
}
ul.outline li.unfolded:hover {
  padding: 0 0 0 20px;
  background: transparent url(http://www.scs.stanford.edu/11au-cs240h/graphics/fold.gif) no-repeat 0px 0.5em;
}
ul.outline li.folded:hover {
  padding: 0 0 0 20px;
  background: transparent url(http://www.scs.stanford.edu/11au-cs240h/graphics/unfold.gif) no-repeat 0px 0.5em;
}

/* for slides with class "title" in table of contents */
a.titleslide { font-weight: bold; font-style: italic }

/*
 hide images for work around for save as bug
 where browsers fail to save images used by CSS
*/
img.hidden { display: none; visibility: hidden }
div.initial_prompt { display: none; visibility: hidden }

  div.slide {
     visibility: visible;
     position: inherit;
  }
  div.handout {
     border-top-style: solid;
     border-top-width: thin;
     border-top-color: black;
  }

@media screen {
  .hidden { display: none; visibility: visible }

  div.slide.hidden { display: block; visibility: visible }
  div.handout.hidden { display: block; visibility: visible }
  div.background { display: none; visibility: hidden }
  body.single_slide div.initial_prompt { display: block; visibility: visible }
  body.single_slide div.background { display: block; visibility: visible }
  body.single_slide div.background.hidden { display: none; visibility: hidden }
  body.single_slide .invisible { visibility: hidden }
  body.single_slide .hidden { display: none; visibility: hidden }
  body.single_slide div.slide { position: absolute }
  body.single_slide div.handout { display: none; visibility: hidden }
}

@media print {
  .hidden { display: block; visibility: visible }

  div.slide pre { font-size: 60%; padding-left: 0.5em; }
  div.toolbar { display: none; visibility: hidden; }
  div.slidy_toc { display: none; visibility: hidden; }
  div.background { display: none; visibility: hidden; }
  div.slide { page-break-before: always }
  /* :first-child isn't reliable for print media */
  div.slide.first-slide { page-break-before: avoid }
}

/*]]>*/
  </style>
<script type="text/javascript" charset="utf-8">
/*<![CDATA[*/
var w3c_slidy={ns_pos:(typeof window.pageYOffset!="undefined"),khtml:((navigator.userAgent).indexOf("KHTML")>=0?true:false),opera:((navigator.userAgent).indexOf("Opera")>=0?true:false),ipad:((navigator.userAgent).indexOf("iPad")>=0?true:false),iphone:((navigator.userAgent).indexOf("iPhone")>=0?true:false),ie:(typeof document.all!="undefined"&&!this.opera),ie6:(!this.ns_pos&&navigator.userAgent.indexOf("MSIE 6")!=-1),ie7:(!this.ns_pos&&navigator.userAgent.indexOf("MSIE 7")!=-1),ie8:(!this.ns_pos&&navigator.userAgent.indexOf("MSIE 8")!=-1),ie9:(!this.ns_pos&&navigator.userAgent.indexOf("MSIE 9")!=-1),keyboardless:(this.ipad||this.iphone),is_xhtml:/xml/.test(document.contentType),slide_number:0,slide_number_element:null,slides:[],notes:[],backgrounds:[],toolbar:null,title:null,last_shown:null,eos:null,toc:null,outline:null,selected_text_len:0,view_all:0,want_toolbar:true,mouse_click_enabled:true,scroll_hack:0,disable_slide_click:false,lang:"en",help_anchor:null,help_page:"http://www.w3.org/Talks/Tools/Slidy2/help/help.html",help_text:"Navigate with mouse click, space bar, Cursor Left/Right, or Pg Up and Pg Dn. Use S and B to change font size.",size_index:0,size_adjustment:0,sizes:new Array("10pt","12pt","14pt","16pt","18pt","20pt","22pt","24pt","26pt","28pt","30pt","32pt"),last_width:0,last_height:0,objects:[],set_up:function(){var a=function(){w3c_slidy.init()};if(typeof window.addEventListener!="undefined"){window.addEventListener("load",a,false)}else{window.attachEvent("onload",a)}},hide_slides:function(){if(document.body&&!w3c_slidy.initialized){document.body.style.visibility="hidden"}else{setTimeout(w3c_slidy.hide_slides,50)}},ie_hack:function(){window.resizeBy(0,-1);window.resizeBy(0,1)},init:function(){document.body.style.visibility="visible";this.init_localization();this.add_toolbar();this.wrap_implicit_slides();this.collect_slides();this.collect_notes();this.collect_backgrounds();this.objects=document.body.getElementsByTagName("object");this.patch_anchors();this.slide_number=this.find_slide_number(location.href);window.offscreenbuffering=true;this.size_adjustment=this.find_size_adjust();this.time_left=this.find_duration();this.hide_image_toolbar();this.init_outliner();this.title=document.title;this.is_xhtml=(document.body.tagName=="BODY"?false:true);if(this.slides.length>0){var a=this.slides[this.slide_number];if(this.slide_number>0){this.set_visibility_all_incremental("visible");this.last_shown=this.previous_incremental_item(null);this.set_eos_status(true)}else{this.last_shown=null;this.set_visibility_all_incremental("hidden");this.set_eos_status(!this.next_incremental_item(this.last_shown))}this.set_location();this.add_class(this.slides[0],"first-slide");w3c_slidy.show_slide(a)}this.toc=this.table_of_contents();this.add_initial_prompt();if(!this.keyboardless){this.add_listener(document.body,"click",this.mouse_button_click)}this.add_listener(document,"keydown",this.key_down);this.add_listener(document,"keypress",this.key_press);this.add_listener(window,"resize",this.resized);this.add_listener(window,"scroll",this.scrolled);this.add_listener(window,"unload",this.unloaded);this.single_slide_view();this.resized();if(this.ie7){setTimeout(w3c_slidy.ie_hack,100)}this.show_toolbar();setInterval(function(){w3c_slidy.check_location()},200);w3c_slidy.initialized=true},table_of_contents:function(){var c=this.create_element("div");this.add_class(c,"slidy_toc hidden");var k=this.create_element("div");this.add_class(k,"toc-heading");k.innerHTML=this.localize("Table of Contents");c.appendChild(k);var f=null;for(var d=0;d<this.slides.length;++d){var g=this.has_class(this.slides[d],"title");var e=document.createTextNode((d+1)+". ");c.appendChild(e);var h=this.create_element("a");h.setAttribute("href","#("+(d+1)+")");if(g){this.add_class(h,"titleslide")}var b=document.createTextNode(this.slide_name(d));h.appendChild(b);h.onclick=w3c_slidy.toc_click;h.onkeydown=w3c_slidy.toc_key_down;h.previous=f;if(f){f.next=h}c.appendChild(h);if(d==0){c.first=h}if(d<this.slides.length-1){var j=this.create_element("br");c.appendChild(j)}f=h}c.focus=function(){if(this.first){this.first.focus()}};c.onmouseup=w3c_slidy.mouse_button_up;c.onclick=function(a){a||(a=window.event);if(w3c_slidy.selected_text_len<=0){w3c_slidy.hide_table_of_contents(true)}w3c_slidy.stop_propagation(a);if(a.cancel!=undefined){a.cancel=true}if(a.returnValue!=undefined){a.returnValue=false}return false};document.body.insertBefore(c,document.body.firstChild);return c},is_shown_toc:function(){return !w3c_slidy.has_class(w3c_slidy.toc,"hidden")},show_table_of_contents:function(){w3c_slidy.remove_class(w3c_slidy.toc,"hidden");var a=w3c_slidy.toc;a.focus();if(w3c_slidy.ie7&&w3c_slidy.slide_number==0){setTimeout(w3c_slidy.ie_hack,100)}},hide_table_of_contents:function(a){w3c_slidy.add_class(w3c_slidy.toc,"hidden");if(a&&!w3c_slidy.opera){w3c_slidy.help_anchor.focus()}},toggle_table_of_contents:function(){if(w3c_slidy.is_shown_toc()){w3c_slidy.hide_table_of_contents(true)}else{w3c_slidy.show_table_of_contents()}},toc_click:function(d){if(!d){d=window.event}var c=w3c_slidy.get_target(d);if(c&&c.nodeType==1){var b=c.getAttribute("href");if(b){var a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=w3c_slidy.find_slide_number(b);a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.last_shown=null;w3c_slidy.set_location();w3c_slidy.set_visibility_all_incremental("hidden");w3c_slidy.set_eos_status(!w3c_slidy.next_incremental_item(w3c_slidy.last_shown));w3c_slidy.show_slide(a);try{if(!w3c_slidy.opera){w3c_slidy.help_anchor.focus()}}catch(d){}}}w3c_slidy.hide_table_of_contents(true);if(w3c_slidy.ie7){w3c_slidy.ie_hack()}w3c_slidy.stop_propagation(d);return w3c_slidy.cancel(d)},toc_key_down:function(d){var b;if(!d){var d=window.event}if(window.event){b=window.event.keyCode}else{if(d.which){b=d.which}else{return true}}if(!b){return true}if(d.ctrlKey||d.altKey){return true}if(b==13){var c=this.getAttribute("href");if(c){var a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=w3c_slidy.find_slide_number(c);a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.last_shown=null;w3c_slidy.set_location();w3c_slidy.set_visibility_all_incremental("hidden");w3c_slidy.set_eos_status(!w3c_slidy.next_incremental_item(w3c_slidy.last_shown));w3c_slidy.show_slide(a);try{if(!w3c_slidy.opera){w3c_slidy.help_anchor.focus()}}catch(f){}}w3c_slidy.hide_table_of_contents(true);if(self.ie7){w3c_slidy.ie_hack()}return w3c_slidy.cancel(d)}if(b==40&&this.next){this.next.focus();return w3c_slidy.cancel(d)}if(b==38&&this.previous){this.previous.focus();return w3c_slidy.cancel(d)}return true},before_print:function(){this.show_all_slides();this.hide_toolbar();alert("before print")},after_print:function(){if(!this.view_all){this.single_slide_view();this.show_toolbar()}alert("after print")},print_slides:function(){this.before_print();window.print();this.after_print()},toggle_view:function(){if(this.view_all){this.single_slide_view();this.show_toolbar();this.view_all=0}else{this.show_all_slides();this.hide_toolbar();this.view_all=1}},show_all_slides:function(){this.remove_class(document.body,"single_slide");this.set_visibility_all_incremental("visible")},single_slide_view:function(){this.add_class(document.body,"single_slide");this.set_visibility_all_incremental("visible");this.last_shown=this.previous_incremental_item(null)},hide_image_toolbar:function(){if(!this.ns_pos){var a=document.getElementsByTagName("IMG");for(var b=0;b<a.length;++b){a[b].setAttribute("galleryimg","no")}}},unloaded:function(a){},is_KHTML:function(){var a=navigator.userAgent;return(a.indexOf("KHTML")>=0?true:false)},slide_name:function(c){var b=null;var a=this.slides[c];var d=this.find_heading(a);if(d){b=this.extract_text(d)}if(!b){b=this.title+"("+(c+1)+")"}b.replace(/\&/g,"&amp;");b.replace(/\</g,"&lt;");b.replace(/\>/g,"&gt;");return b},find_heading:function(a){if(!a||a.nodeType!=1){return null}if(a.nodeName=="H1"||a.nodeName=="h1"){return a}var b=a.firstChild;while(b){a=this.find_heading(b);if(a){return a}b=b.nextSibling}return null},extract_text:function(a){if(!a){return""}if(a.nodeType==3){return a.nodeValue}if(a.nodeType==1){a=a.firstChild;var b="";while(a){b=b+this.extract_text(a);a=a.nextSibling}return b}return""},find_copyright:function(){var a,c;var d=document.getElementsByTagName("meta");for(var b=0;b<d.length;++b){a=d[b].getAttribute("name");c=d[b].getAttribute("content");if(a=="copyright"){return c}}return null},find_size_adjust:function(){var a,c,e;var d=document.getElementsByTagName("meta");for(var b=0;b<d.length;++b){a=d[b].getAttribute("name");c=d[b].getAttribute("content");if(a=="font-size-adjustment"){return 1*c}}return 1},find_duration:function(){var a,c,e;var d=document.getElementsByTagName("meta");for(var b=0;b<d.length;++b){a=d[b].getAttribute("name");c=d[b].getAttribute("content");if(a=="duration"){return 60000*c}}return null},replace_by_non_breaking_space:function(b){for(var a=0;a<b.length;++a){b[a]=160}},init_outliner:function(){var a=document.getElementsByTagName("li");for(var b=0;b<a.length;++b){var c=a[b];if(!this.has_class(c.parentNode,"outline")){continue}c.onclick=this.outline_click;if(this.foldable(c)){c.foldable=true;c.onfocus=function(){w3c_slidy.outline=this};c.onblur=function(){w3c_slidy.outline=null};if(!c.getAttribute("tabindex")){c.setAttribute("tabindex","0")}if(this.has_class(c,"expand")){this.unfold(c)}else{this.fold(c)}}else{this.add_class(c,"nofold");c.visible=true;c.foldable=false}}},foldable:function(b){if(!b||b.nodeType!=1){return false}var a=b.firstChild;while(a){if(a.nodeType==1&&this.is_block(a)){return true}a=a.nextSibling}return false},fold:function(b){if(b){this.remove_class(b,"unfolded");this.add_class(b,"folded")}var a=b?b.firstChild:null;while(a){if(a.nodeType==1&&this.is_block(a)){w3c_slidy.add_class(a,"hidden")}a=a.nextSibling}b.visible=false},unfold:function(b){if(b){this.add_class(b,"unfolded");this.remove_class(b,"folded")}var a=b?b.firstChild:null;while(a){if(a.nodeType==1&&this.is_block(a)){w3c_slidy.remove_class(a,"hidden")}a=a.nextSibling}b.visible=true},outline_click:function(c){if(!c){c=window.event}var a=false;var b=w3c_slidy.get_target(c);while(b&&b.visible==undefined){b=b.parentNode}if(!b){return true}if(c.which){a=(c.which==3)}else{if(c.button){a=(c.button==2)}}if(!a&&b.visible!=undefined){if(b.foldable){if(b.visible){w3c_slidy.fold(b)}else{w3c_slidy.unfold(b)}}w3c_slidy.stop_propagation(c);c.cancel=true;c.returnValue=false}return false},add_initial_prompt:function(){var a=this.create_element("div");a.setAttribute("class","initial_prompt");var b=this.create_element("p");a.appendChild(b);b.setAttribute("class","help");if(this.keyboardless){b.innerHTML="Tap footer to move to next slide"}else{b.innerHTML="Space or Right Arrow to move to next slide, click help below for more details"}this.add_listener(a,"click",function(c){document.body.removeChild(a);w3c_slidy.stop_propagation(c);if(c.cancel!=undefined){c.cancel=true}if(c.returnValue!=undefined){c.returnValue=false}return false});document.body.appendChild(a);this.initial_prompt=a;setTimeout(function(){document.body.removeChild(a)},5000)},add_toolbar:function(){var a,i;this.toolbar=this.create_element("div");this.toolbar.setAttribute("class","toolbar");if(this.ns_pos||!this.ie6){var k=this.create_element("div");k.setAttribute("style","float: right; text-align: right");a=this.create_element("span");a.innerHTML=this.localize("slide")+" n/m";k.appendChild(a);this.toolbar.appendChild(k);var e=this.create_element("div");e.setAttribute("style","text-align: left");this.eos=this.create_element("span");this.eos.innerHTML="* ";e.appendChild(this.eos);var g=this.create_element("a");g.setAttribute("href",this.help_page);g.setAttribute("title",this.localize(this.help_text));g.innerHTML=this.localize("help?");e.appendChild(g);this.help_anchor=g;var d=document.createTextNode(" ");e.appendChild(d);var f=this.create_element("a");f.setAttribute("href","javascript:w3c_slidy.toggle_table_of_contents()");f.setAttribute("title",this.localize("table of contents"));f.innerHTML=this.localize("contents?");e.appendChild(f);var b=document.createTextNode(" ");e.appendChild(b);var h=this.find_copyright();if(h){var j=this.create_element("span");j.className="copyright";j.innerHTML=h;e.appendChild(j)}this.toolbar.setAttribute("tabindex","0");this.toolbar.appendChild(e)}else{this.toolbar.style.position=(this.ie7?"fixed":"absolute");this.toolbar.style.zIndex="200";this.toolbar.style.width="99.9%";this.toolbar.style.height="1.2em";this.toolbar.style.top="auto";this.toolbar.style.bottom="0";this.toolbar.style.left="0";this.toolbar.style.right="0";this.toolbar.style.textAlign="left";this.toolbar.style.fontSize="60%";this.toolbar.style.color="red";this.toolbar.borderWidth=0;this.toolbar.className="toolbar";this.toolbar.style.background="rgb(240,240,240)";var c=this.create_element("span");c.innerHTML="&nbsp;&nbsp;*&nbsp;";this.toolbar.appendChild(c);this.eos=c;var g=this.create_element("a");g.setAttribute("href",this.help_page);g.setAttribute("title",this.localize(this.help_text));g.innerHTML=this.localize("help?");this.toolbar.appendChild(g);this.help_anchor=g;var d=document.createTextNode(" ");this.toolbar.appendChild(d);var f=this.create_element("a");f.setAttribute("href","javascript:toggleTableOfContents()");f.setAttribute("title",this.localize("table of contents".localize));f.innerHTML=this.localize("contents?");this.toolbar.appendChild(f);var b=document.createTextNode(" ");this.toolbar.appendChild(b);var h=this.find_copyright();if(h){var j=this.create_element("span");j.innerHTML=h;j.style.color="black";j.style.marginLeft="0.5em";this.toolbar.appendChild(j)}a=this.create_element("div");a.style.position="absolute";a.style.width="auto";a.style.height="1.2em";a.style.top="auto";a.style.bottom=0;a.style.right="0";a.style.textAlign="right";a.style.color="red";a.style.background="rgb(240,240,240)";a.innerHTML=this.localize("slide")+" n/m";this.toolbar.appendChild(a)}this.toolbar.onclick=function(m){if(!m){m=window.event}var l=m.target;if(!l&&m.srcElement){l=m.srcElement}if(l&&l.nodeType==3){l=l.parentNode}w3c_slidy.stop_propagation(m);if(l&&l.nodeName.toLowerCase()!="a"){w3c_slidy.mouse_button_click(m)}};this.slide_number_element=a;this.set_eos_status(false);document.body.appendChild(this.toolbar)},wrap_implicit_slides:function(){var a,d,c,b,f;var e=document.getElementsByTagName("h1");if(!e){return}for(a=0;a<e.length;++a){d=e[a];if(d.parentNode!=document.body){continue}c=d.nextSibling;f=document.createElement("div");this.add_class(f,"slide");document.body.replaceChild(f,d);f.appendChild(d);while(c){if(c.nodeType==1&&(c.nodeName=="H1"||c.nodeName=="h1"||c.nodeName=="DIV"||c.nodeName=="div")){break}b=c.nextSibling;c=document.body.removeChild(c);f.appendChild(c);c=b}}},collect_slides:function(){var e=new Array();var d=document.body.getElementsByTagName("div");for(var c=0;c<d.length;++c){div=d.item(c);if(this.has_class(div,"slide")){e[e.length]=div;this.add_class(div,"hidden");var b=document.createElement("br");div.appendChild(b);var a=document.createElement("br");div.appendChild(a)}else{if(this.has_class(div,"background")){div.style.display="block"}}}this.slides=e},collect_notes:function(){var b=new Array();var c=document.body.getElementsByTagName("div");for(var a=0;a<c.length;++a){div=c.item(a);if(this.has_class(div,"handout")){b[b.length]=div;this.add_class(div,"hidden")}}this.notes=b},collect_backgrounds:function(){var c=new Array();var b=document.body.getElementsByTagName("div");for(var a=0;a<b.length;++a){div=b.item(a);if(this.has_class(div,"background")){c[c.length]=div;this.add_class(div,"hidden")}}this.backgrounds=c},patch_anchors:function(){var a=w3c_slidy;var c=function(g){if(a.page_address(this.href)==a.page_address(location.href)){var f=a.find_slide_number(this.href);if(f!=a.slide_number){var e=a.slides[a.slide_number];a.hide_slide(e);a.slide_number=f;e=a.slides[a.slide_number];a.show_slide(e);a.set_location()}}else{w3c_slidy.stop_propagation(g)}this.blur();a.disable_slide_click=true};var d=document.body.getElementsByTagName("a");for(var b=0;b<d.length;++b){if(window.addEventListener){d[b].addEventListener("click",c,false)}else{d[b].attachEvent("onclick",c)}}},show_slide_number:function(){var a=w3c_slidy.get_timer();w3c_slidy.slide_number_element.innerHTML=a+w3c_slidy.localize("slide")+" "+(w3c_slidy.slide_number+1)+"/"+w3c_slidy.slides.length},check_location:function(){var b=location.hash;if(w3c_slidy.slide_number>0&&(b==""||b=="#")){w3c_slidy.goto_slide(0)}else{if(b.length>2&&b!="#("+(w3c_slidy.slide_number+1)+")"){var a=parseInt(location.hash.substr(2));if(!isNaN(a)){w3c_slidy.goto_slide(a-1)}}}if(w3c_slidy.time_left&&w3c_slidy.slide_number>0){w3c_slidy.show_slide_number();if(w3c_slidy.time_left>0){w3c_slidy.time_left-=200}}},get_timer:function(){var c="";if(w3c_slidy.time_left){var b,a;a=Math.floor(w3c_slidy.time_left/1000);b=Math.floor(a/60);a=a%60;c=(b?b+"m":"")+a+"s "}return c},set_location:function(){var a=w3c_slidy.page_address(location.href);var b="#("+(w3c_slidy.slide_number+1)+")";if(w3c_slidy.slide_number>=0){a=a+b}if(w3c_slidy.ie&&(w3c_slidy.ie6||w3c_slidy.ie7)){w3c_slidy.push_hash(b)}if(a!=location.href){location.href=a}if(this.khtml){b="("+(w3c_slidy.slide_number+1)+")"}if(!this.ie&&location.hash!=b&&location.hash!=""){location.hash=b}document.title=w3c_slidy.title+" ("+(w3c_slidy.slide_number+1)+")";w3c_slidy.show_slide_number()},page_address:function(b){var a=b.indexOf("#");if(a<0){a=b.indexOf("%23")}if(a<0){return b}return b.substr(0,a)},on_frame_loaded:function(b){location.hash=b;var a=w3c_slidy.page_address(location.href);location.href=a+b},push_hash:function(b){if(b==""){b="#(1)"}window.location.hash=b;var a=document.getElementById("historyFrame").contentWindow.document;a.open("javascript:'<html></html>'");a.write('<html><head><script type="text/javascript">window.parent.w3c_slidy.on_frame_loaded(\''+(b)+"');\74/script></head><body>hello mum</body></html>");a.close()},find_slide_number:function(e){var c=e.indexOf("#");if(c<0){return 0}var b=unescape(e.substr(c+1));var f=document.getElementById(b);if(!f){var d=/\((\d)+\)/;if(b.match(d)){var a=parseInt(b.substring(1,b.length-1));if(a>this.slides.length){a=1}if(--a<0){a=0}return a}d=/\[(\d)+\]/;if(b.match(d)){var a=parseInt(b.substring(1,b.length-1));if(a>this.slides.length){a=1}if(--a<0){a=0}return a}return 0}while(true){if(f.nodeName.toLowerCase()=="div"&&this.has_class(f,"slide")){break}f=f.parentNode;if(!f){return 0}}for(c=0;c<slides.length;++c){if(slides[c]==f){return c}}return 0},previous_slide:function(b){if(!w3c_slidy.view_all){var a;if((b||w3c_slidy.slide_number==0)&&w3c_slidy.last_shown!=null){w3c_slidy.last_shown=w3c_slidy.hide_previous_item(w3c_slidy.last_shown);w3c_slidy.set_eos_status(false)}else{if(w3c_slidy.slide_number>0){a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=w3c_slidy.slide_number-1;a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.set_visibility_all_incremental("visible");w3c_slidy.last_shown=w3c_slidy.previous_incremental_item(null);w3c_slidy.set_eos_status(true);w3c_slidy.show_slide(a)}}w3c_slidy.set_location();if(!w3c_slidy.ns_pos){w3c_slidy.refresh_toolbar(200)}}},next_slide:function(c){if(!w3c_slidy.view_all){var a,b=w3c_slidy.last_shown;if(c||w3c_slidy.slide_number==w3c_slidy.slides.length-1){w3c_slidy.last_shown=w3c_slidy.reveal_next_item(w3c_slidy.last_shown)}if((!c||w3c_slidy.last_shown==null)&&w3c_slidy.slide_number<w3c_slidy.slides.length-1){a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=w3c_slidy.slide_number+1;a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.last_shown=null;w3c_slidy.set_visibility_all_incremental("hidden");w3c_slidy.show_slide(a)}else{if(!w3c_slidy.last_shown){if(b&&c){w3c_slidy.last_shown=b}}}w3c_slidy.set_location();w3c_slidy.set_eos_status(!w3c_slidy.next_incremental_item(w3c_slidy.last_shown));if(!w3c_slidy.ns_pos){w3c_slidy.refresh_toolbar(200)}}},first_slide:function(){if(!w3c_slidy.view_all){var a;if(w3c_slidy.slide_number!=0){a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=0;a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.last_shown=null;w3c_slidy.set_visibility_all_incremental("hidden");w3c_slidy.show_slide(a)}w3c_slidy.set_eos_status(!w3c_slidy.next_incremental_item(w3c_slidy.last_shown));w3c_slidy.set_location()}},last_slide:function(){if(!w3c_slidy.view_all){var a;w3c_slidy.last_shown=null;if(w3c_slidy.last_shown==null&&w3c_slidy.slide_number<w3c_slidy.slides.length-1){a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=w3c_slidy.slides.length-1;a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.set_visibility_all_incremental("visible");w3c_slidy.last_shown=w3c_slidy.previous_incremental_item(null);w3c_slidy.show_slide(a)}else{w3c_slidy.set_visibility_all_incremental("visible");w3c_slidy.last_shown=w3c_slidy.previous_incremental_item(null)}w3c_slidy.set_eos_status(true);w3c_slidy.set_location()}},set_eos_status:function(a){if(this.eos){this.eos.style.color=(a?"rgb(240,240,240)":"red")}},goto_slide:function(b){var a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=b;a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.last_shown=null;w3c_slidy.set_visibility_all_incremental("hidden");w3c_slidy.set_eos_status(!w3c_slidy.next_incremental_item(w3c_slidy.last_shown));document.title=w3c_slidy.title+" ("+(w3c_slidy.slide_number+1)+")";w3c_slidy.show_slide(a);w3c_slidy.show_slide_number()},show_slide:function(a){this.sync_background(a);window.scrollTo(0,0);this.remove_class(a,"hidden")},hide_slide:function(a){this.add_class(a,"hidden")},sync_background:function(a){var e;var g;if(a.currentStyle){g=a.currentStyle.backgroundColor}else{if(document.defaultView){var f=document.defaultView.getComputedStyle(a,null);if(f){g=f.getPropertyValue("background-color")}else{g="transparent"}}else{g=="transparent"}}if(g=="transparent"||g.indexOf("rgba")>=0||g.indexOf("opacity")>=0){var c=this.get_class_list(a);for(var d=0;d<this.backgrounds.length;d++){e=this.backgrounds[d];var b=this.get_class_list(e);if(this.matching_background(c,b)){this.remove_class(e,"hidden")}else{this.add_class(e,"hidden")}}}else{this.hide_backgrounds()}},hide_backgrounds:function(){for(var a=0;a<this.backgrounds.length;a++){background=this.backgrounds[a];this.add_class(background,"hidden")}},matching_background:function(c,b){var d,e,f,a;f=/\w+/g;a=b.match(f);for(d=e=0;d<a.length;d++){if(a[d]=="hidden"){continue}if(a[d]=="background"){continue}++e}if(e==0){return true}a=c.match(f);for(d=e=0;d<a.length;d++){if(a[d]=="hidden"){continue}if(this.has_token(b,a[d])){return true}}return false},resized:function(){var c=0;if(typeof(window.innerWidth)=="number"){c=window.innerWidth}else{if(document.documentElement&&document.documentElement.clientWidth){c=document.documentElement.clientWidth}else{if(document.body&&document.body.clientWidth){c=document.body.clientWidth}}}var b=0;if(typeof(window.innerHeight)=="number"){b=window.innerHeight}else{if(document.documentElement&&document.documentElement.clientHeight){b=document.documentElement.clientHeight}else{if(document.body&&document.body.clientHeight){b=document.body.clientHeight}}}if(b&&(c/b>1.05*1024/768)){c=b*1024/768}if(c!=w3c_slidy.last_width||b!=w3c_slidy.last_height){if(c>=1100){w3c_slidy.size_index=5}else{if(c>=1000){w3c_slidy.size_index=4}else{if(c>=800){w3c_slidy.size_index=3}else{if(c>=600){w3c_slidy.size_index=2}else{if(c){w3c_slidy.size_index=0}}}}}if(0<=w3c_slidy.size_index+w3c_slidy.size_adjustment&&w3c_slidy.size_index+w3c_slidy.size_adjustment<w3c_slidy.sizes.length){w3c_slidy.size_index=w3c_slidy.size_index+w3c_slidy.size_adjustment}w3c_slidy.adjust_object_dimensions(c,b);if(document.body.style.fontSize!=w3c_slidy.sizes[w3c_slidy.size_index]){document.body.style.fontSize=w3c_slidy.sizes[w3c_slidy.size_index]}w3c_slidy.last_width=c;w3c_slidy.last_height=b;if(w3c_slidy.ns_pos){var a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.show_slide(a)}w3c_slidy.refresh_toolbar(200)}},scrolled:function(){if(w3c_slidy.toolbar&&!w3c_slidy.ns_pos&&!w3c_slidy.ie7){w3c_slidy.hack_offset=w3c_slidy.scroll_x_offset();w3c_slidy.toolbar.style.display="none";if(w3c_slidy.scrollhack==0&&!w3c_slidy.view_all){setTimeout(function(){w3c_slidy.show_toolbar()},1000);w3c_slidy.scrollhack=1}}},hide_toolbar:function(){w3c_slidy.add_class(w3c_slidy.toolbar,"hidden");window.focus()},refresh_toolbar:function(a){if(!w3c_slidy.ns_pos&&!w3c_slidy.ie7){w3c_slidy.hide_toolbar();setTimeout(function(){w3c_slidy.show_toolbar()},a)}},show_toolbar:function(){if(w3c_slidy.want_toolbar){w3c_slidy.toolbar.style.display="block";if(!w3c_slidy.ns_pos){var b=w3c_slidy.scroll_x_offset();w3c_slidy.toolbar.style.left=b;w3c_slidy.toolbar.style.right=b;w3c_slidy.toolbar.style.bottom=0}w3c_slidy.remove_class(w3c_slidy.toolbar,"hidden")}w3c_slidy.scrollhack=0;try{if(!w3c_slidy.opera){w3c_slidy.help_anchor.focus()}}catch(a){}},toggle_toolbar:function(){if(!w3c_slidy.view_all){if(w3c_slidy.has_class(w3c_slidy.toolbar,"hidden")){w3c_slidy.remove_class(w3c_slidy.toolbar,"hidden");w3c_slidy.want_toolbar=1}else{w3c_slidy.add_class(w3c_slidy.toolbar,"hidden");w3c_slidy.want_toolbar=0}}},scroll_x_offset:function(){if(window.pageXOffset){return self.pageXOffset}if(document.documentElement&&document.documentElement.scrollLeft){return document.documentElement.scrollLeft}if(document.body){return document.body.scrollLeft}return 0},scroll_y_offset:function(){if(window.pageYOffset){return self.pageYOffset}if(document.documentElement&&document.documentElement.scrollTop){return document.documentElement.scrollTop}if(document.body){return document.body.scrollTop}return 0},optimize_font_size:function(){var a=w3c_slidy.slides[w3c_slidy.slide_number];var d=a.scrollHeight;var b=getWindowHeight();var c=100*d/b;alert("window utilization = "+c+"% (doc "+d+" win "+b+")")},get_doc_height:function(a){if(!a){a=document}if(a&&a.body&&a.body.offsetHeight){return a.body.offsetHeight}if(a&&a.body&&a.body.scrollHeight){return a.body.scrollHeight}alert("couldn't determine document height")},get_window_height:function(){if(typeof(window.innerHeight)=="number"){return window.innerHeight}if(document.documentElement&&document.documentElement.clientHeight){return document.documentElement.clientHeight}if(document.body&&document.body.clientHeight){return document.body.clientHeight}},document_height:function(){var a,b;a=document.body.scrollHeight;b=document.body.offsetHeight;if(a&&b){return(a>b?a:b)}return 0},smaller:function(){if(w3c_slidy.size_index>0){--w3c_slidy.size_index}w3c_slidy.toolbar.style.display="none";document.body.style.fontSize=w3c_slidy.sizes[w3c_slidy.size_index];var a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.show_slide(a);setTimeout(function(){w3c_slidy.show_toolbar()},50)},bigger:function(){if(w3c_slidy.size_index<w3c_slidy.sizes.length-1){++w3c_slidy.size_index}w3c_slidy.toolbar.style.display="none";document.body.style.fontSize=w3c_slidy.sizes[w3c_slidy.size_index];var a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.show_slide(a);setTimeout(function(){w3c_slidy.show_toolbar()},50)},adjust_object_dimensions:function(c,k){for(var e=0;e<w3c_slidy.objects.length;e++){var d=this.objects[e];var b=d.getAttribute("type");if(b=="image/svg+xml"||b=="application/x-shockwave-flash"){if(!d.initialWidth){d.initialWidth=d.getAttribute("width")}if(!d.initialHeight){d.initialHeight=d.getAttribute("height")}if(d.initialWidth&&d.initialWidth.charAt(d.initialWidth.length-1)=="%"){var j=parseInt(d.initialWidth.slice(0,d.initialWidth.length-1));var a=c*(j/100);d.setAttribute("width",a)}if(d.initialHeight&&d.initialHeight.charAt(d.initialHeight.length-1)=="%"){var f=parseInt(d.initialHeight.slice(0,d.initialHeight.length-1));var g=k*(f/100);d.setAttribute("height",g)}}}},key_press:function(a){if(!a){a=window.event}if(!w3c_slidy.key_wanted){return w3c_slidy.cancel(a)}return true},key_down:function(d){var c,e,a;w3c_slidy.key_wanted=true;if(!d){d=window.event}if(window.event){c=window.event.keyCode;e=window.event.srcElement}else{if(d.which){c=d.which;e=d.target}else{return true}}if(!c){return true}if(!w3c_slidy.slidy_chrome(e)&&w3c_slidy.special_element(e)){return true}if(d.ctrlKey||d.altKey||d.metaKey){return true}if(w3c_slidy.is_shown_toc()&&c!=9&&c!=16&&c!=38&&c!=40){w3c_slidy.hide_table_of_contents(true);if(c==27||c==84||c==67){return w3c_slidy.cancel(d)}}if(c==34){if(w3c_slidy.view_all){return true}w3c_slidy.next_slide(false);return w3c_slidy.cancel(d)}else{if(c==33){if(w3c_slidy.view_all){return true}w3c_slidy.previous_slide(false);return w3c_slidy.cancel(d)}else{if(c==32){w3c_slidy.next_slide(true);return w3c_slidy.cancel(d)}else{if(c==37){w3c_slidy.previous_slide(!d.shiftKey);return w3c_slidy.cancel(d)}else{if(c==36){w3c_slidy.first_slide();return w3c_slidy.cancel(d)}else{if(c==35){w3c_slidy.last_slide();return w3c_slidy.cancel(d)}else{if(c==39){w3c_slidy.next_slide(!d.shiftKey);return w3c_slidy.cancel(d)}else{if(c==13){if(w3c_slidy.outline){if(w3c_slidy.outline.visible){w3c_slidy.fold(w3c_slidy.outline)}else{w3c_slidy.unfold(w3c_slidy.outline)}return w3c_slidy.cancel(d)}}else{if(c==188){w3c_slidy.smaller();return w3c_slidy.cancel(d)}else{if(c==190){w3c_slidy.bigger();return w3c_slidy.cancel(d)}else{if(c==189||c==109){w3c_slidy.smaller();return w3c_slidy.cancel(d)}else{if(c==187||c==191||c==107){w3c_slidy.bigger();return w3c_slidy.cancel(d)}else{if(c==83){w3c_slidy.smaller();return w3c_slidy.cancel(d)}else{if(c==66){w3c_slidy.bigger();return w3c_slidy.cancel(d)}else{if(c==90){w3c_slidy.last_slide();return w3c_slidy.cancel(d)}else{if(c==70){w3c_slidy.toggle_toolbar();return w3c_slidy.cancel(d)}else{if(c==65){w3c_slidy.toggle_view();return w3c_slidy.cancel(d)}else{if(c==75){w3c_slidy.mouse_click_enabled=!w3c_slidy.mouse_click_enabled;var b=(w3c_slidy.mouse_click_enabled?"enabled":"disabled")+" mouse click advance";alert(w3c_slidy.localize(b));return w3c_slidy.cancel(d)}else{if(c==84||c==67){if(w3c_slidy.toc){w3c_slidy.toggle_table_of_contents()}return w3c_slidy.cancel(d)}else{if(c==72){window.location=w3c_slidy.help_page;return w3c_slidy.cancel(d)}}}}}}}}}}}}}}}}}}}}return true},create_element:function(a){if(this.xhtml&&(typeof document.createElementNS!="undefined")){return document.createElementNS("http://www.w3.org/1999/xhtml",a)}return document.createElement(a)},get_element_style:function(d,b,c){if(d.currentStyle){return d.currentStyle[b]}else{if(window.getComputedStyle){var a=window.getComputedStyle(d,"");return a.getPropertyValue(c)}}return""},has_token:function(e,c){if(e){var d=/\w+/g;var a=e.match(d);for(var b=0;b<a.length;b++){if(a[b]==c){return true}}}return false},get_class_list:function(a){if(typeof a.className!="undefined"){return a.className}return a.getAttribute("class")},has_class:function(b,a){if(b.nodeType!=1){return false}var c=new RegExp("(^| )"+a+"W*");if(typeof b.className!="undefined"){return c.test(b.className)}return c.test(b.getAttribute("class"))},remove_class:function(b,a){var d=new RegExp("(^| )"+a+"W*");var c="";if(typeof b.className!="undefined"){c=b.className;if(c){c=c.replace(d,"");b.className=c}}else{c=b.getAttribute("class");if(c){c=c.replace(d,"");b.setAttribute("class",c)}}},add_class:function(b,a){if(!this.has_class(b,a)){if(typeof b.className!="undefined"){b.className+=" "+a}else{var c=b.getAttribute("class");c=c?c+" "+a:a;b.setAttribute("class",c)}}},incremental_elements:null,okay_for_incremental:function(a){if(!this.incremental_elements){var b=new Array();b.p=true;b.pre=true;b.li=true;b.blockquote=true;b.dt=true;b.dd=true;b.h2=true;b.h3=true;b.h4=true;b.h5=true;b.h6=true;b.span=true;b.address=true;b.table=true;b.tr=true;b.th=true;b.td=true;b.img=true;b.object=true;this.incremental_elements=b}return this.incremental_elements[a.toLowerCase()]},next_incremental_item:function(c){var b=this.is_xhtml?"br":"BR";var a=w3c_slidy.slides[w3c_slidy.slide_number];for(;;){c=w3c_slidy.next_node(a,c);if(c==null||c.parentNode==null){break}if(c.nodeType==1){if(c.nodeName==b){continue}if(w3c_slidy.has_class(c,"incremental")&&w3c_slidy.okay_for_incremental(c.nodeName)){return c}if(w3c_slidy.has_class(c.parentNode,"incremental")&&!w3c_slidy.has_class(c,"non-incremental")){return c}}}return c},previous_incremental_item:function(c){var b=this.is_xhtml?"br":"BR";var a=w3c_slidy.slides[w3c_slidy.slide_number];for(;;){c=w3c_slidy.previous_node(a,c);if(c==null||c.parentNode==null){break}if(c.nodeType==1){if(c.nodeName==b){continue}if(w3c_slidy.has_class(c,"incremental")&&w3c_slidy.okay_for_incremental(c.nodeName)){return c}if(w3c_slidy.has_class(c.parentNode,"incremental")&&!w3c_slidy.has_class(c,"non-incremental")){return c}}}return c},set_visibility_all_incremental:function(b){var a=this.next_incremental_item(null);if(b=="hidden"){while(a){w3c_slidy.add_class(a,"invisible");a=w3c_slidy.next_incremental_item(a)}}else{while(a){w3c_slidy.remove_class(a,"invisible");a=w3c_slidy.next_incremental_item(a)}}},reveal_next_item:function(a){a=w3c_slidy.next_incremental_item(a);if(a&&a.nodeType==1){w3c_slidy.remove_class(a,"invisible")}return a},hide_previous_item:function(a){if(a&&a.nodeType==1){w3c_slidy.add_class(a,"invisible")}return this.previous_incremental_item(a)},next_node:function(a,b){if(b==null){return a.firstChild}if(b.firstChild){return b.firstChild}if(b.nextSibling){return b.nextSibling}for(;;){b=b.parentNode;if(!b||b==a){break}if(b&&b.nextSibling){return b.nextSibling}}return null},previous_node:function(a,b){if(b==null){b=a.lastChild;if(b){while(b.lastChild){b=b.lastChild}}return b}if(b.previousSibling){b=b.previousSibling;while(b.lastChild){b=b.lastChild}return b}if(b.parentNode!=a){return b.parentNode}return null},previous_sibling_element:function(a){a=a.previousSibling;while(a&&a.nodeType!=1){a=a.previousSibling}return a},next_sibling_element:function(a){a=a.nextSibling;while(a&&a.nodeType!=1){a=a.nextSibling}return a},first_child_element:function(a){var b;for(b=a.firstChild;b;b=b.nextSibling){if(b.nodeType==1){break}}return b},first_tag:function(b,a){var c;if(!this.is_xhtml){a=a.toUpperCase()}for(c=b.firstChild;c;c=c.nextSibling){if(c.nodeType==1&&c.nodeName==a){break}}return c},hide_selection:function(){if(window.getSelection){var b=window.getSelection();if(b.rangeCount>0){var a=b.getRangeAt(0);a.collapse(false)}}else{var c=document.selection.createRange();c.collapse(false)}},get_selected_text:function(){try{if(window.getSelection){return window.getSelection().toString()}if(document.getSelection){return document.getSelection().toString()}if(document.selection){return document.selection.createRange().text}}catch(a){}return""},mouse_button_up:function(a){w3c_slidy.selected_text_len=w3c_slidy.get_selected_text().length},mouse_button_click:function(g){var c=false;var b=false;var d=false;var f;if(!g){var g=window.event}if(g.target){f=g.target}else{if(g.srcElement){f=g.srcElement}}if(f.nodeType==3){f=f.parentNode}if(g.which){b=(g.which==1);d=(g.which==2);c=(g.which==3)}else{if(g.button){if(g.button==4){d=true}c=(g.button==2)}else{b=true}}if(w3c_slidy.selected_text_len>0){w3c_slidy.stop_propagation(g);g.cancel=true;g.returnValue=false;return false}w3c_slidy.hide_table_of_contents(false);var a=f.nodeName.toLowerCase();if(w3c_slidy.mouse_click_enabled&&b&&!w3c_slidy.special_element(f)&&!f.onclick){w3c_slidy.next_slide(true);w3c_slidy.stop_propagation(g);g.cancel=true;g.returnValue=false;return false}return true},special_element:function(b){var a=b.nodeName.toLowerCase();return b.onkeydown||b.onclick||a=="a"||a=="embed"||a=="object"||a=="video"||a=="audio"||a=="input"||a=="textarea"||a=="select"||a=="option"},slidy_chrome:function(a){while(a){if(a==w3c_slidy.toc||a==w3c_slidy.toolbar||w3c_slidy.has_class(a,"outline")){return true}a=a.parentNode}return false},get_key:function(b){var a;if(typeof window.event!="undefined"){a=window.event.keyCode}else{if(b.which){a=b.which}}return a},get_target:function(b){var a;if(!b){b=window.event}if(b.target){a=b.target}else{if(b.srcElement){a=b.srcElement}}if(a.nodeType!=1){a=a.parentNode}return a},is_block:function(b){var a=b.nodeName.toLowerCase();return a=="ol"||a=="ul"||a=="p"||a=="li"||a=="table"||a=="pre"||a=="h1"||a=="h2"||a=="h3"||a=="h4"||a=="h5"||a=="h6"||a=="blockquote"||a=="address"},add_listener:function(a,c,b){if(window.addEventListener){a.addEventListener(c,b,false)}else{a.attachEvent("on"+c,b)}},stop_propagation:function(a){a=a?a:window.event;a.cancelBubble=true;if(a.stopPropagation){a.stopPropagation()}return true},cancel:function(a){if(a){a.cancel=true;a.returnValue=false;if(a.preventDefault){a.preventDefault()}}w3c_slidy.key_wanted=false;return false},strings_es:{slide:"pág.","help?":"Ayuda","contents?":"Índice","table of contents":"tabla de contenidos","Table of Contents":"Tabla de Contenidos","restart presentation":"Reiniciar presentación","restart?":"Inicio"},help_es:"Utilice el ratón, barra espaciadora, teclas Izda/Dcha, o Re pág y Av pág. Use S y B para cambiar el tamaño de fuente.",strings_ca:{slide:"pàg..","help?":"Ajuda","contents?":"Índex","table of contents":"taula de continguts","Table of Contents":"Taula de Continguts","restart presentation":"Reiniciar presentació","restart?":"Inici"},help_ca:"Utilitzi el ratolí, barra espaiadora, tecles Esq./Dta. o Re pàg y Av pàg. Usi S i B per canviar grandària de font.",strings_cs:{slide:"snímek","help?":"nápověda","contents?":"obsah","table of contents":"obsah prezentace","Table of Contents":"Obsah prezentace","restart presentation":"znovu spustit prezentaci","restart?":"restart"},help_cs:"Prezentaci můžete procházet pomocí kliknutí myši, mezerníku, šipek vlevo a vpravo nebo kláves PageUp a PageDown. Písmo se dá zvětšit a zmenšit pomocí kláves B a S.",strings_nl:{slide:"pagina","help?":"Help?","contents?":"Inhoud?","table of contents":"inhoudsopgave","Table of Contents":"Inhoudsopgave","restart presentation":"herstart presentatie","restart?":"Herstart?"},help_nl:"Navigeer d.m.v. het muis, spatiebar, Links/Rechts toetsen, of PgUp en PgDn. Gebruik S en B om de karaktergrootte te veranderen.",strings_de:{slide:"Seite","help?":"Hilfe","contents?":"Übersicht","table of contents":"Inhaltsverzeichnis","Table of Contents":"Inhaltsverzeichnis","restart presentation":"Präsentation neu starten","restart?":"Neustart"},help_de:"Benutzen Sie die Maus, Leerschlag, die Cursortasten links/rechts oder Page up/Page Down zum Wechseln der Seiten und S und B für die Schriftgrösse.",strings_pl:{slide:"slajd","help?":"pomoc?","contents?":"spis treści?","table of contents":"spis treści","Table of Contents":"Spis Treści","restart presentation":"Restartuj prezentację","restart?":"restart?"},help_pl:"Zmieniaj slajdy klikając myszą, naciskając spację, strzałki lewo/prawolub PgUp / PgDn. Użyj klawiszy S i B, aby zmienić rozmiar czczionki.",strings_fr:{slide:"page","help?":"Aide","contents?":"Index","table of contents":"table des matières","Table of Contents":"Table des matières","restart presentation":"Recommencer l'exposé","restart?":"Début"},help_fr:"Naviguez avec la souris, la barre d'espace, les flèches gauche/droite ou les touches Pg Up, Pg Dn. Utilisez les touches S et B pour modifier la taille de la police.",strings_hu:{slide:"oldal","help?":"segítség","contents?":"tartalom","table of contents":"tartalomjegyzék","Table of Contents":"Tartalomjegyzék","restart presentation":"bemutató újraindítása","restart?":"újraindítás"},help_hu:"Az oldalak közti lépkedéshez kattintson az egérrel, vagy használja a szóköz, a bal, vagy a jobb nyíl, illetve a Page Down, Page Up billentyűket. Az S és a B billentyűkkel változtathatja a szöveg méretét.",strings_it:{slide:"pag.","help?":"Aiuto","contents?":"Indice","table of contents":"indice","Table of Contents":"Indice","restart presentation":"Ricominciare la presentazione","restart?":"Inizio"},help_it:"Navigare con mouse, barra spazio, frecce sinistra/destra o PgUp e PgDn. Usare S e B per cambiare la dimensione dei caratteri.",strings_el:{slide:"σελίδα","help?":"βοήθεια;","contents?":"περιεχόμενα;","table of contents":"πίνακας περιεχομένων","Table of Contents":"Πίνακας Περιεχομένων","restart presentation":"επανεκκίνηση παρουσίασης","restart?":"επανεκκίνηση;"},help_el:"Πλοηγηθείτε με το κλίκ του ποντικιού, το space, τα βέλη αριστερά/δεξιά, ή Page Up και Page Down. Χρησιμοποιήστε τα πλήκτρα S και B για να αλλάξετε το μέγεθος της γραμματοσειράς.",strings_ja:{slide:"スライド","help?":"ヘルプ","contents?":"目次","table of contents":"目次を表示","Table of Contents":"目次","restart presentation":"最初から再生","restart?":"最初から"},help_ja:"マウス左クリック ・ スペース ・ 左右キー または Page Up ・ Page Downで操作， S ・ Bでフォントサイズ変更",strings_zh:{slide:"幻灯片","help?":"帮助?","contents?":"内容?","table of contents":"目录","Table of Contents":"目录","restart presentation":"重新启动展示","restart?":"重新启动?"},help_zh:"用鼠标点击, 空格条, 左右箭头, Pg Up 和 Pg Dn 导航. 用 S, B 改变字体大小.",strings_ru:{slide:"слайд","help?":"помощь?","contents?":"содержание?","table of contents":"оглавление","Table of Contents":"Оглавление","restart presentation":"перезапустить презентацию","restart?":"перезапуск?"},help_ru:"Перемещайтесь кликая мышкой, используя клавишу пробел, стрелкивлево/вправо или Pg Up и Pg Dn. Клавиши S и B меняют размер шрифта.",strings_sv:{slide:"sida","help?":"hjälp","contents?":"innehåll","table of contents":"innehållsförteckning","Table of Contents":"Innehållsförteckning","restart presentation":"visa presentationen från början","restart?":"börja om"},help_sv:"Bläddra med ett klick med vänstra musknappen, mellanslagstangenten, vänster- och högerpiltangenterna eller tangenterna Pg Up, Pg Dn. Använd tangenterna S och B för att ändra textens storlek.",strings:{},localize:function(d){if(d==""){return d}var b,c=w3c_slidy.strings[w3c_slidy.lang];if(c){b=c[d];if(b){return b}}var a=w3c_slidy.lang.split("-");if(a.length>1){c=w3c_slidy.strings[a[0]];if(c){b=c[d];if(b){return b}}}return d},init_localization:function(){var b=w3c_slidy;var a=w3c_slidy.help_text;this.strings={es:this.strings_es,ca:this.strings_ca,cs:this.strings_cs,nl:this.strings_nl,de:this.strings_de,pl:this.strings_pl,fr:this.strings_fr,hu:this.strings_hu,it:this.strings_it,el:this.strings_el,jp:this.strings_ja,zh:this.strings_zh,ru:this.strings_ru,sv:this.strings_sv},b.strings_es[a]=b.help_es;b.strings_ca[a]=b.help_ca;b.strings_cs[a]=b.help_cs;b.strings_nl[a]=b.help_nl;b.strings_de[a]=b.help_de;b.strings_pl[a]=b.help_pl;b.strings_fr[a]=b.help_fr;b.strings_hu[a]=b.help_hu;b.strings_it[a]=b.help_it;b.strings_el[a]=b.help_el;b.strings_ja[a]=b.help_ja;b.strings_zh[a]=b.help_zh;b.strings_ru[a]=b.help_ru;b.strings_sv[a]=b.help_sv;w3c_slidy.lang=document.body.parentNode.getAttribute("lang");if(!w3c_slidy.lang){w3c_slidy.lang=document.body.parentNode.getAttribute("xml:lang")}if(!w3c_slidy.lang){w3c_slidy.lang="en"}}};if(w3c_slidy.ie6||w3c_slidy.ie7){document.write("<iframe id='historyFrame' src='javascript:\"<html></html>\"' height='1' width='1' style='position:absolute;left:-800px'></iframe>")}w3c_slidy.set_up();setTimeout(w3c_slidy.hide_slides,50);
/*]]>*/
</script>
</head>
<body>
<div class="slide">
<h1 id="cs240h-functional-systems-in-haskell">CS240h: Functional systems in Haskell</h1>
<ul>
<li>I'm David Mazières
<ul>
<li>Spent most of my career working on OSes, Systems, and Security</li>
<li>Previously used C++ and C, but started using Haskell a couple of years ago</li>
<li>Course partly inspired by my experience learning Haskell</li>
</ul></li>
<li>Also teaching this class: Bryan O'Sullivan
<ul>
<li>Has implemented many key Haskell libraries in widespread use today</li>
<li>Co-wrote <a href="http://book.realworldhaskell.org/"><em>Real World Haskell</em></a>, a great non-theoretical intro book</li>
<li>Also plenty of systems experience (e.g., Linux early userspace code)</li>
</ul></li>
<li>Course assistant: David Terei
<ul>
<li>Implemented LLVM backend and type-safe extensions that ship with GHC Haskell compiler</li>
<li>Currently using Haskell for security research here at Stanford</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="why-haskell">Why Haskell?</h1>
<ul>
<li>Haskell's expressive power can improve productivity
<ul>
<li>Small language core provides big flexibility</li>
<li>Code can be very concise, speeding development</li>
<li>Get best of both worlds from compiled and interpreted languages</li>
</ul></li>
<li>Haskell makes code easier to understand and maintain
<ul>
<li>Can dive into complex libraries and understand <em>what</em> the code is doing<br> (<em>why</em> may be a different story, but conciseness leaves room for comments...)</li>
</ul></li>
<li>Haskell can increase the robustness of systems
<ul>
<li>Strong typing catches many bugs at compile time</li>
<li>Functional code permits better testing methodologies</li>
<li>Can parallelize non-concurrent code without changing semantics</li>
<li>Concurrent programming abstractions resistant to data races</li>
</ul></li>
<li>Haskell lets you realize new types of functionality (DIFC, STM, ...)</li>
</ul>
</div>
<div class="slide">
<h1 id="why-take-cs240h">Why take CS240h?</h1>
<ul>
<li>Learn to build systems in Haskell with reduced upfront cost
<ul>
<li>Historically, Haskell was a vehicle for language research.<br> The history is reflected in how the language is usually taught</li>
<li>CS240h will present the language more from a systems perspective</li>
</ul></li>
<li>Learn new, surprising, and effective programming techniques
<ul>
<li>There are more than enough to fill a 10-week quarter</li>
<li>Often only documented in more theoretical papers</li>
</ul></li>
<li><strong>You enjoy programming</strong>
<ul>
<li>With Haskell, you will think about programming in new ways</li>
</ul></li>
<li>You sometimes get frustrated with other languages
<ul>
<li>Maybe you've wanted to design a new language, or tend to &quot;max-out&quot; existing language features (macros, templates, overloading, etc.)</li>
<li>Things that require changes to most languages can be done in a library with Haskell</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="administrivia">Administrivia</h1>
<ul>
<li>We assume some of you may have toyed with Haskell, others not</li>
<li>First week cover Haskell basics
<ul>
<li>If you haven't used Haskell, you should supplement by reading parts of <a href="http://book.realworldhaskell.org/">Bryan's book</a> and/or on-line tutorials (such as <a href="http://www.haskell.org/tutorial/"><code class="url">http://www.haskell.org/tutorial/</code></a>).</li>
<li>If you have used Haskell, you may still learn some things from these lectures</li>
</ul></li>
<li>Rest of term covers more advanced techniques</li>
<li>Final grade will be based on several factors
<ol style="list-style-type: decimal">
<li>Two small warm-up solo programming exercises</li>
<li>A large final project &amp; presentation</li>
<li>Class attendance and participation</li>
</ol></li>
</ul>
</div>
<div class="slide">
<h1 id="final-project">Final project</h1>
<ul>
<li>Final project is most important component of grade</li>
<li>Consists of a Haskell-related project of your choice
<ul>
<li>Form project team of 1-3 people</li>
<li>Meet with one of the instructors to discuss project</li>
<li>Complete and evaluate project and turn in short paper</li>
<li>Final exam will be mini-conference where you present your work<br><strong>(Make sure you are here for exam December 15)</strong></li>
</ul></li>
<li>Class home page has list of <a href="http://cs240h.scs.stanford.edu/labs/project.html">suggested projects</a> (we will add more)</li>
<li>We encourage overlap of CS240h project with your research
<ul>
<li>The programming techniques you learn in CS240h are likely orthogonal to whatever research you are doing</li>
</ul></li>
<li>We are okay with CS240h project also serving as another class project,<br><strong>provided the other instructor and all teammates (from both classes) approve</strong></li>
</ul>
</div>
<div class="slide">
<h1 id="getting-started-with-haskell">Getting started with Haskell</h1>
<ul>
<li>Install the <a href="http://hackage.haskell.org/platform/">Haskell Platform</a>, which includes the <a href="http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html">GHC</a> compiler.</li>
<li><p>Create a file called <code>hello.hs</code> with the following contents:</p>
<pre class="sourceCode"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;Hello, world!&quot;</span></code></pre></li>
<li><p>Compile your program to a native executable like this:</p>
<pre><code>$ ghc --make hello
[1 of 1] Compiling Main             ( hello.hs, hello.o )
Linking hello ...
$ ./hello
Hello, world!
</code></pre></li>
<li><p>Or run it in the <a href="http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci.html">GHCI interpreter</a> like this:</p>
<pre><code>$ ghci hello.hs 
GHCi, version 7.0.3: http://www.haskell.org/ghc/  :? for help
...
Ok, modules loaded: Main.
*Main&gt; main
Hello, world!
*Main&gt; 
</code></pre></li>
</ul>
</div>
<div class="slide">
<h1 id="bindings">Bindings</h1>
<ul>
<li><p>Haskell uses the <code>=</code> sign to declare <em>bindings</em>:</p>
<pre class="sourceCode"><code class="sourceCode haskell">x <span class="fu">=</span> <span class="dv">2</span>                   <span class="co">-- Two hyphens introduce a comment</span><br />y <span class="fu">=</span> <span class="dv">3</span>                   <span class="co">--    ...that continues to end of line.</span><br />main <span class="fu">=</span> <span class="kw">let</span> z <span class="fu">=</span> x <span class="fu">+</span> y    <span class="co">-- let introduces local bindings</span><br />       <span class="kw">in</span> <span class="fu">print</span> z       <span class="co">-- program will print 5</span></code></pre>
<ul>
<li>Bound names cannot start with upper-case letters</li>
<li>Bindings are separated by &quot;<code>;</code>&quot;, which is usually auto-inserted by a <a href="http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7">layout</a> rule</li>
</ul></li>
<li>A binding may declare a <em>function</em> of one or more arguments
<ul>
<li>Function and arguments are separated by spaces (when defining or invoking them)</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell">add arg1 arg2 <span class="fu">=</span> arg1 <span class="fu">+</span> arg2   <span class="co">-- defines function add</span><br />five <span class="fu">=</span> add <span class="dv">2</span> <span class="dv">3</span>                <span class="co">-- invokes function add</span></code></pre></li>
<li><p>Parentheses can wrap compound expressions, must do so for arguments</p>
<pre class="sourceCode"><code class="sourceCode haskell">bad <span class="fu">=</span> <span class="fu">print</span> add <span class="dv">2</span> <span class="dv">3</span>     <span class="co">-- error! (print should have only 1 argument)</span></code></pre>
<pre class="sourceCode"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="fu">print</span> (add <span class="dv">2</span> <span class="dv">3</span>)  <span class="co">-- ok, calls print with 1 argument, 5</span></code></pre></li>
</ul>
</div>
<div class="slide">
<h1 id="haskell-is-a-pure-functional-language">Haskell is a <em>pure</em> functional language</h1>
<ul>
<li>Unlike variables in imperative languages, Haskell bindings are
<ul>
<li><em>immutable</em> - can only bind a symbol once in a give scope<br> (We still call bound symbols &quot;variables&quot; though)</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell">x <span class="fu">=</span> <span class="dv">5</span><br />x <span class="fu">=</span> <span class="dv">6</span>                      <span class="co">-- error, cannot re-bind x</span></code></pre>
<ul>
<li><em>order-independent</em> - order of bindings in source code does not matter</li>
<li><em>lazy</em> - definitions of symbols are evaluated only when needed</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell">safeDiv x y <span class="fu">=</span><br />    <span class="kw">let</span> q <span class="fu">=</span> <span class="fu">div</span> x y        <span class="co">-- safe as q never evaluated if y == 0</span><br />    <span class="kw">in</span> <span class="kw">if</span> y <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> q<br />main <span class="fu">=</span> <span class="fu">print</span> (safeDiv <span class="dv">1</span> <span class="dv">0</span>) <span class="co">-- prints 0</span></code></pre>
<ul>
<li><em>recursive</em> - the bound symbol is in scope within its own definition</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell">x <span class="fu">=</span> <span class="dv">5</span>                 <span class="co">-- this x is not used in main</span><br /><br />main <span class="fu">=</span> <span class="kw">let</span> x <span class="fu">=</span> x <span class="fu">+</span> <span class="dv">1</span>  <span class="co">-- introduces new x, defined in terms of itself</span><br />       <span class="kw">in</span> <span class="fu">print</span> x     <span class="co">-- program &quot;diverges&quot; (i.e., loops forever)</span></code></pre></li>
</ul>
</div>
<div class="slide">
<h1 id="how-to-program-without-mutable-variables">How to program without mutable variables?</h1>
<ul>
<li><p>In C, we use mutable variables to create loops:</p>
<pre class="sourceCode"><code class="sourceCode c"><span class="dt">long</span> factorial (<span class="dt">int</span> n)<br />{<br />  <span class="dt">long</span> result = <span class="dv">1</span>;<br />  <span class="kw">while</span> (n &gt; <span class="dv">1</span>)<br />    result *= n--;<br />  <span class="kw">return</span> result;<br />}</code></pre></li>
<li><p>In Haskell, can use recursion to &quot;re-bind&quot; argument symbols in new scope</p>
<pre class="sourceCode"><code class="sourceCode haskell">factorial n <span class="fu">=</span> <span class="kw">if</span> n <span class="fu">&gt;</span> <span class="dv">1</span><br />              <span class="kw">then</span> n <span class="fu">*</span> factorial (n<span class="fu">-</span><span class="dv">1</span>)<br />              <span class="kw">else</span> <span class="dv">1</span></code></pre>
<ul>
<li>Recursion often fills a similar need to mutable variables</li>
<li>But the above Haskell factorial is inferior to the C one--why?</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="tail-recursion">Tail recursion</h1>
<ul>
<li>Each recursive call may require a stack frame
<ul>
<li><p>This Haskell code requires <code>n</code> stack frames</p>
<pre class="sourceCode"><code class="sourceCode haskell">factorial n <span class="fu">=</span> <span class="kw">if</span> n <span class="fu">&gt;</span> <span class="dv">1</span> <span class="kw">then</span> n <span class="fu">*</span> factorial (n<span class="fu">-</span><span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span></code></pre></li>
<li>By contrast, our C factorial ran in constant space</li>
</ul></li>
<li>Fortunately, Haskell supports optimized <em>tail recursion</em>
<ul>
<li>A function is tail recursive if it ends with a call to itself</li>
<li>Unfortunately, <code>factorial n</code> multiplies by <code>n</code> <em>after</em> evaluating <code>factorial (n-1)</code></li>
</ul></li>
<li><p>Idea: use <em>accumulator</em> argument to make calls tail recursive</p>
<pre class="sourceCode"><code class="sourceCode haskell">factorial n <span class="fu">=</span> <span class="kw">let</span> loop acc n' <span class="fu">=</span> <span class="kw">if</span> n' <span class="fu">&gt;</span> <span class="dv">1</span><br />                                <span class="kw">then</span> loop (acc <span class="fu">*</span> n') (n' <span class="fu">-</span> <span class="dv">1</span>)<br />                                <span class="kw">else</span> acc<br />              <span class="kw">in</span> loop <span class="dv">1</span> n</code></pre>
<ul>
<li>Here <code>loop</code> is tail recursive, compiles to an actual loop</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="guards-and-where-clauses">Guards and <code>where</code> clauses</h1>
<ul>
<li><p><em>Guards</em> let you shorten function declarations:</p>
<pre class="sourceCode"><code class="sourceCode haskell">factorial n <span class="fu">=</span> <span class="kw">let</span> loop acc n' <span class="fu">|</span> n' <span class="fu">&gt;</span> <span class="dv">1</span> <span class="fu">=</span> loop (acc <span class="fu">*</span> n') (n' <span class="fu">-</span> <span class="dv">1</span>)<br />                              <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> acc<br />              <span class="kw">in</span> loop <span class="dv">1</span> n</code></pre>
<ul>
<li>&quot;<code>|</code>&quot; symbol introduces a guard</li>
<li>Guards are evaluated top to bottom; the first <code>True</code> guard wins</li>
<li>The system Prelude (standard library) defines <code>otherwise = True</code></li>
</ul></li>
<li><p>Bindings can also end with <code>where</code> clauses--like inverted <code>let</code></p>
<pre class="sourceCode"><code class="sourceCode haskell">factorial n <span class="fu">=</span> loop <span class="dv">1</span> n<br />    <span class="kw">where</span> loop acc n' <span class="fu">|</span> n' <span class="fu">&gt;</span> <span class="dv">1</span>    <span class="fu">=</span> loop (acc <span class="fu">*</span> n') (n' <span class="fu">-</span> <span class="dv">1</span>)<br />                      <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> acc</code></pre>
<ul>
<li>Unlike <code>let</code>, a <code>where</code> clause scopes over multiple guarded definitions</li>
<li>This is convenient for binding variables to use in guards</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="tip-variable-names">Tip: variable names</h1>
<ul>
<li>Inner functions (e.g., <code>loop</code>) often have arguments related to outer function
<ul>
<li>It is legal to shadow bindings and re-use variable names, but the compiler will warn you</li>
<li>Typical practice is to add <code>'</code> (prime) to the inner-function's argument</li>
<li>Haskell accepts the <code>'</code> character in variables, except as first character</li>
</ul></li>
<li>Personally, I find this practice a bit error-prone
<ul>
<li>While learning Haskell, I repeatedly made the error of dropping primes, e.g.:</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell">factorial n <span class="fu">=</span> loop <span class="dv">1</span> n<br />    <span class="kw">where</span> loop acc n' <span class="fu">|</span> n' <span class="fu">&gt;</span> <span class="dv">1</span>    <span class="fu">=</span> loop (acc <span class="fu">*</span> n) (n' <span class="fu">-</span> <span class="dv">1</span>) <span class="co">-- bug</span><br />                      <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> acc</code></pre>
<ul>
<li>You can avoid the problem by using the longer symbol name for the outer function</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell">factorial n0 <span class="fu">=</span> loop <span class="dv">1</span> n0<br />    <span class="kw">where</span> loop acc n <span class="fu">|</span> n <span class="fu">&gt;</span> <span class="dv">1</span>     <span class="fu">=</span> loop (acc <span class="fu">*</span> n) (n <span class="fu">-</span> <span class="dv">1</span>)<br />                     <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> acc</code></pre>
<ul>
<li>Here accidentally typing &quot;<code>factorial n0 = loop 1 n</code>&quot; causes compile error</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="every-expression-and-binding-has-a-type">Every expression and binding has a type</h1>
<ul>
<li>Some basic types:
<ul>
<li><code>Bool</code> - either <code>True</code> or <code>False</code></li>
<li><code>Char</code> - a unicode code point (i.e., a character)</li>
<li><code>Int</code> - fixed-size integer</li>
<li><code>Integer</code> - an arbitrary-size integer</li>
<li><code>Double</code> - an IEEE double-precision floating-point number</li>
<li><em>type1</em> <code>-&gt;</code> <em>type2</em> - a function from <em>type1</em> to <em>type2</em></li>
<li><code>(</code><em>type1</em><code>,</code> <em>type2</em><code>,</code> ...<code>,</code> <em>typeN</em><code>)</code> - a tuple</li>
<li><code>()</code> - a zero-tuple, pronounced <em>unit</em> (kind of like <code>void</code> in C); there only one value of this type, also written <code>()</code></li>
</ul></li>
<li><p>You can declare the type of a symbol or expression with <code>::</code></p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">x </span><span class="ot">::</span> <span class="dt">Integer</span><br />x <span class="fu">=</span> (<span class="dv">1</span><span class="ot"> </span><span class="ot">::</span> <span class="dt">Integer</span>) <span class="fu">+</span> (<span class="dv">1</span><span class="ot"> </span><span class="ot">::</span> <span class="dt">Integer</span>)<span class="ot"> </span><span class="ot">::</span> <span class="dt">Integer</span></code></pre>
<ul>
<li><code>::</code> has lower precedence than any function operators (including <code>+</code>)</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="more-on-types">More on types</h1>
<ul>
<li><p>Function application happens one argument at a time (a.k.a. &quot;<em>currying</em>&quot;)</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">add </span><span class="ot">::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>)<br />add arg1 arg2 <span class="fu">=</span> arg1 <span class="fu">+</span> arg2</code></pre>
<ul>
<li>So <code>add 2 3</code> is equivalent to <code>(add 2) 3</code></li>
<li><code>(add 2)</code> takes 3 returns 5, so <code>(add 2) has type Integer -&gt; Integer</code></li>
<li><code>-&gt;</code> associates to the right, so parens usually omitted in multi-argument function types:<br> <code>fn ::</code> <em>argType1</em> <code>-&gt;</code> <em>argType2</em> <code>-&gt;</code> ... <code>-&gt;</code> <em>argTypeN</em> <code>-&gt;</code> <em>resultType</em></li>
</ul></li>
<li>Usually the compiler can infer types
<ul>
<li>You can ask <a href="http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci.html">GHCI</a> to show you inferred types with <code>:t</code></li>
</ul>
<pre><code>*Main&gt; :t add
add :: Integer -&gt; Integer -&gt; Integer
</code></pre>
<ul>
<li>Good practice to declare types of top-level bindings anyway (compiler warns if missing)</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="user-defined-data-types">User-defined data types</h1>
<ul>
<li><p>The <code>data</code> keyword declares user-defined data types (like <code>struct</code> in C), E.g.:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">PointT</span> <span class="fu">=</span> <span class="dt">PointC</span> <span class="dt">Double</span> <span class="dt">Double</span> <span class="kw">deriving</span> <span class="kw">Show</span></code></pre>
<ul>
<li>This declaration declares a new type, <code>PointT</code>, and constructor, <code>PointC</code></li>
<li>A value of type <code>PointT</code> contains two <code>Double</code>s</li>
<li><code>deriving Show</code> means you can print the type (helpful in GHCI)</li>
</ul></li>
<li>Note that data types and constructors must start with capital letters</li>
<li><p>Types and constructors can use the same name (often do), E.g.:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Point</span> <span class="fu">=</span> <span class="dt">Point</span> <span class="dt">Double</span> <span class="dt">Double</span> <span class="kw">deriving</span> <span class="kw">Show</span></code></pre></li>
<li><p>One type can have multiple constructors (like a tagged union):</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Point</span> <span class="fu">=</span> <span class="dt">Cartesian</span> <span class="dt">Double</span> <span class="dt">Double</span><br />           <span class="fu">|</span> <span class="dt">Polar</span> <span class="dt">Double</span> <span class="dt">Double</span><br />             <span class="kw">deriving</span> <span class="kw">Show</span></code></pre>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Color</span> <span class="fu">=</span> <span class="dt">Red</span> <span class="fu">|</span> <span class="dt">Green</span> <span class="fu">|</span> <span class="dt">Blue</span> <span class="fu">|</span> <span class="dt">Indigo</span> <span class="fu">|</span> <span class="dt">Violet</span> <span class="kw">deriving</span> <span class="kw">Show</span></code></pre></li>
</ul>
</div>
<div class="slide">
<h1 id="using-data-types">Using data types</h1>
<ul>
<li><p>Constructors act like functions producing values of their types</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Point</span> <span class="fu">=</span> <span class="dt">Point</span> <span class="dt">Double</span> <span class="dt">Double</span> <span class="kw">deriving</span> <span class="kw">Show</span><br /><span class="ot">myPoint </span><span class="ot">::</span> <span class="dt">Point</span><br />myPoint <span class="fu">=</span> <span class="dt">Point</span> <span class="dv">1</span><span class="fu">.</span><span class="dv">0</span> <span class="dv">1</span><span class="fu">.</span><span class="dv">0</span></code></pre>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Color</span> <span class="fu">=</span> <span class="dt">Red</span> <span class="fu">|</span> <span class="dt">Green</span> <span class="fu">|</span> <span class="dt">Blue</span> <span class="fu">|</span> <span class="dt">Indigo</span> <span class="fu">|</span> <span class="dt">Violet</span> <span class="kw">deriving</span> <span class="kw">Show</span><br /><span class="ot">myColor </span><span class="ot">::</span> <span class="dt">Color</span><br />myColor <span class="fu">=</span> <span class="dt">Red</span></code></pre></li>
<li><p><code>case</code> statements &amp; function bindings &quot;de-construct&quot; values with <em>patterns</em></p>
<pre class="sourceCode"><code class="sourceCode haskell">getX,<span class="ot"> getMaxCoord </span><span class="ot">::</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Double</span><br />getX point <span class="fu">=</span> <span class="kw">case</span> point <span class="kw">of</span><br />               <span class="dt">Point</span> x y <span class="ot">-&gt;</span> x<br />getMaxCoord (<span class="dt">Point</span> x y) <span class="fu">|</span> x <span class="fu">&gt;</span> y     <span class="fu">=</span> x<br />                        <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> y</code></pre>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">isRed </span><span class="ot">::</span> <span class="dt">Color</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span><br />isRed <span class="dt">Red</span> <span class="fu">=</span> <span class="kw">True</span>        <span class="co">-- Only matches constructor Red</span><br />isRed c   <span class="fu">=</span> <span class="kw">False</span>       <span class="co">-- Lower-case c just a variable</span></code></pre></li>
</ul>
</div>
<div class="slide">
<h1 id="parameterized-types">Parameterized types</h1>
<ul>
<li>Types can have parameters sort of the way functions do
<ul>
<li>Type parameters start with lower-case letters</li>
<li>Some examples from the standard Prelude</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="fu">=</span> <span class="kw">Just</span> a<br />             <span class="fu">|</span> <span class="kw">Nothing</span></code></pre>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Either</span> a b <span class="fu">=</span> <span class="kw">Left</span> a<br />                <span class="fu">|</span> <span class="kw">Right</span> b</code></pre></li>
<li><p>You can see these at work in GHCI:</p>
<pre><code>Prelude&gt; :t Just True
Just True :: Maybe Bool
Prelude&gt; :t Left True
Left True :: Either Bool b   
</code></pre></li>
<li>Notice the type of <code>Left True</code> contains a type variable, <code>b</code>
<ul>
<li>Expression <code>Left True</code> can be of type <code>Either Bool b</code> for any type <code>b</code></li>
<li>This is an example of a feature called <em>parametric polymorphism</em></li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="more-deconstruction-tips">More deconstruction tips</h1>
<ul>
<li>Special variable &quot;<code>_</code>&quot; can be bound but not used
<ul>
<li>Use it when you don't care about a value:</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">isJust </span><span class="ot">::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>      <span class="co">-- note parametric polymorphism</span><br />isJust (<span class="kw">Just</span> _) <span class="fu">=</span> <span class="kw">True</span><br />isJust <span class="kw">Nothing</span>  <span class="fu">=</span> <span class="kw">False</span></code></pre>
<pre class="sourceCode"><code class="sourceCode haskell">isRed <span class="dt">Red</span> <span class="fu">=</span> <span class="kw">True</span><br />isRed _   <span class="fu">=</span> <span class="kw">False</span>              <span class="co">-- we don't need the non-red value</span></code></pre>
<ul>
<li>Compiler warns if a bound variable not used; <code>_</code> avoids this</li>
</ul></li>
<li><p>You can deconstruct types and bind variables within guards, E.g.:</p>
<pre class="sourceCode"><code class="sourceCode haskell">addMaybes mx my <span class="fu">|</span> <span class="kw">Just</span> x <span class="ot">&lt;-</span> mx, <span class="kw">Just</span> y <span class="ot">&lt;-</span> my <span class="fu">=</span> <span class="kw">Just</span> (x <span class="fu">+</span> y)<br />addMaybes _ _                                <span class="fu">=</span> <span class="kw">Nothing</span></code></pre>
<p>though often there is a simpler way</p>
<pre class="sourceCode"><code class="sourceCode haskell">addMaybes (<span class="kw">Just</span> x) (<span class="kw">Just</span> y) <span class="fu">=</span> <span class="kw">Just</span> (x <span class="fu">+</span> y)<br />addMaybes _ _               <span class="fu">=</span> <span class="kw">Nothing</span></code></pre></li>
</ul>
</div>
<div class="slide">
<h1 id="lists">Lists</h1>
<ul>
<li><p>We could define homogeneous lists with the <code>data</code> keyword</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a) <span class="fu">|</span> <span class="dt">Nil</span><br /><br />oneTwoThree <span class="fu">=</span> (<span class="dt">Cons</span> <span class="dv">1</span> (<span class="dt">Cons</span> <span class="dv">2</span> (<span class="dt">Cons</span> <span class="dv">3</span> <span class="dt">Nil</span>)))<span class="ot"> </span><span class="ot">::</span> <span class="dt">List</span> <span class="dt">Integer</span></code></pre></li>
<li>But Haskell has built-in lists with syntactic sugar
<ul>
<li>Instead of <code>List Integer</code>, the type is written <code>[Integer]</code></li>
<li>Instead of <code>Cons</code>, the constructor is called <code>:</code> and is <em>infix</em></li>
<li>Instead of <code>Nil</code>, the empty list is called <code>[]</code></li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell">oneTwoThree <span class="fu">=</span> <span class="dv">1</span><span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">3</span><span class="fu">:</span>[]<span class="ot"> </span><span class="ot">::</span> [<span class="dt">Integer</span>]</code></pre>
<ul>
<li>But there are even more convenient syntaxes for the same list:</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell">oneTwoThree' <span class="fu">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]    <span class="co">-- comma-separated elements within brackets</span><br />oneTwoThree'' <span class="fu">=</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">3</span>]      <span class="co">-- define list by a range</span></code></pre></li>
<li><p>A <code>String</code> is just a list of <code>Char</code>, so <code>['a', 'b', 'c'] == &quot;abc&quot;</code></p></li>
</ul>
</div>
<div class="slide">
<h1 id="some-basic-list-functions-in-prelude">Some basic list functions in Prelude</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="fu">head</span><span class="ot"> </span><span class="ot">::</span> [a] <span class="ot">-&gt;</span> a<br /><span class="fu">head</span> (x<span class="fu">:</span>_) <span class="fu">=</span> x<br /><span class="fu">head</span> []    <span class="fu">=</span> <span class="fu">error</span> <span class="st">&quot;head: empty list&quot;</span></code></pre>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="fu">tail</span><span class="ot"> </span><span class="ot">::</span> [a] <span class="ot">-&gt;</span> a             <span class="co">-- all but first element</span><br /><span class="fu">tail</span> (_<span class="fu">:</span>xs) <span class="fu">=</span> xs<br /><span class="fu">tail</span> []     <span class="fu">=</span> <span class="fu">error</span> <span class="st">&quot;tail: empty list&quot;</span></code></pre>
<pre class="sourceCode"><code class="sourceCode haskell">a <span class="fu">++</span><span class="ot"> b </span><span class="ot">::</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]  <span class="co">-- infix operator concatenate lists</span><br />[] <span class="fu">++</span> ys <span class="fu">=</span> ys<br />(x<span class="fu">:</span>xs) <span class="fu">++</span> ys <span class="fu">=</span> x <span class="fu">:</span> xs <span class="fu">++</span> ys</code></pre>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="fu">length</span><span class="ot"> </span><span class="ot">::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span>         <span class="co">-- This code is from language spec</span><br /><span class="fu">length</span> []    <span class="fu">=</span>  <span class="dv">0</span>            <span class="co">-- GHC implements differently, why?</span><br /><span class="fu">length</span> (_<span class="fu">:</span>l) <span class="fu">=</span>  <span class="dv">1</span> <span class="fu">+</span> <span class="fu">length</span> l</code></pre>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="fu">filter</span><span class="ot"> </span><span class="ot">::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]<br /><span class="fu">filter</span> <span class="fu">pred</span> [] <span class="fu">=</span> []<br /><span class="fu">filter</span> <span class="fu">pred</span> (x<span class="fu">:</span>xs)<br />  <span class="fu">|</span> <span class="fu">pred</span> x     <span class="fu">=</span> x <span class="fu">:</span> <span class="fu">filter</span> <span class="fu">pred</span> xs<br />  <span class="fu">|</span> <span class="fu">otherwise</span>  <span class="fu">=</span> <span class="fu">filter</span> <span class="fu">pred</span> xs</code></pre>
<p>Note function <code>error :: String -&gt; a</code> reports assertion failures</p>
</div>
<div class="slide">
<h1 id="hoogle">Hoogle</h1>
<ul>
<li>Let's find the source code for GHC's <code>length</code> function?</li>
<li><a href="http://www.haskell.org/hoogle/">Hoogle</a> is a search engine just for Haskell functions
<ul>
<li>Go to <a href="http://www.haskell.org/hoogle/"><code class="url">http://www.haskell.org/hoogle/</code></a></li>
<li>Click on <em>search plugin</em></li>
<li>Keyword &quot;<code>haskell.org</code>&quot; is too long for me--I change to &quot;<code>ho</code>&quot;</li>
</ul></li>
<li>Let's search for length... click on source
<ul>
<li>All those <code>#</code> marks are for &quot;unboxed types&quot;, which are faster but not asymptotically</li>
<li>The important point is that <code>len</code> is tail recursive</li>
</ul></li>
<li>I use Hoogle all the time, all the time when coding
<ul>
<li>Most of the source code is not hard to understand</li>
<li>Length may be a bad starter example just because of unboxed types</li>
<li>Try examining the code of the functions you are using to understand them better</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="example-counting-letters">Example: counting letters</h1>
<ul>
<li><p>Here's a function to count lower-case letters in a <code>String</code></p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">import</span> <span class="dt">Data.Char</span>    <span class="co">-- brings function isLower into scope</span><br /><br /><span class="ot">countLowerCase </span><span class="ot">::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span><br />countLowerCase str <span class="fu">=</span> <span class="fu">length</span> (<span class="fu">filter</span> <span class="fu">isLower</span> str)</code></pre></li>
<li>If we fix <code>length</code>, <code>countLowerCase</code> might run in constant space
<ul>
<li><p>Recall Haskell evaluates expressions lazily... Means in most contexts values are interchangeable with function pointers (a.k.a. <em>thunks</em>)</p></li>
<li><p>A <code>String</code> is a <code>[Char]</code>, which is type with two values, a <em>head</em> and <em>tail</em></p></li>
<li><p>But until each of the <em>head</em> or <em>tail</em> are needed, they can be stored as function pointers</p></li>
<li><p>So <code>length</code> will causes <code>filter</code> to produce <code>Char</code>s one at a time</p></li>
<li><p><code>length</code> does not hold on to characters once counted; can be garbage-collected at will</p></li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="function-composition">Function composition</h1>
<ul>
<li><p>Here's an even more concise definition</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">countLowerCase </span><span class="ot">::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span><br />countLowerCase <span class="fu">=</span> <span class="fu">length</span> <span class="fu">.</span> <span class="fu">filter</span> <span class="fu">isLower</span></code></pre></li>
<li><p>The &quot;<code>.</code>&quot; operator provides function composition</p>
<pre class="sourceCode"><code class="sourceCode haskell">(f <span class="fu">.</span> g) x <span class="fu">=</span> f (g x)</code></pre>
<ul>
<li>On previous slide, <code>countLowerCase</code>'s argument had name <code>str</code></li>
<li>The new version doesn't name the argument, a style called <em>point-free</em></li>
</ul></li>
<li><p>Function composition can be used almost like Unix pipelines</p>
<pre class="sourceCode"><code class="sourceCode haskell">process <span class="fu">=</span> countLowercase <span class="fu">.</span> toPigLatin <span class="fu">.</span> extractComments <span class="fu">.</span> unCompress</code></pre></li>
</ul>
</div>
<div class="slide">
<h1 id="lambda-abstraction">Lambda abstraction</h1>
<ul>
<li>Sometimes you want to name the arguments but not the function</li>
<li>Haskell allows anonymous functions through <em>lambda abstraction</em>
<ul>
<li>The notation is <code>\</code><em>variable(s)</em> <code>-&gt;</code> <em>body</em> (where <code>\</code> is pronounced &quot;lambda&quot;)</li>
</ul></li>
<li><p>Example:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">countLowercaseAndDigits </span><span class="ot">::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span><br />countLowercaseAndDigits <span class="fu">=</span> <span class="fu">length</span> <span class="fu">.</span> <span class="fu">filter</span> (\c <span class="ot">-&gt;</span> <span class="fu">isLower</span> c <span class="fu">||</span> <span class="fu">isDigit</span> c)</code></pre></li>
<li><p>Lambda abstractions can deconstruct values with patterns, e.g.:</p>
<pre class="sourceCode"><code class="sourceCode haskell">        <span class="fu">...</span> (\(<span class="kw">Right</span> x) <span class="ot">-&gt;</span> x) <span class="fu">...</span></code></pre>
<ul>
<li>But note that guards or multiple bindings are not allowed</li>
<li>Patterns must have the right constructor or will get run-time error</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="infix-vs.-prefix-notation">Infix vs. Prefix notation</h1>
<ul>
<li>We've seen some infix functions &amp; constructors: <code>+</code>, <code>*</code>, <code>/</code>, <code>.</code>, <code>||</code>, <code>:</code></li>
<li>In fact, any binary function or constructor can be used infix or prefix</li>
<li>For functions and constructors composed of letters, digits, <code>_</code>, and <code>'</code>
<ul>
<li>Prefix is the default: <code>add 1 2</code></li>
<li>Putting function in backticks makes it infix: <code>1 `add` 2</code></li>
</ul></li>
<li>For functions starting with one of <code>!#$%&amp;*+./&lt;=&gt;?@\^|-~</code> or constructors starting &quot;<code>:</code>&quot;
<ul>
<li>Infix is default, Putting functions in parens makes them prefix, e.g., <code>(+) 1 2</code></li>
</ul></li>
<li>For tuples, prefix constructors are <code>(,)</code>, <code>(,,)</code>, <code>(,,,)</code>, <code>(,,,,)</code>, etc.</li>
<li><p>Infix functions can be partially applied in a parenthesized <em>section</em></p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">stripPunctuation </span><span class="ot">::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span><br />stripPunctuation <span class="fu">=</span> <span class="fu">filter</span> (<span class="ot">`notElem`</span> <span class="st">&quot;!#$%&amp;*+./&lt;=&gt;?@\\^|-~:&quot;</span>)<br /><span class="co">-- Note above string the SECOND argument to notElem ^</span></code></pre></li>
</ul>
</div>
<div class="slide">
<h1 id="fixity">Fixity</h1>
<ul>
<li>Most operators are just library functions in Haskell
<ul>
<li>Very few operators reserved by language syntax (<code>..</code>, <code>:</code>, <code>::</code>, <code>=</code>, <code>\</code>, <code>|</code>, <code>&lt;-</code>, <code>-&gt;</code>, <code>@</code>, <code>~</code>, <code>=&gt;</code>, <code>--</code>)</li>
<li>You can go crazy and define your own operators</li>
<li>Or even use your own definitions instead of system ones</li>
</ul></li>
<li>Define precedence of infix operators with fixity declarations
<ul>
<li>Keywords: <code>infixl</code>/<code>infixr</code>/<code>infix</code> for left/right/no associativity</li>
<li>Syntax: <em>infix-keyword</em> [0-9] <em>function</em> [, <em>function</em> ...]</li>
<li>Allowed wherever a type declaration is allowed</li>
</ul></li>
<li>0 is lowest allowed fixity precedence, 9 is highest
<ul>
<li>Prefix function application has fixity 10--higher than any infix call</li>
<li>Lambda abstractions, <code>else</code> clauses, and <code>let</code>...<code>in</code> clauses extend as far to the right as possible (meaning they never stop at any infix operator, no matter how low precedence)</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="fixity-of-specific-operators">Fixity of specific operators</h1>
<ul>
<li>Here is the fixity of the <a href="http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-820061">standard operators</a>:</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">infixl</span> <span class="dv">9</span>  <span class="fu">!!</span>             <span class="co">-- This is the default when fixity unspecified</span><br /><span class="kw">infixr</span> <span class="dv">9</span>  <span class="fu">.</span><br /><span class="kw">infixr</span> <span class="dv">8</span>  <span class="fu">^</span>, <span class="fu">^^</span>, &#8902;&#8902;<br /><span class="kw">infixl</span> <span class="dv">7</span>  &#8902;, <span class="fu">/</span>, <span class="ot">`quot`</span>, <span class="ot">`rem`</span>, <span class="ot">`div`</span>, <span class="ot">`mod`</span>  <br /><span class="kw">infixl</span> <span class="dv">6</span>  <span class="fu">+</span>, <span class="fu">-</span>           <span class="co">-- Unary negation &quot;-&quot; has this fixity, too</span><br /><span class="kw">infixr</span> <span class="dv">5</span>  <span class="fu">++</span>             <span class="co">-- built-in &quot;:&quot; constructor has this fixity, too</span><br />infix  <span class="dv">4</span>  <span class="fu">==</span>, <span class="fu">/=</span>, <span class="fu">&lt;</span>, <span class="fu">&lt;=</span>, <span class="fu">&gt;=</span>, <span class="fu">&gt;</span>, <span class="ot">`elem`</span>, <span class="ot">`notElem`</span><br /><span class="kw">infixr</span> <span class="dv">3</span>  <span class="fu">&amp;&amp;</span><br /><span class="kw">infixr</span> <span class="dv">2</span>  <span class="fu">||</span><br /><span class="kw">infixl</span> <span class="dv">1</span>  <span class="fu">&gt;&gt;</span>, <span class="fu">&gt;&gt;=</span><br /><span class="kw">infixr</span> <span class="dv">1</span>  <span class="fu">=&lt;&lt;</span>  <br /><span class="kw">infixr</span> <span class="dv">0</span>  <span class="fu">$</span>, <span class="fu">$!</span>, <span class="ot">`seq`</span></code></pre>
<ul>
<li><p>If you can't remember, use <code>:i</code> in <a href="http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci.html">GHCI</a>:</p>
<pre><code>Prelude&gt; :i &amp;&amp;
(&amp;&amp;) :: Bool -&gt; Bool -&gt; Bool    -- Defined in GHC.Classes
infixr 3 &amp;&amp;
</code></pre>
<ul>
<li>If GHCI doesn't specify, means default: <code>infixl 9</code></li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="the-infixr-0-operators">The &quot;<code>infixr 0</code>&quot; operators</h1>
<ul>
<li><p><span style="color:blue"><code>$</code></span> is function application, but with lowest precedence</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">($) </span><span class="ot">::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b<br />f <span class="fu">$</span> x <span class="fu">=</span> f x</code></pre>
<ul>
<li>Turns out to be quite useful for avoiding parentheses, E.g.:</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell">    <span class="fu">putStrLn</span> <span class="fu">$</span> <span class="st">&quot;the value of &quot;</span> <span class="fu">++</span> key <span class="fu">++</span> <span class="st">&quot; is &quot;</span> <span class="fu">++</span> <span class="fu">show</span> value</code></pre></li>
<li><span style="color:blue"><code>seq :: a -&gt; b -&gt; b</code></span> evaluates first argument, and second
<ul>
<li>Means when you are done, first argument is a value, not a thunk</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">let</span> q <span class="fu">=</span> <span class="dv">1</span> <span class="ot">`div`</span> <span class="dv">0</span><br />       <span class="kw">in</span> <span class="fu">seq</span> q <span class="fu">$</span> <span class="fu">putStrLn</span> <span class="st">&quot;Hello world!\n&quot;</span>  <span class="co">-- exception</span></code></pre>
<ul>
<li><code>seq</code> has to be built into the compiler</li>
</ul></li>
<li><p><span style="color:blue"><code>$!</code></span> combines <code>$</code> and <code>seq</code></p>
<pre class="sourceCode"><code class="sourceCode haskell">f <span class="fu">$!</span> x  <span class="fu">=</span> x <span class="ot">`seq`</span> f x</code></pre></li>
</ul>
</div>
<div class="slide">
<h1 id="accumulators-revisited">Accumulators revisited</h1>
<ul>
<li>We used an accumulator to avoid <code>n0</code> stack frames in <code>factorial</code>:</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell">factorial n0 <span class="fu">=</span> loop <span class="dv">1</span> n0<br />    <span class="kw">where</span> loop acc n <span class="fu">|</span> n <span class="fu">&gt;</span> <span class="dv">1</span>     <span class="fu">=</span> loop (acc <span class="fu">*</span> n) (n <span class="fu">-</span> <span class="dv">1</span>)<br />                     <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> acc</code></pre>
<ul>
<li>Unfortunately, <code>acc</code> can contain a chain of thunks <code>n</code> long<br>
<ul>
<li><code>(((1 * n) * (n - 1)) * (n - 2) ...)</code> -- Laziness means only evaluated when needed</li>
<li>GHC is smart enough not to build up thunks, but only when optimizing</li>
</ul></li>
<li>Can fix such problems using <code>$!</code> or <code>seq</code></li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell">factorial n0 <span class="fu">=</span> loop <span class="dv">1</span> n0<br />    <span class="kw">where</span> loop acc n <span class="fu">|</span> n <span class="fu">&gt;</span> <span class="dv">1</span>     <span class="fu">=</span> (loop <span class="fu">$!</span> acc <span class="fu">*</span> n) (n <span class="fu">-</span> <span class="dv">1</span>)<br />                     <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> acc</code></pre>
<pre class="sourceCode"><code class="sourceCode haskell">factorial n0 <span class="fu">=</span> loop <span class="dv">1</span> n0<br />    <span class="kw">where</span> loop acc n <span class="fu">|</span> n <span class="fu">&gt;</span> <span class="dv">1</span>     <span class="fu">=</span> acc <span class="ot">`seq`</span> loop (acc <span class="fu">*</span> n) (n <span class="fu">-</span> <span class="dv">1</span>)<br />                     <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> acc</code></pre>
</div>
<div class="slide">
<h1 id="hackage-and-cabal">Hackage and cabal</h1>
<ul>
<li><a href="http://hackage.haskell.org/packages/archive/pkg-list.html">Hackage</a> is a large collection of Haskell packages</li>
<li><a href="http://www.haskell.org/ghc/docs/7.0-latest/html/Cabal/index.html">Cabal</a> is a tool for browsing hackage and installing packages
<ul>
<li>Cabal comes with the <a href="http://hackage.haskell.org/platform/">haskell platform</a></li>
<li>Run <code>cabal update</code> to create <code>$HOME/.cabal</code>, download package database</li>
<li><p>I highly recommend unconmenting and editing these two lines in <code>$HOME/.cabal/config</code></p>
<pre><code>documentation: True
library-profiling: True
</code></pre></li>
<li>May want to add <code>$HOME/.cabal/bin</code> to your path</li>
</ul></li>
<li><p>To install packages for the next examples, run</p>
<pre><code>cabal install http-enumerator utf8-string tagsoup
</code></pre>
<ul>
<li>Installs packages in <code>$HOME/.cabal</code>, and records them in <code>$HOME/.ghc</code></li>
<li>To start fresh, must delete both <code>$HOME/.cabal</code> and <code>$HOME/.ghc</code></li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="modules-and-import-syntax">Modules and <code>import</code> syntax</h1>
<ul>
<li>Haskell groups top-level bindings into <em>modules</em>
<ul>
<li>Default module name is <code>Main</code>, as programs start at function <code>main</code> in <code>Main</code></li>
<li>Except for <code>Main</code>, a module named <em>M</em> must reside in a file named <em>M</em><code>.hs</code></li>
<li>Module names are capitalized; I use lower-case file names for <code>Main</code> modules</li>
</ul></li>
<li><p>Let's add this to the top of our source file</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>      <span class="co">-- redundant since Main is the default</span><br /><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Lazy.UTF8</span> <span class="kw">as</span> <span class="dt">L</span><br /><span class="kw">import</span> <span class="dt">Data.Char</span><br /><span class="kw">import</span> <span class="dt">Network.HTTP.Enumerator</span> (simpleHttp)<br /><span class="kw">import</span> <span class="dt">System.Environment</span></code></pre>
<ul>
<li>Start module with &quot;<code>module</code> <em>name</em> <code>where</code>&quot; or &quot;<code>module</code> <em>name</em> <code>(</code><em>exported-symbol</em>[<code>,</code> ...]<code>) where</code>&quot; (non-exported symbols provide modularity)</li>
<li><code>import</code> <em>module</em> - imports all symbols in <em>module</em></li>
<li><code>import qualified</code> <em>module</em> <code>as</code> <em>ID</em> - prefixes imported symbols with <em>ID</em><code>.</code></li>
<li><code>import</code> <em>module</em> <code>(</code><em>function1</em>[<code>,</code> <em>function2</em> ...]<code>)</code> - imports just the named functions</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="do-notation"><code>do</code> notation</h1>
<ul>
<li>Let's write a program to dump a web page</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span><br />  (url<span class="fu">:</span>_) <span class="ot">&lt;-</span> getArgs       <span class="co">-- Sets url to first command-line argument</span><br />  page <span class="ot">&lt;-</span> simpleHttp url   <span class="co">-- Sets page to contents as a ByteString</span><br />  <span class="fu">putStr</span> (L.toString page) <span class="co">-- Converts ByteString to String and prints it</span></code></pre>
<ul>
<li>This task requires some impure (non-functional) actions
<ul>
<li>Extracting command-line args, creating a TCP connection, writing to stdout</li>
</ul></li>
<li>A <code>do</code> block lets you sequence IO actions. In a <code>do</code> block:
<ul>
<li><span style="color:blue"><em>pat</em> <code>&lt;-</code> <em>action</em></span> - binds <em>pat</em> (variable or constructor pattern) to result of executing <em>action</em></li>
<li><span style="color:blue"><code>let</code> <em>pat</em> <code>=</code> <em>pure-value</em></span> - binds <em>pat</em> to <em>pure-value</em> (no &quot;<code>in</code> ...&quot; required)</li>
<li><span style="color:blue"><em>action</em></span> - executes <em>action</em> and discards the result, or returns it if at end of block</li>
</ul></li>
<li>GHCI input is like <code>do</code> block (i.e., can use <code>&lt;-</code>, need <code>let</code> for bindings)</li>
<li><code>do</code>/<code>let</code>/<code>case</code> won't parse after prefix function (so say &quot;<code>func $ do</code> ...&quot;)</li>
</ul>
</div>
<div class="slide">
<h1 id="what-are-the-types-of-io-actions">What are the types of IO actions?</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">main </span><span class="ot">::</span> <span class="dt">IO</span> ()<br /><span class="ot">getArgs </span><span class="ot">::</span> <span class="dt">IO</span> [<span class="dt">String</span>]<br /><span class="ot">simpleHttp </span><span class="ot">::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">L.ByteString</span> <span class="co">-- (really more polymorphic)</span><br /><span class="fu">putStr</span><span class="ot"> </span><span class="ot">::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</code></pre>
<ul>
<li><code>IO</code> is a parameterized type (just as <code>Maybe</code> is parameterized)
<ul>
<li>&quot;<code>IO [String]</code>&quot; means IO action that produces a <code>[String]</code> if executed</li>
<li>Unlike <code>Maybe</code>, we won't use a constructor for <code>IO</code>, which is somewhat magic</li>
</ul></li>
<li><p>What if we try to print the first command-line argument as follows?</p>
<pre class="sourceCode"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="fu">putStr</span> (<span class="fu">head</span> getArgs)</code></pre>
<ul>
<li>Oops, <code>head</code> expects type <code>[String]</code>, while <code>getArgs</code> is an <code>IO [String]</code></li>
</ul></li>
<li>How to de-construct an <code>IO [String]</code> to get a <code>[String]</code>
<ul>
<li>We can't use <code>case</code>, because we don't have a constructor for <code>IO</code>... Besides, the order and number of deconstructions of something like <code>putStr</code> matters</li>
<li>That's the point of the <code>&lt;-</code> operator in <code>do</code> blocks!</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="another-way-to-see-io-peyton-jones">Another way to see IO <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf">[Peyton Jones]</a></h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">do</span> page <span class="ot">&lt;-</span> simpleHttp url<br />   <span class="fu">putStr</span> (L.toString page)</code></pre>
<div class="figure">
<img src="http://www.scs.stanford.edu/11au-cs240h/notes/io1.svg" /><p class="caption"></p>
</div>
<ul>
<li><code>simpleHttp</code> and <code>putStr</code> return <code>IO</code> <em>actions</em> that can change the world
<ul>
<li>Pure code can manipulate such actions, but can't actually execute them</li>
<li>Only the special <code>main</code> action is ever executed</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="another-way-to-see-io-peyton-jones-1">Another way to see IO <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf">[Peyton Jones]</a></h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">do</span> page <span class="ot">&lt;-</span> simpleHttp url<br />   <span class="fu">putStr</span> (L.toString page)</code></pre>
<div class="figure">
<img src="http://www.scs.stanford.edu/11au-cs240h/notes/io2.svg" /><p class="caption"></p>
</div>
<ul>
<li>The <code>do</code> block builds a compound action from other actions
<ul>
<li>It sequences how actions will be applied to the real world</li>
<li>When executed, applies <code>IO a</code> actions to the world, extracting values of type <code>a</code></li>
<li>What action to execute next can depend on the value of the extracted <code>a</code></li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="running-urldump">Running <code>urldump</code></h1>
<pre><code>$ ghc --make urldump
[1 of 1] Compiling Main             ( urldump.hs, urldump.o )
Linking urldump ...
$ ./urldump http://www.scs.stanford.edu/
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;
...
</code></pre>
<ul>
<li><p>What if you want to run it in GHCI?</p>
<pre><code>$ ghci ./urldump.hs
Prelude Main&gt;
</code></pre>
<ul>
<li>No <code>*</code> before <code>Main</code> means no access to internal symbols (because compiled)</li>
</ul>
<pre><code>Prelude Main&gt; :load *urldump.hs
[1 of 1] Compiling Main             ( urldump.hs, interpreted )
Ok, modules loaded: Main.
*Main&gt; withArgs [&quot;http://cs240h.scs.stanford.edu/&quot;] main
</code></pre>
<ul>
<li>Alternate GHCI shortcut:</li>
</ul>
<pre><code>Prelude Main&gt; :main &quot;http://cs240h.scs.stanford.edu/&quot;
</code></pre></li>
</ul>
</div>
<div class="slide">
<h1 id="the-return-function">The <code>return</code> function</h1>
<!-- might need to check out
https://blueprints.launchpad.net/inkscape/+spec/allow-browser-resizing
-->

<ul>
<li><p>Let's combine <code>simpleHttp</code> and <code>L.toString</code> into one function</p>
<div class="figure">
<img src="http://www.scs.stanford.edu/11au-cs240h/notes/simpleHttpStr.svg" /><p class="caption"></p>
</div>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">simpleHttpStr </span><span class="ot">::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span><br />simpleHttpStr url <span class="fu">=</span> <span class="kw">do</span><br />  page <span class="ot">&lt;-</span> simpleHttp url<br />  <span class="fu">return</span> (L.toString page)  <span class="co">-- result of do block is last action</span></code></pre></li>
<li><p>Note: <strong><code>return</code> is not control flow statement</strong>, just a function</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="fu">return</span><span class="ot"> </span><span class="ot">::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</code></pre>
<ul>
<li>Every action in an <code>IO</code> do block must have type <code>IO a</code> for some <code>a</code></li>
<li><code>L.toString</code> returns a <code>String</code>, use <code>return</code> to make an <code>IO   String</code></li>
<li>In a <code>do</code> block, &quot;<code>let x = e</code>&quot; is like &quot;<code>x &lt;- return e</code>&quot; (except recursive)</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="point-free-io-composition">Point-free IO composition</h1>
<ul>
<li>Recall point-free function composition with &quot;<code>.</code>&quot; (fixity <code>infixr 9</code>)</li>
<li><p>Function <code>&gt;&gt;=</code> (pronounced &quot;bind&quot;) allows point-free IO composition</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">(&gt;&gt;=) </span><span class="ot">::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b<br /><span class="kw">infixl</span> <span class="dv">1</span> <span class="fu">&gt;&gt;=</span></code></pre></li>
<li><p>Let's re-write <code>urldump</code> in point-free style</p>
<pre class="sourceCode"><code class="sourceCode haskell">main <span class="fu">=</span> getArgs <span class="fu">&gt;&gt;=</span> simpleHttpStr <span class="fu">.</span> <span class="fu">head</span> <span class="fu">&gt;&gt;=</span> <span class="fu">putStr</span></code></pre>
<ul>
<li>Note <code>&gt;&gt;=</code> composes left-to-right, while <code>.</code> goes right-to-left</li>
</ul></li>
<li><code>do</code> blocks are just <a href="http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14">syntactic sugar</a> for calling <code>&gt;&gt;=</code>
<ul>
<li>Let's de-sugar our original <code>main</code>:</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell">main <span class="fu">=</span><br />    getArgs <span class="fu">&gt;&gt;=</span> \(url<span class="fu">:</span>_) <span class="ot">-&gt;</span><br />    simpleHttp url <span class="fu">&gt;&gt;=</span> \page <span class="ot">-&gt;</span><br />    <span class="fu">putStr</span> (L.toString page)</code></pre></li>
</ul>
</div>
<div class="slide">
<h1 id="lazy-io">Lazy IO</h1>
<ul>
<li><p>Some simple file IO functions may be handy for first lab</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">type</span> <span class="fu">FilePath</span> <span class="fu">=</span> <span class="dt">String</span> <span class="co">-- makes FilePath synonym for String</span><br /><span class="fu">getContents</span><span class="ot"> </span><span class="ot">::</span> <span class="dt">IO</span> <span class="dt">String</span>          <span class="co">-- read all stdin</span><br /><span class="fu">readFile</span><span class="ot"> </span><span class="ot">::</span> <span class="fu">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span> <span class="co">-- read (whole) file</span><br /><span class="fu">writeFile</span><span class="ot"> </span><span class="ot">::</span> <span class="fu">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()  <span class="co">-- write file</span></code></pre></li>
<li>E.g., <code>main = readFile &quot;input&quot; &gt;&gt;= writeFile &quot;output&quot;</code>
<ul>
<li>Surprisingly, this program does not require unbounded memory</li>
<li>Rather, input is read lazily as the list of Characters is evaluated</li>
</ul></li>
<li>How lazy IO works
<ul>
<li>A list has two values, the head and the tail, each possibly a thunk</li>
<li>At some point evaluating thunk actually triggers file IO</li>
<li>Function <code>unsafeInterleaveIO</code> creates thunks that execute <code>IO</code> actions (c.f. more widely used <code>unsafePerformIO</code>, described in <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf">[Peyton Jones]</a>)</li>
<li>Lazy IO is great for scripts, bad for servers; more in Iteratee lecture</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="more-on-polymorphism">More on polymorphism</h1>
<ul>
<li>We've seen a bunch of polymorphic functions</li>
<li>Here are some more handy ones from Prelude</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="fu">id</span><span class="ot"> </span><span class="ot">::</span> a <span class="ot">-&gt;</span> a<br /><span class="fu">id</span> x <span class="fu">=</span> x</code></pre>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="fu">const</span><span class="ot"> </span><span class="ot">::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a<br /><span class="fu">const</span> a _ <span class="fu">=</span> a</code></pre>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="fu">fst</span><span class="ot"> </span><span class="ot">::</span> (a, b) <span class="ot">-&gt;</span> a<br /><span class="fu">fst</span> (a, _) <span class="fu">=</span> a</code></pre>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="fu">snd</span><span class="ot"> </span><span class="ot">::</span> (a, b) <span class="ot">-&gt;</span> b<br /><span class="fu">snd</span> (_, b) <span class="fu">=</span> b</code></pre>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="fu">print</span> a <span class="fu">=</span> <span class="fu">putStrLn</span> (<span class="fu">show</span> a)   <span class="co">-- what's the type?  a -&gt; IO ()?</span></code></pre>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="fu">show</span> a <span class="fu">=</span> <span class="fu">???</span>                  <span class="co">-- how to implement?</span></code></pre>
</div>
<div class="slide">
<h1 id="parametric-vs.-ad-hoc-polymorphism">Parametric vs. ad hoc polymorphism</h1>
<ul>
<li>There are actually <em>two</em> kinds of polymorphism at work here</li>
<li><em>parametric polymorphism</em> -- does the same thing for every type
<ul>
<li>E.g., <code>id :: a -&gt; a</code> just passes the value through</li>
<li>Works for every possible type</li>
</ul></li>
<li><em>ad hoc polymorphism</em> -- does different things on different types
<ul>
<li>E.g., <code>1 + 1</code> and <code>1.0 + 1.0</code> compute very different functions</li>
<li>E.g., <code>show</code> converts value to <code>String</code>, depends entirely on input type</li>
<li>Only works on types that support it (hence &quot;<code>deriving Show</code>&quot; in declarations)</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="classes-and-instances">Classes and Instances</h1>
<ul>
<li><p>Ad-hoc polymorphic functions are called <em>methods</em> and declared with <em>classes</em></p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">MyShow</span> a <span class="kw">where</span><br /><span class="ot">    myShow </span><span class="ot">::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre></li>
<li><p>The actual method for each type is defined in an <em>instance</em> declaration</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Point</span> <span class="fu">=</span> <span class="dt">Point</span> <span class="dt">Double</span> <span class="dt">Double</span><br /><span class="kw">instance</span> <span class="dt">MyShow</span> <span class="dt">Point</span> <span class="kw">where</span><br />    myShow (<span class="dt">Point</span> x y) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> <span class="fu">show</span> x <span class="fu">++</span> <span class="st">&quot;, &quot;</span> <span class="fu">++</span> <span class="fu">show</span> y <span class="fu">++</span> <span class="st">&quot;)&quot;</span></code></pre>
<ul>
<li>A class declaration can also include default definitions for methods</li>
</ul></li>
<li><p>What's the type of a function that calls <code>myShow</code>? Ask GHCI:</p>
<pre class="sourceCode"><code class="sourceCode haskell">myPrint x <span class="fu">=</span> <span class="fu">putStrLn</span> <span class="fu">$</span> myShow x</code></pre>
<pre><code>*Main&gt; :t myPrint
myPrint :: MyShow a =&gt; a -&gt; IO ()
</code></pre></li>
</ul>
</div>
<div class="slide">
<h1 id="the-context-of-a-type-declaration">The Context of a type declaration</h1>
<ul>
<li>Type declarations can contain restrictions on type variables
<ul>
<li>Restrictions expressed with &quot;<code>(</code><em>class</em> <em>type-var</em>, ...<code>) =&gt;</code>&quot; at start of type, E.g.:</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">myPrint </span><span class="ot">::</span> <span class="dt">MyShow</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</code></pre>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">sortAndShow </span><span class="ot">::</span> (<span class="kw">Ord</span> a, <span class="dt">MyShow</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="fu">elem</span><span class="ot"> </span><span class="ot">::</span> (<span class="kw">Eq</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span><br /><span class="fu">elem</span> _ []     <span class="fu">=</span> <span class="kw">False</span><br /><span class="fu">elem</span> x (y<span class="fu">:</span>ys) <span class="fu">=</span> x<span class="fu">==</span>y <span class="fu">||</span> <span class="fu">elem</span> x ys</code></pre>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">add </span><span class="ot">::</span> (<span class="kw">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a<br />add arg1 arg2 <span class="fu">=</span> arg1 <span class="fu">+</span> arg2</code></pre></li>
<li>Can think of context as representing hidden <em>dictionary</em> arguments
<ul>
<li>When you call <code>myPrint</code>, you explicitly give it a value of type <code>a</code></li>
<li>But also implicitly give it a function pointer for type <code>a</code>'s <code>MyShow</code> instance</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="the-dreaded-monomorphism-restriction-dmr">The <a href="http://www.haskell.org/haskellwiki/Monomorphism_restriction">Dreaded</a> <a href="http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-930004.5.5">Monomorphism Restriction</a> (DMR)</h1>
<ul>
<li><p>Let's say you want to cache result of super-expensive function</p>
<pre class="sourceCode"><code class="sourceCode haskell">superExpensive val <span class="fu">=</span> len <span class="fu">$</span> veryExpensive (<span class="ot">val </span><span class="ot">::</span> <span class="dt">Int</span>)<br />    <span class="kw">where</span> len [] <span class="fu">=</span> <span class="dv">0</span><br />          len (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> len xs<br />cachedResult <span class="fu">=</span> superExpensive <span class="dv">5</span></code></pre>
<ul>
<li><code>cachedResult</code> will start as thunk, be executed once, then contain value</li>
</ul></li>
<li><p>Let's think about the types</p>
<pre><code>*Main&gt; :t superExpensive
superExpensive :: Num a =&gt; Int -&gt; a
*Main&gt; :t cachedResult
cachedResult :: Integer
</code></pre>
<ul>
<li>+ and 0 are overloaded, so <code>superExpensive</code> can return any <code>Num</code> you want</li>
<li>Why don't we have <code>cachedResult :: (Num a) =&gt; a</code>?</li>
<li>Recall context restrictions are like hidden arguments... so would make <code>cachedResult</code> into a function, undermining our caching goal!</li>
<li>But how is compiler smart enough to save us here?</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="the-dmr-continued">The DMR continued</h1>
<ul>
<li>Answer: in this case, compiler is not actually that smart
<ul>
<li>Heuristic: If it looks like a function, can infer <em>ad hoc</em> polymorphic types</li>
<li>If it looks like anything else, no <em>ad hoc</em> polymorphism unless explicitly declared</li>
<li><em>parametric</em> polymorphic types can always be inferred (no hidden arguments)</li>
</ul></li>
<li>What looks like a function?
<ul>
<li>Has to bind a single symbol (<code>f</code>), rather than a pattern (<code>(x,   y)</code>, <code>(Just x)</code>)</li>
<li>Has to have at least one explicit argument (<code>f x =</code> ... ok, <code>f   =</code> ... not)</li>
</ul></li>
<li>How are monomorphic types inferred?
<ul>
<li>If bound symbol used elsewhere in module, infer type from use</li>
<li>If still ambiguous and type is of class <code>Num</code>, try <code>Integer</code> then <code>Double</code> (this sequence can be changed with a <a href="http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-790004.3.4"><code>default</code> declaration</a>)</li>
<li>If still ambiguous, compilation fails</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="the-dmr-take-away-message">The DMR take-away message</h1>
<ul>
<li>Think of type restrictions as implicit dictionary arguments
<ul>
<li>Compiler won't saddle non-function with implicit arguments</li>
</ul></li>
<li><p>This code will compile</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="co">-- Compiler infers: show1 :: (Show x) =&gt; x -&gt; String</span><br />show1 x <span class="fu">=</span> <span class="fu">show</span> x</code></pre></li>
<li><p>But neither of these will:</p>
<pre class="sourceCode"><code class="sourceCode haskell">show2 <span class="fu">=</span> <span class="fu">show</span><br />show3 <span class="fu">=</span> \x <span class="ot">-&gt;</span> <span class="fu">show</span> x</code></pre>
<ul>
<li>I'd rather you heard it from me than from GHC...</li>
</ul></li>
<li>Relatively easy to work around DMR
<ul>
<li><p>Add type signatures to functions--a good idea anyway for top-level bindings, and sometimes necessary for <code>let</code> bindings</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="co">-- No problem, compiler knows you want ad hoc polymorphism</span><br /><span class="ot">show2 </span><span class="ot">::</span> (<span class="kw">Show</span> x) <span class="ot">=&gt;</span> x <span class="ot">-&gt;</span> <span class="dt">String</span><br />show2 <span class="fu">=</span> <span class="fu">show</span></code></pre></li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="superclasses-and-instance-contexts">Superclasses and instance contexts</h1>
<ul>
<li>One class may require all instances to be members of another
<ul>
<li>Class <code>Eq</code> contains '==' and '/=' methods, while <code>Ord</code> contains <code>&lt;</code>, <code>&gt;=</code>, <code>&gt;</code>, <code>&lt;=</code>, etc.</li>
<li>It doesn't make sense to have an <code>Ord</code> instance not also be an <code>Eq</code> instance</li>
<li><p><code>Ord</code> declares <code>Eq</code> as a superclass, using a context</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Eq</span> a <span class="ot">=&gt;</span> <span class="kw">Ord</span> a <span class="kw">where</span><br />    (<span class="fu">&lt;</span>), (<span class="fu">&gt;=</span>), (<span class="fu">&gt;</span>),<span class="ot"> (&lt;=) </span><span class="ot">::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span><br />    a <span class="fu">&lt;=</span> b <span class="fu">=</span> a <span class="fu">==</span> b <span class="fu">||</span> a <span class="fu">&lt;</span> b <span class="co">-- default methods can use superclasses</span><br />    <span class="fu">....</span></code></pre></li>
<li>Don't need to write superclass restrictions in contexts--any function with an <code>Ord</code> dictionary can lookup the <code>Eq</code> dictionary</li>
<li>Incidentally, can add <code>deriving (Eq, Ord)</code> to <code>data</code> declarations</li>
</ul></li>
<li>Similarly, an instance may require a context
<ul>
<li>E.g., define <code>myShow</code> for a list of items whose type is of class <code>MyShow</code></li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">MyShow</span> a) <span class="ot">=&gt;</span> <span class="dt">MyShow</span> [a] <span class="kw">where</span><br />    myShow [] <span class="fu">=</span> <span class="st">&quot;[]&quot;</span><br />    myShow (x<span class="fu">:</span>xs) <span class="fu">=</span> myShow x <span class="fu">++</span> <span class="st">&quot;:&quot;</span> <span class="fu">++</span> myShow xs</code></pre></li>
</ul>
</div>
<div class="slide">
<h1 id="classes-of-parameterized-types">Classes of parameterized types</h1>
<ul>
<li>Can also have classes of parameterized types</li>
<li><p><code>Functor</code> is a class for parameterized types onto which you can map functions:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Functor</span> f <span class="kw">where</span><br /><span class="ot">    fmap </span><span class="ot">::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre>
<ul>
<li>Notice there are no arguments/results of type <code>f</code>, rather types <code>f a</code> and <code>f b</code></li>
</ul></li>
<li><p>An example of a <code>Functor</code> is <code>Maybe</code>:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span><br />    <span class="fu">fmap</span> _ <span class="kw">Nothing</span>  <span class="fu">=</span> <span class="kw">Nothing</span><br />    <span class="fu">fmap</span> f (<span class="kw">Just</span> a) <span class="fu">=</span> <span class="kw">Just</span> (f a)</code></pre>
<pre><code>GHCi, version 7.0.3: http://www.haskell.org/ghc/  :? for help
Prelude&gt; fmap (+ 1) Nothing
Nothing
Prelude&gt; fmap (+ 1) $ Just 2
Just 3
</code></pre></li>
</ul>
</div>
<div class="slide">
<h1 id="more-functors">More <code>Functor</code>s</h1>
<ul>
<li><p>Lists are a <code>Functor</code></p>
<ul>
<li><code>[]</code> can be used as a prefix type (&quot;<code>[] Int</code>&quot; means &quot;<code>[Int]</code>&quot;) and can be used to declare instances</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="fu">map</span><span class="ot"> </span><span class="ot">::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]<br /><span class="fu">map</span> _ []     <span class="fu">=</span> []<br /><span class="fu">map</span> f (x<span class="fu">:</span>xs) <span class="fu">=</span> f x <span class="fu">:</span> <span class="fu">map</span> f xs<br /><br /><span class="kw">instance</span> <span class="kw">Functor</span> [] <span class="kw">where</span><br />    <span class="fu">fmap</span> <span class="fu">=</span> <span class="fu">map</span></code></pre></li>
<li><p><code>IO</code> is a <code>Functor</code></p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Functor</span> <span class="dt">IO</span> <span class="kw">where</span><br />    <span class="fu">fmap</span> f x <span class="fu">=</span> x <span class="fu">&gt;&gt;=</span> <span class="fu">return</span> <span class="fu">.</span> f</code></pre>
<ul>
<li><p>So we could have said:</p>
<pre class="sourceCode"><code class="sourceCode haskell">simpleHttpStr url <span class="fu">=</span> <span class="fu">fmap</span> L.toString <span class="fu">$</span> simpleHttp url</code></pre>
<p>or, simpler still:</p>
<pre class="sourceCode"><code class="sourceCode haskell">simpleHttpStr <span class="fu">=</span> <span class="fu">fmap</span> L.toString <span class="fu">.</span> simpleHttp</code></pre></li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="kinds">Kinds</h1>
<ul>
<li><p>What happens if you try to make an instance of <code>Functor</code> for <code>Int</code>?</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Functor</span> <span class="dt">Int</span> <span class="kw">where</span>         <span class="co">-- compilation error</span><br />    <span class="fu">fmap</span> _ _ <span class="fu">=</span> <span class="fu">error</span> <span class="st">&quot;placeholder&quot;</span></code></pre>
<ul>
<li>Get <code>fmap :: (a -&gt; b) -&gt; Int a -&gt; Int b</code>, but <code>Int</code> not parameterized</li>
</ul></li>
<li>The compiler must keep track of all the different kinds of types
<ul>
<li>One kind of type (e.g., <code>Int</code>, <code>Double</code>, <code>()</code>) directly describes values</li>
<li>Another kind of type (<code>Maybe</code>, <code>[]</code>, <code>IO</code>) requires a type parameter</li>
<li>Yet another kind of type (<code>Either</code>, <code>(,)</code>), requires <em>two parameters</em></li>
<li>Parameterized types are sometimes called <em>type constructors</em></li>
</ul></li>
<li>Kinds named using symbols ∗ and →, much like curried functions
<ul>
<li>∗ is the kind of type that represents values (<code>Int</code>, <code>Double</code>, <code>()</code>, etc.)</li>
<li>∗ → ∗ is the kind of type with one parameter of type ∗ (<code>Maybe</code>, <code>IO</code>, etc.)</li>
<li>∗ → ∗ → ∗ is a type constructor with two arguments of kind ∗ (<code>Either</code>)</li>
<li>In general, <em>a</em> → <em>b</em> means a type constructor that, applied to kind <em>a</em>, yields kind <em>b</em></li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="the-monad-class">The <code>Monad</code> class</h1>
<ul>
<li><strong>The entire first two lectures have been working up to this slide</strong></li>
<li><code>return</code> and <code>&gt;&gt;=</code> are actually methods of a class called <code>Monad</code></li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Monad</span> m <span class="kw">where</span><br /><span class="ot">    (&gt;&gt;=) </span><span class="ot">::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b<br /><span class="ot">    return </span><span class="ot">::</span> a <span class="ot">-&gt;</span> m a<br /><span class="ot">    fail </span><span class="ot">::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> m a   <span class="co">-- called when pattern binding fails</span><br />    <span class="fu">fail</span> s <span class="fu">=</span> <span class="fu">error</span> s        <span class="co">-- default is to throw exception</span><br /><br /><span class="ot">    (&gt;&gt;) </span><span class="ot">::</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m a<br />    m <span class="fu">&gt;&gt;</span> k <span class="fu">=</span> m <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> k</code></pre>
<ul>
<li>This has far-reaching consequences
<ul>
<li>You can use the syntactic sugar of <code>do</code> blocks for non-IO purposes</li>
<li>Many monadic functions are polymorphic in the <code>Monad</code>--invent a new monad, and you can still use much existing code</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="the-maybe-monad">The <code>Maybe</code> monad</h1>
<ul>
<li><p>System libraries define a <code>Monad</code> instance for <code>Maybe</code></p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span>  <span class="kw">Monad</span> <span class="dt">Maybe</span>  <span class="kw">where</span><br />    (<span class="kw">Just</span> x) <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> k x<br />    <span class="kw">Nothing</span> <span class="fu">&gt;&gt;=</span> _  <span class="fu">=</span> <span class="kw">Nothing</span><br />    <span class="fu">return</span> <span class="fu">=</span> <span class="kw">Just</span><br />    <span class="fu">fail</span> _ <span class="fu">=</span> <span class="kw">Nothing</span></code></pre></li>
<li>You can use <code>Nothing</code> to indicate failure
<ul>
<li>Might have a bunch of functions to extract fields from data</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">extractA </span><span class="ot">::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span><br /><span class="ot">extractB </span><span class="ot">::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">String</span><br /><span class="fu">...</span><br /><span class="ot">parseForm </span><span class="ot">::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Form</span><br />parseForm raw <span class="fu">=</span> <span class="kw">do</span><br />    a <span class="ot">&lt;-</span> extractA raw<br />    b <span class="ot">&lt;-</span> extractB raw<br />    <span class="fu">...</span><br />    <span class="fu">return</span> (<span class="dt">Form</span> a b <span class="fu">...</span>)</code></pre>
<ul>
<li>Threads success/failure state through system as <code>IO</code> threaded World</li>
<li>Since Haskell is lazy, stops computing at first <code>Nothing</code></li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="algebraic-data-types">Algebraic data types</h1>
<ul>
<li><p>Some data types have a large number of fields</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="co">-- Argument to createProcess function</span><br /><span class="kw">data</span> <span class="dt">CreateProcess</span> <span class="fu">=</span> <span class="dt">CreateProcess</span> <span class="dt">CmdSpec</span> (<span class="dt">Maybe</span> <span class="fu">FilePath</span>)<br />    (<span class="dt">Maybe</span> [(<span class="dt">String</span>,<span class="dt">String</span>)]) <span class="dt">StdStream</span> <span class="dt">StdStream</span> <span class="dt">StdStream</span> <span class="dt">Bool</span></code></pre>
<ul>
<li>Quickly gets rather unwieldy</li>
</ul></li>
<li><p>Algebraic data types let you label fields (like C <code>struct</code>s)</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">CreateProcess</span> <span class="fu">=</span> <span class="dt">CreateProcess</span> {<br /><span class="ot">  cmdspec   </span><span class="ot">::</span> <span class="dt">CmdSpec</span>,<br /><span class="ot">  cwd       </span><span class="ot">::</span> <span class="dt">Maybe</span> <span class="fu">FilePath</span>,<br /><span class="ot">  env       </span><span class="ot">::</span> <span class="dt">Maybe</span> [(<span class="dt">String</span>,<span class="dt">String</span>)],<br /><span class="ot">  std_in    </span><span class="ot">::</span> <span class="dt">StdStream</span>,<br /><span class="ot">  std_out   </span><span class="ot">::</span> <span class="dt">StdStream</span>,<br /><span class="ot">  std_err   </span><span class="ot">::</span> <span class="dt">StdStream</span>,<br /><span class="ot">  close_fds </span><span class="ot">::</span> <span class="dt">Bool</span><br />}</code></pre></li>
<li><p>Let's make an algebraic version of our <code>Point</code> class</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Point</span> <span class="fu">=</span> <span class="dt">Point</span> {<span class="ot"> xCoord </span><span class="ot">::</span> <span class="dt">Double</span>,<span class="ot"> yCoord </span><span class="ot">::</span> <span class="dt">Double</span> }</code></pre></li>
</ul>
</div>
<div class="slide">
<h1 id="algebraic-types---initialization-and-matching">Algebraic types - initialization and matching</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Point</span> <span class="fu">=</span> <span class="dt">Point</span> {<span class="ot"> xCoord </span><span class="ot">::</span> <span class="dt">Double</span>,<span class="ot"> yCoord </span><span class="ot">::</span> <span class="dt">Double</span> }</code></pre>
<ul>
<li><p>Can initialize an Algebraic type by naming fields</p>
<pre class="sourceCode"><code class="sourceCode haskell">myPoint <span class="fu">=</span> <span class="dt">Point</span> { xCoord <span class="fu">=</span> <span class="dv">1</span><span class="fu">.</span><span class="dv">0</span>, yCoord <span class="fu">=</span> <span class="dv">1</span><span class="fu">.</span><span class="dv">0</span> }</code></pre>
<ul>
<li>Uninitialized fields get value <code>undefined</code> - a thunk that throws an exception</li>
</ul></li>
<li><p>Can also pattern-match on any subset of fields</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="co">-- Note the pattern binding assigns the variable on the right of =</span><br />getX <span class="dt">Point</span>{ xCoord <span class="fu">=</span> x } <span class="fu">=</span> x</code></pre>
<ul>
<li><p><a href="http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-590003.17.1"><em>As-patterns</em></a> are handy to bind a variable and pattern simultaneously (with <code>@</code>):</p>
<pre class="sourceCode"><code class="sourceCode haskell">getX' p<span class="fu">@</span><span class="dt">Point</span>{ xCoord <span class="fu">=</span> x }<br />        <span class="fu">|</span> x <span class="fu">&lt;</span> <span class="dv">100</span> <span class="fu">=</span> x<br />        <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> <span class="fu">error</span> <span class="fu">$</span> <span class="fu">show</span> p <span class="fu">++</span> <span class="st">&quot; out of range&quot;</span></code></pre>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="co">-- Also works with non-algebraic patterns</span><br />getX' p<span class="fu">@</span>(<span class="dt">Point</span> x _) <span class="fu">=</span> <span class="fu">...</span><br />processString s<span class="fu">@</span>(<span class="ch">'$'</span><span class="fu">:</span>_) <span class="fu">=</span> <span class="fu">...</span><br />processString s         <span class="fu">=</span> <span class="fu">...</span></code></pre></li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="algebraic-types---access-and-update">Algebraic types - access and update</h1>
<ul>
<li><p>Can use field labels as access functions</p>
<pre class="sourceCode"><code class="sourceCode haskell">getX point <span class="fu">=</span> xCoord point</code></pre>
<ul>
<li><code>xCoord</code> works anywhere you can use a function of type <code>Point -&gt;   Double</code></li>
<li>One consequence: field labels share the same namespace as top-level bindings, and must be unique</li>
</ul></li>
<li><p>There is a special syntax for updating one or more fields</p>
<pre class="sourceCode"><code class="sourceCode haskell">setX point x <span class="fu">=</span> point { xCoord <span class="fu">=</span> x }<br />setXY point x y <span class="fu">=</span> point { xCoord <span class="fu">=</span> x, yCoord <span class="fu">=</span> y }</code></pre>
<ul>
<li><p>Obviously doesn't update destructively, but returns new, modified <code>Point</code></p></li>
<li><p>Very handy to maintain state in tail recursive functions and <code>Monads</code></p></li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="a-few-miscellaneous-points">A few Miscellaneous points</h1>
<ul>
<li><p>A <code>!</code> before a data field type makes it <em>strict</em> - i.e., can't be thunk</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">State</span> <span class="fu">=</span> <span class="dt">State</span> <span class="fu">!</span><span class="dt">Int</span> <span class="dt">Int</span><br /><br /><span class="kw">data</span> <span class="dt">AlgState</span> <span class="fu">=</span> <span class="dt">AlgState</span> {<span class="ot"> accumulator </span><span class="ot">::</span> <span class="fu">!</span><span class="dt">Int</span><br />                         ,<span class="ot"> otherValue </span><span class="ot">::</span> <span class="dt">Int</span> }</code></pre>
<ul>
<li><p>In both cases above, the first <code>Int</code> cannot hold a thunk, but only a value</p></li>
<li><p>When initializing an algebraic datatype, it is mandatory to initialize all strict fields (since they cannot hold the <code>undefined</code> thunk).</p></li>
</ul></li>
<li><a href="http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Map.html"><code>Data.Map</code></a> maintains efficient, functional lookup tables
<ul>
<li>The tables cannot be mutated, but can be updated and used in recursive functions</li>
</ul></li>
<li><p><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-List.html#v:words"><code>words</code></a> breaks a <code>String</code> up into a list of whitespace-separated words</p></li>
</ul>
</div>
</body>

<!-- Mirrored from www.scs.stanford.edu/11au-cs240h/notes/basics-slides.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 23 Dec 2016 12:49:39 GMT -->
</html>
