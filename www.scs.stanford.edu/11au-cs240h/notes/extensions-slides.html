<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

Providence Salumu
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">
/*<![CDATA[*/
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre 
   { margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none; }
td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; }
td.sourceCode { padding-left: 5px; }
code.sourceCode span.kw { color: #007020; font-weight: bold; } 
code.sourceCode span.dt { color: #902000; }
code.sourceCode span.dv { color: #40a070; }
code.sourceCode span.bn { color: #40a070; }
code.sourceCode span.fl { color: #40a070; }
code.sourceCode span.ch { color: #4070a0; }
code.sourceCode span.st { color: #4070a0; }
code.sourceCode span.co { color: #60a0b0; font-style: italic; }
code.sourceCode span.ot { color: #007020; }
code.sourceCode span.al { color: red; font-weight: bold; }
code.sourceCode span.fu { color: #06287e; }
code.sourceCode span.re { }
code.sourceCode span.er { color: red; font-weight: bold; }
/*]]>*/
  </style>
  <style type="text/css">
/*<![CDATA[*/
/* slidy.css

   Copyright (c) 2005-2010 W3C (MIT, ERCIM, Keio), All Rights Reserved.
   W3C liability, trademark, document use and software licensing
   rules apply, see:

   http://www.w3.org/Consortium/Legal/copyright-documents
   http://www.w3.org/Consortium/Legal/copyright-software
*/
body
{
  margin: 0 0 0 0;
  padding: 0 0 0 0;
  width: 100%;
  height: 100%;
  color: black;
  background-color: white;
  font-family: "URW Palladio L", "Palatino Linotype", sans-serif;
  font-size: 14pt;
}

code
{
  font-family: "DejaVu Sans Mono", monospace;
}

div.toolbar {
  position: fixed; z-index: 200;
  top: auto; bottom: 0; left: 0; right: 0;
  height: 1.2em; text-align: right;
  padding-left: 1em;
  padding-right: 1em; 
  font-size: 60%;
  color: red;
  background-color: rgb(240,240,240);
  border-top: solid 1px rgb(180,180,180);
}

div.toolbar span.copyright {
  color: black;
  margin-left: 0.5em;
}

div.initial_prompt {
  position: absolute;
  z-index: 1000;
  bottom: 1.2em;
  width: 100%;
  background-color: rgb(200,200,200);
  opacity: 0.35;
  background-color: rgb(200,200,200, 0.35);
  cursor: pointer;
}

div.initial_prompt p.help {
  text-align: center;
}

div.initial_prompt p.close {
  text-align: right;
  font-style: italic;
}

div.slidy_toc {
  position: absolute;
  z-index: 300;
  width: 60%;
  max-width: 30em;
  height: 30em;
  overflow: auto;
  top: auto;
  right: auto;
  left: 4em;
  bottom: 4em;
  padding: 1em;
  background: rgb(240,240,240);
  border-style: solid;
  border-width: 2px;
  font-size: 60%;
}

div.slidy_toc .toc_heading {
  text-align: center;
  width: 100%;
  margin: 0;
  margin-bottom: 1em;
  border-bottom-style: solid;
  border-bottom-color: rgb(180,180,180);
  border-bottom-width: 1px;
}

div.slide {
  z-index: 20;
  margin: 0 0 0 0;
  padding-top: 0;
  padding-bottom: 0;
  padding-left: 20px;
  padding-right: 20px;
  border-width: 0;
  clear: both;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  line-height: 120%;
  background-color: transparent;
}

div.slide > div.figure {
  text-align: center
}

div.background {
  display: none;
}

div.handout {
  margin-left: 20px;
  margin-right: 20px;
}

div.slide.titlepage {
  text-align: center;
}

div.slide.titlepage h1 {
  padding-top: 10%;
  margin-right: 0;
}

div.slide h1 {
  padding-left: 0;
  padding-right: 20pt;
  padding-top: 4pt;
  padding-bottom: 4pt;
  margin-top: 0;
  margin-left: 0;
  margin-right: 60pt;
  margin-bottom: 0.5em;
  display: block; 
  font-size: 160%;
  line-height: 1.2em;
  background: transparent;
}

div.toc {
  position: absolute;
  top: auto;
  bottom: 4em;
  left: 4em;
  right: auto;
  width: 60%;
  max-width: 30em;
  height: 30em;
  border: solid thin black;
  padding: 1em;
  background: rgb(240,240,240);
  color: black;
  z-index: 300;
  overflow: auto;
  display: block;
  visibility: visible;
}

div.toc-heading {
  width: 100%;
  border-bottom: solid 1px rgb(180,180,180);
  margin-bottom: 1em;
  text-align: center;
}

pre {
 font-size: 80%;
 font-weight: bold;
 line-height: 120%;
 padding-top: 0.2em;
 padding-bottom: 0.2em;
 padding-left: 1em;
 padding-right: 1em;
 border-style: solid;
 border-left-width: 1em;
 border-top-width: thin;
 border-right-width: thin;
 border-bottom-width: thin;
 border-color: #95ABD0;
 color: #00428C;
 background-color: #E4E5E7;
}

li pre { margin-left: 0; }

blockquote { font-style: italic }

img { background-color: transparent }

p.copyright { font-size: smaller }

.center { text-align: center }
.footnote { font-size: smaller; margin-left: 2em; }

a img { border-width: 0; border-style: none }

a:visited { color: navy }
a:link { color: navy }
a:hover { color: red; text-decoration: underline }
a:active { color: red; text-decoration: underline }

a {text-decoration: none}
.navbar a:link {color: white}
.navbar a:visited {color: yellow}
.navbar a:active {color: red}
.navbar a:hover {color: red}

ul { list-style-type: square; }
ul ul { list-style-type: disc; }
ul ul ul { list-style-type: circle; }
ul ul ul ul { list-style-type: disc; }
li { margin-left: 0.5em; margin-top: 0.5em; font-weight: bold }
li li { font-size: 85%; font-weight: normal }
li li li { font-size: 85%; font-weight: normal }
strong { color: red; }
li li strong { color: black; }
/* pandoc's rules about when to insert paragraphs don't interact well
with the requirement for blank lines around code blocks.  Let's just
neutralize the effects of p in bullets.  */
li > p { margin: 0em; }

div dt
{
  margin-left: 0;
  margin-top: 1em;
  margin-bottom: 0.5em;
  font-weight: bold;
}
div dd
{
  margin-left: 2em;
  margin-bottom: 0.5em;
}


p,pre,ul,ol,blockquote,h2,h3,h4,h5,h6,dl,table {
  margin-left: 1em;
  margin-right: 1em;
}

p.subhead { font-weight: bold; margin-top: 2em; }

.smaller { font-size: smaller }
.bigger { font-size: 130% }

td,th { padding: 0.2em }

ul {
  margin: 0.5em 1.5em 0.5em 1.5em;
  padding: 0;
}

ol {
  margin: 0.5em 1.5em 0.5em 1.5em;
  padding: 0;
}

ul { list-style-type: square; }
ul ul { list-style-type: disc; }
ul ul ul { list-style-type: circle; }
ul ul ul ul { list-style-type: disc; }

ul li { 
  list-style: square;
  margin: 0.1em 0em 0.6em 0;
  padding: 0 0 0 0;
  line-height: 140%;
}

ol li { 
  margin: 0.1em 0em 0.6em 1.5em;
  padding: 0 0 0 0px;
  line-height: 140%;
  list-style-type: decimal;
}

li ul li { 
  font-size: 85%; 
  font-style: normal;
  list-style-type: disc;
  background: transparent;
  padding: 0 0 0 0;
}
li li ul li { 
  font-size: 85%; 
  font-style: normal;
  list-style-type: circle;
  background: transparent;
  padding: 0 0 0 0;
}
li li li ul li {
  list-style-type: disc;
  background: transparent;
  padding: 0 0 0 0;
}

li ol li {
  list-style-type: decimal;
}


li li ol li {
  list-style-type: decimal;
}

/*
 setting class="outline on ol or ul makes it behave as an
 ouline list where blocklevel content in li elements is
 hidden by default and can be expanded or collapsed with
 mouse click. Set class="expand" on li to override default
*/

ol.outline li:hover { cursor: pointer }
ol.outline li.nofold:hover { cursor: default }

ul.outline li:hover { cursor: pointer }
ul.outline li.nofold:hover { cursor: default }

ol.outline { list-style:decimal; }
ol.outline ol { list-style-type:lower-alpha }

ol.outline li.nofold {
  padding: 0 0 0 20px;
  background: transparent url(http://www.scs.stanford.edu/11au-cs240h/graphics/nofold-dim.gif) no-repeat 0px 0.5em;
}
ol.outline li.unfolded {
  padding: 0 0 0 20px;
  background: transparent url(http://www.scs.stanford.edu/11au-cs240h/graphics/fold-dim.gif) no-repeat 0px 0.5em;
}
ol.outline li.folded {
  padding: 0 0 0 20px;
  background: transparent url(http://www.scs.stanford.edu/11au-cs240h/graphics/unfold-dim.gif) no-repeat 0px 0.5em;
}
ol.outline li.unfolded:hover {
  padding: 0 0 0 20px;
  background: transparent url(http://www.scs.stanford.edu/11au-cs240h/graphics/fold.gif) no-repeat 0px 0.5em;
}
ol.outline li.folded:hover {
  padding: 0 0 0 20px;
  background: transparent url(http://www.scs.stanford.edu/11au-cs240h/graphics/unfold.gif) no-repeat 0px 0.5em;
}

ul.outline li.nofold {
  padding: 0 0 0 20px;
  background: transparent url(http://www.scs.stanford.edu/11au-cs240h/graphics/nofold-dim.gif) no-repeat 0px 0.5em;
}
ul.outline li.unfolded {
  padding: 0 0 0 20px;
  background: transparent url(http://www.scs.stanford.edu/11au-cs240h/graphics/fold-dim.gif) no-repeat 0px 0.5em;
}
ul.outline li.folded {
  padding: 0 0 0 20px;
  background: transparent url(http://www.scs.stanford.edu/11au-cs240h/graphics/unfold-dim.gif) no-repeat 0px 0.5em;
}
ul.outline li.unfolded:hover {
  padding: 0 0 0 20px;
  background: transparent url(http://www.scs.stanford.edu/11au-cs240h/graphics/fold.gif) no-repeat 0px 0.5em;
}
ul.outline li.folded:hover {
  padding: 0 0 0 20px;
  background: transparent url(http://www.scs.stanford.edu/11au-cs240h/graphics/unfold.gif) no-repeat 0px 0.5em;
}

/* for slides with class "title" in table of contents */
a.titleslide { font-weight: bold; font-style: italic }

/*
 hide images for work around for save as bug
 where browsers fail to save images used by CSS
*/
img.hidden { display: none; visibility: hidden }
div.initial_prompt { display: none; visibility: hidden }

  div.slide {
     visibility: visible;
     position: inherit;
  }
  div.handout {
     border-top-style: solid;
     border-top-width: thin;
     border-top-color: black;
  }

@media screen {
  .hidden { display: none; visibility: visible }

  div.slide.hidden { display: block; visibility: visible }
  div.handout.hidden { display: block; visibility: visible }
  div.background { display: none; visibility: hidden }
  body.single_slide div.initial_prompt { display: block; visibility: visible }
  body.single_slide div.background { display: block; visibility: visible }
  body.single_slide div.background.hidden { display: none; visibility: hidden }
  body.single_slide .invisible { visibility: hidden }
  body.single_slide .hidden { display: none; visibility: hidden }
  body.single_slide div.slide { position: absolute }
  body.single_slide div.handout { display: none; visibility: hidden }
}

@media print {
  .hidden { display: block; visibility: visible }

  div.slide pre { font-size: 60%; padding-left: 0.5em; }
  div.toolbar { display: none; visibility: hidden; }
  div.slidy_toc { display: none; visibility: hidden; }
  div.background { display: none; visibility: hidden; }
  div.slide { page-break-before: always }
  /* :first-child isn't reliable for print media */
  div.slide.first-slide { page-break-before: avoid }
}

/*]]>*/
  </style>
<script type="text/javascript" charset="utf-8">
/*<![CDATA[*/
var w3c_slidy={ns_pos:(typeof window.pageYOffset!="undefined"),khtml:((navigator.userAgent).indexOf("KHTML")>=0?true:false),opera:((navigator.userAgent).indexOf("Opera")>=0?true:false),ipad:((navigator.userAgent).indexOf("iPad")>=0?true:false),iphone:((navigator.userAgent).indexOf("iPhone")>=0?true:false),ie:(typeof document.all!="undefined"&&!this.opera),ie6:(!this.ns_pos&&navigator.userAgent.indexOf("MSIE 6")!=-1),ie7:(!this.ns_pos&&navigator.userAgent.indexOf("MSIE 7")!=-1),ie8:(!this.ns_pos&&navigator.userAgent.indexOf("MSIE 8")!=-1),ie9:(!this.ns_pos&&navigator.userAgent.indexOf("MSIE 9")!=-1),keyboardless:(this.ipad||this.iphone),is_xhtml:/xml/.test(document.contentType),slide_number:0,slide_number_element:null,slides:[],notes:[],backgrounds:[],toolbar:null,title:null,last_shown:null,eos:null,toc:null,outline:null,selected_text_len:0,view_all:0,want_toolbar:true,mouse_click_enabled:true,scroll_hack:0,disable_slide_click:false,lang:"en",help_anchor:null,help_page:"http://www.w3.org/Talks/Tools/Slidy2/help/help.html",help_text:"Navigate with mouse click, space bar, Cursor Left/Right, or Pg Up and Pg Dn. Use S and B to change font size.",size_index:0,size_adjustment:0,sizes:new Array("10pt","12pt","14pt","16pt","18pt","20pt","22pt","24pt","26pt","28pt","30pt","32pt"),last_width:0,last_height:0,objects:[],set_up:function(){var a=function(){w3c_slidy.init()};if(typeof window.addEventListener!="undefined"){window.addEventListener("load",a,false)}else{window.attachEvent("onload",a)}},hide_slides:function(){if(document.body&&!w3c_slidy.initialized){document.body.style.visibility="hidden"}else{setTimeout(w3c_slidy.hide_slides,50)}},ie_hack:function(){window.resizeBy(0,-1);window.resizeBy(0,1)},init:function(){document.body.style.visibility="visible";this.init_localization();this.add_toolbar();this.wrap_implicit_slides();this.collect_slides();this.collect_notes();this.collect_backgrounds();this.objects=document.body.getElementsByTagName("object");this.patch_anchors();this.slide_number=this.find_slide_number(location.href);window.offscreenbuffering=true;this.size_adjustment=this.find_size_adjust();this.time_left=this.find_duration();this.hide_image_toolbar();this.init_outliner();this.title=document.title;this.is_xhtml=(document.body.tagName=="BODY"?false:true);if(this.slides.length>0){var a=this.slides[this.slide_number];if(this.slide_number>0){this.set_visibility_all_incremental("visible");this.last_shown=this.previous_incremental_item(null);this.set_eos_status(true)}else{this.last_shown=null;this.set_visibility_all_incremental("hidden");this.set_eos_status(!this.next_incremental_item(this.last_shown))}this.set_location();this.add_class(this.slides[0],"first-slide");w3c_slidy.show_slide(a)}this.toc=this.table_of_contents();this.add_initial_prompt();if(!this.keyboardless){this.add_listener(document.body,"click",this.mouse_button_click)}this.add_listener(document,"keydown",this.key_down);this.add_listener(document,"keypress",this.key_press);this.add_listener(window,"resize",this.resized);this.add_listener(window,"scroll",this.scrolled);this.add_listener(window,"unload",this.unloaded);this.single_slide_view();this.resized();if(this.ie7){setTimeout(w3c_slidy.ie_hack,100)}this.show_toolbar();setInterval(function(){w3c_slidy.check_location()},200);w3c_slidy.initialized=true},table_of_contents:function(){var c=this.create_element("div");this.add_class(c,"slidy_toc hidden");var k=this.create_element("div");this.add_class(k,"toc-heading");k.innerHTML=this.localize("Table of Contents");c.appendChild(k);var f=null;for(var d=0;d<this.slides.length;++d){var g=this.has_class(this.slides[d],"title");var e=document.createTextNode((d+1)+". ");c.appendChild(e);var h=this.create_element("a");h.setAttribute("href","#("+(d+1)+")");if(g){this.add_class(h,"titleslide")}var b=document.createTextNode(this.slide_name(d));h.appendChild(b);h.onclick=w3c_slidy.toc_click;h.onkeydown=w3c_slidy.toc_key_down;h.previous=f;if(f){f.next=h}c.appendChild(h);if(d==0){c.first=h}if(d<this.slides.length-1){var j=this.create_element("br");c.appendChild(j)}f=h}c.focus=function(){if(this.first){this.first.focus()}};c.onmouseup=w3c_slidy.mouse_button_up;c.onclick=function(a){a||(a=window.event);if(w3c_slidy.selected_text_len<=0){w3c_slidy.hide_table_of_contents(true)}w3c_slidy.stop_propagation(a);if(a.cancel!=undefined){a.cancel=true}if(a.returnValue!=undefined){a.returnValue=false}return false};document.body.insertBefore(c,document.body.firstChild);return c},is_shown_toc:function(){return !w3c_slidy.has_class(w3c_slidy.toc,"hidden")},show_table_of_contents:function(){w3c_slidy.remove_class(w3c_slidy.toc,"hidden");var a=w3c_slidy.toc;a.focus();if(w3c_slidy.ie7&&w3c_slidy.slide_number==0){setTimeout(w3c_slidy.ie_hack,100)}},hide_table_of_contents:function(a){w3c_slidy.add_class(w3c_slidy.toc,"hidden");if(a&&!w3c_slidy.opera){w3c_slidy.help_anchor.focus()}},toggle_table_of_contents:function(){if(w3c_slidy.is_shown_toc()){w3c_slidy.hide_table_of_contents(true)}else{w3c_slidy.show_table_of_contents()}},toc_click:function(d){if(!d){d=window.event}var c=w3c_slidy.get_target(d);if(c&&c.nodeType==1){var b=c.getAttribute("href");if(b){var a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=w3c_slidy.find_slide_number(b);a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.last_shown=null;w3c_slidy.set_location();w3c_slidy.set_visibility_all_incremental("hidden");w3c_slidy.set_eos_status(!w3c_slidy.next_incremental_item(w3c_slidy.last_shown));w3c_slidy.show_slide(a);try{if(!w3c_slidy.opera){w3c_slidy.help_anchor.focus()}}catch(d){}}}w3c_slidy.hide_table_of_contents(true);if(w3c_slidy.ie7){w3c_slidy.ie_hack()}w3c_slidy.stop_propagation(d);return w3c_slidy.cancel(d)},toc_key_down:function(d){var b;if(!d){var d=window.event}if(window.event){b=window.event.keyCode}else{if(d.which){b=d.which}else{return true}}if(!b){return true}if(d.ctrlKey||d.altKey){return true}if(b==13){var c=this.getAttribute("href");if(c){var a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=w3c_slidy.find_slide_number(c);a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.last_shown=null;w3c_slidy.set_location();w3c_slidy.set_visibility_all_incremental("hidden");w3c_slidy.set_eos_status(!w3c_slidy.next_incremental_item(w3c_slidy.last_shown));w3c_slidy.show_slide(a);try{if(!w3c_slidy.opera){w3c_slidy.help_anchor.focus()}}catch(f){}}w3c_slidy.hide_table_of_contents(true);if(self.ie7){w3c_slidy.ie_hack()}return w3c_slidy.cancel(d)}if(b==40&&this.next){this.next.focus();return w3c_slidy.cancel(d)}if(b==38&&this.previous){this.previous.focus();return w3c_slidy.cancel(d)}return true},before_print:function(){this.show_all_slides();this.hide_toolbar();alert("before print")},after_print:function(){if(!this.view_all){this.single_slide_view();this.show_toolbar()}alert("after print")},print_slides:function(){this.before_print();window.print();this.after_print()},toggle_view:function(){if(this.view_all){this.single_slide_view();this.show_toolbar();this.view_all=0}else{this.show_all_slides();this.hide_toolbar();this.view_all=1}},show_all_slides:function(){this.remove_class(document.body,"single_slide");this.set_visibility_all_incremental("visible")},single_slide_view:function(){this.add_class(document.body,"single_slide");this.set_visibility_all_incremental("visible");this.last_shown=this.previous_incremental_item(null)},hide_image_toolbar:function(){if(!this.ns_pos){var a=document.getElementsByTagName("IMG");for(var b=0;b<a.length;++b){a[b].setAttribute("galleryimg","no")}}},unloaded:function(a){},is_KHTML:function(){var a=navigator.userAgent;return(a.indexOf("KHTML")>=0?true:false)},slide_name:function(c){var b=null;var a=this.slides[c];var d=this.find_heading(a);if(d){b=this.extract_text(d)}if(!b){b=this.title+"("+(c+1)+")"}b.replace(/\&/g,"&amp;");b.replace(/\</g,"&lt;");b.replace(/\>/g,"&gt;");return b},find_heading:function(a){if(!a||a.nodeType!=1){return null}if(a.nodeName=="H1"||a.nodeName=="h1"){return a}var b=a.firstChild;while(b){a=this.find_heading(b);if(a){return a}b=b.nextSibling}return null},extract_text:function(a){if(!a){return""}if(a.nodeType==3){return a.nodeValue}if(a.nodeType==1){a=a.firstChild;var b="";while(a){b=b+this.extract_text(a);a=a.nextSibling}return b}return""},find_copyright:function(){var a,c;var d=document.getElementsByTagName("meta");for(var b=0;b<d.length;++b){a=d[b].getAttribute("name");c=d[b].getAttribute("content");if(a=="copyright"){return c}}return null},find_size_adjust:function(){var a,c,e;var d=document.getElementsByTagName("meta");for(var b=0;b<d.length;++b){a=d[b].getAttribute("name");c=d[b].getAttribute("content");if(a=="font-size-adjustment"){return 1*c}}return 1},find_duration:function(){var a,c,e;var d=document.getElementsByTagName("meta");for(var b=0;b<d.length;++b){a=d[b].getAttribute("name");c=d[b].getAttribute("content");if(a=="duration"){return 60000*c}}return null},replace_by_non_breaking_space:function(b){for(var a=0;a<b.length;++a){b[a]=160}},init_outliner:function(){var a=document.getElementsByTagName("li");for(var b=0;b<a.length;++b){var c=a[b];if(!this.has_class(c.parentNode,"outline")){continue}c.onclick=this.outline_click;if(this.foldable(c)){c.foldable=true;c.onfocus=function(){w3c_slidy.outline=this};c.onblur=function(){w3c_slidy.outline=null};if(!c.getAttribute("tabindex")){c.setAttribute("tabindex","0")}if(this.has_class(c,"expand")){this.unfold(c)}else{this.fold(c)}}else{this.add_class(c,"nofold");c.visible=true;c.foldable=false}}},foldable:function(b){if(!b||b.nodeType!=1){return false}var a=b.firstChild;while(a){if(a.nodeType==1&&this.is_block(a)){return true}a=a.nextSibling}return false},fold:function(b){if(b){this.remove_class(b,"unfolded");this.add_class(b,"folded")}var a=b?b.firstChild:null;while(a){if(a.nodeType==1&&this.is_block(a)){w3c_slidy.add_class(a,"hidden")}a=a.nextSibling}b.visible=false},unfold:function(b){if(b){this.add_class(b,"unfolded");this.remove_class(b,"folded")}var a=b?b.firstChild:null;while(a){if(a.nodeType==1&&this.is_block(a)){w3c_slidy.remove_class(a,"hidden")}a=a.nextSibling}b.visible=true},outline_click:function(c){if(!c){c=window.event}var a=false;var b=w3c_slidy.get_target(c);while(b&&b.visible==undefined){b=b.parentNode}if(!b){return true}if(c.which){a=(c.which==3)}else{if(c.button){a=(c.button==2)}}if(!a&&b.visible!=undefined){if(b.foldable){if(b.visible){w3c_slidy.fold(b)}else{w3c_slidy.unfold(b)}}w3c_slidy.stop_propagation(c);c.cancel=true;c.returnValue=false}return false},add_initial_prompt:function(){var a=this.create_element("div");a.setAttribute("class","initial_prompt");var b=this.create_element("p");a.appendChild(b);b.setAttribute("class","help");if(this.keyboardless){b.innerHTML="Tap footer to move to next slide"}else{b.innerHTML="Space or Right Arrow to move to next slide, click help below for more details"}this.add_listener(a,"click",function(c){document.body.removeChild(a);w3c_slidy.stop_propagation(c);if(c.cancel!=undefined){c.cancel=true}if(c.returnValue!=undefined){c.returnValue=false}return false});document.body.appendChild(a);this.initial_prompt=a;setTimeout(function(){document.body.removeChild(a)},5000)},add_toolbar:function(){var a,i;this.toolbar=this.create_element("div");this.toolbar.setAttribute("class","toolbar");if(this.ns_pos||!this.ie6){var k=this.create_element("div");k.setAttribute("style","float: right; text-align: right");a=this.create_element("span");a.innerHTML=this.localize("slide")+" n/m";k.appendChild(a);this.toolbar.appendChild(k);var e=this.create_element("div");e.setAttribute("style","text-align: left");this.eos=this.create_element("span");this.eos.innerHTML="* ";e.appendChild(this.eos);var g=this.create_element("a");g.setAttribute("href",this.help_page);g.setAttribute("title",this.localize(this.help_text));g.innerHTML=this.localize("help?");e.appendChild(g);this.help_anchor=g;var d=document.createTextNode(" ");e.appendChild(d);var f=this.create_element("a");f.setAttribute("href","javascript:w3c_slidy.toggle_table_of_contents()");f.setAttribute("title",this.localize("table of contents"));f.innerHTML=this.localize("contents?");e.appendChild(f);var b=document.createTextNode(" ");e.appendChild(b);var h=this.find_copyright();if(h){var j=this.create_element("span");j.className="copyright";j.innerHTML=h;e.appendChild(j)}this.toolbar.setAttribute("tabindex","0");this.toolbar.appendChild(e)}else{this.toolbar.style.position=(this.ie7?"fixed":"absolute");this.toolbar.style.zIndex="200";this.toolbar.style.width="99.9%";this.toolbar.style.height="1.2em";this.toolbar.style.top="auto";this.toolbar.style.bottom="0";this.toolbar.style.left="0";this.toolbar.style.right="0";this.toolbar.style.textAlign="left";this.toolbar.style.fontSize="60%";this.toolbar.style.color="red";this.toolbar.borderWidth=0;this.toolbar.className="toolbar";this.toolbar.style.background="rgb(240,240,240)";var c=this.create_element("span");c.innerHTML="&nbsp;&nbsp;*&nbsp;";this.toolbar.appendChild(c);this.eos=c;var g=this.create_element("a");g.setAttribute("href",this.help_page);g.setAttribute("title",this.localize(this.help_text));g.innerHTML=this.localize("help?");this.toolbar.appendChild(g);this.help_anchor=g;var d=document.createTextNode(" ");this.toolbar.appendChild(d);var f=this.create_element("a");f.setAttribute("href","javascript:toggleTableOfContents()");f.setAttribute("title",this.localize("table of contents".localize));f.innerHTML=this.localize("contents?");this.toolbar.appendChild(f);var b=document.createTextNode(" ");this.toolbar.appendChild(b);var h=this.find_copyright();if(h){var j=this.create_element("span");j.innerHTML=h;j.style.color="black";j.style.marginLeft="0.5em";this.toolbar.appendChild(j)}a=this.create_element("div");a.style.position="absolute";a.style.width="auto";a.style.height="1.2em";a.style.top="auto";a.style.bottom=0;a.style.right="0";a.style.textAlign="right";a.style.color="red";a.style.background="rgb(240,240,240)";a.innerHTML=this.localize("slide")+" n/m";this.toolbar.appendChild(a)}this.toolbar.onclick=function(m){if(!m){m=window.event}var l=m.target;if(!l&&m.srcElement){l=m.srcElement}if(l&&l.nodeType==3){l=l.parentNode}w3c_slidy.stop_propagation(m);if(l&&l.nodeName.toLowerCase()!="a"){w3c_slidy.mouse_button_click(m)}};this.slide_number_element=a;this.set_eos_status(false);document.body.appendChild(this.toolbar)},wrap_implicit_slides:function(){var a,d,c,b,f;var e=document.getElementsByTagName("h1");if(!e){return}for(a=0;a<e.length;++a){d=e[a];if(d.parentNode!=document.body){continue}c=d.nextSibling;f=document.createElement("div");this.add_class(f,"slide");document.body.replaceChild(f,d);f.appendChild(d);while(c){if(c.nodeType==1&&(c.nodeName=="H1"||c.nodeName=="h1"||c.nodeName=="DIV"||c.nodeName=="div")){break}b=c.nextSibling;c=document.body.removeChild(c);f.appendChild(c);c=b}}},collect_slides:function(){var e=new Array();var d=document.body.getElementsByTagName("div");for(var c=0;c<d.length;++c){div=d.item(c);if(this.has_class(div,"slide")){e[e.length]=div;this.add_class(div,"hidden");var b=document.createElement("br");div.appendChild(b);var a=document.createElement("br");div.appendChild(a)}else{if(this.has_class(div,"background")){div.style.display="block"}}}this.slides=e},collect_notes:function(){var b=new Array();var c=document.body.getElementsByTagName("div");for(var a=0;a<c.length;++a){div=c.item(a);if(this.has_class(div,"handout")){b[b.length]=div;this.add_class(div,"hidden")}}this.notes=b},collect_backgrounds:function(){var c=new Array();var b=document.body.getElementsByTagName("div");for(var a=0;a<b.length;++a){div=b.item(a);if(this.has_class(div,"background")){c[c.length]=div;this.add_class(div,"hidden")}}this.backgrounds=c},patch_anchors:function(){var a=w3c_slidy;var c=function(g){if(a.page_address(this.href)==a.page_address(location.href)){var f=a.find_slide_number(this.href);if(f!=a.slide_number){var e=a.slides[a.slide_number];a.hide_slide(e);a.slide_number=f;e=a.slides[a.slide_number];a.show_slide(e);a.set_location()}}else{w3c_slidy.stop_propagation(g)}this.blur();a.disable_slide_click=true};var d=document.body.getElementsByTagName("a");for(var b=0;b<d.length;++b){if(window.addEventListener){d[b].addEventListener("click",c,false)}else{d[b].attachEvent("onclick",c)}}},show_slide_number:function(){var a=w3c_slidy.get_timer();w3c_slidy.slide_number_element.innerHTML=a+w3c_slidy.localize("slide")+" "+(w3c_slidy.slide_number+1)+"/"+w3c_slidy.slides.length},check_location:function(){var b=location.hash;if(w3c_slidy.slide_number>0&&(b==""||b=="#")){w3c_slidy.goto_slide(0)}else{if(b.length>2&&b!="#("+(w3c_slidy.slide_number+1)+")"){var a=parseInt(location.hash.substr(2));if(!isNaN(a)){w3c_slidy.goto_slide(a-1)}}}if(w3c_slidy.time_left&&w3c_slidy.slide_number>0){w3c_slidy.show_slide_number();if(w3c_slidy.time_left>0){w3c_slidy.time_left-=200}}},get_timer:function(){var c="";if(w3c_slidy.time_left){var b,a;a=Math.floor(w3c_slidy.time_left/1000);b=Math.floor(a/60);a=a%60;c=(b?b+"m":"")+a+"s "}return c},set_location:function(){var a=w3c_slidy.page_address(location.href);var b="#("+(w3c_slidy.slide_number+1)+")";if(w3c_slidy.slide_number>=0){a=a+b}if(w3c_slidy.ie&&(w3c_slidy.ie6||w3c_slidy.ie7)){w3c_slidy.push_hash(b)}if(a!=location.href){location.href=a}if(this.khtml){b="("+(w3c_slidy.slide_number+1)+")"}if(!this.ie&&location.hash!=b&&location.hash!=""){location.hash=b}document.title=w3c_slidy.title+" ("+(w3c_slidy.slide_number+1)+")";w3c_slidy.show_slide_number()},page_address:function(b){var a=b.indexOf("#");if(a<0){a=b.indexOf("%23")}if(a<0){return b}return b.substr(0,a)},on_frame_loaded:function(b){location.hash=b;var a=w3c_slidy.page_address(location.href);location.href=a+b},push_hash:function(b){if(b==""){b="#(1)"}window.location.hash=b;var a=document.getElementById("historyFrame").contentWindow.document;a.open("javascript:'<html></html>'");a.write('<html><head><script type="text/javascript">window.parent.w3c_slidy.on_frame_loaded(\''+(b)+"');\74/script></head><body>hello mum</body></html>");a.close()},find_slide_number:function(e){var c=e.indexOf("#");if(c<0){return 0}var b=unescape(e.substr(c+1));var f=document.getElementById(b);if(!f){var d=/\((\d)+\)/;if(b.match(d)){var a=parseInt(b.substring(1,b.length-1));if(a>this.slides.length){a=1}if(--a<0){a=0}return a}d=/\[(\d)+\]/;if(b.match(d)){var a=parseInt(b.substring(1,b.length-1));if(a>this.slides.length){a=1}if(--a<0){a=0}return a}return 0}while(true){if(f.nodeName.toLowerCase()=="div"&&this.has_class(f,"slide")){break}f=f.parentNode;if(!f){return 0}}for(c=0;c<slides.length;++c){if(slides[c]==f){return c}}return 0},previous_slide:function(b){if(!w3c_slidy.view_all){var a;if((b||w3c_slidy.slide_number==0)&&w3c_slidy.last_shown!=null){w3c_slidy.last_shown=w3c_slidy.hide_previous_item(w3c_slidy.last_shown);w3c_slidy.set_eos_status(false)}else{if(w3c_slidy.slide_number>0){a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=w3c_slidy.slide_number-1;a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.set_visibility_all_incremental("visible");w3c_slidy.last_shown=w3c_slidy.previous_incremental_item(null);w3c_slidy.set_eos_status(true);w3c_slidy.show_slide(a)}}w3c_slidy.set_location();if(!w3c_slidy.ns_pos){w3c_slidy.refresh_toolbar(200)}}},next_slide:function(c){if(!w3c_slidy.view_all){var a,b=w3c_slidy.last_shown;if(c||w3c_slidy.slide_number==w3c_slidy.slides.length-1){w3c_slidy.last_shown=w3c_slidy.reveal_next_item(w3c_slidy.last_shown)}if((!c||w3c_slidy.last_shown==null)&&w3c_slidy.slide_number<w3c_slidy.slides.length-1){a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=w3c_slidy.slide_number+1;a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.last_shown=null;w3c_slidy.set_visibility_all_incremental("hidden");w3c_slidy.show_slide(a)}else{if(!w3c_slidy.last_shown){if(b&&c){w3c_slidy.last_shown=b}}}w3c_slidy.set_location();w3c_slidy.set_eos_status(!w3c_slidy.next_incremental_item(w3c_slidy.last_shown));if(!w3c_slidy.ns_pos){w3c_slidy.refresh_toolbar(200)}}},first_slide:function(){if(!w3c_slidy.view_all){var a;if(w3c_slidy.slide_number!=0){a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=0;a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.last_shown=null;w3c_slidy.set_visibility_all_incremental("hidden");w3c_slidy.show_slide(a)}w3c_slidy.set_eos_status(!w3c_slidy.next_incremental_item(w3c_slidy.last_shown));w3c_slidy.set_location()}},last_slide:function(){if(!w3c_slidy.view_all){var a;w3c_slidy.last_shown=null;if(w3c_slidy.last_shown==null&&w3c_slidy.slide_number<w3c_slidy.slides.length-1){a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=w3c_slidy.slides.length-1;a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.set_visibility_all_incremental("visible");w3c_slidy.last_shown=w3c_slidy.previous_incremental_item(null);w3c_slidy.show_slide(a)}else{w3c_slidy.set_visibility_all_incremental("visible");w3c_slidy.last_shown=w3c_slidy.previous_incremental_item(null)}w3c_slidy.set_eos_status(true);w3c_slidy.set_location()}},set_eos_status:function(a){if(this.eos){this.eos.style.color=(a?"rgb(240,240,240)":"red")}},goto_slide:function(b){var a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.slide_number=b;a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.last_shown=null;w3c_slidy.set_visibility_all_incremental("hidden");w3c_slidy.set_eos_status(!w3c_slidy.next_incremental_item(w3c_slidy.last_shown));document.title=w3c_slidy.title+" ("+(w3c_slidy.slide_number+1)+")";w3c_slidy.show_slide(a);w3c_slidy.show_slide_number()},show_slide:function(a){this.sync_background(a);window.scrollTo(0,0);this.remove_class(a,"hidden")},hide_slide:function(a){this.add_class(a,"hidden")},sync_background:function(a){var e;var g;if(a.currentStyle){g=a.currentStyle.backgroundColor}else{if(document.defaultView){var f=document.defaultView.getComputedStyle(a,null);if(f){g=f.getPropertyValue("background-color")}else{g="transparent"}}else{g=="transparent"}}if(g=="transparent"||g.indexOf("rgba")>=0||g.indexOf("opacity")>=0){var c=this.get_class_list(a);for(var d=0;d<this.backgrounds.length;d++){e=this.backgrounds[d];var b=this.get_class_list(e);if(this.matching_background(c,b)){this.remove_class(e,"hidden")}else{this.add_class(e,"hidden")}}}else{this.hide_backgrounds()}},hide_backgrounds:function(){for(var a=0;a<this.backgrounds.length;a++){background=this.backgrounds[a];this.add_class(background,"hidden")}},matching_background:function(c,b){var d,e,f,a;f=/\w+/g;a=b.match(f);for(d=e=0;d<a.length;d++){if(a[d]=="hidden"){continue}if(a[d]=="background"){continue}++e}if(e==0){return true}a=c.match(f);for(d=e=0;d<a.length;d++){if(a[d]=="hidden"){continue}if(this.has_token(b,a[d])){return true}}return false},resized:function(){var c=0;if(typeof(window.innerWidth)=="number"){c=window.innerWidth}else{if(document.documentElement&&document.documentElement.clientWidth){c=document.documentElement.clientWidth}else{if(document.body&&document.body.clientWidth){c=document.body.clientWidth}}}var b=0;if(typeof(window.innerHeight)=="number"){b=window.innerHeight}else{if(document.documentElement&&document.documentElement.clientHeight){b=document.documentElement.clientHeight}else{if(document.body&&document.body.clientHeight){b=document.body.clientHeight}}}if(b&&(c/b>1.05*1024/768)){c=b*1024/768}if(c!=w3c_slidy.last_width||b!=w3c_slidy.last_height){if(c>=1100){w3c_slidy.size_index=5}else{if(c>=1000){w3c_slidy.size_index=4}else{if(c>=800){w3c_slidy.size_index=3}else{if(c>=600){w3c_slidy.size_index=2}else{if(c){w3c_slidy.size_index=0}}}}}if(0<=w3c_slidy.size_index+w3c_slidy.size_adjustment&&w3c_slidy.size_index+w3c_slidy.size_adjustment<w3c_slidy.sizes.length){w3c_slidy.size_index=w3c_slidy.size_index+w3c_slidy.size_adjustment}w3c_slidy.adjust_object_dimensions(c,b);if(document.body.style.fontSize!=w3c_slidy.sizes[w3c_slidy.size_index]){document.body.style.fontSize=w3c_slidy.sizes[w3c_slidy.size_index]}w3c_slidy.last_width=c;w3c_slidy.last_height=b;if(w3c_slidy.ns_pos){var a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.show_slide(a)}w3c_slidy.refresh_toolbar(200)}},scrolled:function(){if(w3c_slidy.toolbar&&!w3c_slidy.ns_pos&&!w3c_slidy.ie7){w3c_slidy.hack_offset=w3c_slidy.scroll_x_offset();w3c_slidy.toolbar.style.display="none";if(w3c_slidy.scrollhack==0&&!w3c_slidy.view_all){setTimeout(function(){w3c_slidy.show_toolbar()},1000);w3c_slidy.scrollhack=1}}},hide_toolbar:function(){w3c_slidy.add_class(w3c_slidy.toolbar,"hidden");window.focus()},refresh_toolbar:function(a){if(!w3c_slidy.ns_pos&&!w3c_slidy.ie7){w3c_slidy.hide_toolbar();setTimeout(function(){w3c_slidy.show_toolbar()},a)}},show_toolbar:function(){if(w3c_slidy.want_toolbar){w3c_slidy.toolbar.style.display="block";if(!w3c_slidy.ns_pos){var b=w3c_slidy.scroll_x_offset();w3c_slidy.toolbar.style.left=b;w3c_slidy.toolbar.style.right=b;w3c_slidy.toolbar.style.bottom=0}w3c_slidy.remove_class(w3c_slidy.toolbar,"hidden")}w3c_slidy.scrollhack=0;try{if(!w3c_slidy.opera){w3c_slidy.help_anchor.focus()}}catch(a){}},toggle_toolbar:function(){if(!w3c_slidy.view_all){if(w3c_slidy.has_class(w3c_slidy.toolbar,"hidden")){w3c_slidy.remove_class(w3c_slidy.toolbar,"hidden");w3c_slidy.want_toolbar=1}else{w3c_slidy.add_class(w3c_slidy.toolbar,"hidden");w3c_slidy.want_toolbar=0}}},scroll_x_offset:function(){if(window.pageXOffset){return self.pageXOffset}if(document.documentElement&&document.documentElement.scrollLeft){return document.documentElement.scrollLeft}if(document.body){return document.body.scrollLeft}return 0},scroll_y_offset:function(){if(window.pageYOffset){return self.pageYOffset}if(document.documentElement&&document.documentElement.scrollTop){return document.documentElement.scrollTop}if(document.body){return document.body.scrollTop}return 0},optimize_font_size:function(){var a=w3c_slidy.slides[w3c_slidy.slide_number];var d=a.scrollHeight;var b=getWindowHeight();var c=100*d/b;alert("window utilization = "+c+"% (doc "+d+" win "+b+")")},get_doc_height:function(a){if(!a){a=document}if(a&&a.body&&a.body.offsetHeight){return a.body.offsetHeight}if(a&&a.body&&a.body.scrollHeight){return a.body.scrollHeight}alert("couldn't determine document height")},get_window_height:function(){if(typeof(window.innerHeight)=="number"){return window.innerHeight}if(document.documentElement&&document.documentElement.clientHeight){return document.documentElement.clientHeight}if(document.body&&document.body.clientHeight){return document.body.clientHeight}},document_height:function(){var a,b;a=document.body.scrollHeight;b=document.body.offsetHeight;if(a&&b){return(a>b?a:b)}return 0},smaller:function(){if(w3c_slidy.size_index>0){--w3c_slidy.size_index}w3c_slidy.toolbar.style.display="none";document.body.style.fontSize=w3c_slidy.sizes[w3c_slidy.size_index];var a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.show_slide(a);setTimeout(function(){w3c_slidy.show_toolbar()},50)},bigger:function(){if(w3c_slidy.size_index<w3c_slidy.sizes.length-1){++w3c_slidy.size_index}w3c_slidy.toolbar.style.display="none";document.body.style.fontSize=w3c_slidy.sizes[w3c_slidy.size_index];var a=w3c_slidy.slides[w3c_slidy.slide_number];w3c_slidy.hide_slide(a);w3c_slidy.show_slide(a);setTimeout(function(){w3c_slidy.show_toolbar()},50)},adjust_object_dimensions:function(c,k){for(var e=0;e<w3c_slidy.objects.length;e++){var d=this.objects[e];var b=d.getAttribute("type");if(b=="image/svg+xml"||b=="application/x-shockwave-flash"){if(!d.initialWidth){d.initialWidth=d.getAttribute("width")}if(!d.initialHeight){d.initialHeight=d.getAttribute("height")}if(d.initialWidth&&d.initialWidth.charAt(d.initialWidth.length-1)=="%"){var j=parseInt(d.initialWidth.slice(0,d.initialWidth.length-1));var a=c*(j/100);d.setAttribute("width",a)}if(d.initialHeight&&d.initialHeight.charAt(d.initialHeight.length-1)=="%"){var f=parseInt(d.initialHeight.slice(0,d.initialHeight.length-1));var g=k*(f/100);d.setAttribute("height",g)}}}},key_press:function(a){if(!a){a=window.event}if(!w3c_slidy.key_wanted){return w3c_slidy.cancel(a)}return true},key_down:function(d){var c,e,a;w3c_slidy.key_wanted=true;if(!d){d=window.event}if(window.event){c=window.event.keyCode;e=window.event.srcElement}else{if(d.which){c=d.which;e=d.target}else{return true}}if(!c){return true}if(!w3c_slidy.slidy_chrome(e)&&w3c_slidy.special_element(e)){return true}if(d.ctrlKey||d.altKey||d.metaKey){return true}if(w3c_slidy.is_shown_toc()&&c!=9&&c!=16&&c!=38&&c!=40){w3c_slidy.hide_table_of_contents(true);if(c==27||c==84||c==67){return w3c_slidy.cancel(d)}}if(c==34){if(w3c_slidy.view_all){return true}w3c_slidy.next_slide(false);return w3c_slidy.cancel(d)}else{if(c==33){if(w3c_slidy.view_all){return true}w3c_slidy.previous_slide(false);return w3c_slidy.cancel(d)}else{if(c==32){w3c_slidy.next_slide(true);return w3c_slidy.cancel(d)}else{if(c==37){w3c_slidy.previous_slide(!d.shiftKey);return w3c_slidy.cancel(d)}else{if(c==36){w3c_slidy.first_slide();return w3c_slidy.cancel(d)}else{if(c==35){w3c_slidy.last_slide();return w3c_slidy.cancel(d)}else{if(c==39){w3c_slidy.next_slide(!d.shiftKey);return w3c_slidy.cancel(d)}else{if(c==13){if(w3c_slidy.outline){if(w3c_slidy.outline.visible){w3c_slidy.fold(w3c_slidy.outline)}else{w3c_slidy.unfold(w3c_slidy.outline)}return w3c_slidy.cancel(d)}}else{if(c==188){w3c_slidy.smaller();return w3c_slidy.cancel(d)}else{if(c==190){w3c_slidy.bigger();return w3c_slidy.cancel(d)}else{if(c==189||c==109){w3c_slidy.smaller();return w3c_slidy.cancel(d)}else{if(c==187||c==191||c==107){w3c_slidy.bigger();return w3c_slidy.cancel(d)}else{if(c==83){w3c_slidy.smaller();return w3c_slidy.cancel(d)}else{if(c==66){w3c_slidy.bigger();return w3c_slidy.cancel(d)}else{if(c==90){w3c_slidy.last_slide();return w3c_slidy.cancel(d)}else{if(c==70){w3c_slidy.toggle_toolbar();return w3c_slidy.cancel(d)}else{if(c==65){w3c_slidy.toggle_view();return w3c_slidy.cancel(d)}else{if(c==75){w3c_slidy.mouse_click_enabled=!w3c_slidy.mouse_click_enabled;var b=(w3c_slidy.mouse_click_enabled?"enabled":"disabled")+" mouse click advance";alert(w3c_slidy.localize(b));return w3c_slidy.cancel(d)}else{if(c==84||c==67){if(w3c_slidy.toc){w3c_slidy.toggle_table_of_contents()}return w3c_slidy.cancel(d)}else{if(c==72){window.location=w3c_slidy.help_page;return w3c_slidy.cancel(d)}}}}}}}}}}}}}}}}}}}}return true},create_element:function(a){if(this.xhtml&&(typeof document.createElementNS!="undefined")){return document.createElementNS("http://www.w3.org/1999/xhtml",a)}return document.createElement(a)},get_element_style:function(d,b,c){if(d.currentStyle){return d.currentStyle[b]}else{if(window.getComputedStyle){var a=window.getComputedStyle(d,"");return a.getPropertyValue(c)}}return""},has_token:function(e,c){if(e){var d=/\w+/g;var a=e.match(d);for(var b=0;b<a.length;b++){if(a[b]==c){return true}}}return false},get_class_list:function(a){if(typeof a.className!="undefined"){return a.className}return a.getAttribute("class")},has_class:function(b,a){if(b.nodeType!=1){return false}var c=new RegExp("(^| )"+a+"W*");if(typeof b.className!="undefined"){return c.test(b.className)}return c.test(b.getAttribute("class"))},remove_class:function(b,a){var d=new RegExp("(^| )"+a+"W*");var c="";if(typeof b.className!="undefined"){c=b.className;if(c){c=c.replace(d,"");b.className=c}}else{c=b.getAttribute("class");if(c){c=c.replace(d,"");b.setAttribute("class",c)}}},add_class:function(b,a){if(!this.has_class(b,a)){if(typeof b.className!="undefined"){b.className+=" "+a}else{var c=b.getAttribute("class");c=c?c+" "+a:a;b.setAttribute("class",c)}}},incremental_elements:null,okay_for_incremental:function(a){if(!this.incremental_elements){var b=new Array();b.p=true;b.pre=true;b.li=true;b.blockquote=true;b.dt=true;b.dd=true;b.h2=true;b.h3=true;b.h4=true;b.h5=true;b.h6=true;b.span=true;b.address=true;b.table=true;b.tr=true;b.th=true;b.td=true;b.img=true;b.object=true;this.incremental_elements=b}return this.incremental_elements[a.toLowerCase()]},next_incremental_item:function(c){var b=this.is_xhtml?"br":"BR";var a=w3c_slidy.slides[w3c_slidy.slide_number];for(;;){c=w3c_slidy.next_node(a,c);if(c==null||c.parentNode==null){break}if(c.nodeType==1){if(c.nodeName==b){continue}if(w3c_slidy.has_class(c,"incremental")&&w3c_slidy.okay_for_incremental(c.nodeName)){return c}if(w3c_slidy.has_class(c.parentNode,"incremental")&&!w3c_slidy.has_class(c,"non-incremental")){return c}}}return c},previous_incremental_item:function(c){var b=this.is_xhtml?"br":"BR";var a=w3c_slidy.slides[w3c_slidy.slide_number];for(;;){c=w3c_slidy.previous_node(a,c);if(c==null||c.parentNode==null){break}if(c.nodeType==1){if(c.nodeName==b){continue}if(w3c_slidy.has_class(c,"incremental")&&w3c_slidy.okay_for_incremental(c.nodeName)){return c}if(w3c_slidy.has_class(c.parentNode,"incremental")&&!w3c_slidy.has_class(c,"non-incremental")){return c}}}return c},set_visibility_all_incremental:function(b){var a=this.next_incremental_item(null);if(b=="hidden"){while(a){w3c_slidy.add_class(a,"invisible");a=w3c_slidy.next_incremental_item(a)}}else{while(a){w3c_slidy.remove_class(a,"invisible");a=w3c_slidy.next_incremental_item(a)}}},reveal_next_item:function(a){a=w3c_slidy.next_incremental_item(a);if(a&&a.nodeType==1){w3c_slidy.remove_class(a,"invisible")}return a},hide_previous_item:function(a){if(a&&a.nodeType==1){w3c_slidy.add_class(a,"invisible")}return this.previous_incremental_item(a)},next_node:function(a,b){if(b==null){return a.firstChild}if(b.firstChild){return b.firstChild}if(b.nextSibling){return b.nextSibling}for(;;){b=b.parentNode;if(!b||b==a){break}if(b&&b.nextSibling){return b.nextSibling}}return null},previous_node:function(a,b){if(b==null){b=a.lastChild;if(b){while(b.lastChild){b=b.lastChild}}return b}if(b.previousSibling){b=b.previousSibling;while(b.lastChild){b=b.lastChild}return b}if(b.parentNode!=a){return b.parentNode}return null},previous_sibling_element:function(a){a=a.previousSibling;while(a&&a.nodeType!=1){a=a.previousSibling}return a},next_sibling_element:function(a){a=a.nextSibling;while(a&&a.nodeType!=1){a=a.nextSibling}return a},first_child_element:function(a){var b;for(b=a.firstChild;b;b=b.nextSibling){if(b.nodeType==1){break}}return b},first_tag:function(b,a){var c;if(!this.is_xhtml){a=a.toUpperCase()}for(c=b.firstChild;c;c=c.nextSibling){if(c.nodeType==1&&c.nodeName==a){break}}return c},hide_selection:function(){if(window.getSelection){var b=window.getSelection();if(b.rangeCount>0){var a=b.getRangeAt(0);a.collapse(false)}}else{var c=document.selection.createRange();c.collapse(false)}},get_selected_text:function(){try{if(window.getSelection){return window.getSelection().toString()}if(document.getSelection){return document.getSelection().toString()}if(document.selection){return document.selection.createRange().text}}catch(a){}return""},mouse_button_up:function(a){w3c_slidy.selected_text_len=w3c_slidy.get_selected_text().length},mouse_button_click:function(g){var c=false;var b=false;var d=false;var f;if(!g){var g=window.event}if(g.target){f=g.target}else{if(g.srcElement){f=g.srcElement}}if(f.nodeType==3){f=f.parentNode}if(g.which){b=(g.which==1);d=(g.which==2);c=(g.which==3)}else{if(g.button){if(g.button==4){d=true}c=(g.button==2)}else{b=true}}if(w3c_slidy.selected_text_len>0){w3c_slidy.stop_propagation(g);g.cancel=true;g.returnValue=false;return false}w3c_slidy.hide_table_of_contents(false);var a=f.nodeName.toLowerCase();if(w3c_slidy.mouse_click_enabled&&b&&!w3c_slidy.special_element(f)&&!f.onclick){w3c_slidy.next_slide(true);w3c_slidy.stop_propagation(g);g.cancel=true;g.returnValue=false;return false}return true},special_element:function(b){var a=b.nodeName.toLowerCase();return b.onkeydown||b.onclick||a=="a"||a=="embed"||a=="object"||a=="video"||a=="audio"||a=="input"||a=="textarea"||a=="select"||a=="option"},slidy_chrome:function(a){while(a){if(a==w3c_slidy.toc||a==w3c_slidy.toolbar||w3c_slidy.has_class(a,"outline")){return true}a=a.parentNode}return false},get_key:function(b){var a;if(typeof window.event!="undefined"){a=window.event.keyCode}else{if(b.which){a=b.which}}return a},get_target:function(b){var a;if(!b){b=window.event}if(b.target){a=b.target}else{if(b.srcElement){a=b.srcElement}}if(a.nodeType!=1){a=a.parentNode}return a},is_block:function(b){var a=b.nodeName.toLowerCase();return a=="ol"||a=="ul"||a=="p"||a=="li"||a=="table"||a=="pre"||a=="h1"||a=="h2"||a=="h3"||a=="h4"||a=="h5"||a=="h6"||a=="blockquote"||a=="address"},add_listener:function(a,c,b){if(window.addEventListener){a.addEventListener(c,b,false)}else{a.attachEvent("on"+c,b)}},stop_propagation:function(a){a=a?a:window.event;a.cancelBubble=true;if(a.stopPropagation){a.stopPropagation()}return true},cancel:function(a){if(a){a.cancel=true;a.returnValue=false;if(a.preventDefault){a.preventDefault()}}w3c_slidy.key_wanted=false;return false},strings_es:{slide:"pág.","help?":"Ayuda","contents?":"Índice","table of contents":"tabla de contenidos","Table of Contents":"Tabla de Contenidos","restart presentation":"Reiniciar presentación","restart?":"Inicio"},help_es:"Utilice el ratón, barra espaciadora, teclas Izda/Dcha, o Re pág y Av pág. Use S y B para cambiar el tamaño de fuente.",strings_ca:{slide:"pàg..","help?":"Ajuda","contents?":"Índex","table of contents":"taula de continguts","Table of Contents":"Taula de Continguts","restart presentation":"Reiniciar presentació","restart?":"Inici"},help_ca:"Utilitzi el ratolí, barra espaiadora, tecles Esq./Dta. o Re pàg y Av pàg. Usi S i B per canviar grandària de font.",strings_cs:{slide:"snímek","help?":"nápověda","contents?":"obsah","table of contents":"obsah prezentace","Table of Contents":"Obsah prezentace","restart presentation":"znovu spustit prezentaci","restart?":"restart"},help_cs:"Prezentaci můžete procházet pomocí kliknutí myši, mezerníku, šipek vlevo a vpravo nebo kláves PageUp a PageDown. Písmo se dá zvětšit a zmenšit pomocí kláves B a S.",strings_nl:{slide:"pagina","help?":"Help?","contents?":"Inhoud?","table of contents":"inhoudsopgave","Table of Contents":"Inhoudsopgave","restart presentation":"herstart presentatie","restart?":"Herstart?"},help_nl:"Navigeer d.m.v. het muis, spatiebar, Links/Rechts toetsen, of PgUp en PgDn. Gebruik S en B om de karaktergrootte te veranderen.",strings_de:{slide:"Seite","help?":"Hilfe","contents?":"Übersicht","table of contents":"Inhaltsverzeichnis","Table of Contents":"Inhaltsverzeichnis","restart presentation":"Präsentation neu starten","restart?":"Neustart"},help_de:"Benutzen Sie die Maus, Leerschlag, die Cursortasten links/rechts oder Page up/Page Down zum Wechseln der Seiten und S und B für die Schriftgrösse.",strings_pl:{slide:"slajd","help?":"pomoc?","contents?":"spis treści?","table of contents":"spis treści","Table of Contents":"Spis Treści","restart presentation":"Restartuj prezentację","restart?":"restart?"},help_pl:"Zmieniaj slajdy klikając myszą, naciskając spację, strzałki lewo/prawolub PgUp / PgDn. Użyj klawiszy S i B, aby zmienić rozmiar czczionki.",strings_fr:{slide:"page","help?":"Aide","contents?":"Index","table of contents":"table des matières","Table of Contents":"Table des matières","restart presentation":"Recommencer l'exposé","restart?":"Début"},help_fr:"Naviguez avec la souris, la barre d'espace, les flèches gauche/droite ou les touches Pg Up, Pg Dn. Utilisez les touches S et B pour modifier la taille de la police.",strings_hu:{slide:"oldal","help?":"segítség","contents?":"tartalom","table of contents":"tartalomjegyzék","Table of Contents":"Tartalomjegyzék","restart presentation":"bemutató újraindítása","restart?":"újraindítás"},help_hu:"Az oldalak közti lépkedéshez kattintson az egérrel, vagy használja a szóköz, a bal, vagy a jobb nyíl, illetve a Page Down, Page Up billentyűket. Az S és a B billentyűkkel változtathatja a szöveg méretét.",strings_it:{slide:"pag.","help?":"Aiuto","contents?":"Indice","table of contents":"indice","Table of Contents":"Indice","restart presentation":"Ricominciare la presentazione","restart?":"Inizio"},help_it:"Navigare con mouse, barra spazio, frecce sinistra/destra o PgUp e PgDn. Usare S e B per cambiare la dimensione dei caratteri.",strings_el:{slide:"σελίδα","help?":"βοήθεια;","contents?":"περιεχόμενα;","table of contents":"πίνακας περιεχομένων","Table of Contents":"Πίνακας Περιεχομένων","restart presentation":"επανεκκίνηση παρουσίασης","restart?":"επανεκκίνηση;"},help_el:"Πλοηγηθείτε με το κλίκ του ποντικιού, το space, τα βέλη αριστερά/δεξιά, ή Page Up και Page Down. Χρησιμοποιήστε τα πλήκτρα S και B για να αλλάξετε το μέγεθος της γραμματοσειράς.",strings_ja:{slide:"スライド","help?":"ヘルプ","contents?":"目次","table of contents":"目次を表示","Table of Contents":"目次","restart presentation":"最初から再生","restart?":"最初から"},help_ja:"マウス左クリック ・ スペース ・ 左右キー または Page Up ・ Page Downで操作， S ・ Bでフォントサイズ変更",strings_zh:{slide:"幻灯片","help?":"帮助?","contents?":"内容?","table of contents":"目录","Table of Contents":"目录","restart presentation":"重新启动展示","restart?":"重新启动?"},help_zh:"用鼠标点击, 空格条, 左右箭头, Pg Up 和 Pg Dn 导航. 用 S, B 改变字体大小.",strings_ru:{slide:"слайд","help?":"помощь?","contents?":"содержание?","table of contents":"оглавление","Table of Contents":"Оглавление","restart presentation":"перезапустить презентацию","restart?":"перезапуск?"},help_ru:"Перемещайтесь кликая мышкой, используя клавишу пробел, стрелкивлево/вправо или Pg Up и Pg Dn. Клавиши S и B меняют размер шрифта.",strings_sv:{slide:"sida","help?":"hjälp","contents?":"innehåll","table of contents":"innehållsförteckning","Table of Contents":"Innehållsförteckning","restart presentation":"visa presentationen från början","restart?":"börja om"},help_sv:"Bläddra med ett klick med vänstra musknappen, mellanslagstangenten, vänster- och högerpiltangenterna eller tangenterna Pg Up, Pg Dn. Använd tangenterna S och B för att ändra textens storlek.",strings:{},localize:function(d){if(d==""){return d}var b,c=w3c_slidy.strings[w3c_slidy.lang];if(c){b=c[d];if(b){return b}}var a=w3c_slidy.lang.split("-");if(a.length>1){c=w3c_slidy.strings[a[0]];if(c){b=c[d];if(b){return b}}}return d},init_localization:function(){var b=w3c_slidy;var a=w3c_slidy.help_text;this.strings={es:this.strings_es,ca:this.strings_ca,cs:this.strings_cs,nl:this.strings_nl,de:this.strings_de,pl:this.strings_pl,fr:this.strings_fr,hu:this.strings_hu,it:this.strings_it,el:this.strings_el,jp:this.strings_ja,zh:this.strings_zh,ru:this.strings_ru,sv:this.strings_sv},b.strings_es[a]=b.help_es;b.strings_ca[a]=b.help_ca;b.strings_cs[a]=b.help_cs;b.strings_nl[a]=b.help_nl;b.strings_de[a]=b.help_de;b.strings_pl[a]=b.help_pl;b.strings_fr[a]=b.help_fr;b.strings_hu[a]=b.help_hu;b.strings_it[a]=b.help_it;b.strings_el[a]=b.help_el;b.strings_ja[a]=b.help_ja;b.strings_zh[a]=b.help_zh;b.strings_ru[a]=b.help_ru;b.strings_sv[a]=b.help_sv;w3c_slidy.lang=document.body.parentNode.getAttribute("lang");if(!w3c_slidy.lang){w3c_slidy.lang=document.body.parentNode.getAttribute("xml:lang")}if(!w3c_slidy.lang){w3c_slidy.lang="en"}}};if(w3c_slidy.ie6||w3c_slidy.ie7){document.write("<iframe id='historyFrame' src='javascript:\"<html></html>\"' height='1' width='1' style='position:absolute;left:-800px'></iframe>")}w3c_slidy.set_up();setTimeout(w3c_slidy.hide_slides,50);
/*]]>*/
</script>
</head>
<body>
<div class="slide">
<h1 id="ghc-language-extensions">GHC Language extensions</h1>
<ul>
<li>GHC implements a bunch of different extensions to Haskell
<ul>
<li>To enable an extension, compile with <code>-X</code><em>ExtensionName</em></li>
<li>Or place a <code>{-# LANGUAGE</code> <em>ExtensionName</em> <code>#-}</code> pragma at top of file</li>
<li>Complete list at <a href="http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html#id491691">Language options</a> section of GHC's option summary</li>
</ul></li>
<li>Some extensions are very safe to use
<ul>
<li>E.g., core libraries depend on extension in a deep way</li>
<li>Extension very superficial, easily de-sugars into Haskell2010</li>
<li>Extension restricts rather than expands set of permissible programs</li>
</ul></li>
<li>Other extensions less widely accepted
<ul>
<li>E.g., makes type inference/checking undecidable or non-deterministic</li>
<li>Undermines type safety</li>
<li>A work in progress that could never be incorporated into standard</li>
</ul></li>
<li>Many extensions in a middle/gray area</li>
</ul>
<!--
# Warm-up: [`ExistentialQuantification`][]

* Lets you introduce type variables on right side of `data`
  declaration

    ~~~~ {.haskell}
    {-# LANGUAGE ExistentialQuantification #-}
    data Step s a = Done | Skip !s | Yield !a !s
    data Stream a = forall s. Stream (s -> Step s a) !s                
    ~~~~

    * Given a value of type `Stream a`, there exists a type `s` such
      that...<br> But syntax uses `forall`, not `exists`, to avoid
      introducing new keyword
    * Very safe extension (`Control.Exception` relies on it--more next
      week)
    * Not to be confused with [`Rank2Types`], in which `forall` means
      for all types `s`:

        ~~~~ {.haskell}
        data Stream a = Stream (forall s. (s -> Step s a, s))  -- incorrect
        ~~~~

* Recall contexts on functions like hidden *dictionary* arguments

    * Contexts on existential variables like hidden dictionary fields

        ~~~~ {.haskell}
        data Showable = forall a. (Show a) => Showable a
        instance Show Showable where
            show (Showable a) = "Showable " ++ show a
        ~~~~

    * A `Showable` value has both a value of type `a`, and a
      dictionary for `Show`
-->

</div>
<div class="slide">
<h1 id="background-monad-transformers">Background: Monad transformers</h1>
<ul>
<li>Type constructors building monads parameterized by other monads
<ul>
<li><p>Method <a href="http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-Class.html#t:MonadTrans"><code>lift</code></a> executes actions from underlying transformed monad:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">MonadTrans</span> t <span class="kw">where</span><span class="ot"> lift </span><span class="ot">::</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> t m a</code></pre></li>
<li><p>Note monads have kind ∗ → ∗, so transformers have kind (∗ → ∗) → ∗ → ∗</p></li>
</ul></li>
<li>Example: State transformer monad, <a href="http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-State-Lazy.html#v:StateT"><code>StateT</code></a>
<ul>
<li>Transformer version of <a href="http://cs240h.scs.stanford.edu/notes/monads-slides.html#(32)"><code>State</code> from old lecture</a>--can combine, e.g., state and <code>IO</code></li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">StateT</span> s m a <span class="fu">=</span> <span class="dt">StateT</span> {<span class="ot"> runStateT </span><span class="ot">::</span> s <span class="ot">-&gt;</span> m (a,s) }<br /><br /><span class="kw">instance</span> (<span class="kw">Monad</span> m) <span class="ot">=&gt;</span> <span class="kw">Monad</span> (<span class="dt">StateT</span> s m) <span class="kw">where</span><br />    <span class="fu">return</span> a <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="fu">return</span> (a, s)<br />    m <span class="fu">&gt;&gt;=</span> k  <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \s0 <span class="ot">-&gt;</span> <span class="kw">do</span>          <span class="co">-- in monad m</span><br />                 <span class="fu">~</span>(a, s1) <span class="ot">&lt;-</span> runStateT m s0<br />                 runStateT (k a) s1<br /><br /><span class="kw">instance</span> <span class="dt">MonadTrans</span> (<span class="dt">StateT</span> s) <span class="kw">where</span><br />    lift ma <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">do</span>            <span class="co">-- in monad m</span><br />                a <span class="ot">&lt;-</span> ma<br />                <span class="fu">return</span> (a, s)</code></pre></li>
</ul>
</div>
<div class="slide">
<h1 id="using-statet">Using <code>StateT</code></h1>
<ul>
<li><p><a href="http://cs240h.scs.stanford.edu/notes/monads-slides.html#(35)">Like <code>State</code></a>, need actions for getting and setting state</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">get </span><span class="ot">::</span> (<span class="kw">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">StateT</span> s m s<br />get <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="fu">return</span> (s, s)<br /><br /><span class="ot">put </span><span class="ot">::</span> (<span class="kw">Monad</span> m) <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">StateT</span> s m ()<br />put s <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \_ <span class="ot">-&gt;</span> <span class="fu">return</span> ((), s)</code></pre></li>
<li><p>Example: count lines of standard input</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">import</span> <span class="dt">Control.Exception</span><br /><span class="kw">import</span> <span class="dt">Control.Monad.Trans</span><br /><span class="kw">import</span> <span class="dt">Control.Monad.Trans.State</span><br /><br /><span class="ot">countLines </span><span class="ot">::</span> <span class="dt">IO</span> <span class="dt">Int</span><br />countLines <span class="fu">=</span> runStateT go <span class="dv">0</span> <span class="fu">&gt;&gt;=</span> <span class="fu">return</span> <span class="fu">.</span> <span class="fu">fst</span><br />    <span class="kw">where</span> go <span class="fu">=</span> lift (try <span class="fu">getLine</span>) <span class="fu">&gt;&gt;=</span> doline<br />          doline (<span class="kw">Left</span> (<span class="dt">SomeException</span> _)) <span class="fu">=</span> get<br />          doline (<span class="kw">Right</span> _) <span class="fu">=</span> <span class="kw">do</span> n <span class="ot">&lt;-</span> get; put (n <span class="fu">+</span> <span class="dv">1</span>); go</code></pre>
<ul>
<li>Note that <code>try getLine</code> is an <code>IO</code> action, execute with <code>lift</code></li>
<li>Mixed with <code>IO</code> are <code>get</code>, <code>set</code> actions from <code>StateT Int IO</code> monad</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="review-monadio">Review: <code>MonadIO</code></h1>
<ul>
<li><p>Recall the <code>MonadIO</code> class from the <a href="http://cs240h.scs.stanford.edu/notes/iteratee-slides.html#(21)">iteratee lecture</a></p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="kw">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadIO</span> m <span class="kw">where</span><br /><span class="ot">    liftIO </span><span class="ot">::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> m a<br /><br /><span class="kw">instance</span> <span class="dt">MonadIO</span> <span class="dt">IO</span> <span class="kw">where</span><br />    liftIO <span class="fu">=</span> <span class="fu">id</span></code></pre></li>
<li><p>Let's make <code>liftIO</code> work for <code>StateT</code></p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">MonadIO</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadIO</span> (<span class="dt">StateT</span> s m) <span class="kw">where</span><br />    liftIO <span class="fu">=</span> lift <span class="fu">.</span> liftIO</code></pre></li>
<li><p>Now can execute IO actions without regard to which monad you are in</p>
<pre class="sourceCode"><code class="sourceCode haskell">          go <span class="fu">=</span> liftIO (try <span class="fu">getLine</span>) <span class="fu">&gt;&gt;=</span> doline</code></pre></li>
<li>All standard Monad transformers implement class <code>MonadIO</code>
<ul>
<li><code>ContT</code>, <code>ErrorT</code>, <code>ListT</code>, <code>RWST</code>, <code>ReaderT</code>, <code>StateT</code>, <code>WriterT</code>, ...</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="background-recursive-bindings">Background: recursive bindings</h1>
<ul>
<li><p>Top-level, <code>let</code>, and <code>where</code> bindings are all recursive in Haskell, e.g.:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">oneTwo </span><span class="ot">::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)<br />oneTwo <span class="fu">=</span> (<span class="fu">fst</span> y, <span class="fu">snd</span> x)<br />    <span class="kw">where</span> x <span class="fu">=</span> (<span class="dv">1</span>, <span class="fu">snd</span> y)    <span class="co">-- mutual recursion</span><br />          y <span class="fu">=</span> (<span class="fu">fst</span> x, <span class="dv">2</span>)<br /><br /><span class="ot">nthFib </span><span class="ot">::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span><br />nthFib n <span class="fu">=</span> fibList <span class="fu">!!</span> n<br />    <span class="kw">where</span> fibList <span class="fu">=</span> <span class="dv">1</span> <span class="fu">:</span> <span class="dv">1</span> <span class="fu">:</span> <span class="fu">zipWith</span> (<span class="fu">+</span>) fibList (<span class="fu">tail</span> fibList)</code></pre></li>
<li>Recursion can be implemented using a fixed-point combinator
<ul>
<li><p>Function <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Function.html#v:fix"><code>fix</code></a> calls a function with its own result, use to re-implement above:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">fix </span><span class="ot">::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a<br />fix f <span class="fu">=</span> <span class="kw">let</span> x <span class="fu">=</span> f x <span class="kw">in</span> x</code></pre>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">oneTwo' </span><span class="ot">::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)<br />oneTwo' <span class="fu">=</span> (<span class="fu">fst</span> y, <span class="fu">snd</span> x)<br />    <span class="kw">where</span> (x, y) <span class="fu">=</span> fix <span class="fu">$</span> \ <span class="fu">~</span>(x0, y0) <span class="ot">-&gt;</span> <span class="kw">let</span> x1 <span class="fu">=</span> (<span class="dv">1</span>, <span class="fu">snd</span> y0)<br />                                            y1 <span class="fu">=</span> (<span class="fu">fst</span> x0, <span class="dv">2</span>)<br />                                        <span class="kw">in</span> (x1, y1)<br />nthFib' n <span class="fu">=</span> fibList <span class="fu">!!</span> n<br />    <span class="kw">where</span> fibList <span class="fu">=</span> fix <span class="fu">$</span> \l <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="fu">:</span> <span class="dv">1</span> <span class="fu">:</span> <span class="fu">zipWith</span> (<span class="fu">+</span>) l (<span class="fu">tail</span> l)</code></pre></li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="recursion-and-monadic-bindings">Recursion and monadic bindings</h1>
<ul>
<li><p>By contrast, monadic bindings are <em>not</em> recursive</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">do</span> fibList <span class="ot">&lt;-</span> <span class="fu">return</span> <span class="fu">$</span> <span class="dv">1</span> <span class="fu">:</span> <span class="dv">1</span> <span class="fu">:</span> <span class="fu">zipWith</span> (<span class="fu">+</span>) fibList (<span class="fu">tail</span> fibList)<br />   <span class="fu">...</span>     <span class="co">-- error, fibList not in scope  ^^^^^^^       ^^^^^^^</span></code></pre></li>
<li><p>But monads in the <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad-Fix.html#t:MonadFix"><code>MonadFix</code></a> class have a fixed-point combinator</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadFix</span> m <span class="kw">where</span><br /><span class="ot">    mfix </span><span class="ot">::</span> (a <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a</code></pre>
<ul>
<li><code>mfix</code> can be used to implement recursive monadic bindings <a href="http://citeseer.ist.psu.edu/viewdoc/download;jsessionid=13851C3A2D4F33918B9D662C20F30762?doi=10.1.1.43.5313&amp;rep=rep1&amp;type=pdf">[Erkök00]</a>, e.g.:</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">mfib </span><span class="ot">::</span> (<span class="dt">MonadFix</span> m) <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m <span class="dt">Integer</span><br />mfib n <span class="fu">=</span> <span class="kw">do</span><br />  fibList <span class="ot">&lt;-</span> mfix <span class="fu">$</span> \l <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="fu">$</span> <span class="dv">1</span> <span class="fu">:</span> <span class="dv">1</span> <span class="fu">:</span> <span class="fu">zipWith</span> (<span class="fu">+</span>) l (<span class="fu">tail</span> l)<br />  <span class="fu">return</span> <span class="fu">$</span> fibList <span class="fu">!!</span> n <span class="co">-- ^^^^^</span></code></pre></li>
<li>Why? E.g., might want to simulate circuits with monads
<ul>
<li>Need recursion if there is a loop in your circuit</li>
<li>Might want recursion anyway to avoid worrying about order of statements</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="the-dorec-extension">The <a href="http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#recursive-do-notation"><code>DoRec</code></a> extension</h1>
<ul>
<li>New <code>rec</code> keyword introduces recursive bindings in a <code>do</code> block <a href="https://sites.google.com/site/leventerkok/recdo.pdf?attredirects=0">[Erkök02]</a>
<ul>
<li>Monad must be an instance of <code>MonadFix</code> (<code>rec</code> desugars to <code>mfix</code> calls)</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">oneTwo'' </span><span class="ot">::</span> (<span class="dt">MonadFix</span> m) <span class="ot">=&gt;</span> m (<span class="dt">Int</span>, <span class="dt">Int</span>)<br />oneTwo'' <span class="fu">=</span> <span class="kw">do</span><br />  rec x <span class="ot">&lt;-</span> <span class="fu">return</span> (<span class="dv">1</span>, <span class="fu">snd</span> y)<br />      y <span class="ot">&lt;-</span> <span class="fu">return</span> (<span class="fu">fst</span> x, <span class="dv">2</span>)<br />  <span class="fu">return</span> (<span class="fu">fst</span> y, <span class="fu">snd</span> x)</code></pre>
<ul>
<li>Desugars to:</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">oneTwo''' </span><span class="ot">::</span> (<span class="dt">MonadFix</span> m) <span class="ot">=&gt;</span> m (<span class="dt">Int</span>, <span class="dt">Int</span>)<br />oneTwo''' <span class="fu">=</span> <span class="kw">do</span><br />  (x, y) <span class="ot">&lt;-</span> mfix <span class="fu">$</span> \ <span class="fu">~</span>(x0, y0) <span class="ot">-&gt;</span> <span class="kw">do</span> x1 <span class="ot">&lt;-</span> <span class="fu">return</span> (<span class="dv">1</span>, <span class="fu">snd</span> y0)<br />                                     y1 <span class="ot">&lt;-</span> <span class="fu">return</span> (<span class="fu">fst</span> x0, <span class="dv">2</span>)<br />                                     <span class="fu">return</span> (x1, y1)<br />  <span class="fu">return</span> (<span class="fu">fst</span> y, <span class="fu">snd</span> x)</code></pre></li>
<li>Note: In practice <code>DoRec</code> helps structure thinking, not shipped that much
<ul>
<li>Can manually desugar rather than require a language extension</li>
<li>But <code>mfix</code> on its own is quite useful</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="example-uses-of-mfix-and-rec">Example uses of <code>mfix</code> and <code>rec</code></h1>
<ul>
<li><p>Create recursive data structures in one shot</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Link</span> a <span class="fu">=</span> <span class="dt">Link</span> <span class="fu">!</span>a <span class="fu">!</span>(<span class="dt">MVar</span> (<span class="dt">Link</span> a)) <span class="co">-- note ! is okay</span><br /><br /><span class="ot">mkCycle </span><span class="ot">::</span> <span class="dt">IO</span> (<span class="dt">MVar</span> (<span class="dt">Link</span> <span class="dt">Int</span>))<br />mkCycle <span class="fu">=</span> <span class="kw">do</span><br />  rec l1 <span class="ot">&lt;-</span> newMVar <span class="fu">$</span> <span class="dt">Link</span> <span class="dv">1</span> l2        <span class="co">-- but $! would diverge</span><br />      l2 <span class="ot">&lt;-</span> newMVar <span class="fu">$</span> <span class="dt">Link</span> <span class="dv">2</span> l1<br />  <span class="fu">return</span> l1</code></pre></li>
<li><p>Call non-strict methods of classes (easy access to return-type dictionary)</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">MyClass</span> t <span class="kw">where</span><br /><span class="ot">    myTypeName </span><span class="ot">::</span> t <span class="ot">-&gt;</span> <span class="dt">String</span>        <span class="co">-- non-strict in argument</span><br /><span class="ot">    myDefaultValue </span><span class="ot">::</span> t<br /><span class="kw">instance</span> <span class="dt">MyClass</span> <span class="dt">Int</span> <span class="kw">where</span><br />    myTypeName _ <span class="fu">=</span> <span class="st">&quot;Int&quot;</span><br />    myDefaultValue <span class="fu">=</span> <span class="dv">0</span><br /><br /><span class="ot">getVal </span><span class="ot">::</span> (<span class="dt">MyClass</span> t) <span class="ot">=&gt;</span> <span class="dt">IO</span> t<br />getVal <span class="fu">=</span> mfix <span class="fu">$</span> \t <span class="ot">-&gt;</span> <span class="kw">do</span>      <span class="co">-- doesn't use mfix's full power</span><br />  <span class="fu">putStrLn</span> <span class="fu">$</span> <span class="st">&quot;Caller wants type &quot;</span> <span class="fu">++</span> myTypeName t<br />  <span class="fu">return</span> myDefaultValue</code></pre></li>
</ul>
</div>
<div class="slide">
<h1 id="implementing-mfix">Implementing <code>mfix</code></h1>
<ul>
<li><p>Warm-up: The <a href="http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Data-Functor-Identity.html#v:Identity"><code>Identity</code></a> monad</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Identity</span> a <span class="fu">=</span> <span class="dt">Identity</span> {<span class="ot"> runIdentity </span><span class="ot">::</span> a }<br /><span class="kw">instance</span> <span class="kw">Monad</span> <span class="dt">Identity</span> <span class="kw">where</span><br />    <span class="fu">return</span> <span class="fu">=</span> <span class="dt">Identity</span><br />    m <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> k (runIdentity m)</code></pre>
<ul>
<li><code>newtype</code> compiles to nothing, so basically same as <code>fix</code>:</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">MonadFix</span> <span class="dt">Identity</span> <span class="kw">where</span><br />    mfix f <span class="fu">=</span> <span class="kw">let</span> x <span class="fu">=</span> f (runIdentity x) <span class="kw">in</span> x</code></pre></li>
<li><p>For <code>IO</code>, <code>mfix = fixIO</code> (recalling <a href="http://cs240h.scs.stanford.edu/notes/laziness-slides.html#(15)"><code>IORef</code> from laziness lecture</a>):</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">fixIO </span><span class="ot">::</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a<br />fixIO k <span class="fu">=</span> <span class="kw">do</span><br />    ref <span class="ot">&lt;-</span> newIORef (throw <span class="dt">NonTermination</span>)<br />    ans <span class="ot">&lt;-</span> unsafeInterleaveIO (readIORef ref)<br />    result <span class="ot">&lt;-</span> k ans<br />    writeIORef ref result<br />    <span class="fu">return</span> result</code></pre>
<ul>
<li>This is quite similar to what the compiler does for pure <code>fix</code></li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="a-generic-mfix-is-not-possible">A generic <code>mfix</code> is not possible</h1>
<ul>
<li><p>What if we tried to define an <code>mfix</code>-like function for all monads?</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">mbroken </span><span class="ot">::</span> (<span class="kw">Monad</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a <span class="co">-- equivalent to mfix?</span><br />mbroken f <span class="fu">=</span> fix (<span class="fu">&gt;&gt;=</span> f)</code></pre>
<ul>
<li>This is equivalent to</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell">mbroken f <span class="fu">=</span> mbroken f <span class="fu">&gt;&gt;=</span> f</code></pre>
<ul>
<li>But <code>&gt;&gt;=</code> is strict in its first argument for many monads, so</li>
</ul>
<pre><code>*Main&gt; mfix $ const (return 0)
0
*Main&gt; mbroken $ const (return 0)
*** Exception: stack overflow
</code></pre></li>
<li>So <code>mfix</code> needs to take fixed point over value, not over monadic action
<ul>
<li>How to do this is monad-specific</li>
<li>Doesn't work for all monads (<code>ContT</code>, <code>ListT</code>)</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="monadfix-instance-for-statet"><code>MonadFix</code> instance for <code>StateT</code></h1>
<ul>
<li><p>What about the <a href="http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-State-Lazy.html#t:StateT"><code>StateT</code></a> monad?</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">StateT</span> s m a <span class="fu">=</span> <span class="dt">StateT</span> {<span class="ot"> runStateT </span><span class="ot">::</span> s <span class="ot">-&gt;</span> m (a,s) }<br /><br /><span class="kw">instance</span> (<span class="kw">Monad</span> m) <span class="ot">=&gt;</span> <span class="kw">Monad</span> (<span class="dt">StateT</span> s m) <span class="kw">where</span><br />    <span class="fu">return</span> a <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="fu">return</span> (a, s)<br />    m <span class="fu">&gt;&gt;=</span> k  <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \s0 <span class="ot">-&gt;</span> <span class="kw">do</span>          <span class="co">-- in monad m</span><br />                 <span class="fu">~</span>(a, s1) <span class="ot">&lt;-</span> runStateT m s0<br />                 runStateT (k a) s1</code></pre>
<ul>
<li>Possibly easiest to see using <code>rec</code> notation</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">MonadFix</span> m <span class="ot">=&gt;</span> <span class="dt">MonadFix</span> (<span class="dt">StateT</span> s m) <span class="kw">where</span><br />    mfix f <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \s0 <span class="ot">-&gt;</span> <span class="kw">do</span>            <span class="co">-- in monad m</span><br />               rec <span class="fu">~</span>(a, s1) <span class="ot">&lt;-</span> runStateT (f a) s0 <span class="co">-- ~ redundant?</span><br />               <span class="fu">return</span> (a, s1)</code></pre>
<ul>
<li>But easily implemented with no language extensions</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">MonadFix</span> m <span class="ot">=&gt;</span> <span class="dt">MonadFix</span> (<span class="dt">StateT</span> s m) <span class="kw">where</span><br />    mfix f <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> mfix <span class="fu">$</span> \ <span class="fu">~</span>(a, _) <span class="ot">-&gt;</span> runStateT (f a) s</code></pre></li>
</ul>
</div>
<div class="slide">
<h1 id="review-type-classes">Review: Type classes</h1>
<ul>
<li><p>A <a href="http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-760004.3.1">Haskell 2010 type class declaration</a> can take the form:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">ClassName</span> var <span class="kw">where</span><br /><span class="ot">    methodName </span><span class="ot">::</span> <span class="dt">Type</span> <span class="co">{- where type references var -}</span></code></pre>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">SuperClass</span> var) <span class="ot">=&gt;</span> <span class="dt">ClassName</span> var <span class="kw">where</span> <span class="fu">...</span><br /><span class="kw">class</span> (<span class="dt">Super1</span> var, <span class="dt">Super2</span> var) <span class="ot">=&gt;</span> <span class="dt">ClassName</span> var <span class="kw">where</span> <span class="fu">...</span><br /><span class="fu">...</span></code></pre>
<ul>
<li>Note that <code>var</code> need not have kind ∗</li>
<li><p>However, the type of each method must mention <code>var</code> and an implicit <code>(Classname var)</code> is added to the context of each method, e.g.:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="fu">return</span><br /><span class="fu">return</span><span class="ot"> </span><span class="ot">::</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> m a</code></pre></li>
</ul></li>
<li><p>A <a href="http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-770004.3.2">Haskell 2010 instance declaration</a> has the form:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> [context <span class="ot">=&gt;</span>] <span class="dt">ClassName</span> (<span class="dt">TypeCon</span> v1 <span class="fu">...</span> vk) <span class="kw">where</span> <span class="fu">...</span></code></pre>
<ul>
<li>Note <code>v1</code> ... <code>vk</code> are all variables and all distinct, ruling out, e.g., <code>instance C (a,a)</code> or <code>instance C (Int a)</code> or <code>instance [[a]]</code></li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="multiparamtypeclasses-extension"><a href="http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#id559142"><code>MultiParamTypeClasses</code></a> extension</h1>
<ul>
<li><p>Enables type classes with multiple parameters, E.g.:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span><br /><span class="kw">class</span> <span class="dt">Convert</span> a b <span class="kw">where</span><span class="ot"> convert </span><span class="ot">::</span> a <span class="ot">-&gt;</span> b<br /><span class="kw">instance</span> <span class="dt">Convert</span> <span class="dt">Int</span> <span class="dt">Bool</span> <span class="kw">where</span> convert <span class="fu">=</span> (<span class="fu">/=</span> <span class="dv">0</span>)<br /><span class="kw">instance</span> <span class="dt">Convert</span> <span class="dt">Int</span> <span class="dt">Integer</span> <span class="kw">where</span> convert <span class="fu">=</span> <span class="fu">toInteger</span><br /><span class="kw">instance</span> (<span class="dt">Convert</span> a b) <span class="ot">=&gt;</span> <span class="dt">Convert</span> [a] [b] <span class="kw">where</span><br />    convert <span class="fu">=</span> <span class="fu">map</span> convert</code></pre></li>
<li><p>Extension itself is relatively safe, but encourages other extensions</p>
<ul>
<li><p>E.g., each method's type must use every type parameter</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">MyClass</span> a b <span class="kw">where</span><br /><span class="ot">    aDefault </span><span class="ot">::</span> a  <span class="co">-- can never use (without more extensions...)</span></code></pre></li>
<li><p>All types (argument and return) must be fully determined</p>
<pre class="sourceCode"><code class="sourceCode haskell">       convert <span class="dv">0</span><span class="ot"> </span><span class="ot">::</span> <span class="dt">Bool</span>   <span class="co">-- error, 0 has type (Num a) =&gt; a</span></code></pre></li>
<li><p>And the usual instance restrictions still apply</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Convert</span> <span class="dt">Int</span> [<span class="dt">Char</span>] <span class="kw">where</span> convert <span class="fu">=</span> <span class="fu">show</span>  <span class="co">-- error bad param</span></code></pre>
<ul>
<li><code>[Char]</code>--i.e., <code>([] Char)</code>--is not a valid instance parameter, would have to be <code>([] a)</code></li>
</ul></li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="flexibleinstances-extension"><a href="http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-decls"><code>FlexibleInstances</code></a> extension</h1>
<ul>
<li>Allows more specific type paremeters (relatively safe extension)
<ul>
<li>E.g., now we can say:</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span><br /><br /><span class="kw">instance</span> <span class="dt">Convert</span> <span class="dt">Int</span> [<span class="dt">Char</span>] <span class="kw">where</span><br />    convert <span class="fu">=</span> <span class="fu">show</span></code></pre>
<ul>
<li>And we can make all types convert to themselves:</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Convert</span> a a <span class="kw">where</span> convert a <span class="fu">=</span> a</code></pre>
<pre><code>*Main&gt; convert () :: ()
()
*Main&gt; convert ([1,2,3]::[Int]) :: [Integer]
[1,2,3]
*Main&gt; convert ([1,2,3]::[Int]) :: [Int]
&lt;interactive&gt;:1:1:
    Overlapping instances for Convert [Int] [Int]
      instance Convert a a
      instance Convert a b =&gt; Convert [a] [b]
</code></pre>
<ul>
<li>Oops, two instances apply; GHC doesn't know which to choose</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="overlappinginstances-extension"><a href="http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-overlap"><code>OverlappingInstances</code></a> extension</h1>
<ul>
<li>This extension is used, but also widely frowned upon
<ul>
<li>Only need this extension if overlapping instances actually used</li>
<li>Enable extension where instances defined, not where used</li>
<li>Compiler picks the most specific matching instance. <span class="math"><em>I</em><sub>1</sub></span> is more specific than <span class="math"><em>I</em><sub>2</sub></span> when <span class="math"><em>I</em><sub>1</sub></span> can be created by substituting for the variables of <span class="math"><em>I</em><sub>2</sub></span> and not vice versa</li>
<li><span style="color:red">Contexts (part before <code>=&gt;</code>) not considered when selecting instances</span></li>
</ul></li>
<li><p>Need it to do something like built-in <code>Show</code> instances for <code>String</code>, <code>[]</code></p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">MyShow</span> a <span class="kw">where</span><span class="ot"> myShow </span><span class="ot">::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span><br /><span class="kw">instance</span> <span class="dt">MyShow</span> <span class="dt">Char</span> <span class="kw">where</span> myShow <span class="fu">=</span> <span class="fu">show</span><br /><span class="kw">instance</span> <span class="dt">MyShow</span> <span class="dt">Int</span> <span class="kw">where</span> myShow <span class="fu">=</span> <span class="fu">show</span><br /><span class="kw">instance</span> <span class="dt">MyShow</span> [<span class="dt">Char</span>] <span class="kw">where</span> myShow <span class="fu">=</span> <span class="fu">id</span><br /><span class="kw">instance</span> (<span class="dt">MyShow</span> a) <span class="ot">=&gt;</span> <span class="dt">MyShow</span> [a] <span class="kw">where</span><br />    myShow []     <span class="fu">=</span> <span class="st">&quot;[]&quot;</span><br />    myShow (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="st">&quot;[&quot;</span> <span class="fu">++</span> myShow x <span class="fu">++</span> go xs<br />        <span class="kw">where</span> go (y<span class="fu">:</span>ys) <span class="fu">=</span> <span class="st">&quot;,&quot;</span> <span class="fu">++</span> myShow y <span class="fu">++</span> go ys<br />              go []     <span class="fu">=</span> <span class="st">&quot;]&quot;</span></code></pre></li>
<li><p>So does enabling <code>OverlappingInstances</code> fix <code>Convert</code>?</p></li>
</ul>
</div>
<div class="slide">
<h1 id="most-specific-instances">Most specific instances</h1>
<ul>
<li><p>What is the most specific instance?</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span><br /><span class="ot">{-# LANGUAGE OverlappingInstances #-}</span><br /><span class="kw">instance</span> <span class="dt">Convert</span> a a <span class="kw">where</span> <span class="fu">...</span><br /><span class="kw">instance</span> (<span class="dt">Convert</span> a b) <span class="ot">=&gt;</span> <span class="dt">Convert</span> [a] [b] <span class="kw">where</span> <span class="fu">...</span></code></pre>
<pre><code>*Main&gt; convert ([1,2,3]::[Int]) :: [Int]
&lt;interactive&gt;:1:1:
    Overlapping instances for Convert [Int] [Int]
      instance [overlap ok] Convert a a
      instance [overlap ok] Convert a b =&gt; Convert [a] [b]
</code></pre>
<ul>
<li>Neither instance is most specific!</li>
<li>We have to add a <em>third</em> instance to break the tie--one that can be created by substituting for variables in either of the other two overlapping instances</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Convert</span> [a] [a] <span class="kw">where</span> convert <span class="fu">=</span> <span class="fu">id</span></code></pre>
<pre><code>*Main&gt; convert ([1,2,3]::[Int]) :: [Int]
[1,2,3]
</code></pre></li>
</ul>
</div>
<div class="slide">
<h1 id="a-case-against-overlappinginstances">A case against <code>OverlappingInstances</code></h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Help</span> <span class="kw">where</span><br />    <span class="kw">class</span> <span class="dt">MyShow</span> a <span class="kw">where</span><br /><span class="ot">      myshow </span><span class="ot">::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span><br />    <span class="kw">instance</span> <span class="dt">MyShow</span> a <span class="ot">=&gt;</span> <span class="dt">MyShow</span> [a] <span class="kw">where</span><br />      myshow xs <span class="fu">=</span> <span class="fu">concatMap</span> myshow xs<br /><br /><span class="ot">    showHelp </span><span class="ot">::</span> <span class="dt">MyShow</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">String</span><br />    showHelp xs <span class="fu">=</span> myshow xs     <span class="co">-- doesn't see overlapping instance</span><br /><br /><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span><br />    <span class="kw">import</span> <span class="dt">Help</span><br /><br />    <span class="kw">data</span> <span class="dt">T</span> <span class="fu">=</span> <span class="dt">MkT</span><br />    <span class="kw">instance</span> <span class="dt">MyShow</span> <span class="dt">T</span> <span class="kw">where</span><br />      myshow x <span class="fu">=</span> <span class="st">&quot;Used generic instance&quot;</span><br />    <span class="kw">instance</span> <span class="dt">MyShow</span> [<span class="dt">T</span>] <span class="kw">where</span><br />      myshow xs <span class="fu">=</span> <span class="st">&quot;Used more specific instance&quot;</span><br /><br />    main <span class="fu">=</span> <span class="kw">do</span> { <span class="fu">print</span> (myshow [<span class="dt">MkT</span>]); <span class="fu">print</span> (showHelp [<span class="dt">MkT</span>]) }</code></pre>
<pre><code>*Main&gt; main
&quot;Used more specific instance&quot;
&quot;Used generic instance&quot;
</code></pre>
</div>
<div class="slide">
<h1 id="flexiblecontexts-extension"><a href="http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#flexible-contexts"><code>FlexibleContexts</code></a> extension</h1>
<ul>
<li><p><code>MultiParamTypeClasses</code> leads to inexpressible types</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="fu">toInt</span> val <span class="fu">=</span> convert<span class="ot"> val </span><span class="ot">::</span> <span class="dt">Int</span></code></pre>
<ul>
<li>What is the type of function <code>toInt</code>? Would like to write:</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="fu">toInt</span><span class="ot"> </span><span class="ot">::</span> (<span class="dt">Convert</span> a <span class="dt">Int</span>) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></code></pre>
<ul>
<li>But <code>(Convert a Int) =&gt;</code> is an illegal context, as <code>Int</code> not a type variable</li>
</ul></li>
<li><code>FlexibleContexts</code> extension makes the above type legal to write
<ul>
<li>Is a relatively safe extension to use</li>
</ul></li>
<li>Still a couple of restrictions
<ul>
<li><p>Each type variable in context must be &quot;reachable&quot; from a type variable in type<br> (Reachable = explicitly used, or in another constraint with a reachable variable.)</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">sym </span><span class="ot">::</span> forall a<span class="fu">.</span> <span class="kw">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span>   <span class="co">-- illegal</span></code></pre></li>
<li><p>Every constraint must have a type variable</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">sym </span><span class="ot">::</span> <span class="kw">Eq</span> <span class="dt">Int</span> <span class="ot">=&gt;</span> <span class="dt">Bool</span>          <span class="co">-- illegal</span></code></pre></li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="monad-classes">Monad classes</h1>
<ul>
<li>It's neat that <code>liftIO</code> works from so many monads
<ul>
<li>Why not do something similar for <code>StateT</code>? Make <code>get</code>/<code>set</code> methods</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span><br /><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span><br /><span class="co">-- Saw this very briefly in Monad lecture:</span><br /><span class="kw">class</span> (<span class="kw">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadState</span> s m <span class="kw">where</span><br /><span class="ot">    get </span><span class="ot">::</span> m s<br /><span class="ot">    put </span><span class="ot">::</span> s <span class="ot">-&gt;</span> m ()<br /><span class="kw">instance</span> (<span class="kw">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadState</span> s (<span class="dt">StateT</span> s m) <span class="kw">where</span><br />    get <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="fu">return</span> (s, s)<br />    put s <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \_ <span class="ot">-&gt;</span> <span class="fu">return</span> ((), s)</code></pre></li>
<li><p>Now for each other <code>MonadTrans</code>, pass requests down</p>
<ul>
<li>This is just like <code>liftIO</code>. E.g., for <code>ReaderT</code>:</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">MonadIO</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadIO</span> (<span class="dt">ReaderT</span> r m) <span class="kw">where</span><br />    liftIO <span class="fu">=</span> lift <span class="fu">.</span> liftIO<br /><br /><span class="kw">instance</span> (<span class="dt">MonadState</span> s m) <span class="ot">=&gt;</span> <span class="dt">MonadState</span> s (<span class="dt">ReaderT</span> r m) <span class="kw">where</span><br />    get <span class="fu">=</span> lift get<br />    put <span class="fu">=</span> lift <span class="fu">.</span> put</code></pre></li>
</ul>
</div>
<div class="slide">
<h1 id="problem-weve-defeated-type-inference">Problem: we've defeated type inference</h1>
<ul>
<li><p>Remember <code>countLines</code>?</p>
<pre class="sourceCode"><code class="sourceCode haskell">      doline (<span class="kw">Left</span> (<span class="dt">SomeException</span> _)) <span class="fu">=</span> get<br />      doline (<span class="kw">Right</span> _) <span class="fu">=</span> <span class="kw">do</span> n <span class="ot">&lt;-</span> get; put (n <span class="fu">+</span> <span class="dv">1</span>); go</code></pre>
<ul>
<li>The compiler knows we are in <code>StateT Int IO</code> monad</li>
<li>So can infer that the type of <code>get</code> is <code>StateT Int IO s</code></li>
<li>But need to know <code>s</code> in order to select an instance of <code>MonadState</code>!</li>
<li><p>For all compiler knows, might be other matching instances, e.g.,</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">MonadState</span> <span class="dt">Double</span> (<span class="dt">StateT</span> <span class="dt">Int</span> <span class="dt">IO</span>) <span class="kw">where</span><br />    <span class="co">-- would be legal, but exists only in compiler's imagination</span></code></pre></li>
</ul></li>
<li><p>Since compiler can't infer return type of <code>get</code>, must type it manually:</p>
<pre class="sourceCode"><code class="sourceCode haskell">      doline (<span class="kw">Left</span> (<span class="dt">SomeException</span> _)) <span class="fu">=</span><span class="ot"> get </span><span class="ot">::</span> <span class="dt">StateT</span> <span class="dt">Int</span> <span class="dt">IO</span> <span class="dt">Int</span><br />      doline (<span class="kw">Right</span> _) <span class="fu">=</span> <span class="kw">do</span> n <span class="ot">&lt;-</span> get; put ((<span class="ot">n </span><span class="ot">::</span> <span class="dt">Int</span>) <span class="fu">+</span> <span class="dv">1</span>); go</code></pre>
<ul>
<li>Yuck! Lack of type inference gets old fast!</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="functionaldependencies-extension"><a href="http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#functional-dependencies"><code>FunctionalDependencies</code></a> extension</h1>
<ul>
<li>Widely used &amp; frowned upon (not as bad as <code>OverlappingInstances</code>)
<ul>
<li>Also referred to as &quot;fundeps&quot;</li>
</ul></li>
<li><p>Lets a class declare some parameters to be functions of others</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="kw">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadState</span> s m <span class="fu">|</span> m <span class="ot">-&gt;</span> s <span class="kw">where</span><br /><span class="ot">    get </span><span class="ot">::</span> m s<br /><span class="ot">    put </span><span class="ot">::</span> s <span class="ot">-&gt;</span> m ()</code></pre>
<ul>
<li>The best way to think of this is in terms of <em>instance selection</em></li>
<li>&quot;<code>| m -&gt; s</code>&quot; says can select an instance based on <code>m</code> without considering <code>s</code>, because <strong><code>s</code> is a function of <code>m</code></strong></li>
<li>Once you've selected the instance, you can use <code>s</code> for type inference</li>
</ul></li>
<li>Disallows conflicting instances (even w. <code>OverlappingInstances</code>)</li>
<li>Also allows arbitrary computation at the type level <a href="http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=D19C7E3BD1B5C1FC24035542B1494ED9?doi=10.1.1.22.7806&amp;rep=rep1&amp;type=pdf">[Hallgren]</a>
<ul>
<li>But language committee wants compilation to be decidable and deterministic</li>
<li>So need to add some restrictions</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="sufficient-conditions-of-decidable-instances"><a href="http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-rules">Sufficient conditions of decidable instances</a></h1>
<ul>
<li>Anatomy of an instance: <code>instance</code> [<em>context</em> <code>=&gt;</code>] <em>head</em> [<code>where</code> <em>body</em>]
<ul>
<li><em>context</em> consists of zero or more comma-separated <em>assertions</em></li>
</ul></li>
</ul>
<!-- -->

<ol style="list-style-type: decimal">
<li><p>The Paterson Conditions: for each assertion in the context</p>
<ol style="list-style-type: lower-alpha">
<li><p>No type variable has more occurrences in the assertion than in the head</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Class</span> a b <span class="fu">|</span> a <span class="ot">-&gt;</span> b<br /><span class="kw">instance</span> (<span class="dt">Class</span> a a) <span class="ot">=&gt;</span> <span class="dt">Class</span> [a] <span class="dt">Bool</span>  <span class="co">-- bad: 2 * a =&gt; 1 * a</span><br /><span class="kw">instance</span> (<span class="dt">Class</span> a b) <span class="ot">=&gt;</span> <span class="dt">Class</span> [a] <span class="dt">Bool</span>  <span class="co">-- bad: 1 * b =&gt; 0 * b</span></code></pre></li>
<li><p>The assertion has fewer constructors and variables than the head</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Class</span> a <span class="dt">Int</span>) <span class="ot">=&gt;</span> <span class="dt">Class</span> a <span class="dt">Integer</span>   <span class="co">-- bad: 2 =&gt; 2</span></code></pre></li>
</ol></li>
<li><p>The Coverage Condition: For each fundep <em>left</em> <code>-&gt;</code> <em>right</em>, the types in <em>right</em> cannot have type variables not mentioned in <em>left</em></p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Class</span> a b <span class="fu">|</span> a <span class="ot">-&gt;</span> b<br /><span class="kw">instance</span> <span class="dt">Class</span> a (<span class="dt">Maybe</span> a)       <span class="co">-- ok: a &quot;covered&quot; by left</span><br /><span class="kw">instance</span> <span class="dt">Class</span> <span class="dt">Int</span> (<span class="dt">Maybe</span> b)     <span class="co">-- bad: b not covered</span><br /><span class="kw">instance</span> <span class="dt">Class</span> a (<span class="dt">Either</span> a b)    <span class="co">-- bad: b not covered</span></code></pre></li>
</ol>
</div>
<div class="slide">
<h1 id="undecidable-vs.-exponential----who-cares">Undecidable vs. exponential -- who cares?</h1>
<ul>
<li>Editorial: maybe decidability of language is overrated
<ul>
<li>Computers aren't Turing machines with infinite tapes, after all</li>
</ul></li>
<li><p>This legal, decidable program will crash your Haskell compiler</p>
<pre class="sourceCode"><code class="sourceCode haskell">crash <span class="fu">=</span> f5 ()<br />    <span class="kw">where</span> f0 x <span class="fu">=</span> (x, x)      <span class="co">-- type size 2^{2^0}</span><br />          f1 x <span class="fu">=</span> f0 (f0 x)   <span class="co">-- type size 2^{2^1}</span><br />          f2 x <span class="fu">=</span> f1 (f1 x)   <span class="co">-- type size 2^{2^2}</span><br />          f3 x <span class="fu">=</span> f2 (f2 x)   <span class="co">-- type size 2^{2^3}</span><br />          f4 x <span class="fu">=</span> f3 (f3 x)   <span class="co">-- type size 2^{2^4}</span><br />          f5 x <span class="fu">=</span> f4 (f4 x)   <span class="co">-- type size 2^{2^5}</span></code></pre></li>
<li>While plenty of not provably decidable programs happily compile
<ul>
<li>The conditions of the last slide are <em>sufficient</em>, not <em>necessary</em></li>
<li>Might have other ways of knowing your program can compile</li>
<li>Or maybe figure it out from trial and error?</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="undecidableinstances-extension"><a href="http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#undecidable-instances"><code>UndecidableInstances</code></a> extension</h1>
<ul>
<li>Lifts the Paterson and Coverage conditions
<ul>
<li>Also enables <code>FlexibleContexts</code> when enabled</li>
</ul></li>
<li>Instead, imposes a maximum recursion depth
<ul>
<li>Default maximum depth is 20</li>
<li><p>Can increase with <code>-fcontext-stack=</code><em>n</em> option, e.g.:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">{-# OPTIONS_GHC -fcontext-stack=1024 #-}</span><br /><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></code></pre></li>
</ul></li>
<li>A bit reminiscent of C++ templates
<ul>
<li>gcc has a <code>-ftemplate-depth=</code> option</li>
<li>Note C++0x raises minimum depth from 17 to 1024</li>
<li>Similarly, people have talked of increasing GHC's default context-stack</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="monadio-revisited"><code>MonadIO</code> revisited</h1>
<ul>
<li><p>Recall definition of <code>MonadIO</code></p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="kw">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadIO</span> m <span class="kw">where</span><br /><span class="ot">    liftIO </span><span class="ot">::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> m a<br /><span class="kw">instance</span> <span class="dt">MonadIO</span> <span class="dt">IO</span> <span class="kw">where</span><br />    liftIO <span class="fu">=</span> <span class="fu">id</span></code></pre></li>
<li><p>Currently must define an instance for every transformer</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">MonadIO</span> (<span class="dt">StateT</span> s) <span class="kw">where</span> liftIO <span class="fu">=</span> lift <span class="fu">.</span> liftIO<br /><span class="kw">instance</span> <span class="dt">MonadIO</span> (<span class="dt">ReaderT</span> t) <span class="kw">where</span> liftIO <span class="fu">=</span> lift <span class="fu">.</span> liftIO<br /><span class="kw">instance</span> <span class="dt">MonadIO</span> (<span class="dt">WriterT</span> w) <span class="kw">where</span> liftIO <span class="fu">=</span> lift <span class="fu">.</span> liftIO<br /><span class="fu">...</span></code></pre></li>
<li><p>With <code>UndecidableInstances</code>, one instance can cover all transformers!</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span><br /><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span><br /><br /><span class="co">-- undecidable: assertion Monad (t m) no smaller than head</span><br /><span class="kw">instance</span> (<span class="dt">MonadTrans</span> t, <span class="dt">MonadIO</span> m, <span class="kw">Monad</span> (t m)) <span class="ot">=&gt;</span><br />    <span class="dt">MonadIO</span> (t m) <span class="kw">where</span> liftIO <span class="fu">=</span> lift <span class="fu">.</span> liftIO</code></pre></li>
</ul>
</div>
<div class="slide">
<h1 id="summary-of-extensions">Summary of extensions</h1>
<ul>
<li><p>We've seen 6 typeclass-related extensions</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span>  <span class="co">-- very conservative</span><br /><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>      <span class="co">-- conservative</span><br /><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span>       <span class="co">-- conservative</span><br /><span class="ot">{-# LANGUAGE FunctionalDependencies #-}</span> <span class="co">-- frowned upon</span><br /><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>   <span class="co">-- very frowned upon</span><br /><span class="ot">{-# LANGUAGE OverlappingInstances #-}</span>   <span class="co">-- the most controversial</span></code></pre>
<ul>
<li>Not all of these are looked upon kindly by the community</li>
<li>But if you enable all six, can be very powerful</li>
</ul></li>
<li>Remainder of lecture looks at what you can do with all 6 enabled
<ul>
<li>Much inspired by <a href="http://homepages.cwi.nl/~ralf/HList/paper.pdf">[Hlist]</a> and <a href="http://homepages.cwi.nl/~ralf/OOHaskell/paper.pdf">[OOHaskell]</a></li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="type-level-natural-numbers">Type-level natural numbers</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Zero</span> <span class="fu">=</span> <span class="dt">Zero</span>      <span class="co">-- Type-level 0</span><br /><span class="kw">data</span> <span class="dt">Succ</span> n <span class="fu">=</span> <span class="dt">Succ</span> n  <span class="co">-- Type-level successor (n + 1)</span><br /><br /><span class="kw">class</span> <span class="dt">NatPlus</span> a b c <span class="fu">|</span> a b <span class="ot">-&gt;</span> c, a c <span class="ot">-&gt;</span> b <span class="kw">where</span><br /><span class="ot">    natPlus </span><span class="ot">::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c<br /><span class="ot">    natMinus </span><span class="ot">::</span> c <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b<br /><br /><span class="kw">instance</span> <span class="dt">NatPlus</span> <span class="dt">Zero</span> a a <span class="kw">where</span><br />    natPlus _ a <span class="fu">=</span> a<br />    natMinus a _ <span class="fu">=</span> a<br /><br /><span class="co">-- Note failure of coverage condition below</span><br /><span class="kw">instance</span> (<span class="dt">NatPlus</span> a b c) <span class="ot">=&gt;</span> <span class="dt">NatPlus</span> (<span class="dt">Succ</span> a) b (<span class="dt">Succ</span> c) <span class="kw">where</span> <br />    natPlus (<span class="dt">Succ</span> a) b <span class="fu">=</span> (<span class="dt">Succ</span> (natPlus a b))<br />    natMinus (<span class="dt">Succ</span> c) (<span class="dt">Succ</span> a) <span class="fu">=</span> natMinus c a</code></pre>
<ul>
<li>Fundeps + Context let us compute recursively on types!
<ul>
<li>If context has assertion <code>NatPlus a b c</code>, then from types <code>Succ   a</code> and <code>b</code> we can compute <code>Succ c</code> (computation at type level)</li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="type-level-booleans">Type-level booleans</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">HFalse</span> <span class="fu">=</span> <span class="dt">HFalse</span> <span class="kw">deriving</span> <span class="kw">Show</span><br /><span class="kw">data</span> <span class="dt">HTrue</span> <span class="fu">=</span> <span class="dt">HTrue</span> <span class="kw">deriving</span> <span class="kw">Show</span><br /><br /><span class="kw">class</span> <span class="dt">HNot</span> a b <span class="fu">|</span> a <span class="ot">-&gt;</span> b <span class="kw">where</span><span class="ot"> hnot </span><span class="ot">::</span> a <span class="ot">-&gt;</span> b<br /><span class="kw">instance</span> <span class="dt">HNot</span> <span class="dt">HFalse</span> <span class="dt">HTrue</span> <span class="kw">where</span> hnot _ <span class="fu">=</span> <span class="dt">HTrue</span><br /><span class="kw">instance</span> <span class="dt">HNot</span> <span class="dt">HTrue</span> <span class="dt">HFalse</span> <span class="kw">where</span> hnot _ <span class="fu">=</span> <span class="dt">HFalse</span><br /><br /><span class="kw">class</span> <span class="dt">HEven</span> a b <span class="fu">|</span> a <span class="ot">-&gt;</span> b <span class="kw">where</span><span class="ot"> hEven </span><span class="ot">::</span> a <span class="ot">-&gt;</span> b<br /><span class="kw">instance</span> <span class="dt">HEven</span> <span class="dt">Zero</span> <span class="dt">HTrue</span> <span class="kw">where</span> hEven _ <span class="fu">=</span> <span class="dt">HTrue</span><br /><span class="kw">instance</span> (<span class="dt">HEven</span> n b, <span class="dt">HNot</span> b nb) <span class="ot">=&gt;</span> <span class="dt">HEven</span> (<span class="dt">Succ</span> n) nb <span class="kw">where</span><br />    hEven (<span class="dt">Succ</span> n) <span class="fu">=</span> hnot (hEven n)</code></pre>
<pre><code>*Main&gt; hEven Zero
HTrue
*Main&gt; hEven (Succ Zero)
HFalse
*Main&gt; hEven (Succ (Succ Zero))
HTrue
*Main&gt; hEven (Succ (Succ (Succ Zero)))
HFalse
</code></pre>
<ul>
<li>Note how we use assertion <code>HNot b nb</code> to compute negation of <code>b</code></li>
</ul>
</div>
<div class="slide">
<h1 id="computing-over-types">Computing over types</h1>
<ul>
<li>Haven't used <code>OverlappingInstances</code> yet, let's start...</li>
<li><p>Can we compute whether two types are equal? First attempt:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">TypeEq</span> a b c <span class="fu">|</span> a b <span class="ot">-&gt;</span> c <span class="kw">where</span><span class="ot"> typeEq </span><span class="ot">::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c<br /><span class="kw">instance</span> <span class="dt">TypeEq</span> a a <span class="dt">HTrue</span> <span class="kw">where</span> typeEq _ _ <span class="fu">=</span> <span class="dt">HTrue</span><br /><span class="kw">instance</span> <span class="dt">TypeEq</span> a b <span class="dt">HFalse</span> <span class="kw">where</span> typeEq _ _ <span class="fu">=</span> <span class="dt">HFalse</span></code></pre>
<ul>
<li>Problem: <code>TypeEq a a HTrue</code> not more specific than <code>TypeEq a b   HFalse</code></li>
<li>... but it is more specific than <code>TypeEq a b c</code></li>
</ul></li>
<li>Recall that context is never consulted for instance selection
<ul>
<li>Only afterwards to reject failed assertions or infer types from fundeps</li>
<li>Solution: compute <code>c</code> after instance selection with another fundep</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">TypeCast</span> a b <span class="fu">|</span> a <span class="ot">-&gt;</span> b <span class="kw">where</span><span class="ot"> typeCast </span><span class="ot">::</span> a <span class="ot">-&gt;</span> b<br /><span class="kw">instance</span> <span class="dt">TypeCast</span> a a <span class="kw">where</span> typeCast <span class="fu">=</span> <span class="fu">id</span><br /><br /><span class="kw">instance</span> <span class="dt">TypeEq</span> a a <span class="dt">HTrue</span> <span class="kw">where</span> typeEq _ _ <span class="fu">=</span> <span class="dt">HTrue</span> <span class="co">-- as before</span><br /><span class="kw">instance</span> (<span class="dt">TypeCast</span> <span class="dt">HFalse</span> c) <span class="ot">=&gt;</span> <span class="dt">TypeEq</span> a b c <span class="kw">where</span><br />    typeEq _ _ <span class="fu">=</span> typeCast <span class="dt">HFalse</span></code></pre></li>
</ul>
</div>
<div class="slide">
<h1 id="the-utility-of-typeeq">The utility of <code>TypeEq</code></h1>
<ul>
<li>Editorial: <code>TypeEq</code> is kind of the holy grail of fundeps
<ul>
<li>Means you can program recursively at the type level</li>
<li>If you can implement <code>TypeEq</code>, you can distinguish base and recursive cases</li>
<li>But relies deeply on <code>OverlappingInstances</code>...</li>
</ul></li>
<li><p>Example: Let's do for <code>MonadState</code> what we did for <code>MonadIO</code></p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="kw">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadState</span> s (<span class="dt">StateT</span> s m) <span class="kw">where</span><br /><span class="ot">    get </span><span class="ot">::</span> m s<br /><span class="ot">    put </span><span class="ot">::</span> s <span class="ot">-&gt;</span> m ()<br /><br /><span class="kw">instance</span> (<span class="dt">MonadTrans</span> t, <span class="dt">MonadState</span> s m, <span class="kw">Monad</span> (t m)) <span class="ot">=&gt;</span><br />    <span class="dt">MonadState</span> s (t m) <span class="kw">where</span><br />        get <span class="fu">=</span> lift get<br />        put <span class="fu">=</span> lift <span class="fu">.</span> put</code></pre>
<ul>
<li><code>MonadIO</code> was easier because type <code>IO</code> can't match parameter <code>(t m)</code></li>
<li>Unfortunately, <code>StateT s m</code> matches <em>both</em> of above instance heads</li>
<li>So need <code>OverlappingInstances</code> to select first instance for <code>StateT s m</code></li>
</ul></li>
</ul>
</div>
<div class="slide">
<h1 id="heterogeneous-lists">Heterogeneous lists</h1>
<ul>
<li><p>Last extension: <a href="http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#infix-tycons"><code>TypeOperators</code></a> allows infix types starting with &quot;<code>:</code>&quot;</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> a <span class="fu">:*:</span> b <span class="fu">=</span> <span class="dt">Foo</span> a b<br /><span class="kw">type</span> a <span class="fu">:+:</span> b <span class="fu">=</span> <span class="dt">Either</span> a b</code></pre></li>
<li><p>Let's use an infix constructor to define a heterogeneous list</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">HNil</span> <span class="fu">=</span> <span class="dt">HNil</span> <span class="kw">deriving</span> <span class="kw">Show</span><br /><span class="kw">data</span> (<span class="fu">:*:</span>) h t <span class="fu">=</span> h <span class="fu">:*:</span> <span class="fu">!</span>t <span class="kw">deriving</span> <span class="kw">Show</span><br /><span class="kw">infixr</span> <span class="dv">9</span> <span class="fu">:*:</span><br /><br /><span class="co">-- Example:</span><br /><span class="kw">data</span> <span class="dt">A</span> <span class="fu">=</span> <span class="dt">A</span> <span class="kw">deriving</span> <span class="kw">Show</span><br /><span class="kw">data</span> <span class="dt">B</span> <span class="fu">=</span> <span class="dt">B</span> <span class="kw">deriving</span> <span class="kw">Show</span><br /><span class="kw">data</span> <span class="dt">C</span> <span class="fu">=</span> <span class="dt">C</span> <span class="kw">deriving</span> <span class="kw">Show</span><br /><br />foo <span class="fu">=</span> (<span class="dt">A</span>, <span class="st">&quot;Hello&quot;</span>) <span class="fu">:*:</span> (<span class="dt">B</span>, <span class="dv">7</span>) <span class="fu">:*:</span> (<span class="dt">C</span>, <span class="dv">3</span><span class="fu">.</span><span class="dv">0</span>) <span class="fu">:*:</span> <span class="dt">HNil</span></code></pre>
<pre><code>*Main&gt; foo
(A,&quot;Hello&quot;) :*: ((B,7) :*: ((C,3.0) :*: HNil))
*Main&gt; :t foo
foo :: (A, [Char]) :*: ((B, Integer) :*: ((C, Double) :*: HNil))
</code></pre></li>
</ul>
</div>
<div class="slide">
<h1 id="operations-on-heterogeneous-lists">Operations on heterogeneous lists</h1>
<ul>
<li><p>Notice our list consisted of pairs</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">foo </span><span class="ot">::</span> (<span class="dt">A</span>, [<span class="dt">Char</span>]) <span class="fu">:*:</span> (<span class="dt">B</span>, <span class="dt">Integer</span>) <span class="fu">:*:</span> (<span class="dt">C</span>, <span class="dt">Double</span>) <span class="fu">:*:</span> <span class="dt">HNil</span><br />foo <span class="fu">=</span> (<span class="dt">A</span>, <span class="st">&quot;Hello&quot;</span>) <span class="fu">:*:</span> (<span class="dt">B</span>, <span class="dv">7</span>) <span class="fu">:*:</span> (<span class="dt">C</span>, <span class="dv">3</span><span class="fu">.</span><span class="dv">0</span>) <span class="fu">:*:</span> <span class="dt">HNil</span></code></pre>
<ul>
<li>View first element as a key or tag, second as a value--How to look up value?</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Select</span> k h v <span class="fu">|</span> k h <span class="ot">-&gt;</span> v <span class="kw">where</span><br /><span class="ot">    (.!) </span><span class="ot">::</span> h <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> v<br /><span class="kw">instance</span> <span class="dt">Select</span> k ((k, v) <span class="fu">:*:</span> t) v <span class="kw">where</span><br />    (<span class="fu">.!</span>) ((_, v) <span class="fu">:*:</span> _) _ <span class="fu">=</span> v<br /><span class="kw">instance</span> (<span class="dt">Select</span> k h v) <span class="ot">=&gt;</span> <span class="dt">Select</span> k (kv' <span class="fu">:*:</span> h) v <span class="kw">where</span><br />    (<span class="fu">.!</span>) (kv' <span class="fu">:*:</span> h) k <span class="fu">=</span> h <span class="fu">.!</span> k</code></pre>
<pre><code>*Main&gt; foo .! A
&quot;Hello&quot;
</code></pre></li>
<li>Once again, note the importance of <code>OverlappingInstances</code>
<ul>
<li>Needed to break recursion when type of lookup tag matches head of list</li>
</ul></li>
<li><p>Can use to implement all sorts of other features (concatenation, etc.)</p></li>
</ul>
</div>
<div class="slide">
<h1 id="object-oriented-programming">Object-oriented programming</h1>
<ul>
<li><p>Heterogeneous can implement object-oriented programming!</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">returnIO </span><span class="ot">::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a<br />returnIO <span class="fu">=</span> <span class="fu">return</span><br /><br /><span class="kw">data</span> <span class="dt">GetVal</span> <span class="fu">=</span> <span class="dt">GetVal</span> <span class="kw">deriving</span> <span class="kw">Show</span><br /><span class="kw">data</span> <span class="dt">SetVal</span> <span class="fu">=</span> <span class="dt">SetVal</span> <span class="kw">deriving</span> <span class="kw">Show</span><br /><span class="kw">data</span> <span class="dt">ClearVal</span> <span class="fu">=</span> <span class="dt">ClearVal</span> <span class="kw">deriving</span> <span class="kw">Show</span><br /><br />mkVal n self <span class="fu">=</span> <span class="kw">do</span><br />  val <span class="ot">&lt;-</span> newIORef (<span class="ot">n </span><span class="ot">::</span> <span class="dt">Int</span>)<br />  returnIO <span class="fu">$</span> (<span class="dt">GetVal</span>, readIORef val)<br />           <span class="fu">:*:</span> (<span class="dt">SetVal</span>, writeIORef val)<br />           <span class="fu">:*:</span> (<span class="dt">ClearVal</span>, self <span class="fu">.!</span> <span class="dt">SetVal</span> <span class="fu">$</span> <span class="dv">0</span>)<br />           <span class="fu">:*:</span> <span class="dt">HNil</span><br /><br />test <span class="fu">=</span> <span class="kw">do</span>               <span class="co">-- prints 7, then 0</span><br />  x <span class="ot">&lt;-</span> mfix <span class="fu">$</span> mkVal <span class="dv">7</span><br />  x <span class="fu">.!</span> <span class="dt">GetVal</span> <span class="fu">&gt;&gt;=</span> <span class="fu">print</span><br />  x <span class="fu">.!</span> <span class="dt">ClearVal</span><br />  x <span class="fu">.!</span> <span class="dt">GetVal</span> <span class="fu">&gt;&gt;=</span> <span class="fu">print</span></code></pre></li>
<li><p>But why <code>mfix</code>?</p></li>
</ul>
</div>
<div class="slide">
<h1 id="tying-the-recursive-knot">&quot;Tying the recursive knot&quot;</h1>
<ul>
<li><code>mfix</code> allows you to override methods with inheritance
<ul>
<li>Example, create a &quot;const val&quot; that ignores <code>SetVal</code> messages</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell">mkConstVal n self <span class="fu">=</span> <span class="kw">do</span><br />  super <span class="ot">&lt;-</span> mkVal n self<br />  returnIO <span class="fu">$</span> (<span class="dt">SetVal</span>, <span class="fu">const</span> <span class="fu">$</span> <span class="fu">return</span> ())<br />           <span class="fu">:*:</span> super<br /><br />test2 <span class="fu">=</span> <span class="kw">do</span><br />  x <span class="ot">&lt;-</span> mfix <span class="fu">$</span> mkConstVal <span class="dv">7</span><br />  x <span class="fu">.!</span> <span class="dt">GetVal</span> <span class="fu">&gt;&gt;=</span> <span class="fu">print</span><br />  x <span class="fu">.!</span> <span class="dt">ClearVal</span><br />  x <span class="fu">.!</span> <span class="dt">GetVal</span> <span class="fu">&gt;&gt;=</span> <span class="fu">print</span></code></pre>
<pre><code>*Main&gt; test
7
0
*Main&gt; test2
7
7   
</code></pre></li>
<li><code>mkVal</code>'s call to <code>SetVal</code> was properly overridden by <code>mkConstVal</code></li>
</ul>
</div>
</body>

Providence Salumu
</html>
