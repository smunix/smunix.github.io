<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Stephen Diehl</title>
    <link href="http://www.stephendiehl.com/feed.atom" rel="self" />
    <link href="http://www.stephendiehl.com" />
    <id>http://www.stephendiehl.com/feed.atom</id>
    <author>
        <name>Stephen Diehl</name>
        <email>stephen.m.diehl@gmail.com</email>
    </author>
    <updated>2016-12-23T00:00:00Z</updated>
    <entry>
    <title>Reflecting on Haskell in 2016</title>
    <link href="http://www.stephendiehl.com/posts/haskell_2017.html" />
    <id>http://www.stephendiehl.com/posts/haskell_2017.html</id>
    <published>2016-12-23T00:00:00Z</published>
    <updated>2016-12-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="reflecting-on-haskell-in-2016">Reflecting on Haskell in 2016</h3>
<p>Well, 2016 … that just happened. About the only thing I can put in perspective at closing of this year is progress and innovation in Haskell ecosystem. There was a lot inspiring work and progress that pushed the state of the art forward.</p>
<p>This was a monumental year of Haskell in production. There were dozens of talks given about success stories with an unprecedented amount of commercially funded work from small startups to international banks. Several very honest accounts of the good and the bad were published, which gave us a rare glimpse into what it takes to plant Haskell in a corporate environment and foster it’s growth.</p>
<ol style="list-style-type: decimal">
<li><a href="http://baatz.io/posts/haskell-in-a-startup/">A Founder’s Perspective on 4 Years With Haskell</a> by Carl Baatz</li>
<li><a href="https://chadaustin.me/2016/06/the-story-of-haskell-at-imvu/">The Story of Haskell at IMVU</a> by Chad Austin</li>
<li><a href="https://lexi-lambda.github.io/blog/2016/06/12/four-months-with-haskell/">Four Months with Haskell</a> by Alexis King</li>
<li><a href="http://www.stephendiehl.com/posts/production.html">The Joy and Agony of Haskell in Production</a> by Stephen Diehl</li>
<li><a href="https://www.youtube.com/watch?v=AZQLkkDXy68&amp;t=1s">Production Haskell</a> by Reid Draper</li>
</ol>
<h4 id="writing">Writing</h4>
<p>There was a lot of excellent Haskell writing this year. One can’t possible enumerate all of them, but several stood out as concise and mind-bending examples of practical Haskell:</p>
<ol style="list-style-type: decimal">
<li><a href="https://flannelhead.github.io/projects/blackstar.html">Raytracing Black Holes with Haskell</a> by Sakari Kapanen</li>
<li><a href="http://www.parsonsmatt.org/2015/12/09/exploratory_haskell.html">Exploratory Haskell</a> by Parsons Matt</li>
<li><a href="http://www.haskellforall.com/2016/02/state-of-haskell-ecosystem-february.html?m=1">State of the Haskell Ecosystem</a> by Gabriel Gonzalez</li>
<li><a href="https://blog.jle.im/entry/introducing-the-hamilton-library.html">Introducing the Hamilton Library</a> by Justin Le</li>
<li><a href="https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html">Practical Dependent Types in Haskell: Type Safe Neural Networks</a> by Justin Le</li>
<li><a href="https://aherrmann.github.io/programming/2016/05/28/mutual-recursion-in-final-encoding/">Mutual Recursion in Final Encoding</a> by Andreas Herrmann</li>
<li><a href="https://blogs.ncl.ac.uk/andreymokhov/an-algebra-of-graphs/">An Algebra of Graphs</a> by Andrey Mokhov</li>
<li><a href="https://www.stackbuilders.com/tutorials/haskell/ghc-optimization-and-fusion/">GHC optimization and fusion</a> by Mark Karpov</li>
<li><a href="https://github.com/quchen/articles/tree/master/hindley-milner#readme">Hindley-Damas-Milner tutorial</a> by David Luposchainsky</li>
<li><a href="https://wespiser.com/writings/wyas/home.html">Write You a Scheme 2.0</a> by Adam Wespiser</li>
<li><a href="http://madsbuch.com/blog/proving-stuff-in-haskell/">Proving Stuff in Haskell</a> by Mads Buch</li>
<li><a href="https://lettier.github.io/posts/2016-08-15-making-movie-monad.html">Making Movie Monad</a> by David Lettier<br />
</li>
<li><a href="https://neilmitchell.blogspot.com/2016/02/selling-haskell-in-pub.html">Selling Haskell in the Pub</a> by Neil Mitchell</li>
<li><a href="http://dlaing.org/little-languages/">Little Languages</a> by David Laing</li>
</ol>
<p>The second edition of Graham Hutton’s book <a href="https://www.amazon.com/Programming-Haskell-Graham-Hutton/dp/1316626229/ref=dp_ob_title_bk">Programming in Haskell</a> was released, which updated the presentation to include modern Haskell including recent changes concerning applicative, monadic, foldable, and traversable types.</p>
<p>In addition there were several great lecture series by Bartosz Milewski on relevant Haskell topics that are generally underserved in writing.</p>
<ol style="list-style-type: decimal">
<li><a href="https://www.youtube.com/watch?v=N6sOMGYsvFA">Parallel and Concurrent Programming in Haskell</a></li>
<li><a href="https://www.youtube.com/watch?v=I8LbkfSSR58&amp;t=221s&amp;index=1&amp;list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_">Category Theory</a></li>
</ol>
<h4 id="uncategorized-projects">Uncategorized Projects</h4>
<p>There was a lot of open source work done this year, a few that stood out as particularly novel ideas or interesting ways of looking at problems through a Haskell lens:</p>
<ol style="list-style-type: decimal">
<li><a href="https://github.com/HuwCampbell/grenade">grenade</a> A dependently typed, practical, and fast neural network library.</li>
<li><a href="https://github.com/colah/ImplicitCAD">implicitCAD</a> A math-inspired CAD engine in Haskell.</li>
<li><a href="https://github.com/sleexyz/hylogen">hylogen</a> GLSL embedded in Haskell.</li>
<li><a href="https://github.com/tweag/sparkle">sparkle</a> Haskell on Apache Spark.</li>
<li><a href="https://github.com/Gabriel439/bench">bench</a> Command-line benchmark tool.</li>
<li><a href="https://github.com/oblivia-simplex/roper">roper</a> A return-oriented programming exploit toolkit using genetic programming.</li>
<li><a href="https://github.com/mstksg/tensor-ops">tensor-ops</a> Type-safe tensor manipulation operations in Haskell</li>
<li><a href="https://github.com/alexbecker/formal-morality/">formal-morality</a> A Pseudo-Rawlsian domain language in Haskell.</li>
<li><a href="https://github.com/sru-systems/protobuf-simple">protobuf-simple</a> A simpler Protocol Buffers library for Haskell.</li>
<li><a href="https://github.com/DanielG/rts-loader">rts-loader</a> A Haskell dynamic RTS loader supporting multiple GHC APIs.</li>
<li><a href="https://github.com/I3ck/HGE2D">hge2d</a> 2D game engine written in Haskell.</li>
</ol>
<h4 id="haskell-sucks">Haskell Sucks</h4>
<p>On a reflective note, there were quite a few <a href="https://www.reddit.com/r/haskell/comments/4f47ou/why_does_haskell_in_your_opinion_suck/">dogpile threads</a> in which we collectively ripped on our beloved language for it’s many flaws. The responses ranged from the obvious to the absurd, but the most voted flaws (in order) were:</p>
<ol style="list-style-type: decimal">
<li>Strings</li>
<li>No documentation</li>
<li>Records</li>
<li>Prelude with partial functions</li>
<li>Ambigious space/time complexity</li>
<li>No stack traces</li>
<li>Language extension overload</li>
<li>Long compilation times</li>
<li>No IDE</li>
</ol>
<p>There’s some truth to most of these. There’s also a answer or workaround to all of them except documentation.</p>
<h4 id="editor-ides">Editor &amp; IDEs</h4>
<p>The traditional editors saw incremental improvements and much was written about provisioning development environments for Haskell.</p>
<ol style="list-style-type: decimal">
<li><a href="https://rikvdkleij.github.io/intellij-haskell/">IntelliJ plugin for Haskell</a></li>
<li><a href="http://www.prigrammer.com/?p=332">Setting Up A Haskell Development Environment (Mac OS)</a></li>
<li><a href="http://blog.jez.io/2016/08/03/vim-and-haskell-in-2016-on-os-x/">Vim and Haskell in 2016 on OS X</a></li>
</ol>
<p>FP Complete released the wonderful <a href="https://github.com/commercialhaskell/intero">Intero</a> a background process for interacting with Emacs to do type assisted programming and completion. Plugins were also created to integrate Intero with the <a href="https://github.com/parsonsmatt/intero-neovim">Neovim editor</a>.</p>
<p><a href="http://haskellformac.com/">Haskell for Mac</a> continued to develop this year adding new tutorial content and an interactive playground for live programming using HTML and SVG. It remains probably the simplest way to teach students using the Macintosh operating system.</p>
<p>I gave a talk on <a href="http://dev.stephendiehl.com/editor_talk.html">editor tooling</a> in Boston and updated the <a href="http://www.stephendiehl.com/posts/vim_2016.html">vim tutorial</a> as well.</p>
<p><a href="https://github.com/HeinrichApfelmus/hyper-haskell">HyperHaskell</a> was released which provides an IPython/Mathematica style workbook for interactive Haskell development. It is cross-platform and runs on Linux, Mac and Windows. Hyper extends Haskell’s Show mechanism to support with a <code>Display</code> typeclass which can be overloaded to display graphics, mathematics, diagrams or structured HTML when rendering Haskell values to the workbook.</p>
<p><img src="https://github.com/HeinrichApfelmus/hyper-haskell/raw/master/docs/screenshots/worksheet-diagrams.png" width=400/></p>
<p>On a future note, industry programmers using tools like Slack, Atom, and Visual Studio Code seem quite happy using web applications disguised in Chromium disguised as a native application using frameworks like <a href="http://electron.atom.io">Electron</a>. Obviously this isn’t a perfectly optimal solution, but there is definitely room for an ambitious team to take the prebuilt haskell-ide-engine, FP Complete <a href="https://github.com/fpco/haskell-ide">haskell-ide</a> or intero backends and shape it into an Haskell specialized IDE environment developers who like such a fully featured environment. Perhaps the FP Complete IDE was a good idea, just a bit early.</p>
<h4 id="ghc">GHC</h4>
<p>The Glorious Glasgow Haskell Compiler had it’s 8.0 release, and landed to to much rejoicing. It was a big release and landed quite a few new features. It also staged quite a bit of partial work that will be manifest in the 8.2 which is tentatively scheduled for release candidate in mid-February 2017 and release in mid-April 2017. The GHC core development team did some truly progressive work this year.</p>
<p><strong>Type In Type</strong></p>
<p>Haskell’s pseudo-dependent type solution <code>TypeInType</code> landed. The initial solution was a bit brittle and is not actively used too much in the wild. Simply put the <code>TypeInType</code> extension removed the distinction between types of kind <code>*</code> and types of other kinds.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="fu">:</span>set <span class="fu">-</span><span class="dt">XTypeInType</span> 
λ<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Data.Kind</span> 
λ<span class="fu">&gt;</span> <span class="fu">:</span>info <span class="dt">Type</span>
<span class="kw">type</span> <span class="dt">Type</span> <span class="fu">=</span> <span class="fu">*</span> 	<span class="co">-- Defined in ‘GHC.Types’</span>
λ<span class="fu">&gt;</span> <span class="fu">:</span>kind <span class="dt">Type</span>
<span class="dt">Type</span><span class="ot"> ::</span> <span class="fu">*</span></code></pre></div>
<p>Richard Eisenberg finished up the work for his <a href="https://github.com/goldfirere/thesis/blob/master/built/thesis.pdf">thesis</a> and released a status report on the <a href="https://typesandkinds.wordpress.com/2016/07/24/dependent-types-in-haskell-progress-report/">efforts</a>.</p>
<p><strong>Type Family Dependencies</strong></p>
<p>Type families historically have not been injective, i.e. they are not guaranteed to maps distinct elements of its arguments to the same element of its result. The syntax is similar to the multiparmater typeclass functional dependencies in that the resulting type is uniquely determined by a set of the type families parameters. GHC 8.0 added support for this with the <code>TypeFamilyDependencies</code> extension.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">F</span> a b c <span class="fu">=</span> (<span class="ot">result ::</span> k) <span class="fu">|</span> result <span class="ot">-&gt;</span> a b c
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">F</span> <span class="dt">Int</span>  <span class="dt">Char</span> <span class="dt">Bool</span> <span class="fu">=</span> <span class="dt">Bool</span>
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">F</span> <span class="dt">Char</span> <span class="dt">Bool</span> <span class="dt">Int</span>  <span class="fu">=</span> <span class="dt">Int</span>
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">F</span> <span class="dt">Bool</span> <span class="dt">Int</span>  <span class="dt">Char</span> <span class="fu">=</span> <span class="dt">Char</span></code></pre></div>
<p><strong>Kind Equalities</strong></p>
<p>Up until GHC 8.0, we’ve not been able to express explicit kind equality proofs. As a result, type-level computation does not have access to kind level functions or promoted GADTs, the type-level analogues to expression-level features that have been so useful.</p>
<p>For instance in Agda if we wanted to write down a type-level proof about the commutativity of addition over the natural numbers we can do this quite simply. We use the usual propositional equality to express the type that two things are equal using substitutivity (<code>subst</code>): for any proposition (type), we can replace a term with a propositionally equal one, without changing the meaning of the proposition. And relatedly congruence (<code>cong</code>): if any function f respects propositional equality, it yields propositionally equal results if applied to propositionally equal arguments.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> ℕ <span class="fu">:</span> <span class="dt">Set</span> <span class="kw">where</span>
  zero <span class="fu">:</span> ℕ
  suc  <span class="fu">:</span> ℕ <span class="ot">→</span> ℕ

<span class="ot">{-# BUILTIN NATURAL ℕ #-}</span>

<span class="kw">infixl</span> <span class="dv">6</span> _<span class="fu">+</span>_

_<span class="fu">+</span>_ <span class="fu">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> ℕ
<span class="dv">0</span> <span class="fu">+</span> n <span class="fu">=</span> n
suc m <span class="fu">+</span> n <span class="fu">=</span> suc (m <span class="fu">+</span> n)

infix <span class="dv">4</span> _≡_

<span class="kw">data</span> _≡_ {<span class="dt">A</span> <span class="fu">:</span> <span class="dt">Set</span>} (x <span class="fu">:</span> <span class="dt">A</span>) <span class="fu">:</span> <span class="dt">A</span> <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span>
  refl <span class="fu">:</span> x ≡ x

subst <span class="fu">:</span> {<span class="dt">A</span> <span class="fu">:</span> <span class="dt">Set</span>} <span class="ot">→</span> (<span class="dt">P</span> <span class="fu">:</span> <span class="dt">A</span> <span class="ot">→</span> <span class="dt">Set</span>) <span class="ot">→</span> <span class="ot">∀</span>{x y} <span class="ot">→</span> x ≡ y <span class="ot">→</span> <span class="dt">P</span> x <span class="ot">→</span> <span class="dt">P</span> y
subst <span class="dt">P</span> refl p <span class="fu">=</span> p

cong <span class="fu">:</span> {<span class="dt">A</span> <span class="dt">B</span> <span class="fu">:</span> <span class="dt">Set</span>} (f <span class="fu">:</span> <span class="dt">A</span> <span class="ot">→</span> <span class="dt">B</span>) <span class="ot">→</span> {x y <span class="fu">:</span> <span class="dt">A</span>} <span class="ot">→</span> x ≡ y <span class="ot">→</span> f x ≡ f y
cong f refl <span class="fu">=</span> refl

assoc <span class="fu">:</span> (m n p <span class="fu">:</span> ℕ) <span class="ot">→</span> (m <span class="fu">+</span> n) <span class="fu">+</span> p ≡ m <span class="fu">+</span> (n <span class="fu">+</span> p)
assoc zero    _ _ <span class="fu">=</span> refl
assoc (suc m) n p <span class="fu">=</span> cong suc (assoc n p)</code></pre></div>
<p>As of GHC 8.0 we now have enough to do this kind of kind-level reasoning using propositional equality with <code>TypeInType</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">{-# LANGUAGE RankNTypes #-}</span>
<span class="ot">{-# LANGUAGE TypeInType #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>

<span class="kw">import </span><span class="dt">Data.Kind</span>

 <span class="co">-- pattern matching on Refl introduces proof</span>
<span class="kw">data</span><span class="ot"> (==) ::</span> forall (<span class="ot">t ::</span> <span class="fu">*</span>)<span class="fu">.</span> t <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">Refl</span><span class="ot"> ::</span> x <span class="fu">==</span> x

<span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Nat</span>

<span class="kw">infixl</span> <span class="dv">6</span> <span class="fu">+</span>
<span class="kw">type</span> family (<span class="fu">+</span>) a b <span class="kw">where</span>
  <span class="dt">Z</span>   <span class="fu">+</span> b <span class="fu">=</span> b
  <span class="dt">S</span> a <span class="fu">+</span> b <span class="fu">=</span> <span class="dt">S</span> (a <span class="fu">+</span> b)

<span class="kw">type</span> family <span class="dt">Sym</span> (<span class="ot">eq ::</span> (<span class="ot">x ::</span> a) <span class="fu">==</span> (<span class="ot">y ::</span> a))<span class="ot"> ::</span> y <span class="fu">==</span> x <span class="kw">where</span>
  <span class="dt">Sym</span> <span class="dt">Refl</span> <span class="fu">=</span> <span class="dt">Refl</span>

<span class="kw">type</span> family <span class="dt">Cong</span> (<span class="ot">f ::</span> a <span class="ot">-&gt;</span> b) (<span class="ot">p ::</span> x <span class="fu">==</span> y)<span class="ot"> ::</span> f x <span class="fu">==</span> f y <span class="kw">where</span>
  <span class="dt">Cong</span> f <span class="dt">Refl</span> <span class="fu">=</span> <span class="dt">Refl</span>

<span class="kw">type</span> family <span class="dt">Assoc</span>
  (<span class="ot">a ::</span> <span class="dt">Nat</span>) (<span class="ot">b ::</span> <span class="dt">Nat</span>) (<span class="ot">c ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> (a <span class="fu">+</span> b <span class="fu">+</span> c) <span class="fu">==</span> ((a <span class="fu">+</span> b) <span class="fu">+</span> c)
  <span class="kw">where</span> 
    <span class="dt">Assoc</span> <span class="dt">Z</span>     b c <span class="fu">=</span> <span class="dt">Refl</span>
    <span class="dt">Assoc</span> (<span class="dt">S</span> a) b c <span class="fu">=</span> <span class="dt">Cong</span> <span class="dt">S</span> (<span class="dt">Assoc</span> a b c)</code></pre></div>
<p><strong>Visible Type Applications</strong></p>
<p>Visible Type Applications was added with the <code>-XTypeApplications</code> flag to allow the addition of explicit type arguments directly to polymorphic call-sites. For instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">show (read <span class="fu">@</span><span class="dt">Int</span> <span class="dv">42</span><span class="st">&quot;)</span></code></pre></div>
<p><strong>Custom Type Errors</strong></p>
<p>As of GHC 8.0 we have the capacity to provide custom type error using type families. The messages themselves hook into GHC and expressed using the small datatype found in <code>GHC.TypeLits</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ErrorMessage</span> <span class="kw">where</span>
  <span class="dt">Text</span><span class="ot"> ::</span> <span class="dt">Symbol</span> <span class="ot">-&gt;</span> <span class="dt">ErrorMessage</span>
  <span class="dt">ShowType</span><span class="ot"> ::</span> t <span class="ot">-&gt;</span> <span class="dt">ErrorMessage</span>

  <span class="co">-- Put two messages next to each other</span>
<span class="ot">  (:&lt;&gt;:) ::</span> <span class="dt">ErrorMessage</span> <span class="ot">-&gt;</span> <span class="dt">ErrorMessage</span> <span class="ot">-&gt;</span> <span class="dt">ErrorMessage</span>

  <span class="co">-- Put two messages on top of each other</span>
<span class="ot">  (:$$:) ::</span> <span class="dt">ErrorMessage</span> <span class="ot">-&gt;</span> <span class="dt">ErrorMessage</span> <span class="ot">-&gt;</span> <span class="dt">ErrorMessage</span></code></pre></div>
<p>An example would be creating a type-safe embedded DSL that enforces invariants about the semantics at the type-level. We’ve been able to do this sort of thing using GADTs and type-families for a while but the error reporting has been horrible. With 8.0 we can have type-families that emit useful type errors that reflect what actually goes wrong and integrate this inside of GHC. This is going to a <em>big deal</em> for embedded DSL design in Haskell where failures were typically opaque and gnarly.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>

<span class="kw">import </span><span class="dt">GHC.TypeLits</span>

<span class="kw">type</span> family <span class="dt">Coerce</span> a b <span class="kw">where</span>
  <span class="dt">Coerce</span> <span class="dt">Int</span> <span class="dt">Int</span>     <span class="fu">=</span> <span class="dt">Int</span>
  <span class="dt">Coerce</span> <span class="dt">Float</span> <span class="dt">Float</span> <span class="fu">=</span> <span class="dt">Float</span>
  <span class="dt">Coerce</span> <span class="dt">Int</span> <span class="dt">Float</span>   <span class="fu">=</span> <span class="dt">Float</span>
  <span class="dt">Coerce</span> <span class="dt">Float</span> <span class="dt">Int</span>   <span class="fu">=</span> <span class="dt">TypeError</span> (<span class="dt">Text</span> <span class="st">&quot;Cannot cast to smaller type&quot;</span>)

<span class="kw">data</span> <span class="dt">Expr</span> a <span class="kw">where</span>
  <span class="dt">EInt</span><span class="ot">    ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Int</span>
  <span class="dt">EFloat</span><span class="ot">  ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Float</span>
  <span class="dt">ECoerce</span><span class="ot"> ::</span> <span class="dt">Expr</span> b <span class="ot">-&gt;</span> <span class="dt">Expr</span> c <span class="ot">-&gt;</span> <span class="dt">Expr</span> (<span class="dt">Coerce</span> b c)

<span class="ot">foo ::</span> <span class="dt">Expr</span> <span class="dt">Int</span>
foo <span class="fu">=</span> <span class="dt">ECoerce</span> (<span class="dt">EFloat</span> <span class="dv">3</span>) (<span class="dt">EInt</span> <span class="dv">4</span>)</code></pre></div>
<p><strong>OverloadedRecordFields</strong></p>
<p>This was a source of great pain in previous releases where common identifiers like <code>id</code> would have to have superflous prefixes associated with each record, this is no longer an issue with the <code>OverloadedRecordFields</code> extension.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="kw">data</span> <span class="dt">A</span> <span class="fu">=</span> <span class="dt">A</span>
  {<span class="ot"> a ::</span> <span class="dt">Int</span>
  ,<span class="ot"> b ::</span> <span class="dt">Double</span>
  } <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">data</span> <span class="dt">B</span> <span class="fu">=</span> <span class="dt">B</span>
  {<span class="ot"> a ::</span> <span class="dt">String</span>
  ,<span class="ot"> c ::</span> <span class="dt">Char</span>
  } <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="ot">mkA ::</span> <span class="dt">A</span>
mkA <span class="fu">=</span> <span class="dt">A</span> {a <span class="fu">=</span> <span class="dv">23</span>, b <span class="fu">=</span> <span class="dv">42</span>}

<span class="ot">upA ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">A</span>
upA x <span class="fu">=</span> x {a <span class="fu">=</span> <span class="dv">12</span>}

<span class="ot">sel ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
sel <span class="fu">=</span> a

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> print <span class="fu">$</span> sel <span class="fu">$</span> upA <span class="fu">$</span> mkA</code></pre></div>
<p>GHC 8.0 also introduced the <code>OverloadedLabels</code> extension which allows a limited form of polymorphism over record selectors and updators that share the same name.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">IsLabel</span> (<span class="ot">x ::</span> <span class="dt">Symbol</span>) a <span class="kw">where</span>
<span class="ot">  fromLabel ::</span> <span class="dt">Proxy</span><span class="fu">#</span> x <span class="ot">-&gt;</span> a</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">IsLabel</span> <span class="st">&quot;true&quot;</span> <span class="dt">Bool</span> <span class="kw">where</span>
  fromLabel _ <span class="fu">=</span> <span class="dt">True</span>

<span class="kw">instance</span> <span class="dt">IsLabel</span> <span class="st">&quot;false&quot;</span> <span class="dt">Bool</span> <span class="kw">where</span>
  fromLabel _ <span class="fu">=</span> <span class="dt">False</span>

<span class="kw">instance</span> <span class="dt">IsLabel</span> <span class="st">&quot;true&quot;</span> <span class="dt">Int</span> <span class="kw">where</span>
  fromLabel _ <span class="fu">=</span> <span class="dv">1</span>

<span class="ot">a ::</span> <span class="dt">Bool</span>
a <span class="fu">=</span> <span class="fu">#</span>false

<span class="ot">b ::</span> <span class="dt">IsLabel</span> <span class="st">&quot;true&quot;</span> t <span class="ot">=&gt;</span> t
b <span class="fu">=</span> <span class="fu">#</span>true</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span> 
  print a
  print (<span class="ot">b ::</span> <span class="dt">Bool</span>)
  print (<span class="ot">b ::</span> <span class="dt">Int</span>)</code></pre></div>
<p><strong>MonadFail</strong></p>
<p>The MonadFail Proposal finally removed the ugly <code>fail</code> function that was historical cruft from the 90s. A new class <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad-Fail.html"><code>MonadFail</code></a> was implemented along with a set of warning flags pattern matching or guard would introduce a <code>fail</code> occurrence.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadFail</span> m <span class="kw">where</span>
<span class="ot">    fail ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> m a</code></pre></div>
<p><strong>DeriveLift</strong></p>
<p>8.0 added yet another automatic deriving mechanism. This time we can now automatically derive the boilerplate for TH Lift instances allowing us to embed free variables containing <code>Lift</code> instances inside of the Oxford brackets.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveLift #-}</span>

<span class="kw">module</span> <span class="dt">Lift</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Language.Haskell.TH.Syntax</span>

<span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="dt">Zero</span>
  <span class="fu">|</span> <span class="dt">Succ</span> <span class="dt">Expr</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Lift</span>)</code></pre></div>
<p>And in a separate module:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>

<span class="kw">module</span> <span class="dt">Exp</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Lift</span>
<span class="kw">import </span><span class="dt">Language.Haskell.TH.Syntax</span>

<span class="ot">zero ::</span> <span class="dt">Q</span> <span class="dt">Exp</span>
zero  <span class="fu">=</span> [<span class="fu">|</span><span class="dt">Zero</span><span class="fu">|</span>]

<span class="ot">suc ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span>
suc x <span class="fu">=</span> [<span class="fu">|</span><span class="dt">Succ</span> x<span class="fu">|</span>]

<span class="ot">x ::</span> <span class="dt">Expr</span>
x <span class="fu">=</span> <span class="fu">$</span>( [<span class="fu">|</span><span class="dt">Succ</span> <span class="dt">Zero</span><span class="fu">|</span>] )</code></pre></div>
<p><strong>Strict Haskell</strong></p>
<p>Haskell is normally uses a call-by-need semantics such that arguments passed to functions are only evaluated if their value is used. Bang patterns (written as <code>!x</code>) are explicit annotations that can force a specific to be evaluated before entering the function instead of as needed. GHC 8.0 introduced the ability to enable this for all functions in a specific module.</p>
<p>For example given the following set of definitions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">T</span> <span class="fu">=</span> <span class="dt">C</span> a
f x <span class="fu">=</span> y x
<span class="kw">let</span> x <span class="fu">=</span> y <span class="kw">in</span> rhs
<span class="kw">case</span> x <span class="kw">of</span> y <span class="ot">-&gt;</span> rhs
<span class="kw">case</span> x <span class="kw">of</span> (<span class="dt">NewType</span> y) <span class="ot">-&gt;</span> rhs</code></pre></div>
<p>Enable <code>-XStrict</code> will automatically performs the equivalent of adding strictness annotations to the every argument source. Effectively transforming the above into the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">T</span> <span class="fu">=</span> <span class="dt">C</span> <span class="fu">!</span>a
f <span class="fu">!</span>x <span class="fu">=</span> y x
<span class="kw">let</span> <span class="fu">!</span>x <span class="fu">=</span> y <span class="kw">in</span> rhs
<span class="kw">case</span> x <span class="kw">of</span> <span class="fu">!</span>y <span class="ot">-&gt;</span> rhs
<span class="kw">case</span> x <span class="kw">of</span> <span class="fu">!</span>(<span class="dt">NewType</span> y) <span class="ot">-&gt;</span> rhs</code></pre></div>
<p>Enabling will not uniformly increase the performance of code as some care is required when enabling it. It simply makes a slightly alters the behavior to one extreme of the space-time compromise spectrum, optimal performance still requires a clever mix of both laziness and strictness.</p>
<p><strong>Stack Traces</strong></p>
<p>Simon Marlow cracked the perpetual <a href="https://simonmar.github.io/posts/2016-02-12-Stack-traces-in-GHCi.html">stack trace problem</a> allowing a variety of approaches to getting detailed stack trace informations when we have to panic or unwind the stack.</p>
<p>For explicitly defined functions we can annotate call sites with a <code>HasCallStack</code> constraint which can be used to to obtain a partial call-stack at any point in the program. HasCallStack is a type constraint synonym for threading an implicit paramater <code>?callStack</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">HasCallStack</span> <span class="fu">=</span> <span class="fu">?</span><span class="ot">callStack ::</span> <span class="dt">CallStack</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">GHC.Stack</span>

<span class="ot">f ::</span> <span class="dt">HasCallStack</span> <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
f x <span class="fu">=</span> error (<span class="st">&quot;Error: &quot;</span> <span class="fu">++</span> show x)

<span class="ot">g ::</span> <span class="dt">HasCallStack</span> <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
g <span class="fu">=</span> withFrozenCallStack f

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> print <span class="fu">$</span> g <span class="dv">23</span></code></pre></div>
<p>For automatic stack traces across the entire program in GHCi we can compile the with a specific set of flags and profiling enabled. The precise stack trace from the closure where assertion was called will then be printed if the term is evaluated. Currently this introduces a 2-3x runtime overhead when compiled.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">ghci</span> -fexternal-interpreter -prof </code></pre></div>
<p><strong>Unboxed Sum Types</strong></p>
<p>GHC 8.2 will have <code>UnboxedSums</code>, that enables unboxed representation for non-recursive sum types. The extension will be enabled as an opt-in annotation with new to explicitly unpack selected datatypes for high-performance structures.</p>
<p>Unboxed types are those which instead of being represented by a pointer to heap value are passed directly in a CPU register. The usual numerics types in Haskell can be considered to be a regular algebraic datatype with special constructor arguments for their underlying unboxed values.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Int</span> <span class="fu">=</span> <span class="dt">I</span><span class="fu">#</span> <span class="dt">Int</span><span class="fu">#</span>

<span class="kw">data</span> <span class="dt">Integer</span>
  <span class="fu">=</span> <span class="dt">S</span><span class="fu">#</span> <span class="dt">Int</span><span class="fu">#</span>              <span class="co">-- Small integers</span>
  <span class="fu">|</span> <span class="dt">J</span><span class="fu">#</span> <span class="dt">Int</span><span class="fu">#</span> <span class="dt">ByteArray</span><span class="fu">#</span>   <span class="co">-- Large GMP integers</span>

<span class="kw">data</span> <span class="dt">Float</span> <span class="fu">=</span> <span class="dt">F</span><span class="fu">#</span> <span class="dt">Float</span><span class="fu">#</span></code></pre></div>
<p>The syntax introduced allows sums to be explicitly unboxed by delimiters <code>(# ...  #)</code>. Pattern matching syntax follows the same form, and allows explicit unpacking of the unboxed sum in case statements.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Sum1</span> <span class="fu">=</span> 
  (<span class="fu">#</span> 
    (<span class="fu">#</span> <span class="dt">Int</span><span class="fu">#</span>, <span class="dt">Int</span> <span class="fu">#</span>)
    <span class="fu">|</span> (<span class="fu">#</span> <span class="dt">Int</span><span class="fu">#</span>, <span class="dt">Int</span><span class="fu">#</span> <span class="fu">#</span>)
    <span class="fu">|</span> (<span class="fu">#</span> <span class="dt">Int</span>, <span class="dt">Int</span><span class="fu">#</span> <span class="fu">#</span>) 
  <span class="fu">#</span>)

<span class="ot">showSum1 ::</span> <span class="dt">Sum1</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
showSum1 (<span class="fu">#</span> p1 <span class="fu">|</span> <span class="fu">|</span> <span class="fu">#</span>) <span class="fu">=</span> showP1 p1
showSum1 (<span class="fu">#</span> <span class="fu">|</span> p2 <span class="fu">|</span> <span class="fu">#</span>) <span class="fu">=</span> showP2 p2
showSum1 (<span class="fu">#</span> <span class="fu">|</span> <span class="fu">|</span> p3 <span class="fu">#</span>) <span class="fu">=</span> showP3 p3</code></pre></div>
<p>The usual ( <code>Maybe a</code> ) type was traditionally represented by a tagged closure, with a two pointer lookups to the parameter <code>a</code>. With unboxed sums we simply store the pointer to the value a alongside the flag for the sum type without the need for extra indirection. This would effectively allow a ‘zero-cost abstraction’ (with full type safety) use of the Maybe monad when fully optimized.</p>
<p><strong>Compact Regions</strong></p>
<p>Support for ‘Compact Regionss’ is planned for GHC 8.2. Compact regions are manually allocated regions where the data allocated inside it are compacted and not traversed by the GC. This is amenable for long-lived data structures that are resident in memory without mutation frequently occurring. William Sewell gave a great <a href="https://blog.pusher.com/latency-working-set-ghc-gc-pick-two/">talk</a> at the London Haskell meetup where the issues with large <code>Data.Map</code> structures used for a message bus system caused non-optimal GC performance</p>
<p>The proposed API has been <a href="http://ezyang.com/compact/Data-Compact.html">expressed</a> as well as a paper on the details on extensions to the GC and <a href="http://ezyang.com/papers/ezyang15-cnf.pdf">runtime system</a>.</p>
<p><strong>GHC Education</strong></p>
<p>At the beginning of the year I felt one of the larger looming issues is that GHC internals are too opaque. However there was a lot of great writing and talks given this year about practical examples of extending and exploring the GHC internals.</p>
<p>Simon Petyon Jones gave a brilliant talk on <a href="https://www.youtube.com/watch?v=uR_VzYxvbxg">Into the Core</a>, describing the System-FC core language at the heart of all of Haskell. He also then described the new work on the <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/sequent-core/scfp_ext.pdf">Sequent calculus</a> as a compiler intermediate language for future work.</p>
<p>I wrote a three part blog series on the internal GHC types, pipeline, and gave some practical tutorials on augmenting the compiler with custom logic. Work permitting I’ll try to extend this series next year with posts on CMM and RTS internals.</p>
<ol style="list-style-type: decimal">
<li><a href="http://www.stephendiehl.com/posts/ghc_01.html">Dive into GHC: Part 1</a></li>
<li><a href="http://www.stephendiehl.com/posts/ghc_02.html">Dive into GHC: Part 2</a></li>
<li><a href="http://www.stephendiehl.com/posts/ghc_03.html">Dive into GHC: Part 3</a></li>
</ol>
<p>Takenobu Tani published a lovely slide deck on <a href="https://takenobu-hs.github.io/downloads/haskell_ghc_illustrated.pdf">GHC internals illustrated</a>.</p>
<p>David Luposchainsky released a <a href="https://github.com/quchen/stgi">STGj</a>, a visual STG (Spineless Tagless G-Machine) implementation to help understand Haskell’s execution model. A talk on the subject was also given at <a href="https://www.youtube.com/watch?v=-MFk7PIKYsg">ZuriHac</a>.</p>
<p>Alberto Sade wrote a short tutorial on manipulating the <a href="http://aesadde.xyz/posts/ghc_core.html">GHC Core</a> types from inside Haskell programs.</p>
<p>Christiaan Baaij wrote a <a href="https://christiaanb.github.io/posts/type-checker-plugin/">detailed tutorial</a> on extending the GHC typechecker with a custom plugins which allow more complex logic to be embedded in the type system.</p>
<h4 id="stack">Stack</h4>
<p>Since last year Stack has become near ubiquitous. Every company that I’ve come in contact with in the last year is using it internally for their builds. The tooling makes some compromises on version bounds and compatibility that are ‘pragmatic’ and actively debated, but overall the tooling has brought more people into the language and vastly decreased a lot of the friction we once had. The innovation of Stack can be put quite simply as making all build commands idempotent and sandboxes as stateless, which was a vast improvement over stateful sandboxes which would quickly become corrupted or inconsistent and needed to be rebuilt constantly.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">stack</span> ghci --package protolude</code></pre></div>
<p>Stack has since grown a rich set of integrations with tooling such as Nix, GHCjs, TravisCI, CircleCI, Docker, Kubernetes as well as broad set of templates for <a href="https://github.com/commercialhaskell/stack-templates">quickly starting</a> Haskell projects.</p>
<p>The alternative <code>cabal new-build</code> build system is under active development. The new build system uses Nix-style local builds which makes a distinction between local packages and external packages. Local packages, which users edit and recompile and must be built per-project whereas external packages are cached across projects and retrieved from Hackage.</p>
<ol style="list-style-type: decimal">
<li><a href="https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html">New-Build Documentation</a></li>
<li><a href="http://blog.ezyang.com/2016/05/announcing-cabal-new-build-nix-style-local-builds/">Announcing Cabal New-Build</a></li>
</ol>
<p>There will likely still be healthy debate about best practices, but despite whatever approach converges much of the Cabal-hell problems of years past are a distant memory. We have ubiquitous cached builds, stateless sandboxing and easy to use-tooling.</p>
<h4 id="probabilistic-programming">Probabilistic Programming</h4>
<p>Probalistic domain languages are designed to describe probabilistic models by allowing variables defined in the language to represent stochastic quantitaties, and then perform inference (Markov Chain Monte-Carlo, Gibbs Sampling, etc) on combinations of these stochastic models according to the structure of the their combination in the program. Probabilistic programming is an exciting, and growing, area of research, with fantastic people in both AI/ML and PL working together and making big strides. It is especially finding uses in quantitative finance as of late.</p>
<p>Jared Tobin has written some <a href="https://jtobin.io/simple-probabilistic-programming">excellent articles</a> on the topic of building minimalist domain languages to model probabilistic models. There’s also been several other encodings in libraries like <a href="https://hakaru-dev.github.io/">hakaru</a> and <a href="https://github.com/adscib/monad-bayes">monad-bayes</a>.</p>
<h4 id="llvm">LLVM</h4>
<p>LLVM is a compiler toolchain and intermediate language used in most modern compilers. Since Haskell is heavily used in compiler and language work, the LLVM bindings are of great interest to a lot of Haskellers. This year saw quite a few new compilers and derived work.</p>
<p>Roberto Castañeda Lozano released <a href="https://github.com/unison-code/unison/tree/master/src/unison">Unison</a> a new Haskell library which integrates with the LLVM toolchain as an alternative or as a complementary approach to default register allocation algorithms which are suboptimal for embedded or low-power systems.</p>
<p>Moritz Angermann gave a lovely talk on using embedded DSLs in Haskell to generate <a href="https://github.com/angerman/data-bitcode-llvm">LLVM bitcode</a> and presented at <a href="https://www.youtube.com/watch?v=mrJUjlxoTTY">ICFP</a>.</p>
<p>I travelled to Paris and Berlin this autumn and gave a short talk on compiling small native languages using llvm-general Haskell bindings to build a small compiler called ‘Petit’. Andreas Herrmann also gave a brilliant talk on the subject in Zurich with a more detailed <a href="https://www.youtube.com/watch?v=Re3XgFfflzg">dive through</a> through the internals of a simple LLVM compiler backend.</p>
<p>The Summer of Code sponsored work on the LLVM backend to Accelerate, one of Haskell’s array computing librarys. The work <a href="https://github.com/AccelerateHS/accelerate-llvm/commits?author=ZihengJiang">implemented all</a> of the core operators and the project should be ready widespread soon.</p>
<h4 id="mathematics">Mathematics</h4>
<p>The <a href="https://github.com/cartazio/arithmoi">arithmoi</a> number theory library found new maintainers and is being actively developed once again.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Math.NumberTheory.Zeta</span>
<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Math.NumberTheory.Primes.Sieve</span>

<span class="fu">&gt;</span> take <span class="dv">10</span> primes
[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">11</span>,<span class="dv">13</span>,<span class="dv">17</span>,<span class="dv">19</span>,<span class="dv">23</span>,<span class="dv">29</span>]

<span class="fu">&gt;</span> take <span class="dv">3</span> (zetas 1e<span class="fu">-</span><span class="dv">14</span>)<span class="ot"> ::</span> [<span class="dt">Double</span>]
[<span class="fu">-</span><span class="fl">0.5</span>,<span class="dt">Infinity</span>,<span class="fl">1.6449340668482262</span>]</code></pre></div>
<p>A rather popular student project this year was a <a href="https://github.com/jyh1/mmaclone">implementation of the Wolfram Language</a>, a simple M-Expression language based on term rewriting. The project demonstrated the obvious strength Haskell has for modeling mathematical domain languages. There is most definitely a lot of low-hanging fruit for building the core machinery for classic computer algebra problems. A basic implementation of the following would go quite far toward advancing Haskell in computational algebra:</p>
<ol style="list-style-type: decimal">
<li><em>Gröbner basis</em> calculation for solving systems of polynomials in commutative algebras.</li>
<li><em>Normal-Risch algorithm</em> for symbolic integration.</li>
<li><em>Strong Generating Sets/Coset</em> algorithms for tensor index canonicalization.</li>
<li><em>Horner scheme</em> for evaluation of univariate polynomials over arbitrary domains.</li>
</ol>
<h4 id="cryptography">Cryptography</h4>
<p>Due to commercial investment, cryptography libraries in Haskell have gotten much more mature this year. We have a complete complement of the industry standard algorithms for various tasks:</p>
<ol style="list-style-type: decimal">
<li><a href="https://hackage.haskell.org/package/cryptonite-0.21/docs/Crypto-MAC-Poly1305.html#g:1">Poly1305</a> for message authentication codes.</li>
<li><a href="https://hackage.haskell.org/package/cryptonite-0.21/docs/Crypto-Hash-Algorithms.html#g:1">Blake2b</a> or <a href="https://hackage.haskell.org/package/cryptonite-0.21/docs/Crypto-Hash-Algorithms.html#t:Keccak_256">Keccak-256</a> for hashing.</li>
<li><a href="https://hackage.haskell.org/package/cryptonite-0.21/docs/Crypto-KDF-Scrypt.html">Scrypt</a> or <a href="https://hackage.haskell.org/package/argon2-1.2.0/docs/Crypto-Argon2.html">Argon2</a> for password key derivation.</li>
<li><a href="https://hackage.haskell.org/package/cryptonite-0.21/docs/Crypto-Cipher-ChaCha.html#g:1">Chacha20-256</a> for symmetric key encryption.</li>
<li><a href="https://hackage.haskell.org/package/cryptonite-0.21/docs/Crypto-PubKey-Curve25519.html">Curve25519</a> for elliptic curve public key cryptography.</li>
</ol>
<p>Also a friendly reminder that the NSA has likely developed the capability to decrypt a large number of HTTPS, SSH, and VPN connections using an attack on common primes used in the parameters of the Diffie-Hellman key exchange algorithm with keys less than 2048 bits. Some estimates also put decryption with the D-Wave computers within 10 years which poses a thread to current crytographic approachs based on the discrete-logarithm problem in finite fields and elliptic curves. Be safe as we go into uncertain territory in 2017.</p>
<p>At ICFP there was a <a href="https://www.youtube.com/watch?v=RA0DsMrwcxo">fascinating presentation</a> on interesting work on implementing <a href="https://eprint.iacr.org/2015/1134.pdf#page=24">somewhat homomorphic encryption (SHE)</a> and lattice cryptography in Haskell.</p>
<h4 id="committees">Committees</h4>
<p>The Haskell 2020 committee formed with the goal of forming a new language report that GHC 8.8 would implement. There is a mailing list for <a href="https://mail.haskell.org/pipermail/haskell-prime/">haskell prime</a> as well as several RFC projects on Github to track the progress. The GHC project also started tracking proposal discussion on Github using pull requests in a more public <a href="https://github.com/ghc-proposals/ghc-proposals/pulls">forum</a>.</p>
<p>The <a href="https://github.com/DataHaskell">DataHaskell</a> github organization was formed with the stated goal of improving the environment for data science in Haskell. It has since become an incubator for several ambitious projects to advance the state of numerical computing libraries and documentation.</p>
<h4 id="serialization">Serialization</h4>
<p>Well-Typed and FPComplete both released two binary serialization libraries.</p>
<ol style="list-style-type: decimal">
<li><a href="https://github.com/well-typed/binary-serialise-cbor">binary-serialise-cbor</a></li>
<li><a href="https://hackage.haskell.org/package/store">store</a></li>
</ol>
<p>Both are high performance serialization libraries with different encodings, endianness choices and performance characteristics, especially around fixed-size vectors and traversals times of input types.</p>
<h4 id="halvm">HalVM</h4>
<p>Development on HalVM out of Galois picked up with some public statements on project. HalVM is a framework for writing Haskell programs that run lightweight virtual machines run directly on the Xen hypervisor. This potentially opens up the opportunity for deploying “containers” that are single purpose programs with minimal exposure to the usual baggage Linux operating system carry and their potential exploits.</p>
<ol style="list-style-type: decimal">
<li><a href="http://uhsure.com/halvm-status1.html">HalVM Status 1</a></li>
<li><a href="http://uhsure.com/halvm3.html">HalVM: The Vision</a></li>
</ol>
<p>Tooling was also published to deploy these Unikernels to standard Amazon EC2 infrastructure. See: <a href="https://github.com/GaloisInc/ec2-unikernel">ec2-unikernel</a></p>
<h4 id="languages">Languages</h4>
<p>Los Alamos National Laboratory released an interesting <a href="https://tfp2016.org/papers/TFP_2016_paper_14.pdf">auto-parallelizing</a> Haskell subset called <a href="https://github.com/losalamos/APPFL">APPFL</a>.</p>
<p><a href="https://github.com/kellino/microML">microML</a> is a simple functional programming language designed for teaching at University College of London for the BBC micro:bit microcomputer.</p>
<p>Fugue developed an internal language called <a href="https://fugue.co/">Fugue</a> which is used for automating cloud deployments. The technology was demoed at <a href="https://www.youtube.com/watch?v=rIphd57Sm1U">ICFP talk</a> this year.</p>
<p>Summer of Code sponsored work on a <a href="https://code.world/blocks">“blocky” interface</a> for composing Haskell programmers, used for teaching basic functional programming.</p>
<p>Swift Navigation released <a href="https://github.com/swift-nav/plover">Plover</a>, an embedded Haskell DSL for compiling linear algebra routines into C for running on embedded systems.</p>
<p>Daan Leijen continued development on <a href="https://github.com/koka-lang/koka">Koka</a> an experiment in effect typing using row polymorphism.</p>
<p><a href="https://github.com/jameysharp/corrode">The Corrode</a> project was introduced which provided a semantics-preserving automatic translation tool from C to Rust, for migrating legacy code. Using Haskell to remove legacy C code from this world can only be a good thing.</p>
<p>Paul Chiusano continued development on <a href="http://unisonweb.org/2016-10-12/search.html#post-start">Unison</a> a ‘next generation programming platform’ implemented in Haskell and designed for building large-scale distributed systems.</p>
<p>Gabriel Gonzalez released <a href="https://hackage.haskell.org/package/dhall-1.0.1/docs/Dhall-Tutorial.html">Dhall</a>, a total non-Turing complete programming language specialized for configuration files. Including a standard library hosted on permanent web <a href="https://ipfs.io/ipfs/QmcTbCdS21pCxXysTzEiucDuwwLWbLUWNSKwkJVfwpy2zK/Prelude">IPFS</a> node.</p>
<h4 id="prelude">Prelude</h4>
<p>The single largest reported pain point for the Haskell language is simply from certain “naughty” historical things in the Prelude which no longer reflect modern thinking. The default Prelude makes it much too accidently shoot oneself in the foot by using suboptimal String types, partial functions, impure exception throwing, and a variety of other papercuts.</p>
<p>Earlier this year I released my perspective on the issue: Protolude. Protolude is likely the least ambitious alt-prelude ever. It doesn’t do anyting new, just fixes Base exports with the legacy bits masked and much of the mental overload of String conversions smoothed over. Notably it maintains ABI compatibility with existing Haskell code. Judging by the number of uses of Github it seems well-received and is being used in the core of major projects like PostgREST and Purescript.</p>
<p>There are plenty of other approaches to <a href="https://hackage.haskell.org/packages/#cat:Prelude">prelude design</a> and I believe the explosion is a healthy reaction to a standard library which many users consider not suitable for industrial use. No one prelude will be suitable for everyone for all use cases. The two concerning factors to keep in mind when exploring this space are:</p>
<ol style="list-style-type: decimal">
<li>Keep the transitive dependency tree small.</li>
<li>Maintain compatibility with base whenever possible.</li>
</ol>
<p>For a new projects in 2017, consider just starting with <code>NoImplicitPrelude</code> in your cabal file and importing a sensible set of defaults from your library of choice.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">default<span class="fu">-</span>extensions<span class="fu">:</span>
  <span class="dt">NoImplicitPrelude</span></code></pre></div>
<p>Or use a stack template like:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">stack</span> new protolude</code></pre></div>
<h4 id="foundation">Foundation</h4>
<p>Alternate preludes are only routing around the problem because of the constraints of being unable to fix problems upstream. The <a href="library%20is%20https://github.com/haskell-foundation/foundation">Foundation</a> bit grander in scope and aims to fix quite a few of the overarching problems with the ecosystem.</p>
<ol style="list-style-type: decimal">
<li>UTF8 based strings are default and are stored as packed array of codepoints.</li>
<li>FilePath are algebraic datatypes and can be manipulated and inspected without string munging.</li>
<li>IO actions read into ByteStrings and conversion into the appropriate type is left to the user.</li>
<li>Partial functions are either removed or wrapped in a <code>Partial</code> monad. Non-empty datatypes are provided by default.</li>
<li>An abstract container interface is provided that allows multiple data structures (Set, Map, Vector, etc) to use the same functions overloaded by a type class with associated data families to track elements or index types.</li>
<li>More granular numerical tower that doesn’t require partial implementations of functions that aren’t relevant.</li>
</ol>
<p>For a quick taste:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span>

<span class="kw">import </span><span class="dt">Foundation</span>
<span class="kw">import </span><span class="dt">Foundation.IO</span>
<span class="kw">import </span><span class="dt">Foundation.String</span>
<span class="kw">import </span><span class="dt">Foundation.VFS.FilePath</span>

<span class="kw">import </span><span class="dt">Foundation.Collection</span>

<span class="ot">example ::</span> <span class="dt">String</span>
example <span class="fu">=</span> <span class="st">&quot;Violence is the last refuge of the incompetent.&quot;</span>

<span class="ot">bytes ::</span> <span class="dt">UArray</span> <span class="dt">Word8</span>
bytes <span class="fu">=</span> toBytes <span class="dt">UTF8</span> example

<span class="ot">file ::</span> <span class="dt">IO</span> (<span class="dt">UArray</span> <span class="dt">Word8</span>)
file <span class="fu">=</span> readFile <span class="st">&quot;foundation.hs&quot;</span>

<span class="ot">fileString ::</span> <span class="dt">IO</span> (<span class="dt">String</span>, <span class="dt">Maybe</span> <span class="dt">ValidationFailure</span>, <span class="dt">UArray</span> <span class="dt">Word8</span>)
fileString <span class="fu">=</span> fromBytes <span class="dt">UTF8</span> <span class="fu">&lt;$&gt;</span> file

<span class="ot">xs ::</span> <span class="dt">NonEmpty</span> [<span class="dt">Int</span>]
xs <span class="fu">=</span> fromList [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]

<span class="ot">x ::</span> <span class="dt">Int</span>
x <span class="fu">=</span> head xs</code></pre></div>
<p>I’m not aware anyone currently using this library, but it most certainly something to watch as it matures in 2017. It might be the “new hope” we’ve been looking for which consolidates industrial Haskell best practices.</p>
<h4 id="generics">Generics</h4>
<p>Generics in 8.0 extended the generics structure to include a richer set of queryable data. We now have full access to the lifted status, strictness annotations, datatype names, selector names, constructors, and newtype status of all symbols in a Generic instance.</p>
<p>The implementation of <code>DeriveAnyClass</code> pragma has also allowed classes which provide fully default signatures to automatically derived without empty instance declarations. Aeson for instance can now automatically derive JSON serializes and de serializes for any instance of Generic for free.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span>
<span class="ot">{-# LANGUAGE DeriveAnyClass #-}</span>

<span class="kw">import </span><span class="dt">Data.Text</span>
<span class="kw">import </span><span class="dt">Data.Aeson</span>

<span class="kw">data</span> <span class="dt">Sample</span> <span class="fu">=</span> <span class="dt">Sample</span>
  {<span class="ot"> a ::</span> <span class="dt">Text</span>
  ,<span class="ot"> b ::</span> <span class="dt">Text</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Generic</span>,<span class="dt">FromJSON</span>,<span class="dt">ToJSON</span>)

<span class="co">-- decode { &quot;a&quot;: &quot;foo&quot;, &quot;b&quot;: &quot;bar&quot; } :: Sample</span></code></pre></div>
<p>Libraries like <code>optparse-generic</code> have implemented prototypes of building entire command line interfaces using generics on top of vanilla Haskell data structures.</p>
<p>Andres Löh gave an hour long lecture on the new approach of using generic sums-of-products with generics-sop at <a href="https://www.youtube.com/watch?v=sQxH349HOik">ZuriHac 2016</a>.</p>
<p>I wrote a <a href="http://www.stephendiehl.com/posts/generics.html">short blog</a> post amount implementing custom generics functionality and how the internals of Generic deriving works.</p>
<p>Ryan Scott wrote a detailed blog post detailing all of the <a href="https://ryanglscott.github.io/2016/05/12/whats-new-with-ghc-generics-in-80/">substantial changes</a> in GHC 8.2 and changes to metadata format.</p>
<h4 id="idris">Idris</h4>
<p>Idris is a pure functional language with full dependent types, and is itself written in Haskell. Idris is not likely to be the tool I’ll reach for most of my day-to-day work, but it’s maturing quite rapidly and pushing the envelope of practicality in dependent types more so than any other language. It was announced that Idris is heading toward a <a href="http://www.idris-lang.org/towards-version-1-0/">1.0 milestone</a>.</p>
<p>There is also initial work on a <a href="https://github.com/mmhelloworld/idris-jvm">Java Virtual Machine backend</a> to Idris to supplement the builtin native code generator and Javascript backends.</p>
<p>There is also work on porting Benjamin Pierce’s seminal work ‘Software Foundations’ into <a href="https://github.com/idris-hackers/software-foundations">Idris</a>.</p>
<p>Most notably 0.9 introduced elaboration reflection using Idris as its own metalanguage. To explain, Idris is type checked in two stages: first, a metaprogram known as an elaborator translates the surface language into a small core language (called TT), after which the resulting TT program is type checked . Incomplete programs can be introduced as holes, which in the context of the rest of the program, have a set of unification constraints to be solved.</p>
<p>Elaboration allows us to ‘script’ the automatic completion of these holes with reusable logic that can access the full typing environment. This used to exist in a dedicated <a href="http://docs.idris-lang.org/en/latest/reference/tactics.html">tactic system</a> (ala Coq) but now these tactics can themselves be expressed using the elaborators reflection in Idris itself using a small set of monadic combinators.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Convert a hole to make it suitable for bindings</span>
attack <span class="fu">:</span> <span class="dt">Elab</span> ()

<span class="co">-- Introduce a lambda binding around the current hole and focus on the body</span>
intro <span class="fu">:</span> (n <span class="fu">:</span> <span class="dt">TTName</span>) <span class="ot">-&gt;</span> <span class="dt">Elab</span> ()

<span class="co">-- Place a term into a hole, unifying its type.</span>
fill <span class="fu">:</span> <span class="dt">Raw</span> <span class="ot">-&gt;</span> <span class="dt">Elab</span> ()

<span class="co">-- Substitute a guess into a hole.</span>
solve <span class="fu">:</span> <span class="dt">Elab</span> ()</code></pre></div>
<p>For example to elaborate a polymorphic identity function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">mkId <span class="fu">:</span> <span class="dt">Elab</span> ()
mkId <span class="fu">=</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> gensym <span class="st">&quot;x&quot;</span>
  attack
  intro x
  fill (<span class="dt">Var</span> x); solve
  solve

idNat <span class="fu">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span>
idNat <span class="fu">=</span> <span class="fu">%</span>runElab mkId</code></pre></div>
<p>The latest version now ships with a standard library of proof tactics called <a href="https://github.com/idris-lang/Idris-dev/tree/master/libs/pruviloj">Pruviloj</a> that work with Idris’s elaborator. For example we can automate induction proofs to prove associativity of numerical operations.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Pruviloj</span>

auto <span class="fu">:</span> <span class="dt">Elab</span> ()
auto <span class="fu">=</span> <span class="kw">do</span>
  compute
  attack
  try intros
  hs <span class="ot">&lt;-</span> map fst <span class="fu">&lt;$&gt;</span> getEnv
  for_ hs <span class="fu">$</span> \ih <span class="ot">=&gt;</span> try (rewriteWith (<span class="dt">Var</span> ih))
  hypothesis <span class="fu">&lt;|&gt;</span> search
  solve

ind <span class="fu">:</span> <span class="dt">Elab</span> ()
ind <span class="fu">=</span> <span class="kw">do</span>
  attack
  n <span class="ot">&lt;-</span> gensym <span class="st">&quot;x&quot;</span>
  intro n
  try intros
  ignore <span class="fu">$</span> induction (<span class="dt">Var</span> n) <span class="ot">`andThen`</span> auto
  solve

assoc <span class="fu">:</span> (j, k, l <span class="fu">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> plus (plus j k) l <span class="fu">=</span> plus j (plus k l)
assoc <span class="fu">=</span> <span class="fu">%</span>runElab ind</code></pre></div>
<p>Will then automatically fill in the term:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">assoc <span class="fu">:</span> (j, k, l <span class="fu">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> plus (plus j k) l <span class="fu">=</span> plus j (plus k l)
assoc <span class="dt">Z</span>     k l <span class="fu">=</span> <span class="dt">Refl</span>
assoc (<span class="dt">S</span> j) k l <span class="fu">=</span> <span class="kw">let</span> rec <span class="fu">=</span> assoc j k l <span class="kw">in</span> rewrite rec <span class="kw">in</span> <span class="dt">Refl</span></code></pre></div>
<h4 id="agda">Agda</h4>
<p>Agda is the most mature dependently typed functional programming language, and is itself written in Haskell. It is regularly used for research and for build complex type-level constructions to extract into Haskell.</p>
<p>Agda actually has quite lovely <a href="https://agda.readthedocs.io/en/latest/">documentation now</a> and is far more approachable than 5-6 years ago. There was recently a full course entitled Agda from Nothing (<a href="https://www.youtube.com/watch?v=-i-QQ36Nfsk">video</a>, <a href="https://github.com/scott-fleischman/agda-from-nothing">source</a>) by which walks one Scott Fleischman through the basics of dependently typed programming from first principles. It’s never been easier to learn.</p>
<h4 id="javascript">Javascript</h4>
<p>Javascript unfortunately continues to exist. While I remain skeptical of the entire transpiring phenomenon and think it will lead to an endless amount of wasted person-hours and legacy code. However the pragmatist in me also knows that the browser vendors are not economically incentivized to change the status quo, so nothing will change quickly and we should adapt ourselves to the least worst solution.</p>
<p>Last year I said I would revisit Elm if anything changed. Nothing has changed. It’s as uninteresting a language as it was last year. It’s 2017, languages should have a coherent story for polymorphism that doesn’t involve manual code duplication. I remain unconvinced by arguments attempting to reframe ‘primitive’ technology as ‘simple’.</p>
<p>Purescript on the other hand is increasingly becoming a more mature and robust language fully grounded in modern ideas. There was a <a href="https://leanpub.com/purescript/read">lovely book written</a> this year as well as variety of language improvements like newtype deriving, generics, type directed search, source maps, better error reporting, and custom package manager.</p>
<p>The Purescript community developed <a href="https://github.com/slamdata/purescript-halogen/blob/master/GUIDE.md">Halogen</a> which is a a toolkit for building reactive web apps using signal functions and a virtual DOM. It exposes a set of combinator for acting on signals which vary over time and dispatch to DOM event changes. This provides a proposal to the current trend of React/Redux-style application construction.</p>
<p>The GHCjs solutuion has gotten more mature and stable, and integrated with the Stack ecosystem. There were some impressive demos on compiling the entirety of <a href="http://markup.rocks">Pandoc</a> into Javascript, which is quite a feat of engineering. Nevertheless, I remain somewhat skeptical that compiling Haskell to enormous blobs of auto-generated Javascript that contain the entire Haskell runtime is a sustainable solution for large commercial codebases. With WebAssembly on the horizon I might be convinced otherwise in 2017.</p>
<h4 id="eta">Eta</h4>
<p><a href="https://github.com/typelead/eta">Eta</a> is a Java Virtual Machine Backend for GHC 7.10. The stated goal of the project is to compile the entirety of Haskell to run with full core library and concurrent runtime support. The first release is estimated in January of 2017. The codebase is under active development by Rahul Muttineni and taking contributions.</p>
<p>Most notably the library will first class support for integrating with existing Java libraries through FFI, much like we do with C today.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Java</span>

<span class="kw">data</span> <span class="ot">{-# CLASS &quot;java.util.List&quot; #-}</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">List</span> (<span class="dt">Object</span><span class="fu">#</span> (<span class="dt">List</span> a))
  <span class="kw">deriving</span> <span class="dt">Class</span>

foreign <span class="kw">import </span>java unsafe &quot;@new&quot; newArrayList :: <span class="dt">Java</span> c (<span class="dt">ArrayList</span> a)</code></pre></div>
<h4 id="formal-verification">Formal Verification</h4>
<p>Haskell continues to find use in verification and auditing of cryptography. Although not new developments, both the Galois Cryptol library and Tamarin Prover (both Haskell-based tools) are being used for industrial strength uses in high-assurance work. Haskell continues to have best in class integration with external solvers such as Z3 and CVC4.</p>
<ol style="list-style-type: decimal">
<li><a href="https://tamarin-prover.github.io/">Tamarin</a></li>
<li><a href="https://github.com/GaloisInc/cryptol">Cryptol</a></li>
</ol>
<p>The National Science Foundation is currently funding work out of University of Pennsylvania and MIT to build an entire ecosystem of language tools that have end-to-end correctness proofs called DeepSpec. The <a href="http://www.deepspec.org/research/Haskell/">CoreSpec</a> program aims to develop a formal Coq specification of the GHC Core Language, type system, and semantics.</p>
<p>The Lean theorem prove recently added a complete <a href="https://github.com/leanprover/lean2/blob/master/hott/hott.md">Homotopy Type Theory</a> library with a complete <a href="https://github.com/leanprover/lean2/blob/master/hott/book.md">mapping of the chapters</a> from the textbook.</p>
<h4 id="liquid-haskell">Liquid Haskell</h4>
<p>Refinement types allow us to enrich Haskell’s type system with predicates that precisely describe the sets of valid inputs and outputs of functions These predicates are compiled down into a specific core language which can be discharged to an SMT solver for which there are fast decision procedures for testing the validity of the type.</p>
<p>For example we can construct refinements over a <code>Int</code> variable <code>v</code> .</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">{-@ type Zero    = {v:Int | v == 0} @-}</span>
<span class="co">{-@ type NonZero = {v:Int | v /= 0} @-}</span></code></pre></div>
<p>And constrain our function definitions so that the functions carry around a proof that a non-zero term will not be passed to it.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">{-@ zero :: Zero @-}</span>
zero  <span class="fu">=</span> <span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Int</span>

<span class="co">{-@ one, two, three :: NonZero @-}</span>
one   <span class="fu">=</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>
two   <span class="fu">=</span> <span class="dv">2</span><span class="ot"> ::</span> <span class="dt">Int</span>
three <span class="fu">=</span> <span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Int</span></code></pre></div>
<p>We can combine these predicates to prove non-trivial properties about arithmetic relations, properties about data structures and pointer <a href="https://ucsd-progsys.github.io/liquidhaskell-tutorial/11-case-study-pointers.html#/heartbleeds-in-haskell">memory access</a> to prevent bugs like Heartbleed.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (mod, gcd)

<span class="co">{-@ mod :: a:Nat -&gt; b:{v:Nat| 0 &lt; v} -&gt; {v:Nat | v &lt; b} @-}</span>
mod<span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
mod a b
  <span class="fu">|</span> a <span class="fu">&lt;</span> b <span class="fu">=</span> a
  <span class="fu">|</span> otherwise <span class="fu">=</span> mod (a <span class="fu">-</span> b) b

<span class="co">{-@ gcd :: a:Nat -&gt; b:{v:Nat | v &lt; a} -&gt; Int @-}</span>
gcd<span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
gcd a <span class="dv">0</span> <span class="fu">=</span> a
gcd a b <span class="fu">=</span> gcd b (a <span class="ot">`mod`</span> b)</code></pre></div>
<p>LiquidHaskell has developed a lovely and approachable <a href="https://ucsd-progsys.github.io/liquidhaskell-tutorial/02-logic.html">set of documentation</a> this year, and is now quite usable in production.</p>
<h4 id="linear-types">Linear Types</h4>
<p>Intuitively linear types model finite resources by a notion of <em>consumption</em> of variables in scope. A linear variable needs to be consumed in the same concept it was introduced and can not be “duplicated” or “destroyed”. In a linear λ-calculus we have typing rules in which statements such as “this function will use its argument exactly once” can be checked which can be used to enforce invariants on resource usage such as memory, channels, sockets, tokens, file descriptors, etc.</p>
<p>At the Haskell Exchange and ICFP there was some very early discussion about the possibility of introducing linear types into GHC. The proposed addition would allow weight inference and annotations to variables allowing users to constrain variable usage. The proposal and semantics are being actively discussed on the <a href="https://ghc.haskell.org/trac/ghc/wiki/LinearTypes#Semantics">issue tracker</a>. An implementation likely remains in the far future.</p>
<p>An undergraduate project at Chalmers presented a simple prototype Haskell-like language <a href="https://github.com/m0ar/lollipop">Lollipop</a> using linear typing.</p>
<p>Jeff Polokow presented <a href="http://functorial.com/Embedding-a-Full-Linear-Lambda-Calculus-in-Haskell/linearlam.pdf">a construction</a> by which a full linear lambda calculus can be deeply embedded in the current type system using advanced type features.</p>
<h4 id="backpack">Backpack</h4>
<p>Backpack is Haskell’s partial answer to “module problem”, of having cross-package libraries which are currently duplicated to provide similar interfaces. Backpack will allow libraries which are parametrized by signatures, letting users decide how to instantiate them at a later point in time.</p>
<p>This work is still very early, but Edward Yang gave a insightful talk at NYC <a href="https://www.youtube.com/watch?v=s_geh6SlGuM">Haksell Meetup</a> on the current design decisions taken in the prototype implementation. There is also a thorough description of the applications of Backpack to solve the problem of reusable <a href="http://blog.ezyang.com/2016/09/the-base-of-a-string-theory-for-haskell/">string libraries</a> that work over different underlying string representations.</p>
<p>In the early prototype we can construct an abstract <code>Str</code> signature module which provides a set of types:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">signature <span class="dt">Str</span> <span class="kw">where</span>

  <span class="kw">data</span> <span class="dt">Str</span>
  <span class="kw">data</span> <span class="dt">Elem</span>

  <span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Str</span>
  <span class="kw">instance</span> <span class="dt">Ord</span> <span class="dt">Str</span>
  <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Str</span>
  <span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">Str</span>

<span class="ot">  empty ::</span> <span class="dt">Str</span>
<span class="ot">  length ::</span> <span class="dt">Str</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></code></pre></div>
<p>This is then exposed in the cabal file for the library in the <code>signatures</code> field.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">name<span class="fu">:</span> str<span class="fu">-</span>sig<span class="fu">-</span>major1

library
  signatures<span class="fu">:</span>          <span class="dt">Str</span>
  build<span class="fu">-</span>depends<span class="fu">:</span>       base <span class="fu">&gt;=</span> <span class="fl">4.9</span> <span class="fu">&amp;&amp;</span> <span class="fu">&lt;</span> <span class="fl">4.10</span>,
                       deepseq
  default<span class="fu">-</span>language<span class="fu">:</span>    <span class="dt">Haskell2010</span></code></pre></div>
<p>An implementation of this signature then imports then library, and can then be implement the interface downstream by using a <code>mixin</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">name<span class="fu">:</span> str<span class="fu">-</span>text

library
  mixins<span class="fu">:</span>
    str<span class="fu">-</span>text (<span class="dt">Str.Text</span> as <span class="dt">Str</span>)
  build<span class="fu">-</span>depends<span class="fu">:</span>
    base,
    str<span class="fu">-</span>sig<span class="fu">-</span>major1</code></pre></div>
<p>The concrete implementation of the module would look like the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Str.Text</span> (
  <span class="dt">Str</span>,
  <span class="dt">Elem</span>,
  empty,
  length,
) <span class="kw">where</span>

<span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>

<span class="kw">type</span> <span class="dt">Str</span> <span class="fu">=</span> <span class="dt">T.Text</span>
<span class="kw">type</span> <span class="dt">Elem</span> <span class="fu">=</span> <span class="dt">Char</span>

<span class="ot">empty ::</span> <span class="dt">Str</span>
empty <span class="fu">=</span> T.empty

length<span class="ot"> ::</span> <span class="dt">Str</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
length <span class="fu">=</span> T.empty</code></pre></div>
<p>The work is still early, so this precise form may or may not end up in the final release of Backpack.</p>
<h4 id="databases">Databases</h4>
<p>Earlier this year I commented that compromises in type-safe database libraries consisted of the following traedoffs:</p>
<blockquote>
<p>Haskell SQL libraries: endless boilerplate, opaque metaprogramming, or wall of 15 language exts and no inference. Pick two.</p>
</blockquote>
<p>A lot of industrial Haskell I’ve seen sadsly still uses string interpolation for SQL synthesis, or fall back on libraries that use TemplateHaskell to unsafely lock a specific build to a snapshot of a database at compile-time. Both of these trade-offs are suboptimal and fall short of what we can do in other robust frameworks like SQLAlchemy in Python. There’s three different key points that need to be addressed:</p>
<ol style="list-style-type: decimal">
<li>Definition of a schema tied to a specific databases and migration handling that can done at runtime.</li>
<li>Consistency checking of schema against definitions of SQL statements with type-safety.</li>
<li>Composition and reuse of units of SQL statements and values that preserve type safety under composition.</li>
</ol>
<p>The challenge I continue to pose, that occurs quite frequently in data warehousing and ETL, is given a dynamic (i.e. at runtime) specification of a table in some embedding of DDL: create a table, query it, and dump the results into an existing table of the same schema. Doing this in a safe manor requires a rather complex <a href="http://docs.sqlalchemy.org/en/latest/core/reflection.html">reflection framework</a> by which a table object can load the <code>information_schema</code> and check the constancy of the query before evaluation.</p>
<p>I don’t think the ideal library is quite there yet, but year I was most impressed by Jake Wheat’s very early <a href="https://jakewheat.github.io/hssqlppp/0.6.0"><code>hssqlppp</code></a> which implements a restricted domain language for modeling and typechecking a Postgres SQL subset and generating queries. The full integration with a runtime SQL type-checker is a <a href="https://jakewheat.github.io/hssqlppp/latest/TypeCheckTests.html">lovely piece of work</a> and it would be follow naturally to lift this into a type-safe quasiquoter which would give the ideal solution of unifying both the dynamic and static semantics of SQL program synthesis at runtime and compile-time.</p>
<h4 id="industrial-users">Industrial Users</h4>
<p>Facebook quietly retains and recruits some of the legendary-level Haskell talent. See: <a href="https://simonmar.github.io/posts/2016-12-08-Haskell-in-the-datacentre.html">Haskell in the Datacentre</a></p>
<p>Barclay’s in the UK is also quietly building up an impressive team. See: <a href="https://neilmitchell.blogspot.co.uk/2016/09/full-time-haskell-jobs-in-london-at.html">Full-time Haskell jobs in London, at Barclays</a></p>
<p>JP Morgan funded development on a transaction modeling language <a href="https://github.com/hopper-lang/hopper-v0">Hopper</a>.</p>
<p>Ambiata presented at ICFP this year about a new query language <a href="https://github.com/ambiata/icicle">Icicle</a> for streaming time series, with a <a href="http://conf.researchr.org/event/icfp-2016/fhpc-2016-papers-icicle-write-once-run-once">novel approach to fusion</a> and <a href="https://github.com/ambiata/icicle">released source code</a>.</p>
<p>Awake Networks is building a next generation network security and analytics platform, utilizing using Purescript and Haskell.</p>
<p>Google has been pushing out Haskell bindings to some of their core infastructure, including Tensorflow. See: <a href="https://github.com/tensorflow/haskell">Haskell Tensorflow</a></p>
<p>There’s a fairly large group of Haskellers very quietly working on building smart contract solutions based on functional programming and formal methods. A lot of is happening behind doors at banks but some truly amazing work is being done in this space by singularly talented people. Watch for some amazing future-tech to drop in 2017.</p>
<p>Lots of exciting things going on at Barclay’s, Facebook, Target, Ambiata, Tweag, Takt, Zalora, Galois, JP Morgan, Helium, Silk, Lumi Guide, Awake Networks, FrontRow, Clearmatics, Standard Chartered, Digital Asset Holdings and Microsoft.</p>
<h4 id="stephen">Stephen</h4>
<p>Since last year I’ve been criss-crossing the globe through Germany, London, Paris, San Francisco, Zurich, Portland, New York and Boston doing some mix of advising, consulting, and investments. Late this year, I finally ended up starting a new company, which I’ll speak about publically in the next few months.</p>
<p>I’m especially grateful for the warmth and kindness I felt traveling across European programming scene. I consistently always had a friend in whatever city I visited and it’s been a pleasure meeting many of you. Wish you all Merry Christmas and a Functional New Year!</p>]]></summary>
</entry>
<entry>
    <title>Why Haskellers should be interested in Smart Contracts</title>
    <link href="http://www.stephendiehl.com/posts/smart_contracts.html" />
    <id>http://www.stephendiehl.com/posts/smart_contracts.html</id>
    <published>2016-09-16T00:00:00Z</published>
    <updated>2016-09-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="why-haskellers-should-be-interested-in-smart-contracts">Why Haskellers should be interested in ‘Smart Contracts’</h3>
<p>For most Haskellers the phrase ‘smart contract’ might bring up some vague inclinations of contracts in languages like Racket, but the term is increasingly coming to mean an interesting way of writing and executing stored procedure programs on an immutable distributed database. The technology is very early but is piquing the interesting of people like myself who see an amazing potential of the ideas, but also the peril and human cost of building the technology on top of a set of foundations that lacks rigor and discipline.</p>
<p><strong>Foundations</strong></p>
<p>There are a few definitions of smart contracts, that most applicable here is:</p>
<blockquote>
<p>Smart contracts are executable programs run on top of an immutable distributed database whose inputs and outputs are maintained globally consistent by a distributed consensus protocol.</p>
</blockquote>
<p>In particular I’m not constraining the definition to contracts that run on a <em>blockchain</em> which is a specific minimal implementation of a distributed database which has certain properties that are amenable to creation of so-called cryptocurrencies. Probably the biggest turnoff from looking at this technology is that the community around the technology is populated by particularly vocal cryptoanarchists with fringe views. And while those people do exist, there are also a lot of people like myself who are interested in the technology independent of the currency component, for it’s pure applications in database, programming language theory, and distributed systems.</p>
<p>On the industrial side of the space there are several emerging platforms on which to deploy smart contracts:</p>
<ol style="list-style-type: decimal">
<li>Ethereum</li>
<li>Ripple Codius</li>
<li>Mastercoin</li>
<li>Intel Sawtooth</li>
<li>Hyperledger Fabric</li>
<li>R3 Corda</li>
<li>Raft with Stored Procedures</li>
</ol>
<p>With the exception of Ethereum most of the platforms are not in a usable state and some of which are quite likely vaporware.</p>
<p><strong>Technical Details</strong></p>
<p>The current state of the art, <a href="https://solidity.readthedocs.io/en/develop/introduction-to-smart-contracts.html#overview">Ethereum is a public blockchain</a> that embed a Turing-complete virtual machine that can be scripted in a language known as Solidity.</p>
<p>In PL parlance an Etheruem-flavored smart contract is basically a Smalltalk object that allows message passing through transactions on a blockchain. The code is deployed by it’s owner and then anyone on the network can interact it with it by message passing which may result in data or state changes on the global network. The execution occurs on the ‘miners’ on the network who execute the contract code with the inputs and outputs specified in the transaction and compute a solution to a RAM-hard SHA inversion problem called Ethash which adds the new block to the chain and updates the global state of contract network. Whichever miner solves the problem first gets to append the newly hashed block and the process continues ad-infinitum with the global network converging on consensus.</p>
<p>From a programming language perspective this introduces the non-trivial constraint that programs must necessarily terminate. The current implementation accomplishes this by attaching a cost semantics to each opcode in the virtual machine that expends a finite resource called ‘gas’ that is a function of the current block. In programming language space smart contracts are necessarily <a href="https://en.wikipedia.org/wiki/Total_functional_programming"><strong>total programs</strong></a> meaning they must probably terminating.</p>
<p>Solidity, while being an interesting proof of concept, is dangerously under-contained and very difficult to analyze statically. As a case in point, I gave a talk on this subject to room full of veteran programmers (database and operating system architects) and even after walking through the basic structure of the code none of the them could figure out where the bug in this basic code was.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">contract Coin <span class="op">{</span>
    <span class="at">mapping</span> (address <span class="op">-&gt;</span> uint) balances<span class="op">;</span>
    
    <span class="kw">function</span> <span class="at">Coin</span>() <span class="op">{}</span>

    <span class="kw">function</span>() <span class="op">{</span> 
        balances[<span class="va">msg</span>.<span class="at">sender</span>] <span class="op">+=</span> <span class="va">msg</span>.<span class="at">amount</span><span class="op">;</span>
    <span class="op">}</span>

    <span class="kw">function</span> <span class="at">sendAll</span>(address recipient)<span class="op">{</span>
        <span class="cf">if</span> (balances[<span class="va">msg</span>.<span class="at">sender</span>] <span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">{</span>
            balances[recipient] <span class="op">=</span> balances[<span class="va">msg</span>.<span class="at">sender</span>]<span class="op">;</span>
            balances[<span class="va">msg</span>.<span class="at">sender</span>] <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>
        <span class="op">}</span>
    <span class="op">}</span>

    <span class="kw">function</span> <span class="at">withdraw</span>() <span class="op">{</span>
        uint toSend <span class="op">=</span> balances[<span class="va">msg</span>.<span class="at">sender</span>]<span class="op">;</span>
        bool success <span class="op">=</span> <span class="va">msg</span>.<span class="va">sender</span>.<span class="va">call</span>.<span class="at">value</span>(toSend)()<span class="op">;</span>
        <span class="cf">if</span> (success) 
            balances[<span class="va">msg</span>.<span class="at">sender</span>] <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// Vulnerable to call-stack attack</span>
    <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>The basic structure of this contract is the construction of a token which is pegged to a specific amount of the ambient currency on Ethereum called ‘ether’. The contract allows people to exchange the values, send their balance to another recipient or withdraw their balance back. the <code>function()</code> behaves like Smalltalk’s <code>message-not-understood</code> and handles calls that don’t invoke a method a contract.</p>
<p>The particular problem with this contract is that the <code>send</code> in the withdraw function is particularly dangerous to an exploit when invoked from a malicious contract which repeatedly call into the contract and then implement a default function which calls withdraw repeatedly until the maximum call-stack (1023) of the contract is reached and the balance is never zeroed-out.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">contract Malicious <span class="op">{</span>
    Coin toAttack <span class="op">=</span> <span class="at">Coin</span>(coin_address)<span class="op">;</span>
    bool shouldAttack <span class="op">=</span> <span class="kw">true</span><span class="op">;</span>

    <span class="kw">function</span> <span class="at">Malicious</span>() <span class="op">{</span> 
      <span class="va">toAttack</span>.<span class="va">call</span>.<span class="at">value</span>(<span class="va">msg</span>.<span class="at">amount</span>)()<span class="op">;</span> 
    <span class="op">}</span>


    <span class="kw">function</span>() <span class="op">{</span> 
        <span class="cf">if</span> (shouldAttack <span class="op">&amp;&amp;</span> <span class="va">msg</span>.<span class="at">sender</span> <span class="op">==</span> coin_address) <span class="op">{</span>
            shouldAttack <span class="op">=</span> <span class="kw">false</span><span class="op">;</span>
            <span class="va">toAttack</span>.<span class="at">withdraw</span>()<span class="op">;</span>
        <span class="op">}</span>
    <span class="op">}</span>

    <span class="kw">function</span> <span class="at">attack</span>()<span class="op">{</span> 
      <span class="va">toAttack</span>.<span class="at">withdraw</span>()<span class="op">;</span> 
    <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>This is a subtle bug and really indicates how difficult it is to reason about these kind of contracts are to analyze using current schools of thought.</p>
<p><strong>DAO</strong></p>
<p>I first heard about the DAO contract from the <a href="http://www.nytimes.com/2016/05/22/business/dealbook/crypto-ether-bitcoin-currency.html?_r=0">New York Times</a> from a friend of mine who works in venture who was very excited about the model of <em>distributed autonomous organizations</em> and automated venture pools . The article outlined all of the systemic and social structural problems and casually made the somewhat prescient remark “Young, complex machines tend to have flaws and vulnerabilities that you can’t anticipate”. Two weeks later the same class of bug as the above code was exploited and the contract was compromised in one of the more spectacular failures around this new technology. Of note is that underlying protocol behaved exactly as specified, and the bug was simply a fact of the contract language not <em>making invalid states unrepresentable</em> and making it too hard to reason about.</p>
<p>At the heart of this statement is getting at the deeper problem of “How we do we know what the code will do before we run it”. The answer to this question is obvious to most of us who have read the literature of programming language semantics and it’s associated theories of verification, but this still remains a fairly niche domain in CS education and we’re seeing the manifestation of that in projects like Solidity which are making the same mistakes of the past instead of standing on the shoulders of work that is already done.</p>
<p>If anything, the precedent after the DAO-hack is that software verification is no longer purely in the realm of academics and hobbyists and the latest work in dependent type theory, model checkers, and types has suddenly found immediate relevance that needs no further explanation other than to prevent these kind of catastrophic failures from happening again. More importantly in the Haskell ecosystem we have an abundance of riches with regards to tools for software verification from tools like QuickCheck, SBV, and best in class support for compile design and domain language implementation.</p>
<p><strong>Future</strong></p>
<p>It’s an exciting new emerging field and more interesting for us, the ideas and technology is precisely at the intersection of Haskell’s strengths and would drastically benefit from the enthusiasm and expertise of people who are willing to dabble in the more formal side of programming. The maturation of technology is likely to occur in 2017 but the foundations are being laid this year. The technology is a bit early, but hopefully some of the light are going off in your head when you consider the exciting new applications of programmable distributed ledgers endowed with the strengths of modern tools like Haskell.</p>]]></summary>
</entry>
<entry>
    <title>Dive into GHC: Targeting Core</title>
    <link href="http://www.stephendiehl.com/posts/ghc_03.html" />
    <id>http://www.stephendiehl.com/posts/ghc_03.html</id>
    <published>2016-07-12T00:00:00Z</published>
    <updated>2016-07-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="dive-into-ghc-targeting-core">Dive into GHC: Targeting Core</h3>
<p>In the <a href="http://www.stephendiehl.com/posts/ghc_01.html">last blog post</a>, we discussed the intermediate structures used in the GHC compiler. This time let’s discuss the Core language.</p>
<p style="text-align:center">
<strong><a href="https://github.com/sdiehl/dive-into-ghc/tree/master/03-core">Accompaying Source Code</a></strong>
</p>
<h4 id="core">Core</h4>
<p>GHC’s most central data types. Core is a very small, explicitly-typed, variant of System FC; a typed lambda calculus that differs from the simply typed lambda calculus by the introduction of a mechanism of universal quantification over types denoted as capital lambda <span class="math inline">\(\Lambda\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- System-F Notation</span>
Λ b c a<span class="fu">.</span> λ (f1 <span class="fu">:</span> b <span class="ot">-&gt;</span> c) (g <span class="fu">:</span> a <span class="ot">-&gt;</span> b) (x1 <span class="fu">:</span> a)<span class="fu">.</span> f1 (g x1)

<span class="co">-- Haskell Core</span>
\ (<span class="fu">@</span> b) (<span class="fu">@</span> c) (<span class="fu">@</span> a) (<span class="ot">f1 ::</span> b <span class="ot">-&gt;</span> c) (<span class="ot">g ::</span> a <span class="ot">-&gt;</span> b) (<span class="ot">x1 ::</span> a) <span class="ot">-&gt;</span> f1 (g x1)</code></pre></div>
<p>While the Haskell frontend is an implicitly-typed source language, Core is an explicitly-typed language. Every binder has an explicit type, and terms include explicit type abstractions and applications.</p>
<p>To inspect the core from GHCi we can invoke it using the following flags and the following shell alias. We have explicitly disable the printing of certain metadata and longform names to make the representation easier to read.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">alias</span> ghci-core=<span class="st">&quot;ghci -ddump-simpl -dsuppress-idinfo \</span>
<span class="st">-dsuppress-coercions -dsuppress-type-applications \</span>
<span class="st">-dsuppress-uniques -dsuppress-module-prefixes&quot;</span></code></pre></div>
<p>At the interactive prompt we can then explore the core representation interactively:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">ghci-core</span></code></pre></div>
<p>Then for example we can type in normal expressions and see their translation into Core.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">λ: <span class="kw">let</span> f x = x + 2 <span class="kw">;</span> <span class="kw">f</span> :: Int -<span class="kw">&gt;</span> Int

==================== <span class="kw">Simplified</span> expression ====================
<span class="kw">returnIO</span>
  <span class="kw">(:</span> ((<span class="dt">\ </span>(x :: Int<span class="kw">)</span> <span class="kw">-&gt;</span> + <span class="ot">$fNumInt</span> x (I# 2)) <span class="kw">`cast`</span> <span class="kw">...</span>) <span class="kw">(</span>[]<span class="kw">)</span>)

λ: <span class="kw">let</span> f x = (x, x)

==================== <span class="kw">Simplified</span> expression ====================
<span class="kw">returnIO</span> (: ((<span class="dt">\ </span>(@ t) <span class="kw">(x</span> :: t<span class="kw">)</span> <span class="kw">-&gt;</span> (x, x)) <span class="kw">`cast`</span> <span class="kw">...</span>) <span class="kw">(</span>[]<span class="kw">)</span>)</code></pre></div>
<h4 id="core-syntax">Core Syntax</h4>
<p>Core is defined in the <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/ghc-7.10.3/CoreSyn.html">CoreSyn</a> module. The central datatype is <code>Expr</code> which holds the 10 core datatypes that all Haskell expressions can be condensed down into.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr</span> b
  <span class="fu">=</span> <span class="dt">Var</span>	  <span class="dt">Id</span>
  <span class="fu">|</span> <span class="dt">Lit</span>   <span class="dt">Literal</span>
  <span class="fu">|</span> <span class="dt">App</span>   (<span class="dt">Expr</span> b) (<span class="dt">Arg</span> b)
  <span class="fu">|</span> <span class="dt">Lam</span>   b (<span class="dt">Expr</span> b)
  <span class="fu">|</span> <span class="dt">Let</span>   (<span class="dt">Bind</span> b) (<span class="dt">Expr</span> b)
  <span class="fu">|</span> <span class="dt">Case</span>  (<span class="dt">Expr</span> b) b <span class="dt">Type</span> [<span class="dt">Alt</span> b]
  <span class="fu">|</span> <span class="dt">Cast</span>  (<span class="dt">Expr</span> b) <span class="dt">Coercion</span>
  <span class="fu">|</span> <span class="dt">Tick</span>  (<span class="dt">Tickish</span> <span class="dt">Id</span>) (<span class="dt">Expr</span> b)
  <span class="fu">|</span> <span class="dt">Type</span>  <span class="dt">Type</span>
  <span class="fu">|</span> <span class="dt">Coercion</span> <span class="dt">Coercion</span>	</code></pre></div>
<p>The pattern match logic for Core is broken down into several datatypes which discriminate on at most one branch of a constructor. The process of translating frontend case statements into Core case statements involves the process of expanding pattern matches out into their a “splitting tree” of cases. The case for the wild card pattern match is <code>(DEFAULT, [], rhs)</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Arg</span> b <span class="fu">=</span> <span class="dt">Expr</span> b

<span class="kw">type</span> <span class="dt">Alt</span> b <span class="fu">=</span> (<span class="dt">AltCon</span>, [b], <span class="dt">Expr</span> b)

<span class="kw">data</span> <span class="dt">AltCon</span> 
  <span class="fu">=</span> <span class="dt">DataAlt</span> <span class="dt">DataCon</span>
  <span class="fu">|</span> <span class="dt">LitAlt</span>  <span class="dt">Literal</span>
  <span class="fu">|</span> <span class="dt">DEFAULT</span></code></pre></div>
<p>Notably on all the types there is a parameter <code>b</code> is the type of binders. The binder type is a sum type containing a recursive binder and a non-recursive binder. Bindings that are mutually recursive are encoded as a list of binders.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Bind</span> b 
  <span class="fu">=</span> <span class="dt">NonRec</span> b (<span class="dt">Expr</span> b)
  <span class="fu">|</span> <span class="dt">Rec</span> [(b, (<span class="dt">Expr</span> b))]</code></pre></div>
<p>For example the factorial function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fac ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
fac a <span class="dv">0</span> <span class="fu">=</span> a
fac a n <span class="fu">=</span> fac (n<span class="fu">*</span>a) (n<span class="fu">-</span><span class="dv">1</span>)</code></pre></div>
<p>… is expanded out into it’s core binders is enclosed in a recursive binding.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Rec</span> {
<span class="ot">fac ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
fac <span class="fu">=</span>
  \ (<span class="ot">a ::</span> <span class="dt">Int</span>) (<span class="ot">ds ::</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span>
    <span class="kw">case</span> ds <span class="kw">of</span> wild { <span class="dt">I</span><span class="fu">#</span> ds1 <span class="ot">-&gt;</span>
    <span class="kw">case</span> ds1 <span class="kw">of</span> _ {
      __<span class="dt">DEFAULT</span> <span class="ot">-&gt;</span>
        fac (<span class="fu">*</span> <span class="fu">@</span> <span class="dt">Int</span> <span class="fu">$</span>fNumInt wild a) (<span class="fu">-</span> <span class="fu">@</span> <span class="dt">Int</span> <span class="fu">$</span>fNumInt wild (<span class="dt">I</span><span class="fu">#</span> <span class="dv">1</span>));
      <span class="dv">0</span> <span class="ot">-&gt;</span> a
    }
    }
end <span class="dt">Rec</span> }</code></pre></div>
<p>There are several type synonyms provided by the <code>CoreSyn</code> module that expand out the binder parameter into a convenient synonym.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TyVar</span> <span class="fu">=</span> <span class="dt">Var</span>
<span class="kw">type</span> <span class="dt">CoreExpr</span> <span class="fu">=</span> <span class="dt">Expr</span> <span class="dt">Var</span>
<span class="kw">type</span> <span class="dt">CoreBndr</span> <span class="fu">=</span> <span class="dt">Var</span>
<span class="kw">type</span> <span class="dt">CoreBind</span> <span class="fu">=</span> <span class="dt">Bind</span> <span class="dt">CoreBndr</span>
<span class="kw">type</span> <span class="dt">CoreProgram</span> <span class="fu">=</span> [<span class="dt">CoreBind</span>]</code></pre></div>
<p>As an aside the notation used in papers on the typing judgements for Haskell syntax typically uses the following convention and has a one-to-one mapping to each of the Haskell datatypes in <code>Expr</code>.</p>
<p><span class="math display">\[
\begin{aligned}
e ::= \ &amp; n                                              &amp; \mathtt{Var}      &amp;\quad \text{Variable} \\
    |\ &amp; \mathtt{lit}                                   &amp; \mathtt{Lam}      &amp;\quad \text{Literal} \\
    |\ &amp; e_1 \ e_2                                      &amp; \mathtt{App}      &amp;\quad \text{Application} \\
    |\ &amp; \lambda n . e                                  &amp; \mathtt{Lam}      &amp;\quad \text{Abstraction} \\
    |\ &amp; \textbf{let}\ \mathit{binding}\ \textbf{in}\ e &amp; \mathtt{Let}      &amp;\quad \text{Variable binding} \\
    |\ &amp; \textbf{case}\ e\ \textbf{as}\ n\ \textbf{return}\ \tau\ \textbf{of}\ \overline{alt} &amp; \mathtt{Case}     &amp;\quad \text{Pattern match} \\
    |\ &amp; e \triangleright \gamma                        &amp; \mathtt{Cast}     &amp;\quad \text{Cast} \\
    |\ &amp; e_{\lbrace \textit{tick} \rbrace }             &amp; \mathtt{Tick}     &amp;\quad \text{Internal note} \\
    |\ &amp; \tau                                           &amp; \mathtt{Type}     &amp;\quad \text{Type} \\
    |\ &amp; \gamma                                         &amp; \mathtt{Coercion} &amp;\quad \text{Coercion} \\
\end{aligned}
\]</span></p>
<h4 id="var">Var</h4>
<p>The <code>Var</code> type is central to most of the core definitions, it is the primary name type used in the later half of the compiler and contains is a synonym for the <code>Id</code> type but it may additionally potentially contain type variables,</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Var</span>
  <span class="co">-- Type and kind variables</span>
  <span class="fu">=</span> <span class="dt">TyVar</span> 
    {<span class="ot"> varName       ::</span> <span class="dt">Name</span>
    ,<span class="ot"> realUnique    ::</span> <span class="dt">FastInt</span>
    ,<span class="ot"> varType       ::</span> <span class="dt">Kind</span>
    }

  <span class="co">-- Internal type variables used by inference algorithm</span>
  <span class="fu">|</span> <span class="dt">TcTyVar</span> 
    {<span class="ot"> varName       ::</span> <span class="dt">Name</span>
    ,<span class="ot"> realUnique    ::</span> <span class="dt">FastInt</span>
    ,<span class="ot"> varType       ::</span> <span class="dt">Kind</span>
    ,<span class="ot"> tc_tv_details ::</span> <span class="dt">TcTyVarDetails</span>
    }

  <span class="co">-- Value level identifiers</span>
  <span class="fu">|</span> <span class="dt">Id</span> 
    {<span class="ot"> varName       ::</span> <span class="fu">!</span><span class="dt">Name</span>
    ,<span class="ot"> realUnique    ::</span> <span class="dt">FastInt</span>
    ,<span class="ot"> varType       ::</span> <span class="dt">Type</span>
    ,<span class="ot"> idScope       ::</span> <span class="dt">IdScope</span>
    ,<span class="ot"> id_details    ::</span> <span class="dt">IdDetails</span>
    ,<span class="ot"> id_info       ::</span> <span class="dt">IdInfo</span>
    }</code></pre></div>
<p>The fields for Var also contain and important type which indicates the provenance of the identifier. A <code>LocalId</code> is bound within an expression such as a lambda, case, or let binding. A <code>GlobalId</code> is either a top-level expression or a imported data constructor, class, etc.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">IdScope</span>
  <span class="fu">=</span> <span class="dt">GlobalId</span>
  <span class="fu">|</span> <span class="dt">LocalId</span> <span class="dt">ExportFlag</span></code></pre></div>
<p>In addition to the scope there are two metadata records that give additional information about the usage and type of the identifier. These are the <code>IdInfo</code> and <code>IdDetails</code>. The <code>IdDetails</code> primary contains information about why the variable is introduced while <code>IdInfo</code> contains metadata about optimizations that may be applied during the core to core passes.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">IdDetails</span>
  <span class="fu">=</span> <span class="dt">VanillaId</span>
  <span class="fu">|</span> <span class="dt">RecSelId</span> {<span class="ot">sel_tycon ::</span> <span class="dt">TyCon</span>,<span class="ot"> sel_naughty ::</span> <span class="dt">Bool</span>}
  <span class="fu">|</span> <span class="dt">DataConWorkId</span> <span class="dt">DataCon.DataCon</span>
  <span class="fu">|</span> <span class="dt">DataConWrapId</span> <span class="dt">DataCon.DataCon</span>
  <span class="fu">|</span> <span class="dt">ClassOpId</span> <span class="dt">Class.Class</span>
  <span class="fu">|</span> <span class="dt">PrimOpId</span> <span class="dt">PrimOp.PrimOp</span>
  <span class="fu">|</span> <span class="dt">FCallId</span> <span class="dt">ForeignCall.ForeignCall</span>
  <span class="fu">|</span> <span class="dt">TickBoxOpId</span> <span class="dt">TickBoxOp</span>
  <span class="fu">|</span> <span class="dt">DFunId</span> <span class="dt">Int</span> <span class="dt">Bool</span></code></pre></div>
<p>The structure of <code>IdInfo</code> is a set flags.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">IdInfo</span> <span class="fu">=</span> <span class="dt">IdInfo</span> 
  {<span class="ot"> arityInfo       ::</span> <span class="dt">ArityInfo</span>
  ,<span class="ot"> specInfo        ::</span> <span class="dt">SpecInfo</span>
  ,<span class="ot"> unfoldingInfo   ::</span> <span class="dt">Unfolding</span>
  ,<span class="ot"> cafInfo         ::</span> <span class="dt">CafInfo</span>
  ,<span class="ot"> oneShotInfo     ::</span> <span class="dt">OneShotInfo</span>
  ,<span class="ot"> inlinePragInfo  ::</span> <span class="dt">InlinePragma</span>
  ,<span class="ot"> occInfo         ::</span> <span class="dt">OccInfo</span>
  ,<span class="ot"> strictnessInfo  ::</span> <span class="dt">StrictSig</span>
  ,<span class="ot"> demandInfo      ::</span> <span class="dt">Demand</span>
  ,<span class="ot"> callArityInfo   ::</span> <span class="fu">!</span><span class="dt">ArityInfo</span>
  }</code></pre></div>
<p>For the identifiers we’ll construct we’ll simply use the vanilla flavor of id as they are simply from lambda expressions and toplevel functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">vanillaIdInfo ::</span> <span class="dt">IdInfo</span>
vanillaIdInfo <span class="fu">=</span> <span class="dt">IdInfo</span> 
  { cafInfo           <span class="fu">=</span> vanillaCafInfo,
  , arityInfo         <span class="fu">=</span> unknownArity,
  , specInfo          <span class="fu">=</span> emptySpecInfo,
  , unfoldingInfo     <span class="fu">=</span> noUnfolding,
  , oneShotInfo       <span class="fu">=</span> <span class="dt">NoOneShotInfo</span>,
  , inlinePragInfo    <span class="fu">=</span> defaultInlinePragma,
  , occInfo           <span class="fu">=</span> <span class="dt">NoOccInfo</span>,
  , demandInfo        <span class="fu">=</span> topDmd,
  , strictnessInfo    <span class="fu">=</span> nopSig,
  , callArityInfo     <span class="fu">=</span> unknownArity
  }</code></pre></div>
<p>A name combined with this metadata and a type uniquely constructs and Id/Var and there are several helper functions that combine them together.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkTyVar ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Kind</span> <span class="ot">-&gt;</span> <span class="dt">TyVar</span>
<span class="ot">mkLocalVar ::</span> <span class="dt">IdDetails</span> <span class="ot">-&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">IdInfo</span> <span class="ot">-&gt;</span> <span class="dt">Id</span>
<span class="ot">mkGlobalVar ::</span> <span class="dt">IdDetails</span> <span class="ot">-&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">IdInfo</span> <span class="ot">-&gt;</span> <span class="dt">Id</span></code></pre></div>
<h4 id="example">Example</h4>
<p>Consider the following incredibly simple module:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Example</span> (f) <span class="kw">where</span>

<span class="ot">f ::</span> a <span class="ot">-&gt;</span> a
f x <span class="fu">=</span> x</code></pre></div>
<p>Let’s recreate it using Core constructions, as the functions we mentioned above. We’ll simulate the unique supply in a contrived way using <code>mkUnique</code>, in practice one shouldn’t actually do this and instead simply initialize the supply inside of IO.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkName ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Name</span>
mkName i n <span class="fu">=</span> mkInternalName (mkUnique <span class="ch">&#39;n&#39;</span> i) (mkOccName OccName.varName n) noSrcSpan

<span class="ot">xn ::</span> <span class="dt">Name</span>
xn <span class="fu">=</span> mkName <span class="dv">0</span> <span class="st">&quot;x&quot;</span>

<span class="ot">an ::</span> <span class="dt">Name</span>
an <span class="fu">=</span> mkName <span class="dv">1</span> <span class="st">&quot;a&quot;</span>

<span class="ot">fn ::</span> <span class="dt">Name</span>
fn <span class="fu">=</span> mkExternalName (mkUnique <span class="ch">&#39;n&#39;</span> <span class="dv">2</span>) modl (mkOccName OccName.varName <span class="st">&quot;f&quot;</span>) noSrcSpan

<span class="co">-- a :: *</span>
<span class="ot">a ::</span> <span class="dt">TyVar</span>
a <span class="fu">=</span> mkTyVar an anyKind

<span class="co">-- x :: a</span>
<span class="ot">x ::</span> <span class="dt">Var</span>
x <span class="fu">=</span> mkLocalVar <span class="dt">VanillaId</span> xn (<span class="dt">TyVarTy</span> a) vanillaIdInfo

<span class="co">-- f :: a -&gt; a</span>
<span class="ot">fv ::</span> <span class="dt">Var</span>
fv <span class="fu">=</span> mkGlobalVar <span class="dt">VanillaId</span> fn (<span class="dt">FunTy</span> (<span class="dt">TyVarTy</span> a) (<span class="dt">TyVarTy</span> a)) vanillaIdInfo

<span class="ot">def ::</span> [<span class="dt">Syn.CoreBind</span>]
def <span class="fu">=</span> [<span class="dt">Syn.NonRec</span> fv f]

<span class="ot">f ::</span> <span class="dt">Syn.Expr</span> <span class="dt">Var</span>
f <span class="fu">=</span> <span class="dt">Syn.Lam</span> x (<span class="dt">Syn.Var</span> x)

<span class="ot">modl ::</span> <span class="dt">Module</span>
modl <span class="fu">=</span> mkModule mainPackageKey (mkModuleName <span class="st">&quot;Example&quot;</span>)</code></pre></div>
<p>So now we have a synthetic Core module that we can package up into a <code>ModGuts</code> and <code>ModSummary</code> just like what we’d get from the top half of the compiler after Typechecking. For most of these fields we simply initialize them with default dummy values.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">guts ::</span> <span class="dt">ModGuts</span>
guts <span class="fu">=</span> <span class="dt">ModGuts</span>
  {
      mg_module          <span class="fu">=</span> modl,
      mg_exports         <span class="fu">=</span> [<span class="dt">Avail</span> fn],
      mg_deps            <span class="fu">=</span> noDependencies,
      mg_dir_imps        <span class="fu">=</span> emptyModuleEnv,
      mg_used_names      <span class="fu">=</span> mkNameSet [fn],
      mg_used_th         <span class="fu">=</span> <span class="dt">False</span>,
      mg_rdr_env         <span class="fu">=</span> emptyGlobalRdrEnv,
      mg_fix_env         <span class="fu">=</span> emptyFixityEnv,
      mg_tcs             <span class="fu">=</span> [],
      mg_insts           <span class="fu">=</span> [],
      mg_fam_insts       <span class="fu">=</span> [],
      mg_patsyns         <span class="fu">=</span> [],
      mg_rules           <span class="fu">=</span> [],
      mg_binds           <span class="fu">=</span> def,                  <span class="co">-- our binding</span>
      mg_foreign         <span class="fu">=</span> <span class="dt">NoStubs</span>,
      mg_warns           <span class="fu">=</span> <span class="dt">NoWarnings</span>,
      mg_hpc_info        <span class="fu">=</span> <span class="dt">NoHpcInfo</span> <span class="dt">False</span>,
      mg_modBreaks       <span class="fu">=</span> emptyModBreaks,
      mg_vect_decls      <span class="fu">=</span> [],
      mg_vect_info       <span class="fu">=</span> noVectInfo,
      mg_boot            <span class="fu">=</span> <span class="dt">False</span>,
      mg_anns            <span class="fu">=</span> [],
      mg_inst_env        <span class="fu">=</span> emptyInstEnv,
      mg_fam_inst_env    <span class="fu">=</span> emptyFamInstEnv,
      mg_safe_haskell    <span class="fu">=</span> <span class="dt">Sf_None</span>,
      mg_trust_pkg       <span class="fu">=</span> <span class="dt">False</span>,
      mg_dependent_files <span class="fu">=</span> []
  }</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">summ ::</span> <span class="dt">DynFlags</span> <span class="ot">-&gt;</span> <span class="dt">ModSummary</span>
summ dflags <span class="fu">=</span> <span class="dt">ModSummary</span> 
  {
      ms_mod          <span class="fu">=</span> modl,
      ms_hsc_src      <span class="fu">=</span> <span class="dt">HsSrcFile</span>,
      ms_location     <span class="fu">=</span> <span class="dt">ModLocation</span> {
          ml_hs_file  <span class="fu">=</span> <span class="dt">Nothing</span>
      ,   ml_hi_file  <span class="fu">=</span> <span class="st">&quot;Example.hi&quot;</span>
      ,   ml_obj_file <span class="fu">=</span> <span class="st">&quot;Example.o&quot;</span>
      },
      ms_hs_date      <span class="fu">=</span> <span class="dt">UTCTime</span> (toEnum <span class="dv">0</span>) <span class="dv">0</span>,
      ms_obj_date     <span class="fu">=</span> <span class="dt">Nothing</span>,
      ms_iface_date   <span class="fu">=</span> <span class="dt">Nothing</span>,
      ms_srcimps      <span class="fu">=</span> [],
      ms_textual_imps <span class="fu">=</span> [],
      ms_hspp_file    <span class="fu">=</span> <span class="st">&quot;Example.hs&quot;</span>,
      ms_hspp_opts    <span class="fu">=</span> dflags,
      ms_hspp_buf     <span class="fu">=</span> <span class="dt">Nothing</span>
  }</code></pre></div>
<h4 id="code-generation">Code Generation</h4>
<p>So now that we have our synthetic core module we can run the normal compiler pipeline on it and compile it just like we would with source code. The transformation of Core to native code goes through several processes:</p>
<ol style="list-style-type: decimal">
<li><a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/ghc-7.10.3/CorePrep.html">CorePrep</a></li>
<li><a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/ghc-7.10.3/CoreToStg.html">CoreToStg</a></li>
<li><a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/ghc-7.10.3/CoreLint.html">Core Linting (Optional)</a></li>
<li><a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/ghc-7.10.3/SimplStg.html">Stg2Stg</a></li>
<li><a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/ghc-7.10.3/AsmCodeGen.html">Code Generation</a></li>
</ol>
<p>The main pass is called the Simplifier, which maps Core to Core. It’s job it is to perform a large collection of correctness-preserving transformations, with the goal of producing a more efficient program.</p>
<ol style="list-style-type: decimal">
<li>Constant folding</li>
<li>Applying the rewrite rules</li>
<li>Inlining</li>
<li>Case of case optimization</li>
<li>Case of known constructor optimization</li>
<li>Eta expansion and Eta reduction</li>
</ol>
<p>In addition to optimization GHC contains a pass called the Core Linter which does a variety of internal consistency checks on a given Core program. Since Core is explicitly typed, typechecking a given program is trivial as we simply check that the type of identifiers matches with their bindings and that the types are internally consistent. The Core linter is extremely useful if you’re writing optimization passes that transform Core or are targeting it from another language (other than vanilla Haskell). The linter pass can prevent a whole slew of bugs before they manifest as code generation errors.</p>
<p>So now we’ll run the rest of the compiler pipeline and generate assembly code from our module. There’s a bit of song and dance in converting between types but the process is basically just connecting the inputs and outputs of the above passes together.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> runGhc (<span class="dt">Just</span> libdir) <span class="fu">$</span> <span class="kw">do</span>
  dflags <span class="ot">&lt;-</span> getSessionDynFlags

  setSessionDynFlags <span class="fu">$</span> dflags { hscTarget <span class="fu">=</span> <span class="dt">HscAsm</span>, ghcLink <span class="fu">=</span> <span class="dt">LinkBinary</span> }

  dflags <span class="ot">&lt;-</span> getSessionDynFlags
  env <span class="ot">&lt;-</span> getSession

  setTargets [<span class="dt">Target</span> 
    { targetId <span class="fu">=</span> <span class="dt">TargetModule</span> (mkModuleName <span class="st">&quot;Example&quot;</span>)
    , targetAllowObjCode <span class="fu">=</span> <span class="dt">True</span>
    , targetContents <span class="fu">=</span> <span class="dt">Nothing</span> }]

  <span class="co">-- repares for code generation.</span>
  prep <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> corePrepPgm env (ms_location (summ dflags)) (mg_binds guts) (mg_tcs guts)

  <span class="co">-- Transform Core into STG</span>
  stg <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> coreToStg dflags (mg_module guts) prep

  <span class="co">-- STG Transformer</span>
  (stg_binds2, cost_centre_info) <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> stg2stg dflags (mg_module guts) stg

  <span class="co">-- Generated Cmm</span>
  <span class="kw">let</span> cmms <span class="fu">=</span> codeGen dflags (mg_module guts) (mg_tcs guts) cost_centre_info stg_binds2 (mg_hpc_info guts)

  <span class="co">-- Initialize a name supply for the Cmm pipeline</span>
  us <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> mkSplitUniqSupply <span class="ch">&#39;S&#39;</span>
  <span class="kw">let</span> initTopSRT <span class="fu">=</span> initUs_ us emptySRT
      run_pipeline <span class="fu">=</span> cmmPipeline env

  <span class="co">-- Collect the Cmm code stream after running the pipeline.</span>
  <span class="kw">let</span> cmmstream <span class="fu">=</span> <span class="kw">do</span>
       a <span class="ot">&lt;-</span> Stream.mapAccumL run_pipeline initTopSRT cmms
       Stream.yield (srtToData a)

  <span class="co">-- Prepare the Cmm for </span>
  genraw <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> cmmToRawCmm dflags cmmstream

  <span class="co">-- Initialize name supply for the native code generator and generate x86 to a</span>
  <span class="co">-- file from the prepared Cmm.</span>
  ncg_uniqs <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> mkSplitUniqSupply <span class="ch">&#39;n&#39;</span>
  fname <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> (openFile <span class="st">&quot;Example.asm&quot;</span> <span class="dt">WriteMode</span>)
  liftIO <span class="fu">$</span> nativeCodeGen dflags (mg_module guts) modloc fname ncg_uniqs genraw

  <span class="co">-- Dump the outputted Stg and  Cmm out</span>
  gen <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> Stream.collect cmmstream
  liftIO <span class="fu">$</span> putStrLn <span class="st">&quot;=== STG ===&quot;</span>
  liftIO <span class="fu">$</span> putStrLn <span class="fu">$</span> showGhc stg_binds2

  liftIO <span class="fu">$</span> putStrLn <span class="st">&quot;=== CMM ===&quot;</span>
  liftIO <span class="fu">$</span> putStrLn <span class="fu">$</span> showGhc gen</code></pre></div>
<p>And then we get a <code>Example.asm</code> file outputted from our synthetic core module. A next step project would be to target a more complicated language to GHC Core to take advantage of it’s compiler optimizations and native code generation.</p>]]></summary>
</entry>
<entry>
    <title>Dive into GHC: Intermediate Forms</title>
    <link href="http://www.stephendiehl.com/posts/ghc_02.html" />
    <id>http://www.stephendiehl.com/posts/ghc_02.html</id>
    <published>2016-07-11T00:00:00Z</published>
    <updated>2016-07-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="dive-into-ghc-intermediate-forms">Dive into GHC: Intermediate Forms</h3>
<p>In the <a href="http://www.stephendiehl.com/posts/ghc_01.html">last blog post</a>, we discussed the high-level API used inside the GHC compiler. This time let’s zoom into the pieces that comprise the frontend of the compilation pipeline, namely:</p>
<ol style="list-style-type: decimal">
<li><strong>Parsing</strong></li>
<li><strong>Renaming</strong></li>
<li><strong>Typechecking</strong></li>
<li><strong>Desugaring</strong></li>
<li><strong>Simplification</strong></li>
<li>Code Generation</li>
</ol>
<p style="text-align:center">
<strong><a href="https://github.com/sdiehl/dive-into-ghc/tree/master/02-parser">Accompaying Source Code</a></strong>
</p>
<h4 id="passes">Passes</h4>
<p>The following functions are the main passes are that are used inside of the compiler driver functions in <code>HscMain</code> .</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Parse a module.</span>
<span class="ot">parseModule ::</span> <span class="dt">GhcMonad</span> m <span class="ot">=&gt;</span> <span class="dt">ModSummary</span> <span class="ot">-&gt;</span> m <span class="dt">ParsedModule</span>

<span class="co">-- Typecheck and rename a parsed module.</span>
<span class="ot">typecheckModule ::</span> <span class="dt">GhcMonad</span> m <span class="ot">=&gt;</span> <span class="dt">ParsedModule</span> <span class="ot">-&gt;</span> m <span class="dt">TypecheckedModule</span>

<span class="co">-- Desugar a typechecked module.</span>
<span class="ot">desugarModule ::</span> <span class="dt">GhcMonad</span> m <span class="ot">=&gt;</span> <span class="dt">TypecheckedModule</span> <span class="ot">-&gt;</span> m <span class="dt">DesugaredModule</span>

<span class="co">-- Extract ModGuts</span>
<span class="ot">coreModule ::</span> <span class="dt">DesugaredMod</span> m <span class="ot">=&gt;</span> m <span class="ot">-&gt;</span> <span class="dt">ModGuts</span>

<span class="co">-- Generated STG bindings from Core module</span>
<span class="ot">coreToStg ::</span> <span class="dt">DynFlags</span> <span class="ot">-&gt;</span> <span class="dt">Module</span> <span class="ot">-&gt;</span> <span class="dt">CoreProgram</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">StgBinding</span>]</code></pre></div>
<p>Each of the these functions manipulates an <em>intermediate form</em> used in the process of compiling a Haskell module into a form that can be compiled into machine code or interpreted.</p>
<h4 id="parser">Parser</h4>
<p>The frontend syntax for Haskell is fairly large and is partially defined in the <a href="https://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17500010">Haskell 2010 specification</a> and extended by GHC. The parser is written using two custom tools:</p>
<ol style="list-style-type: decimal">
<li><em>Alex</em>, for lexical analysis. See: <a href="https://github.com/ghc/ghc/blob/master/compiler/parser/Lexer.x">Lexer.x</a></li>
<li><em>Happy</em>, for the parser itself. See: <a href="https://github.com/ghc/ghc/blob/master/compiler/parser/Parser.y">Parser.y</a></li>
</ol>
<p>Happy is a parser generator system for Haskell, similar to the tool `yacc’ for C. It works as a preprocessor with it’s own syntax that generates a parse table from two specifications, a lexer file and parser file. The Happy parser consists of a list of a production rules and a monad to running the parser in. Production rules consist of a set of options on the left and generating Haskell expressions on the right with indexed variables (<code>$1</code>, <code>$2</code>, …) mapping to the ordered terms on the left (i.e. in the second term <code>term</code> ~ <code>$1</code>, <code>term</code> ~ <code>$2</code>).</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl">terms
    : term                   { [<span class="dt">$1</span>] }
    | term terms             { <span class="dt">$1</span> : <span class="dt">$2</span> }</code></pre></div>
<p>The most complicated part of the lexer is with regards to whitespace-sensitive layout. To handle whitespace the lexer will analyze the line position of certain productions and will output <em>virtual tokens</em> (vbrace, vsemi, etc) which are used to canonicalize the syntax. For example the use of layout rule in do-notation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
  putStrLn <span class="st">&quot;Hello&quot;</span>
  putStrLn <span class="st">&quot;Haskell&quot;</span></code></pre></div>
<p>Is converted into explicit virtual braces and semicolons at parse time.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span> { putStrLn <span class="st">&quot;Hello&quot;</span>; putStrLn <span class="st">&quot;Haskell&quot;</span> }</code></pre></div>
<p>The main entry points are defined in the <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/ghc-7.10.3/Parser.html">Parser</a> and resolve into a monad <code>P</code> which holds state about the source buffer, and filename and location. The resulting AST is called HsSyn and contains position information preserved from the tokens.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseType ::</span> <span class="dt">P</span> (<span class="dt">LHsType</span> <span class="dt">RdrName</span>)
<span class="ot">parseExpression ::</span> <span class="dt">P</span> (<span class="dt">LHsExpr</span> <span class="dt">RdrName</span>)
<span class="ot">parseModule ::</span> <span class="dt">P</span> (<span class="dt">Located</span> (<span class="dt">HsModule</span> <span class="dt">RdrName</span>))</code></pre></div>
<h4 id="located">Located</h4>
<p>Frontend syntax in GHC carries position information along with it that can be used in error reporting. Location information is defined by a <code>Located</code> type which has a single type paramater for the AST element to be “located”. Typically type synonyms follow the convention that a “L” before the type indicates a synonym for a located element. So a located <code>HsExpr</code> is a <code>LHsExxpr</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">GenLocated</span> l e <span class="fu">=</span> <span class="dt">L</span> l e
<span class="kw">type</span> <span class="dt">Located</span> e <span class="fu">=</span> <span class="dt">GenLocated</span> <span class="dt">SrcSpan</span> e</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">unLoc ::</span> <span class="dt">GenLocated</span> l e <span class="ot">-&gt;</span> e
unLoc (<span class="dt">L</span> _ e) <span class="fu">=</span> e

<span class="ot">getLoc ::</span> <span class="dt">GenLocated</span> l e <span class="ot">-&gt;</span> l
getLoc (<span class="dt">L</span> l _) <span class="fu">=</span> l

<span class="ot">noLoc ::</span> e <span class="ot">-&gt;</span> <span class="dt">Located</span> e
noLoc e <span class="fu">=</span> <span class="dt">L</span> noSrcSpan e</code></pre></div>
<p>Most notably there is a functor instance for <code>fmap</code>ing over a located element, which modifies the underlying type preserving the location.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">GenLocated</span> l) <span class="kw">where</span>
  fmap f (<span class="dt">L</span> l e) <span class="fu">=</span> <span class="dt">L</span> l (f e)</code></pre></div>
<h4 id="frontend-syntax">Frontend Syntax</h4>
<p>The <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/ghc-7.10.3/HsSyn.html">frontend syntax</a> (called HsSyn) is spread across several data types which contain all possible syntax elements generated from the parser. These are parameterized over the name type so that transformations (renamer, etc) can alter the structure of bindings and identifiers while preserving the syntax tree structure.</p>
<ol style="list-style-type: decimal">
<li><strong>HsModule</strong> - Top-level structure for a module. Contains module name, exports, imports, and toplevel declarations.</li>
<li><strong>HsDecl</strong> - Type, class, value, and interface signature decls</li>
<li><strong>HsBind</strong> - Value bindings used for both top level and nested bindings.</li>
<li><strong>HsGroup</strong> - A HsGroup is a group of related HsDecls.</li>
<li><strong>HsLit</strong> - Literal value (Int, Char, etc)</li>
<li><strong>HsExpr</strong> - A Haskell expression.</li>
<li><strong>HsType</strong> - Frontend type annotation.</li>
<li><strong>Pat</strong> - Pattern match in a case statement or toplevel binding.</li>
</ol>
<p>There are many variants of <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/ghc-7.10.3/Var.html#t:Var">identifiers</a> used in different phases of compilation. In order of generality:</p>
<ol style="list-style-type: decimal">
<li><strong>OccName</strong> - Simplest name used, it holds the names as strings with the namespace that the name came from and position.</li>
<li><strong>RdrName</strong> - Is the type of names that come directly from the parser. Contains information whether the name is unqualified or qualified (with module name).</li>
<li><strong>Name</strong> - Is the type of names that have had their scoping and binding resolved. They have an OccName but also a Unique that disambiguates Names</li>
<li><strong>Var</strong> - Is the type of names that not only have a Name but also a Type. Vars are either global or local.</li>
</ol>
<p>Names are disambiguated from each other by an internal unique numerical key called a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/ghc-7.10.3/Unique.html#t:Unique">Unique</a> , which are generated from a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/ghc-7.10.3/UniqSupply.html">UniqSupply</a> . These are often embedded within the monad transformer <code>MonadUnique</code> layer of the pass.</p>
<p>After typechecking we deal with Var and Id names which have the property that the Name and Type can always be recovered using the following functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">varName ::</span> <span class="dt">Var</span> <span class="ot">-&gt;</span> <span class="dt">Name</span>
<span class="ot">varType ::</span> <span class="dt">Var</span> <span class="ot">-&gt;</span> <span class="dt">Kind</span></code></pre></div>
<p>In addition, many lookup functions use a sum type <code>TyThing</code> which wraps “things” in scope which have types, such as identifiers and type constructors.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">TyThing</span>
  <span class="fu">=</span> <span class="dt">AnId</span> <span class="dt">Id</span>
  <span class="fu">|</span> <span class="dt">AConLike</span> <span class="dt">ConLike.ConLike</span>
  <span class="fu">|</span> <span class="dt">ATyCon</span> <span class="dt">TyCon</span>
  <span class="fu">|</span> <span class="dt">ACoAxiom</span> (<span class="dt">CoAxiom</span> <span class="dt">Branched</span>)</code></pre></div>
<h4 id="outputable">Outputable</h4>
<p>Inside the GHC API is a pretty printer which can be used to dump out a pretty printed summary of a large number of the internal types. The structure of the class is similar to <code>Show</code> typeclass.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Outputable</span> a <span class="kw">where</span>
<span class="ot">  ppr ::</span> a <span class="ot">-&gt;</span> <span class="dt">SDoc</span>
<span class="ot">  pprPrec ::</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">SDoc</span>

<span class="ot">showPpr ::</span> <span class="dt">Outputable</span> a <span class="ot">=&gt;</span> <span class="dt">DynFlags</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre></div>
<p>To simplify our life a bit we can write a wrapper <code>showGhc</code> which uses the default dynflags to dump out an instance of <code>Outputable</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">showGhc ::</span> (<span class="dt">Outputable</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>
showGhc <span class="fu">=</span> showPpr unsafeGlobalDynFlags</code></pre></div>
<h4 id="tracing-compilation">Tracing Compilation</h4>
<p>Given the following example module we’d like to trace the transformation of the intermediate forms as it’s run through the compiler.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Example</span> <span class="kw">where</span>

<span class="kw">data</span> <span class="dt">Animal</span> <span class="fu">=</span> <span class="dt">Cat</span> <span class="fu">|</span> <span class="dt">Dog</span>

<span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
add x y <span class="fu">=</span> x <span class="fu">+</span> y </code></pre></div>
<p>Using the machinery of the last post we import the module target, load it, and then instead of adding it to an interactive context we explicitly call the functions of the individual passes and dump our their structure to the screen.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> runGhc (<span class="dt">Just</span> libdir) <span class="fu">$</span> <span class="kw">do</span>
  env <span class="ot">&lt;-</span> getSession
  dflags <span class="ot">&lt;-</span> getSessionDynFlags
  setSessionDynFlags <span class="fu">$</span> dflags { hscTarget <span class="fu">=</span> <span class="dt">HscInterpreted</span> }

  target <span class="ot">&lt;-</span> guessTarget <span class="st">&quot;Example.hs&quot;</span> <span class="dt">Nothing</span>
  setTargets [target]
  load <span class="dt">LoadAllTargets</span>
  modSum <span class="ot">&lt;-</span> getModSummary <span class="fu">$</span> mkModuleName <span class="st">&quot;Example&quot;</span>

  pmod <span class="ot">&lt;-</span> parseModule modSum      <span class="co">-- ModuleSummary</span>
  tmod <span class="ot">&lt;-</span> typecheckModule pmod    <span class="co">-- TypecheckedSource</span>
  dmod <span class="ot">&lt;-</span> desugarModule tmod      <span class="co">-- DesugaredModule</span>
  <span class="kw">let</span> core <span class="fu">=</span> coreModule dmod      <span class="co">-- ModGuts</span>
  stg <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> coreToStg dflags (mg_module core) (mg_binds core)

  liftIO <span class="fu">$</span> banner <span class="st">&quot;Parsed Source&quot;</span>
  liftIO <span class="fu">$</span> putStrLn <span class="fu">$</span> showGhc ( parsedSource pmod )

  liftIO <span class="fu">$</span> banner <span class="st">&quot;Renamed Module&quot;</span>
  liftIO <span class="fu">$</span> putStrLn <span class="fu">$</span> showGhc ( tm_renamed_source tmod )

  liftIO <span class="fu">$</span> banner <span class="st">&quot;Typechecked Module&quot;</span>
  liftIO <span class="fu">$</span> putStrLn <span class="fu">$</span> showGhc ( tm_typechecked_source tmod )

  liftIO <span class="fu">$</span> banner <span class="st">&quot;Typed Toplevel Definitions&quot;</span>
  liftIO <span class="fu">$</span> putStrLn <span class="fu">$</span> showGhc ( modInfoTyThings (moduleInfo tmod) )

  liftIO <span class="fu">$</span> banner <span class="st">&quot;Typed Toplevel Exports&quot;</span>
  liftIO <span class="fu">$</span> putStrLn <span class="fu">$</span> showGhc ( modInfoExports (moduleInfo tmod) )

  liftIO <span class="fu">$</span> banner <span class="st">&quot;Core Module&quot;</span>
  liftIO <span class="fu">$</span> putStrLn <span class="fu">$</span> showGhc ( mg_binds core )

  liftIO <span class="fu">$</span> banner <span class="st">&quot;STG&quot;</span>
  liftIO <span class="fu">$</span> putStrLn <span class="fu">$</span> showGhc stg</code></pre></div>
<h4 id="parsing">Parsing</h4>
<p>From the module summary we can extract the underlying text stream of the source file <code>Example.hs</code>. Running the parser over this generates a <em>ParsedSource</em> datatype which contains the HsSyn AST with raw OccNames.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ParsedModule</span> <span class="fu">=</span> <span class="dt">ParsedModule</span> 
  {<span class="ot"> pm_mod_summary ::</span> <span class="dt">ModSummary</span>
  ,<span class="ot"> pm_parsed_source ::</span> <span class="dt">ParsedSource</span>
  ,<span class="ot"> pm_extra_src_files ::</span> [FilePath]
  ,<span class="ot"> pm_annotations ::</span> <span class="dt">ApiAnns</span>
  }</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">===============================</span><span class="dt">Parsed</span> <span class="dt">Source</span><span class="fu">===============================</span>
<span class="kw">module</span> <span class="dt">Example</span> <span class="kw">where</span>
<span class="kw">data</span> <span class="dt">Animal</span> <span class="fu">=</span> <span class="dt">Cat</span> <span class="fu">|</span> <span class="dt">Dog</span>
<span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
add x y <span class="fu">=</span> x <span class="fu">+</span> y</code></pre></div>
<hr />
<h4 id="renaming">Renaming</h4>
<p>After parsing we run the renamer pass which is responsible for resolving scopes, operator precedences, and unique’ifying all names so that clashes cannot occur. The renamer resolves <code>RdrName</code>s into <code>Name</code>s across all syntax elements. In addition it annotates each name with whether they are qualified and global or local to the current module. If a name is not in scope, compilation simply halts here and reports the missing name.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">===============================</span><span class="dt">Renamed</span> <span class="dt">Module</span><span class="fu">===============================</span>
<span class="dt">Just</span> (<span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
      add x y <span class="fu">=</span> x <span class="fu">+</span> y
      
      <span class="kw">data</span> <span class="dt">Animal</span> <span class="fu">=</span> <span class="dt">Cat</span> <span class="fu">|</span> <span class="dt">Dog</span>,
      [<span class="kw">import </span>(implicit) <span class="dt">Prelude</span>],
      <span class="dt">Nothing</span>,
      <span class="dt">Nothing</span>)</code></pre></div>
<hr />
<h4 id="typechecking">Typechecking</h4>
<p>The renamed AST is then run through the typechecker which maps <code>Name</code>s into <code>Id</code> and enriches them with inferred types using type inference.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">TypecheckedModule</span> <span class="fu">=</span> <span class="dt">TypecheckedModule</span> 
  {<span class="ot"> tm_parsed_module ::</span> <span class="dt">ParsedModule</span>
  ,<span class="ot"> tm_renamed_source ::</span> <span class="dt">Maybe</span> <span class="dt">RenamedSource</span>
  ,<span class="ot"> tm_typechecked_source ::</span> <span class="dt">TypecheckedSource</span>
  ,<span class="ot"> tm_checked_module_info ::</span> <span class="dt">ModuleInfo</span>
  ,<span class="ot"> tm_internals_ ::</span> (<span class="dt">TcRnTypes.TcGblEnv</span>, <span class="dt">HscTypes.ModDetails</span>)
  }</code></pre></div>
<p>The resulting structure is a typechecked module which contains the toplevel types of all bindings and all subexpressions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">=============================</span><span class="dt">Typechecked</span> <span class="dt">Module</span><span class="fu">=============================</span>
{<span class="dt">AbsBinds</span> [] []
   {<span class="dt">Exports</span><span class="fu">:</span> [add <span class="fu">&lt;=</span> add
                <span class="fu">&lt;&gt;</span>]
    <span class="dt">Exported</span> types<span class="fu">:</span><span class="ot"> add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
                    [<span class="dt">LclId</span>, <span class="dt">Str</span><span class="fu">=</span><span class="dt">DmdType</span>]
    <span class="dt">Binds</span><span class="fu">:</span> add x y <span class="fu">=</span> (<span class="fu">+</span>) x y}}</code></pre></div>
<p>The resulting datatype has a field for <code>ModuleInfo</code>, which contains various metadata about the typing environment, the names in scope, and typeclasses exported.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ModuleInfo</span> <span class="fu">=</span> <span class="dt">ModuleInfo</span> 
  {<span class="ot"> minf_type_env ::</span> <span class="dt">HscTypes.TypeEnv</span>
  ,<span class="ot"> minf_exports ::</span> <span class="dt">NameSet.NameSet</span>
  ,<span class="ot"> minf_rdr_env ::</span> <span class="dt">Maybe</span> <span class="dt">RdrName.GlobalRdrEnv</span>
  ,<span class="ot"> minf_instances ::</span> [<span class="dt">ClsInst</span>]
  ,<span class="ot"> minf_iface ::</span> <span class="dt">Maybe</span> <span class="dt">ModIface</span>
  ,<span class="ot"> minf_safe ::</span> <span class="dt">SafeHaskellMode</span>
  ,<span class="ot"> minf_modBreaks ::</span> <span class="dt">ModBreaks</span>
  }</code></pre></div>
<p>Using the <code>coreModule</code> we can also construct the gruesomely named <code>ModGuts</code> datatype which contains an expanded form of all the various exports and types with associated metadata.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ModGuts</span> <span class="fu">=</span> <span class="dt">ModGuts</span> 
  {<span class="ot"> mg_module ::</span> <span class="fu">!</span><span class="dt">Module</span>,
  ,<span class="ot"> mg_boot ::</span> <span class="dt">IsBootInterface</span>
  ,<span class="ot"> mg_exports ::</span> <span class="fu">!</span>[<span class="dt">Avail.AvailInfo</span>]
  ,<span class="ot"> mg_deps ::</span> <span class="fu">!</span><span class="dt">Dependencies</span>
  ,<span class="ot"> mg_dir_imps ::</span> <span class="fu">!</span><span class="dt">ImportedMods</span>
  ,<span class="ot"> mg_used_names ::</span> <span class="fu">!</span><span class="dt">NameSet.NameSet</span>
  ,<span class="ot"> mg_used_th ::</span> <span class="fu">!</span><span class="dt">Bool</span>
  ,<span class="ot"> mg_rdr_env ::</span> <span class="fu">!</span><span class="dt">RdrName.GlobalRdrEnv</span>
  ,<span class="ot"> mg_fix_env ::</span> <span class="fu">!</span><span class="dt">FixityEnv</span>
  ,<span class="ot"> mg_tcs ::</span> <span class="fu">!</span>[<span class="dt">TyCon</span>]
  ,<span class="ot"> mg_insts ::</span> <span class="fu">!</span>[<span class="dt">ClsInst</span>]
  ,<span class="ot"> mg_fam_insts ::</span> <span class="fu">!</span>[<span class="dt">FamInst</span>]
  ,<span class="ot"> mg_patsyns ::</span> <span class="fu">!</span>[<span class="dt">PatSyn.PatSyn</span>]
  ,<span class="ot"> mg_rules ::</span> <span class="fu">!</span>[<span class="dt">CoreSyn.CoreRule</span>]
  ,<span class="ot"> mg_binds ::</span> <span class="fu">!</span><span class="dt">CoreSyn.CoreProgram</span>
  ,<span class="ot"> mg_foreign ::</span> <span class="fu">!</span><span class="dt">ForeignStubs</span>
  ,<span class="ot"> mg_warns ::</span> <span class="fu">!</span><span class="dt">Warnings</span>
  ,<span class="ot"> mg_anns ::</span> [<span class="dt">Annotations.Annotation</span>]
  ,<span class="ot"> mg_hpc_info ::</span> <span class="fu">!</span><span class="dt">HpcInfo</span>
  ,<span class="ot"> mg_modBreaks ::</span> <span class="fu">!</span><span class="dt">ModBreaks</span>
  ,<span class="ot"> mg_vect_decls ::</span> <span class="fu">!</span>[<span class="dt">CoreSyn.CoreVect</span>]
  ,<span class="ot"> mg_vect_info ::</span> <span class="fu">!</span><span class="dt">VectInfo</span>
  ,<span class="ot"> mg_inst_env ::</span> <span class="dt">InstEnv.InstEnv</span>
  ,<span class="ot"> mg_fam_inst_env ::</span> <span class="dt">FamInstEnv.FamInstEnv</span>
  ,<span class="ot"> mg_safe_haskell ::</span> <span class="dt">SafeHaskellMode</span>
  ,<span class="ot"> mg_trust_pkg ::</span> <span class="dt">Bool</span>
  ,<span class="ot"> mg_dependent_files ::</span> [FilePath]
  }</code></pre></div>
<p>The ModuleInfo can be queried for any type of information about types or names at this point. For instance if we were interesed in the types of a global name we could look it up as a <code>TyThing</code> inside the typing environment.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">modInfoTyThings ::</span> <span class="dt">ModuleInfo</span> <span class="ot">-&gt;</span> [<span class="dt">TyThing</span>]
<span class="ot">modInfoExports ::</span> <span class="dt">ModuleInfo</span> <span class="ot">-&gt;</span> [<span class="dt">Name</span>]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">=========================</span><span class="dt">Typed</span> <span class="dt">Toplevel</span> <span class="dt">Definitions</span><span class="fu">=========================</span>
[<span class="dt">Type</span> constructor ‘<span class="dt">Animal</span>’, <span class="dt">Data</span> constructor ‘<span class="dt">Cat</span>’,
 <span class="dt">Data</span> constructor ‘<span class="dt">Dog</span>’, <span class="dt">Identifier</span> ‘add’, <span class="dt">Identifier</span> ‘<span class="dt">Cat</span>’,
 <span class="dt">Identifier</span> ‘<span class="dt">Dog</span>’]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">===========================</span><span class="dt">Typed</span> <span class="dt">Toplevel</span> <span class="dt">Exports</span><span class="fu">===========================</span>
[<span class="dt">Animal</span>, <span class="dt">Cat</span>, <span class="dt">Dog</span>, add]</code></pre></div>
<hr />
<h4 id="core">Core</h4>
<p>The Core language is GHC’s most central data types. Core is a very small, explicitly-typed, variant of System FC. The output of the <code>typecheckModule</code> function is a datatype <code>CoreModule</code> which contains the Core program as the typing environment.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">CoreModule</span> <span class="fu">=</span> <span class="dt">CoreModule</span> 
  {<span class="ot"> cm_module ::</span> <span class="fu">!</span><span class="dt">Module</span>
  ,<span class="ot"> cm_types ::</span> <span class="fu">!</span><span class="dt">HscTypes.TypeEnv</span>
  ,<span class="ot"> cm_binds ::</span> <span class="dt">CoreSyn.CoreProgram</span>
  ,<span class="ot"> cm_safe ::</span> <span class="dt">SafeHaskellMode</span>
  }</code></pre></div>
<p>Looking at the core module we see that each name in the program is now annotated with an explicit type and typeclass dictionaries have been inserted.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">================================</span><span class="dt">Core</span> <span class="dt">Module</span><span class="fu">================================</span>
[<span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
 [<span class="dt">LclIdX</span>, <span class="dt">Str</span><span class="fu">=</span><span class="dt">DmdType</span>]
 add <span class="fu">=</span> \ (<span class="ot">x ::</span> <span class="dt">Int</span>) (<span class="ot">y ::</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="fu">+</span> <span class="fu">@</span> <span class="dt">Int</span> <span class="fu">$</span>fNumInt x y]</code></pre></div>
<p>Core then is translated into a intermediate form that is amenable to various analysis passes that optimize the program for code generation. This form is an abstract machine known a <em>Spineless Tagless G-Machine</em>. In this syntax every closure has an associated <em>Static Reference Table</em> or SRT. More on this later.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">====================================</span><span class="dt">STG</span><span class="fu">====================================</span>
[<span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
 [<span class="dt">LclIdX</span>, <span class="dt">Str</span><span class="fu">=</span><span class="dt">DmdType</span>] <span class="fu">=</span>
     \r srt<span class="fu">:</span><span class="dt">SRT</span><span class="fu">:</span>[r6ry <span class="fu">:-&gt;</span> <span class="fu">$</span>fNumInt] [x y] <span class="fu">+</span> <span class="fu">$</span>fNumInt x y;]</code></pre></div>
<hr />
<h4 id="summary-next-steps">Summary &amp; Next Steps</h4>
<p>We mentioned Core and STG only briefly. The process by which frontend syntax is transformed into Core will be our next topic. The design of Core defines a great deal of aspects about how the language is structured and informs the type system as well as code-generation.</p>]]></summary>
</entry>
<entry>
    <title>Dive into GHC: Pipeline</title>
    <link href="http://www.stephendiehl.com/posts/ghc_01.html" />
    <id>http://www.stephendiehl.com/posts/ghc_01.html</id>
    <published>2016-06-21T00:00:00Z</published>
    <updated>2016-06-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="dive-into-ghc-pipeline">Dive into GHC: Pipeline</h3>
<p>After reading <a href="https://ghc.haskell.org/trac/ghc/blog/ContributingToGhc">Simon’s</a> call for more volunteer writing about GHC I thought it would be timely to share some knowledge I’ve accumulated over the years about working with the with GHC internals.</p>
<p>I’m by no means an expert on GHC internals, but I have worked with them a fair bit for several projects and the deep dive style of blog posts tends to be a good format for helping ease into exploring the code for themselves. Often times simply a high-level overview and a small bit of runnable example code is enough to encourage further involvement with an open source project and this what I aim to write.</p>
<p>So begins a multipart writeup on the structure of GHC structured around several examples that use the GHC API for some small project that shows off some internal structure of the compiler.</p>
<p style="text-align:center">
<strong><a href="https://github.com/sdiehl/dive-into-ghc/tree/master/01-pipeline">Accompaying Source Code</a></strong>
</p>
<hr />
<h4 id="official-commentary">Official Commentary</h4>
<p>GHC core developers have actually spent a great deal of time over the sharing knowledge about the design of the compiler. Some good places to start are the following:</p>
<ol style="list-style-type: decimal">
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary">GHC Commentary</a></li>
<li><a href="https://www.youtube.com/watch?v=6COvD8oynmI">OPLSS: Adventures in Types</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/AboutVideos">2006 GHC Hackathon Videos</a></li>
<li><a href="https://davidterei.com/talks/2016-03-cs240h/ghc-compiler.html">David Terei’s Notes</a></li>
<li><a href="https://takenobu-hs.github.io/downloads/haskell_ghc_illustrated.pdf">Takenobu Tani’s GHC Illustrated</a></li>
<li><a href="http://blog.ezyang.com/2011/04/tracing-the-compilation-of-hello-factorial/">Edward Yang’s Blog</a></li>
</ol>
<p>On top of this there is a literature trail going back 25 years that shows how the historical context and the research that led up to GHC today.</p>
<ol style="list-style-type: decimal">
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/ReadingList">GHC Reading List</a></li>
</ol>
<h4 id="toplevel">Toplevel</h4>
<p>GHC is a quirky beast of a codebase, but as far compilers go it is a fairly well-engineered and documented project if you know where to look. Yes, it uses a somewhat idiosyncratic convention in places, but after all it is a 20-year old codebase.</p>
<p>To get the source for the compiler clone the official repo:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> clone --recursive git://git.haskell.org/ghc.git
$ <span class="kw">cd</span> ghc/</code></pre></div>
<p>There are many utilities included with the compiler the encompass documentation and the build system, but the important toplevel directories for the compiler itself are primarily:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">├── <span class="kw">rts</span>          <span class="co"># The Haskell runtime systems</span>
├── <span class="kw">compiler</span>     <span class="co"># The Haskell compiler logic</span>
├── <span class="kw">includes</span>     <span class="co"># Header files for runtime and code generation</span>
└── <span class="kw">libraries</span>    <span class="co"># The base libraries and Prelude source</span></code></pre></div>
<p>For this post we’ll concern ourselves with the <code>compiler</code> folder.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">├── <span class="kw">basicTypes</span>   <span class="co"># Types used across all modules</span>
├── <span class="kw">cbits</span>        <span class="co"># Misc C utilities</span>
├── <span class="kw">cmm</span>          <span class="co"># Cmm langauge definitions</span>
├── <span class="kw">codeGen</span>      <span class="co"># Cmm Compilers</span>
├── <span class="kw">coreSyn</span>      <span class="co"># Core language definitions</span>
├── <span class="kw">deSugar</span>      <span class="co"># Desugarer</span>
├── <span class="kw">ghci</span>         <span class="co"># Interactive shell</span>
├── <span class="kw">hsSyn</span>        <span class="co"># Frontend syntax</span>
├── <span class="kw">iface</span>        <span class="co"># Interface files</span>
├── <span class="kw">llvmGen</span>      <span class="co"># LLVM Code generator</span>
├── <span class="kw">main</span>         <span class="co"># Compiler driver logic and options</span>
├── <span class="kw">nativeGen</span>    <span class="co"># Assemblers for x86 / SPARC / PPC</span>
├── <span class="kw">parser</span>       <span class="co"># Frontend Parser for HsSyn</span>
├── <span class="kw">prelude</span>      <span class="co"># Wired-In Types /  Primops and Builtins</span>
├── <span class="kw">profiling</span>    <span class="co"># Runtime profiing tools</span>
├── <span class="kw">rename</span>       <span class="co"># Frontend renamer</span>
├── <span class="kw">simplCore</span>    <span class="co"># Core-To-Core simplifier</span>
├── <span class="kw">simplStg</span>     <span class="co"># Stg-To-Stg simplifier</span>
├── <span class="kw">specialise</span>   <span class="co"># Specisliation pass ( Eliminates Overloading )</span>
├── <span class="kw">stgSyn</span>       <span class="co"># Stg Core Language</span>
├── <span class="kw">stranal</span>      <span class="co"># Strictness Analyzer</span>
├── <span class="kw">typecheck</span>    <span class="co"># Typechecker</span>
├── <span class="kw">types</span>        <span class="co"># Type language, data constructors, and type families</span>
├── <span class="kw">utils</span>        <span class="co"># Misc functions and core data sstructures</span>
└── <span class="kw">vectorise</span>    <span class="co"># Vectorisation optimiations</span></code></pre></div>
<h4 id="ghc-api">GHC API</h4>
<p>Since GHC is itself written in Haskell, GHC is effectively a large library the encompasses the <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/ghc-7.10.3/index.html">GHC API</a>. The toplevel module is simply called <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/ghc-7.10.3/GHC.html">GHC</a> and contains a namespace dump of many of the core types that drive the <em>compilation pipeline</em>.</p>
<p>Beneath this is the main API for compiling plain Haskell source code called <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/ghc-7.10.3/HscMain.html">HscMain</a> which contains the various drivers for different passes within the compilation. The six core passes make up the <a href="http://www.aosabook.org/images/ghc/hscpipe2.png">compilation pipeline</a>:</p>
<ol style="list-style-type: decimal">
<li>Parsing</li>
<li>Renaming</li>
<li>Typechecking</li>
<li>Desugaring</li>
<li>Simplification</li>
<li>Code Generation</li>
</ol>
<p>The result of this compilation is several artificats which are <em>object files</em> (.o), <em>interface files</em> (.hi) and <em>executables</em>.</p>
<h4 id="ghc-monad">GHC Monad</h4>
<p>The heart of the compilation process is stored within the GHC Monad, a state monad that handles the internal session state of the compilation pipeline, error handling and sequencing of multi-module compilation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Ghc</span> a <span class="fu">=</span> <span class="dt">Ghc</span> {<span class="ot"> unGhc ::</span> <span class="dt">Session</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> a }</code></pre></div>
<p>The abstract class <code>GhcMonad</code> provides a lifted version of the GHC monad functions to get at the internal session objects from within the various submonads used throughout compilation (renamer, typechecker, etc).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Functor</span> m, <span class="dt">MonadIO</span> m, <span class="dt">ExceptionMonad</span> m, <span class="dt">HasDynFlags</span> m) <span class="ot">=&gt;</span> <span class="dt">GhcMonad</span> m <span class="kw">where</span>
<span class="ot">  getSession ::</span> m <span class="dt">HscEnv</span>
<span class="ot">  setSession ::</span> <span class="dt">HscEnv</span> <span class="ot">-&gt;</span> m ()</code></pre></div>
<p>The evaluation function takes in a path to the <code>libdir</code> and returns the result inside of <code>IO</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runGhc ::</span> <span class="dt">Maybe</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Ghc</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</code></pre></div>
<p>The filepaths are installation specific paths indicating the local installation and paths to the GHC compiler. These are provided by the <a href="https://hackage.haskell.org/package/ghc-paths">ghc-paths</a> package.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">GHC.Paths</span>

libdir, docdir, ghc,<span class="ot"> ghc_pkg ::</span> FilePath</code></pre></div>
<p>At the heart of the session object is a very important structure called <code>HscEnv</code> which holds the internal state of compilation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">HscEnv</span>
  <span class="fu">=</span> <span class="dt">HscEnv</span> 
  {<span class="ot"> hsc_dflags ::</span> <span class="dt">DynFlags</span>
  ,<span class="ot"> hsc_targets ::</span> [<span class="dt">Target</span>]
  ,<span class="ot"> hsc_mod_graph ::</span> <span class="dt">ModuleGraph</span>
  ,<span class="ot"> hsc_IC ::</span> <span class="dt">InteractiveContext</span>
  ,<span class="ot"> hsc_HPT ::</span> <span class="dt">HomePackageTable</span>
  <span class="co">-- Many more ... (truncated for brevity)</span>
  }</code></pre></div>
<p>The <code>hsc_dlfags</code> holds the settings objects (more on this next). The <code>hsc_targets</code> holds the roots of the Module graph which are traversed bottom-up to build up the entire set of modules needed for compilation of the current package. The entire set of modules involved in this (roots and non-roots) is stored in <code>hsc_mod_graph</code> which holds the whole ModuleGraph, which is not necessarily in topological order. The <code>hsc_IC</code> field contains the interactive context which is used for the interactive shell and for when the end targets are linked in memory. Specific commands in GHCi such as adding modules to the top-level scope modifying this structure state fully.</p>
<p>The <code>hsc_HPT</code> holds the home package table which describes already-compiled home-package modules, When a module done being compiled, and is loaded with <code>loadModule</code> it is internally added to this mapping.</p>
<h4 id="dynflags">DynFlags</h4>
<p><a href="https://downloads.haskell.org/~ghc/7.10.2/docs/html/libraries/ghc-7.10.2/DynFlags.html#t:DynFlags">DynFlags</a> contains a collection of flags relating to the compilation of a single file or GHC session. This is the core datatype that informs how compilation occurs and is passed to most of the various pass functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">DynFlags</span>
  <span class="fu">=</span> <span class="dt">DynFlags</span> 
  {<span class="ot"> ghcMode ::</span> <span class="dt">GhcMode</span>
  ,<span class="ot"> ghcLink ::</span> <span class="dt">GhcLink</span>
  ,<span class="ot"> hscTarget ::</span> <span class="dt">HscTarget</span>
  ,<span class="ot"> settings ::</span> <span class="dt">Settings</span>

  ,<span class="ot"> flags ::</span> [<span class="dt">DynFlag</span>]
  ,<span class="ot"> extensionFlags ::</span> [<span class="dt">ExtensionFlag</span>]

  ,<span class="ot"> pkgState ::</span> <span class="dt">PackageState</span>
  ,<span class="ot"> pkgDatabase ::</span> <span class="dt">Maybe</span> [<span class="dt">PackageConfig</span>]
  ,<span class="ot"> packageEnv ::</span> <span class="dt">Maybe</span> FilePath
  ,<span class="ot"> packageFlags ::</span> [<span class="dt">PackageFlag</span>]
  ,<span class="ot"> extraPkgConfs ::</span> [<span class="dt">PkgConfRef</span>] <span class="ot">-&gt;</span> [<span class="dt">PkgConfRef</span>]
  <span class="co">-- Many more flags... (truncated for brevity)</span>
  }</code></pre></div>
<p>The <code>GhcMode</code> informs whether we’re doing multi-module compilation or one-shot single-file compilation. In the case of multi-module the ModuleGraph is built up via the <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/ghc-7.10.3/Finder.html">Finder</a> function which searches the home package for the dependent modules.</p>
<table>
<thead>
<tr class="header">
<th align="left"><strong>GhcMode</strong></th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">CompManager</td>
<td align="left"><code>--make</code></td>
</tr>
<tr class="even">
<td align="left">OneShot</td>
<td align="left"><code>ghc -c Foo.hs</code></td>
</tr>
<tr class="odd">
<td align="left">MkDepend</td>
<td align="left"><code>ghc -M</code></td>
</tr>
</tbody>
</table>
<p>The <code>HscTarget</code> datatype defines the target code type of the compilation. By default this is <code>HscAsm</code>.</p>
<table>
<thead>
<tr class="header">
<th align="left"><strong>HscTarget</strong></th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">HscC</td>
<td align="left">Generate C code.</td>
</tr>
<tr class="even">
<td align="left">HscAsm</td>
<td align="left">Generate assembly using the native code generator.</td>
</tr>
<tr class="odd">
<td align="left">HscLlvm</td>
<td align="left">Generate assembly using the llvm code generator.</td>
</tr>
<tr class="even">
<td align="left">HscInterpreted</td>
<td align="left">Generate bytecode.</td>
</tr>
<tr class="odd">
<td align="left">HscNothing</td>
<td align="left">Don’t generate any code. See notes above.</td>
</tr>
</tbody>
</table>
<p>After compilation is done (for multi-module) GHC then begins the linker phase and the <code>GhcLink</code> setting determines what to do with the resulting object files.</p>
<table>
<thead>
<tr class="header">
<th align="left"><strong>GhcLink</strong></th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">NoLink</td>
<td align="left">Don’t link at all</td>
</tr>
<tr class="even">
<td align="left">LinkBinary</td>
<td align="left">Link object code into a binary</td>
</tr>
<tr class="odd">
<td align="left">LinkInMemory</td>
<td align="left">Use the in-memory dynamic linker (works for both bytecode and object code).</td>
</tr>
<tr class="even">
<td align="left">LinkDynLib</td>
<td align="left">Link objects into a dynamic lib (DLL on Windows, DSO on ELF platforms)</td>
</tr>
<tr class="odd">
<td align="left">LinkStaticLib</td>
<td align="left">Link objects into a static lib</td>
</tr>
</tbody>
</table>
<p>The simplest initializer of a GHC session simply uses the defaults and sets up a interpreted session that links any modules it is given in memory.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">example ::</span> <span class="dt">IO</span> ()
example <span class="fu">=</span> runGhc (<span class="dt">Just</span> libdir) <span class="fu">$</span> <span class="kw">do</span>
  dflags <span class="ot">&lt;-</span> getSessionDynFlags
  setSessionDynFlags <span class="fu">$</span> dflags { hscTarget <span class="fu">=</span> <span class="dt">HscInterpreted</span>
                              , ghcLink   <span class="fu">=</span> <span class="dt">LinkInMemory</span>
                              }</code></pre></div>
<p>GHC exposes many compiler flags on the commandline and these are themselves reflected in various subfields of the <code>DynFlags</code> struct. The three major classes of flags are <code>DumpFlag</code> (example: <code>-ddump-simpl</code>), GeneralFlag (example: <code>-fspec-constr</code>) and ExtensionFlag (example: <code>-XTypeInType</code>). There are various helper functions that modifying the DynFlags to twiddle these flags on or off.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">dopt_set ::</span> <span class="dt">DynFlags</span> <span class="ot">-&gt;</span> <span class="dt">DumpFlag</span> <span class="ot">-&gt;</span> <span class="dt">DynFlags</span>
<span class="ot">gopt_set ::</span> <span class="dt">DynFlags</span> <span class="ot">-&gt;</span> <span class="dt">GeneralFlag</span> <span class="ot">-&gt;</span> <span class="dt">DynFlags</span>
<span class="ot">xopt_set ::</span> <span class="dt">DynFlags</span> <span class="ot">-&gt;</span> <span class="dt">ExtensionFlag</span> <span class="ot">-&gt;</span> <span class="dt">DynFlags</span></code></pre></div>
<p>Through the compilation GHC will query the state of these flags to dispatch to different codepaths based on whether a language extension is set or other flag behavior. This is done through querying the <code>GhcMonad</code> instance to get the dynflags and using one of the various flag specific functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">xopt ::</span> <span class="dt">ExtensionFlag</span> <span class="ot">-&gt;</span> <span class="dt">DynFlags</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">gopt ::</span> <span class="dt">GeneralFlag</span> <span class="ot">-&gt;</span> <span class="dt">DynFlags</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">dopt ::</span> <span class="dt">DumpFlag</span> <span class="ot">-&gt;</span> <span class="dt">DynFlags</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></code></pre></div>
<p>To enable various flags we use modify the current <code>dflags</code> object using the flag set functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">example ::</span> <span class="dt">IO</span> ()
example <span class="fu">=</span> runGhc (<span class="dt">Just</span> libdir) <span class="fu">$</span> <span class="kw">do</span>
  dflags <span class="ot">&lt;-</span> getSessionDynFlags
  <span class="kw">let</span> dflags&#39; <span class="fu">=</span> dflags { hscTarget <span class="fu">=</span> <span class="dt">HscInterpreted</span> , ghcLink <span class="fu">=</span> <span class="dt">LinkInMemory</span> }
               <span class="ot">`dopt_set`</span> <span class="dt">Opt_D_dump_BCOs</span>        <span class="co">-- Set Dump Flag</span>
               <span class="ot">`xopt_set`</span> <span class="dt">Opt_OverloadedStrings</span>  <span class="co">-- Set Language Extension Flag</span></code></pre></div>
<h4 id="compilation">Compilation</h4>
<p>To start compilation we first add a target to the state. This modifies the <code>hsc_targets</code> field of the environment. To two types of targets are either module names or filenames. The <code>guessTarget</code> will discriminate on the given string’s extension it to determine which target object to create.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">addTarget ::</span> <span class="dt">GhcMonad</span> m <span class="ot">=&gt;</span> <span class="dt">Target</span> <span class="ot">-&gt;</span> m ()
<span class="ot">guessTarget ::</span> <span class="dt">GhcMonad</span> m <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Phase</span> <span class="ot">-&gt;</span> m <span class="dt">Target</span></code></pre></div>
<p>Targets specify the source files or modules at the top of the dependency tree. For a executable program there is just a single target <code>Main.hs</code>, for a library the targets are visible module in the library.</p>
<table>
<thead>
<tr class="header">
<th align="left"><strong>Target</strong></th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">TargetModule</td>
<td align="left">A module name: search for the file</td>
</tr>
<tr class="even">
<td align="left">TargetFile FilePath</td>
<td align="left">A filename: preprocess and parse it to find the module name.</td>
</tr>
</tbody>
</table>
<p>If with the modules added to the state we can then perform dependency analsysis to determine the module graph to proceed with multi-module compilation. Dependency analysis entails parsing the import directives of the module and resolving the <code>ModuleGraph</code> which is a type alias for a list of <code>ModuleSummary</code> which contains the targets. This is performed by the <code>depanal</code> function.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">depanal ::</span> <span class="dt">GhcMonad</span> m <span class="ot">=&gt;</span> [<span class="dt">ModuleName</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> m <span class="dt">ModuleGraph</span></code></pre></div>
<p>After a target is created the compiler is then run on the module yielding the resulting artifacts and it is loaded into the home package table. This is accomplished via the <code>load</code> command.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">load ::</span> <span class="dt">GhcMonad</span> m <span class="ot">=&gt;</span> <span class="dt">LoadHowMuch</span> <span class="ot">-&gt;</span> m <span class="dt">SuccessFlag</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left"><strong>LoadHowMuch</strong></th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">LoadAllTargets</td>
<td align="left">Load all targets and its dependencies.</td>
</tr>
<tr class="even">
<td align="left">LoadUpTo</td>
<td align="left">Load only the given module and its dependencies.</td>
</tr>
<tr class="odd">
<td align="left">LoadDependenciesOf</td>
<td align="left">Load only the dependencies of the given module, but not the module itself.</td>
</tr>
</tbody>
</table>
<p>A full example of this would be the compilation of a module <code>Example.hs</code> in the current working directory that is interpreted and linked in memory.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">example ::</span> <span class="dt">IO</span> ()
example <span class="fu">=</span> runGhc (<span class="dt">Just</span> libdir) <span class="fu">$</span> <span class="kw">do</span>
  dflags <span class="ot">&lt;-</span> getSessionDynFlags
  setSessionDynFlags <span class="fu">$</span> dflags { hscTarget <span class="fu">=</span> <span class="dt">HscInterpreted</span>
                              , ghcLink   <span class="fu">=</span> <span class="dt">LinkInMemory</span>
                              }

  target <span class="ot">&lt;-</span> guessTarget <span class="st">&quot;Example.hs&quot;</span> <span class="dt">Nothing</span>
  addTarget target
  load <span class="dt">LoadAllTargets</span></code></pre></div>
<h4 id="interactive-context">Interactive Context</h4>
<p>On top of simply generating compiler artifacts. GHC can compile and link code into memory to be evaluated interactively. The state of the interpreter backing this is held in the <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/ghc-7.10.3/HscTypes.html#t:InteractiveContext">InteractiveContext</a>.</p>
<p>The set of modules in the interactive scope can be modified by the <code>setContext</code> function.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getContext ::</span> <span class="dt">GhcMonad</span> m <span class="ot">=&gt;</span> m [<span class="dt">InteractiveImport</span>]
<span class="ot">setContext ::</span> <span class="dt">GhcMonad</span> m <span class="ot">=&gt;</span> [<span class="dt">InteractiveImport</span>] <span class="ot">-&gt;</span> m ()</code></pre></div>
<p>When a module is interpreted and loaded as an interactive import it has its full top-level scope available. We can manipulate, query and extend this scope using various function.</p>
<p><code>parseName</code> can be used to resolve a name (or names) from a given string to a set of symbols in the interactive context. This returns a <code>Name</code> object (more on this later) which is GHC’s internal name type that holds position and a unique identifier.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseName ::</span> <span class="dt">GhcMonad</span> m <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> m [<span class="dt">Name</span>]</code></pre></div>
<p>To resolve the type of an given expression the <code>exprType</code> can be used to extract the type information within the current context.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">exprType ::</span> <span class="dt">GhcMonad</span> m <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> m <span class="dt">Type</span></code></pre></div>
<p>And within the entire interactive context we can query the set of all names that have been brought into scope by imports. This is used for the interactive <code>:browse</code> command.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getNamesInScope ::</span> <span class="dt">GhcMonad</span> m <span class="ot">=&gt;</span> m [<span class="dt">Name</span>]</code></pre></div>
<p>And the most important function is evaluation of arbitrary expressions with in the interactive context. Which is accomplished via <code>dynCompileExpr</code>. This returns a <code>Dynamic</code> which can be safely cast using <code>fromDynamic</code> for any instance of <code>Typeable</code>. This is used to dynamically evaluate a string expression within the interactive context.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">dynCompileExpr ::</span> <span class="dt">GhcMonad</span> m <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> m <span class="dt">Dynamic</span>
<span class="ot">fromDynamic ::</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> <span class="dt">Dynamic</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</code></pre></div>
<h4 id="package-database">Package Database</h4>
<p>In it’s default state GHC is aware of two package databases: the global package database in <code>/usr/lib/ghc-x.x.x/</code> and the user database in <code>~/.ghc/lib</code>.</p>
<p>This however can be extended via the “GHC_PACKAGE_PATH” environment variable which reads the path variable and applies the <code>extraPkgConfs</code> function to add it to the package database. This is used in the various modern sandboxing techniques used in tools like <code>cabal</code> and <code>stack</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">extraPkgConfs ::</span> [<span class="dt">PkgConfRef</span>] <span class="ot">-&gt;</span> [<span class="dt">PkgConfRef</span>]</code></pre></div>
<p>To modify the given dynflagas with a filepath, the following function can be used to extend the state.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">addPkgDbs ::</span> <span class="dt">GhcMonad</span> m <span class="ot">=&gt;</span> [FilePath] <span class="ot">-&gt;</span> m ()
addPkgDbs fps <span class="fu">=</span> <span class="kw">do</span> 
  dfs <span class="ot">&lt;-</span> getSessionDynFlags
  <span class="kw">let</span> pkgs <span class="fu">=</span> map <span class="dt">PkgConfFile</span> fps
  <span class="kw">let</span> dfs&#39; <span class="fu">=</span> dfs { extraPkgConfs <span class="fu">=</span> (pkgs <span class="fu">++</span>) <span class="fu">.</span> extraPkgConfs dfs }
  setSessionDynFlags dfs&#39;
  _ <span class="ot">&lt;-</span> initPackages dfs&#39;
  return ()</code></pre></div>
<p>Stack sets this when launching the shell with <code>stack repl</code>. More on modifying this will be discussed later.</p>
<h4 id="mini-ghci">Mini GHCi</h4>
<p>Ok, so let’s a build a very small interactive shell for GHC. If you’re not familiar with <a href="http://dev.stephendiehl.com/hask/#haskeline">Haskeline</a> (the platform-agnostic readline abstraction) then read up on that first.</p>
<p>The Haskeline interface is exposed as a monad transformer <code>InputT</code> which inside of IO gives us our interactive repl monad.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Repl</span> a <span class="fu">=</span> <span class="dt">InputT</span> <span class="dt">IO</span> a</code></pre></div>
<p>To set up the initial session set get the default dynflags, set the target to be interpreted and memory-linked and twiddle the <code>-XExtendedDefaultRules</code> flag. We set the interactive shell to import the <code>Prelude</code> and then monadically return the resulting session so that we can progressively add to it on each shell commnad.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">initSession ::</span> <span class="dt">IO</span> <span class="dt">HscEnv</span>
initSession <span class="fu">=</span> runGhc (<span class="dt">Just</span> libdir) <span class="fu">$</span> <span class="kw">do</span>
  liftIO <span class="fu">$</span> putStrLn <span class="st">&quot;Setting up HscEnv&quot;</span>
  dflags <span class="ot">&lt;-</span> getSessionDynFlags
  <span class="kw">let</span> dflags&#39; <span class="fu">=</span> dflags { hscTarget <span class="fu">=</span> <span class="dt">HscInterpreted</span> , ghcLink <span class="fu">=</span> <span class="dt">LinkInMemory</span> }
                <span class="ot">`xopt_set`</span> <span class="dt">Opt_ExtendedDefaultRules</span>
  setSessionDynFlags dflags&#39;
  setContext [ <span class="dt">IIDecl</span> <span class="fu">$</span> simpleImportDecl (mkModuleName <span class="st">&quot;Prelude&quot;</span>) ]
  env <span class="ot">&lt;-</span> getSession
  return env</code></pre></div>
<p>Each our interactive shell commands is then wrapped in a helper function <code>session</code> which spins up a new Ghc monad but restores the session from the last compilation. The monadic action is then evaluated and the resulting session afterwards is returned as a value to be reused.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">session ::</span> <span class="dt">HscEnv</span> <span class="ot">-&gt;</span> <span class="dt">Ghc</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">HscEnv</span>
session env m <span class="fu">=</span> runGhc (<span class="dt">Just</span> libdir) <span class="fu">$</span> <span class="kw">do</span>
  setSession env 
  m
  env <span class="ot">&lt;-</span> getSession
  return env</code></pre></div>
<p>The evaluator function tries two different compilation steps. First it tries to compile the expression as is to see if it evaluates to a <code>IO a</code> action. If it does it is then evaluated directly within the monad. If it does not then the <code>fromDyanamic</code> cast will simply yield a Nothing and we’ll try to wrap the expression in a print statement. The resulting compiled expression is guaranteed to be an <code>IO a</code> so we unsafely coerce the compiled code pointer that GHC gives us into IO and run it.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eval ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Ghc</span> ()
eval inp <span class="fu">=</span> <span class="kw">do</span>
  dyn <span class="ot">&lt;-</span> fromDynamic <span class="fu">&lt;$&gt;</span> dynCompileExpr inp
  <span class="kw">case</span> dyn <span class="kw">of</span>
    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
      act <span class="ot">&lt;-</span> compileExpr (<span class="st">&quot;Prelude.print (&quot;</span> <span class="fu">&lt;&gt;</span> inp <span class="fu">&lt;&gt;</span> <span class="st">&quot;)&quot;</span>)
      <span class="co">-- &#39;print&#39; is constrained to &#39;IO ()&#39; so unsafeCoerce is &quot;safe&quot;</span>
      liftIO (unsafeCoerce act)
    <span class="dt">Just</span> act <span class="ot">-&gt;</span> liftIO <span class="fu">$</span> act</code></pre></div>
<p>To add an import we simply cons the import as a module name to the context and then yield the new state.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">addImport ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Ghc</span> ()
addImport mod <span class="fu">=</span> <span class="kw">do</span>
  ctx <span class="ot">&lt;-</span> getContext
  setContext ( (<span class="dt">IIDecl</span> <span class="fu">$</span> simpleImportDecl (mkModuleName mod)) <span class="fu">:</span> ctx )</code></pre></div>
<p>Then we do the naughty thing of catching all exceptions that are thrown and just printing them out. This is fairly justified in the case that if expression compilation fails we have to just trap and report the failure in the embedded interpreter logic.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ghcCatch ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> a)
ghcCatch m <span class="fu">=</span> liftIO <span class="fu">$</span> <span class="kw">do</span>
  mres <span class="ot">&lt;-</span> try m
  <span class="kw">case</span> mres <span class="kw">of</span>
    <span class="dt">Left</span> (<span class="ot">err ::</span> <span class="dt">SomeException</span>) <span class="ot">-&gt;</span> <span class="kw">do</span>
      liftIO <span class="fu">$</span> print err
      return <span class="dt">Nothing</span>
    <span class="dt">Right</span> res <span class="ot">-&gt;</span> return (<span class="dt">Just</span> res)</code></pre></div>
<p>The REPL then just reads the user’s input and dispatch based on whether the line starts with the keyword <code>import</code>. Depending on the expression line it then spins up a GHC session with the currently held HscEnv from the last line and trys to compile it. If succesfully it then calls <code>repl</code> with the new <code>env</code> state ad-infinitum. Unix signals for aborting are handled by Haskeline monad.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">repl ::</span> <span class="dt">HscEnv</span> <span class="ot">-&gt;</span> <span class="dt">Repl</span> ()
repl env <span class="fu">=</span> <span class="kw">do</span>
  minput <span class="ot">&lt;-</span> getInputLine <span class="st">&quot;&gt;&gt;&gt; &quot;</span>
  <span class="kw">case</span> minput <span class="kw">of</span>
    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> outputStrLn <span class="st">&quot;Goodbye.&quot;</span>

    <span class="dt">Just</span> input <span class="fu">|</span> <span class="st">&quot;import&quot;</span> <span class="ot">`isPrefixOf`</span> input <span class="ot">-&gt;</span> <span class="kw">do</span>
      <span class="kw">let</span> mod <span class="fu">=</span> concat <span class="fu">$</span> tail <span class="fu">$</span> words input
      env&#39; <span class="ot">&lt;-</span> ghcCatch (session env (addImport mod))
      maybe (repl env) repl env&#39;

    <span class="dt">Just</span> input <span class="ot">-&gt;</span> <span class="kw">do</span>
      env&#39; <span class="ot">&lt;-</span> ghcCatch (session env (eval input))
      maybe (repl env) repl env&#39;</code></pre></div>
<p>Then putting it all together.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  env <span class="ot">&lt;-</span> initSession
  runInputT defaultSettings (repl env)</code></pre></div>
<p>We can then run our little shell.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">stack</span> build dive
$ <span class="kw">stack</span> exec dive 

<span class="kw">Setting</span> up HscEnv
<span class="kw">&gt;&gt;&gt;</span> <span class="kw">fmap</span> (+1) [<span class="kw">1..10</span>]
[<span class="kw">2</span>,3,4,5,6,7,8,9,10,11]
<span class="kw">&gt;&gt;&gt;</span> <span class="kw">import</span> Data.Text
<span class="kw">&gt;&gt;&gt;</span>
<span class="kw">Goodbye.</span></code></pre></div>
<p>So that’s our custom Mini GHCi. In practice <a href="https://github.com/ghc/ghc/tree/master/libraries/ghci">real GHCi</a> does things a little differently, but some underlying machinery remains the same. Other features like name lookup and introspection are left as an exercise to the reader. A fun next project would be to create tiny shell with an introspection tool querying the original source code of any definition in scope.</p>
<h4 id="summary-next-steps">Summary &amp; Next Steps</h4>
<p>This is the “Very High Level” API we can use to interact with GHC. Next we’ll concern ourselves with the guts of the internal artifacts used and how to introspect and build them programatically.</p>]]></summary>
</entry>
<entry>
    <title>A Sticky Stringy Quandary</title>
    <link href="http://www.stephendiehl.com/posts/strings.html" />
    <id>http://www.stephendiehl.com/posts/strings.html</id>
    <published>2016-06-04T00:00:00Z</published>
    <updated>2016-06-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="a-sticky-stringy-quandary">A Sticky Stringy Quandary</h3>
<p>Anyone who has used Haskell in a professional setting knows that the String situation is kind of a mess. While in many ways the language is progressing at a rapid pace and is only ever getting more compelling for commercial use, the String situation is still regarded by many people as the <a href="https://www.reddit.com/r/haskell/comments/4f47ou/why_does_haskell_in_your_opinion_suck/d25zq7t">largest problem in the langauge</a>. And for good reason, an efficient textual type is absolutely essential for most work and it’s use needs to be streamlined and language-integrated for a overall positive experience writing industrial Haskell.</p>
<p>Let us a consider a logical assessment of why the <strong>String Situation</strong> exists, how far we can get with workarounds and what’s next. See the accompanying Git project for prototype code:</p>
<p style="text-align:center">
<strong><a href="https://github.com/sdiehl/print">Accompaying Source Code</a></strong>
</p>
<h3 id="string">String</h3>
<p>The String type is very naive, it’s <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-String.html#t:String">defined</a> as a linked-list of Char pointers.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">String</span> <span class="fu">=</span> [<span class="dt">Char</span>]</code></pre></div>
<p>This is not only a bad representation, it’s quite possibly the least efficient (non-contrived) representation of text data possible and has horrible performance in both time and space. <em>And it’s used everywhere in Haskell.</em> Even posterchild libraries for Haskell (Pandoc, etc) use it extensively and have horrible performance because of it.</p>
<p>Around 2005-2007 several more efficient libraries were written, that included <a href="https://hackage.haskell.org/package/bytestring">Bytestring</a> and <a href="https://hackage.haskell.org/package/text">Text</a> and both have different use-cases. Both are orders of magnitude more efficient and have become the ubiquitous in “Modern Haskell”. Combined with the recent <code>-XOverloadedStrings</code> language extension we have a partial solution for routing around the problem.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>

<span class="co">-- From overloaded string literal.</span>
<span class="ot">foo ::</span> <span class="dt">T.Text</span>
foo <span class="fu">=</span> <span class="st">&quot;bar&quot;</span></code></pre></div>
<p>Unfortunately conversion between the efficient string types and String is <span class="math inline">\(O(n)\)</span> and involves a deep copy. They’re still not used ubiquitously, and every introductory book on the subject still uses String instead of the modern libraries because it’s provided by default.</p>
<p>So why is String still used? Because it’s too convenient and it has special powers from being wired-in to the compiler.</p>
<h3 id="banishing-string">Banishing String</h3>
<p>You can get pretty far working in a subset of the Prelude and blessed libraries that have nearly removed old historical cruft like String and banished the ugly parts of the Prelude. However one will end up using String in few noticeable dark corners.</p>
<ol style="list-style-type: decimal">
<li>Show instances</li>
<li>Read instances</li>
<li>Pretty printers</li>
<li>FilePath</li>
<li>Third party libraries written before 2007.</li>
</ol>
<p>Older core libraries are getting slowly phased out, this is a social problem not a technology problem. This seems to be going in the right direction on it’s own.</p>
<p>FilePaths are not hard to swap out and not a huge concern.</p>
<p><code>Show</code> typeclasses and Pretty printers are the probably the singularly biggest source of continued [Char] usage and what we’ll concern ourselves with here.</p>
<hr />
<h3 id="show">Show</h3>
<p>The Show class is really useful, and automatically deriving show much boilerplate is part of the reason Haskell is so much fun to write. However it’s current status poses a bit of a problem transitioning to modern types for several reasons:</p>
<ol style="list-style-type: lower-alpha">
<li>It’s abused to write custom pretty printers.</li>
<li>It’s relation to the Read class is problematic.</li>
<li>It’s constrained to use <code>[Char]</code> and forces that choice on downstream users, who end up forced to use it in places it shouldn’t be used.</li>
</ol>
<p>So what is Show class really, it’s so successful that a lot of people actually never look at it’s internals. The guts of it is a function called <code>showPrec</code> which is a overloaded CPS’d function which composes together a collection of string fragments for specific implementations of the Show typeclass.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">ShowS</span> <span class="fu">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>

<span class="kw">class</span> <span class="dt">Show</span> a <span class="kw">where</span>
<span class="ot">  showsPrec ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ShowS</span>
<span class="ot">  show ::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="ot">  showList ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">ShowS</span>
  <span class="ot">{-# MINIMAL showsPrec | show #-}</span></code></pre></div>
<p>Together with the Read class we get a textual serializer and deserializer for free with the laws governing that relation being:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">read <span class="fu">.</span> show <span class="fu">=</span> id</code></pre></div>
<p>GHC can almost always derive this automatically and the instance is pretty simple. Using <code>-ddump-deriv</code> we can ask GHC to dump it out for us.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="fu">:</span>set <span class="fu">-</span>ddump<span class="fu">-</span>deriv 
λ<span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a) <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">List</span> a) <span class="kw">where</span>
  showsPrec _ <span class="dt">Nil</span> <span class="fu">=</span> showString <span class="st">&quot;Nil&quot;</span>
  showsPrec a (<span class="dt">Cons</span> b1 b2)
    <span class="fu">=</span> showParen (a <span class="fu">&gt;=</span> <span class="dv">11</span>) <span class="fu">$</span> 
           showString <span class="st">&quot;Cons &quot;</span> 
         <span class="fu">.</span> showsPrec <span class="dv">11</span> b1 
         <span class="fu">.</span> showSpace
         <span class="fu">.</span> showsPrec <span class="dv">11</span> b2

  showList <span class="fu">=</span> showList__ (showsPrec <span class="dv">0</span>)</code></pre></div>
<p>The emergant problem this is that there are an enormous number of pathological Show instances used in practice, and you don’t need to look even beyond the standard library to find law violations. This coupled with the fact that Read instance is really dangerous, it’s use of a very suboptimal String type means that it’s inefficient and opens up security holes and potential denial-of-service attacks in networked applications. Show should really only to be used for debugging the structure of internal types and used at the interactive shell. For serializing structures to text in a way that differs from Haskell’s internal representation we need a pretty printer.</p>
<h3 id="pretty-printers">Pretty Printers</h3>
<p>The correct way of writing custom textual serializes is through the various pretty-print combinator libraries that stem from Wadler’s original paper <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.19.635&amp;rep=rep1&amp;type=pdf">A prettier printer</a>. There are some degrees of freedom in this design space, but <a href="https://hackage.haskell.org/package/wl-pprint-text">wl-pprint-text</a> is a good choice for almost all use cases. Using the underlying <a href="https://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-Lazy-Builder.html">Data.Text.Lazy.Builder</a> functions is also a sensible choice.</p>
<p>So for example if we have a little λ-calculus…</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="dt">Var</span> <span class="dt">Text</span>
  <span class="fu">|</span> <span class="dt">Lit</span> <span class="dt">Lit</span>
  <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Lam</span> <span class="dt">Text</span> <span class="dt">Expr</span>

<span class="kw">data</span> <span class="dt">Lit</span>
  <span class="fu">=</span> <span class="dt">LInt</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">LBool</span> <span class="dt">Bool</span></code></pre></div>
<p>We can write down a pretty printer quite simply using the provided combinators. See the <a href="https://gist.github.com/sdiehl/d8eae8db0a9fa34c54c10cb46a0b2dc8">gist here</a> for the full example.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Pretty</span> a <span class="kw">where</span>
<span class="ot">  pretty ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Doc</span>

<span class="kw">instance</span> <span class="dt">Pretty</span> <span class="dt">Lit</span> <span class="kw">where</span>
  pretty _ (<span class="dt">LInt</span> n) <span class="fu">=</span> int n
  pretty _ (<span class="dt">LBool</span> b) <span class="fu">=</span> bool b

<span class="kw">instance</span> <span class="dt">Pretty</span> <span class="dt">Expr</span> <span class="kw">where</span>
  pretty _ (<span class="dt">Var</span> x)  <span class="fu">=</span> text x
  pretty p (<span class="dt">Lit</span> x)  <span class="fu">=</span> pretty p x

  pretty p e<span class="fu">@</span>(<span class="dt">App</span> _ _) <span class="fu">=</span>
    <span class="kw">let</span> (f, xs) <span class="fu">=</span> viewApp e <span class="kw">in</span>
    <span class="kw">let</span> args <span class="fu">=</span> sep <span class="fu">$</span> map (pretty (p<span class="fu">+</span><span class="dv">1</span>)) xs <span class="kw">in</span>
    parensIf (p<span class="fu">&gt;</span><span class="dv">0</span>) <span class="fu">$</span> pretty p f <span class="fu">&lt;+&gt;</span> args

  pretty p e<span class="fu">@</span>(<span class="dt">Lam</span> _ _) <span class="fu">=</span>
    <span class="kw">let</span> body <span class="fu">=</span> pretty (p<span class="fu">+</span><span class="dv">1</span>) (viewBody e) <span class="kw">in</span>
    <span class="kw">let</span> vars <span class="fu">=</span> map text (viewVars e) <span class="kw">in</span>
    parensIf (p<span class="fu">&gt;</span><span class="dv">0</span>) <span class="fu">$</span> <span class="st">&quot;\\&quot;</span> <span class="fu">&lt;&gt;</span> hsep vars <span class="fu">&lt;+&gt;</span> <span class="st">&quot;.&quot;</span> <span class="fu">&lt;+&gt;</span> body</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ppexpr ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Text</span>
ppexpr x <span class="fu">=</span> PP.displayT (PP.renderPretty <span class="fl">1.0</span> <span class="dv">70</span> (pretty <span class="dv">0</span> x))</code></pre></div>
<p>So that’s how it <em>should</em> be done. In practice to do this you’d have to setup a cabal/stack project, install 11 dependencies, write a new typeclass, and write this little joy of a import preamble masking several functions that conflict in the Prelude namespace.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Monoid</span>
<span class="kw">import </span><span class="dt">Data.Text.Lazy</span> (<span class="dt">Text</span>)
<span class="kw">import </span><span class="dt">Data.Text.Lazy.IO</span> <span class="kw">as</span> <span class="dt">TL</span>
<span class="kw">import </span><span class="dt">Text.PrettyPrint.Leijen.Text</span> <span class="kw">hiding</span> ((&lt;$&gt;), (&lt;&gt;), <span class="dt">Pretty</span>(..))
<span class="kw">import qualified</span> <span class="dt">Text.PrettyPrint.Leijen.Text</span> <span class="kw">as</span> <span class="dt">PP</span></code></pre></div>
<p>This kind of sucks. It’s the right thing to do, but it’s kind of painful and it’s certainly not intuitive for newcomers. Abusing Show and String is easier, <em>worst practices should be hard</em> but in this case they are much easier than doing the correct thing.</p>
<h3 id="progress-string-text">Progress :: String → Text</h3>
<p>GHC has had the capacity to support custom Preludes for a while and this is a very wise design choice. For all the historical brokenness of certain things, there are very few technological hurdles to replacing them with modern sensible defaults. The question then remains how close can we come to replacing Show with a Text-based equivalent. The answer is about 80% before surgery is required on GHC itself.</p>
<p>The translation of a Text-based show prototype is just one module. Instead of concatenating Strings we use the Text.Builder object to build up a Text representation. The <code>ShowS</code> function now just becomes a Builder transformation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Text.Buildable</span> (build)
<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy</span> <span class="kw">as</span> <span class="dt">TL</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy.Builder</span> <span class="kw">as</span> <span class="dt">TB</span>

<span class="kw">type</span> <span class="dt">ShowS</span> <span class="fu">=</span> <span class="dt">TB.Builder</span> <span class="ot">-&gt;</span> <span class="dt">TB.Builder</span>

<span class="kw">class</span> <span class="dt">Show</span> a <span class="kw">where</span>
<span class="ot">  showsPrec ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ShowS</span>
<span class="ot">  show ::</span> a <span class="ot">-&gt;</span> <span class="dt">TL.Text</span>
  show x <span class="fu">=</span> TB.toLazyText (shows x <span class="st">&quot;&quot;</span>)</code></pre></div>
<p>The various builtin types have builder objects implemented by Buildable that efficiently render to Text.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Integer</span> <span class="kw">where</span>
  showsPrec _ n f <span class="fu">=</span> build n <span class="fu">&lt;&gt;</span> f

<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Float</span> <span class="kw">where</span>
  showsPrec _ n f <span class="fu">=</span> build n <span class="fu">&lt;&gt;</span> f

<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Double</span> <span class="kw">where</span>
  showsPrec _ n f <span class="fu">=</span> build n <span class="fu">&lt;&gt;</span> f

<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Bool</span> <span class="kw">where</span>
  showsPrec _ <span class="dt">True</span> <span class="fu">=</span> showText <span class="st">&quot;True&quot;</span>
  showsPrec _ <span class="dt">False</span> <span class="fu">=</span> showText <span class="st">&quot;False&quot;</span></code></pre></div>
<p>For constructors with parameters there is a very mechanical translation that is exactly like how <code>deriving Show</code> works for String.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">con0 ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">ShowS</span>
con0 <span class="fu">=</span> showText

<span class="ot">con1 ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ShowS</span>
con1 con p x <span class="fu">=</span> 
  showParen (p <span class="fu">&gt;</span> appPrec) <span class="fu">$</span>
    showText con <span class="fu">.</span>
    showsPrec appPrec1 x

<span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Maybe</span> a) <span class="kw">where</span>
  showsPrec _  <span class="dt">Nothing</span> s <span class="fu">=</span> con0 <span class="st">&quot;Nothing&quot;</span> s
  showsPrec p (<span class="dt">Just</span> x) s <span class="fu">=</span> con1 <span class="st">&quot;Just &quot;</span> p x s</code></pre></div>
<p>Since it’s easy to generate the boilerplate instances, we can use Generics to auto-derive the instance for any sum/product type expressible in Haskell and have a DefaultSignature for <code>showsPrec</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Show</span> a <span class="kw">where</span>
<span class="ot">  showsPrec ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ShowS</span>
<span class="ot">  show ::</span> a <span class="ot">-&gt;</span> <span class="dt">TL.Text</span>

  default<span class="ot"> showsPrec ::</span> (<span class="dt">Generic</span> a, <span class="dt">GShow</span> (<span class="dt">Rep</span> a)) <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ShowS</span>
  showsPrec i x <span class="fu">=</span> gshowsPrec <span class="dt">Pref</span> i (from x)

  show x <span class="fu">=</span> TB.toLazyText (shows x <span class="st">&quot;&quot;</span>)</code></pre></div>
<p>And then some ugly (but mechanical) builder munging gives us an exact copy of GHC’s show format. The little known <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#deriving-any-other-class"><code>-XDeriveAnyClass</code></a> can be used to derive any other class that has an empty minimal set or uses DefaultSignatures and Generic instances to implement methods.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">GShow</span> f <span class="kw">where</span>
<span class="ot">  gshowsPrec ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">ShowS</span>
<span class="ot">  basic ::</span> f a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
  basic _ <span class="fu">=</span> <span class="dt">False</span>

<span class="kw">instance</span>  <span class="dt">GShow</span> <span class="dt">U1</span> <span class="kw">where</span>
  gshowsPrec _ _ _ <span class="fu">=</span> id
  basic _ <span class="fu">=</span> <span class="dt">True</span>

<span class="kw">instance</span> <span class="dt">Show</span> c <span class="ot">=&gt;</span> <span class="dt">GShow</span> (<span class="dt">K1</span> i c) <span class="kw">where</span>
  gshowsPrec _ i (<span class="dt">K1</span> fp) <span class="fu">=</span> showsPrec i fp

<span class="kw">instance</span> (<span class="dt">GShow</span> f, <span class="dt">Constructor</span> c) <span class="ot">=&gt;</span> <span class="dt">GShow</span> (<span class="dt">M1</span> <span class="dt">C</span> c f) <span class="kw">where</span>
  gshowsPrec t i c<span class="fu">@</span>(<span class="dt">M1</span> fp) 
    <span class="fu">|</span> conIsRecord c <span class="fu">=</span> 
          showString (conName c)
        <span class="fu">.</span> showChar <span class="ch">&#39; &#39;</span>
        <span class="fu">.</span> showBraces (gshowsPrec <span class="dt">Rec</span> i fp)

    <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">case</span> conFixity c <span class="kw">of</span>
      <span class="dt">Prefix</span> <span class="ot">-&gt;</span> showParen (i <span class="fu">&gt;</span> appPrec <span class="fu">&amp;&amp;</span> not (basic fp)) <span class="fu">$</span>
          showString (conName c)
        <span class="fu">.</span> <span class="kw">if</span> basic fp <span class="kw">then</span> id <span class="kw">else</span> showChar <span class="ch">&#39; &#39;</span>
        <span class="fu">.</span> gshowsPrec t appPrec1 fp

      <span class="dt">Infix</span> _ m <span class="ot">-&gt;</span> showParen (i <span class="fu">&gt;</span> m) <span class="fu">$</span> 
        showBraces (gshowsPrec t m fp)

<span class="kw">instance</span> (<span class="dt">GShow</span> f, <span class="dt">Selector</span> c) <span class="ot">=&gt;</span> <span class="dt">GShow</span> (<span class="dt">M1</span> <span class="dt">S</span> c f) <span class="kw">where</span>
  gshowsPrec t i c<span class="fu">@</span>(<span class="dt">M1</span> fp) <span class="fu">=</span> <span class="kw">case</span> t <span class="kw">of</span>
    <span class="dt">Pref</span>    <span class="ot">-&gt;</span> gshowsPrec t i fp
    <span class="dt">Inf</span> _   <span class="ot">-&gt;</span> gshowsPrec t i fp
    <span class="dt">Rec</span>     <span class="ot">-&gt;</span>
        showString (selName c)
      <span class="fu">.</span> showText <span class="st">&quot; = &quot;</span>
      <span class="fu">.</span> gshowsPrec t i fp

<span class="kw">instance</span> (<span class="dt">GShow</span> f) <span class="ot">=&gt;</span> <span class="dt">GShow</span> (<span class="dt">M1</span> <span class="dt">D</span> c f) <span class="kw">where</span>
  gshowsPrec t i (<span class="dt">M1</span> fp) <span class="fu">=</span> gshowsPrec t i fp

<span class="kw">instance</span> (<span class="dt">GShow</span> f, <span class="dt">GShow</span> g) <span class="ot">=&gt;</span> <span class="dt">GShow</span> (f <span class="fu">:+:</span> g) <span class="kw">where</span>
  gshowsPrec t i (<span class="dt">L1</span> fp) <span class="fu">=</span> gshowsPrec t i fp
  gshowsPrec t i (<span class="dt">R1</span> fp) <span class="fu">=</span> gshowsPrec t i fp

<span class="kw">instance</span> (<span class="dt">GShow</span> a, <span class="dt">GShow</span> b) <span class="ot">=&gt;</span> <span class="dt">GShow</span> (a <span class="fu">:*:</span> b) <span class="kw">where</span>
  gshowsPrec t<span class="fu">@</span><span class="dt">Rec</span> n (a <span class="fu">:*:</span> b) <span class="fu">=</span>
      gshowsPrec t n a 
    <span class="fu">.</span> showText <span class="st">&quot;, &quot;</span>
    <span class="fu">.</span> gshowsPrec t n b

  gshowsPrec t<span class="fu">@</span><span class="dt">Pref</span> n (a <span class="fu">:*:</span> b) <span class="fu">=</span>
      gshowsPrec t (n<span class="fu">+</span><span class="dv">1</span>) a 
    <span class="fu">.</span> showChar <span class="ch">&#39; &#39;</span>
    <span class="fu">.</span> gshowsPrec t (n<span class="fu">+</span><span class="dv">1</span>) b

  gshowsPrec t<span class="fu">@</span>(<span class="dt">Inf</span> s) n (a <span class="fu">:*:</span> b) <span class="fu">=</span>
      gshowsPrec t n a 
    <span class="fu">.</span> showText s 
    <span class="fu">.</span> gshowsPrec t n b</code></pre></div>
<p>And there we have it, a fixed show function that is drop-in compatible with the existing format but uses Text…</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">show<span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Text</span></code></pre></div>
<p>… and has automatic deriving.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">List</span> a 
  <span class="fu">=</span> <span class="dt">Nil</span>
  <span class="fu">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)
  <span class="kw">deriving</span> (<span class="dt">Generic</span>, <span class="dt">Print.Show</span>)</code></pre></div>
<p>We can even go so far as to tell GHCi to use our custom function at the Repl by adding the following to our projects <code>.ghci</code> file.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Print</span>
<span class="fu">:</span>set <span class="fu">-</span>interactive<span class="fu">-</span>print<span class="fu">=</span>Print.print</code></pre></div>
<p>However GHC’s defaulting mechanism has a bunch of ad-hoc specializations for wired-in classes that don’t work for user-defined clases. If we type in an under-specified expression for Show, GHC will just splice in a show dictionary for the unit type <code>Show ()</code> if it can’t figure out an appropriate dictionary.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> print <span class="dt">Nothing</span>

<span class="fu">====================</span> <span class="dt">Simplified</span> expression <span class="fu">====================</span>
bindIO
  (ghciStepIO
     <span class="fu">$</span>fGHCiSandboxIOIO (print (<span class="fu">$</span>fShowMaybe <span class="fu">$</span>fShow()) (<span class="dt">Nothing</span>)))
  (\ (<span class="ot">it ::</span> ()) <span class="ot">-&gt;</span> returnIO (<span class="fu">:</span> it ([])))</code></pre></div>
<p>For our implementation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> print <span class="dt">Nothing</span>

<span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">3</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span>
    <span class="dt">No</span> <span class="kw">instance</span> for (<span class="dt">Show</span> a0) arising from a use <span class="kw">of</span> ‘print’
    <span class="dt">The</span> <span class="kw">type</span> variable ‘a0’ is ambiguous
    <span class="dt">Note</span><span class="fu">:</span> there are several potential instances<span class="fu">:</span>
      <span class="kw">instance</span> (<span class="dt">Show</span> a, <span class="dt">Show</span> b) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Either</span> a b)
        <span class="co">-- Defined at Print.hs:233:10</span>
      <span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Maybe</span> a) <span class="co">-- Defined at Print.hs:229:10</span>
      <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Int16</span> <span class="co">-- Defined at Print.hs:160:10</span>
      <span class="fu">...</span>plus <span class="dv">27</span> others
    <span class="dt">In</span> the expression<span class="fu">:</span> print <span class="dt">Nothing</span>
    <span class="dt">In</span> an equation for ‘it’<span class="fu">:</span> it <span class="fu">=</span> print <span class="dt">Nothing</span></code></pre></div>
<p>There’s currently no way to do this for a custom Show type. This implementation also requires a <code>Generic</code> instance and several language extensions. This is the hard limit to how far we can go in “user space”.</p>
<h3 id="implementation">Implementation</h3>
<p>What we can prototype with Generics today is not hard to translate over into a builtin deriving mechanism inside the compiler tomorrow. In fact we can create a compatibility layer so close the existing Show class deriving that we reuse all of it’s logic sans the type changes.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Print</span> (
  <span class="dt">Show</span>(showsPrec, show),
  <span class="dt">ShowS</span>,
  showChar,
  showText,
  showList,
  showList__,
  showParen,
  shows,
) <span class="kw">where</span></code></pre></div>
<p>Right now in GHC there is a <code>hasBuiltinDeriving</code> that checks if the derived class is one of the blessed “builtins” that has a prescription for deriving a class instance for it. The blessed classes include:</p>
<table>
<thead>
<tr class="header">
<th align="left"><strong>Class</strong></th>
<th align="left"><strong>GHC Function</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Eq</td>
<td align="left"><a href="https://github.com/ghc/ghc/blob/master/compiler/typecheck/TcGenDeriv.hs#L192">gen_Eq_binds</a></td>
</tr>
<tr class="even">
<td align="left">Ord</td>
<td align="left"><a href="https://github.com/ghc/ghc/blob/master/compiler/typecheck/TcGenDeriv.hs#L361">gen_Ord_binds</a></td>
</tr>
<tr class="odd">
<td align="left">Enum</td>
<td align="left"><a href="https://github.com/ghc/ghc/blob/master/compiler/typecheck/TcGenDeriv.hs#L587">gen_Enum_binds</a></td>
</tr>
<tr class="even">
<td align="left">Bounded</td>
<td align="left"><a href="https://github.com/ghc/ghc/blob/master/compiler/typecheck/TcGenDeriv.hs#L667">gen_Bounded_binds</a></td>
</tr>
<tr class="odd">
<td align="left">Ix</td>
<td align="left"><a href="https://github.com/ghc/ghc/blob/master/compiler/typecheck/TcGenDeriv.hs#L754">gen_Ix_binds</a></td>
</tr>
<tr class="even">
<td align="left">Show</td>
<td align="left"><a href="https://github.com/ghc/ghc/blob/master/compiler/typecheck/TcGenDeriv.hs#L1114">gen_Show_binds</a></td>
</tr>
<tr class="odd">
<td align="left">Read</td>
<td align="left"><a href="https://github.com/ghc/ghc/blob/master/compiler/typecheck/TcGenDeriv.hs#L946">gen_Read_binds</a></td>
</tr>
<tr class="even">
<td align="left">Data</td>
<td align="left"><a href="https://github.com/ghc/ghc/blob/master/compiler/typecheck/TcGenDeriv.hs#L1276">gen_Data_binds</a></td>
</tr>
<tr class="odd">
<td align="left">Functor</td>
<td align="left"><a href="https://github.com/ghc/ghc/blob/master/compiler/typecheck/TcGenDeriv.hs#L1553">gen_Functor_binds</a></td>
</tr>
<tr class="even">
<td align="left">Foldable</td>
<td align="left"><a href="https://github.com/ghc/ghc/blob/master/compiler/typecheck/TcGenDeriv.hs#L1870">gen_Foldable_binds</a></td>
</tr>
<tr class="odd">
<td align="left">Traversable</td>
<td align="left"><a href="https://github.com/ghc/ghc/blob/master/compiler/typecheck/TcGenDeriv.hs#L1994">gen_Traversable_binds</a></td>
</tr>
<tr class="even">
<td align="left">Lift</td>
<td align="left"><a href="https://github.com/ghc/ghc/blob/master/compiler/typecheck/TcGenDeriv.hs#L1994">gen_Lift_binds</a></td>
</tr>
<tr class="odd">
<td align="left">Generic</td>
<td align="left"><a href="https://github.com/ghc/ghc/blob/master/compiler/typecheck/TcGenGenerics.hs#L66">gen_Generic_binds</a></td>
</tr>
<tr class="even">
<td align="left">Typeable</td>
<td align="left"><a href="https://github.com/ghc/ghc/blob/master/compiler/typecheck/TcTypeable.hs#L95">mkTypeableBinds</a></td>
</tr>
</tbody>
</table>
<p>If the public interface for generating a Text-Show instance recycled the same structure as String version, we could very easily write <code>gen_ShowText_binds</code> and plug this into the compiler to derive a new (distinct) text Show that wouldn’t break compatibility.</p>
<p>However, at the moment <code>text</code> isn’t in GHC’s boot libraries and can’t be made into <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/ghc-7.10.3/TysWiredIn.html">wired-in type</a> which would be necessary to add the new deriving mechanism to <code>TcGenDeriv.hs</code>. So that’s as far as we can go in 2016, there’s probably a fairly clear path to removing Stringy-Show if <code>text</code> were to at some point become accessible to GHC internals.</p>
<!--

### The Future

If one is working in industrial Haskell and plans to be in this space for
several decades, there's a certain set of questions The Thoughtful Haskell
programmer should consider.

1. In the year 2027 do I still want to be writing hundreds of lines of
   boilerplate Haskell in every module to route around decisions made in 1997?
2. What time is better than now to diverge from these "worst practices" and remove them
   entirely from our compiler and language instead of simply routing around the
   problem?
3. What's the minimal viable set of packages we need to move over to Modern
   Haskell to satisfy the needs of industrial users?

-->]]></summary>
</entry>
<entry>
    <title>Building a Better Custom Haskell Prelude</title>
    <link href="http://www.stephendiehl.com/posts/protolude.html" />
    <id>http://www.stephendiehl.com/posts/protolude.html</id>
    <published>2016-04-07T00:00:00Z</published>
    <updated>2016-04-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="building-a-better-custom-haskell-prelude">Building a Better Custom Haskell Prelude</h3>
<p>The Haskell Prelude is the default import into all Haskell modules, it provides an endless number of ways to shoot ourselves in the foot and historical cruft that can’t be removed. While it is difficult to fix upstream, we can however remove the Prelude entirely on a project-level and replace it with a more sensible set of defaults using the <code>-XNoImplicitPrelude</code> language extension.</p>
<p>There are two philosophies on building new Preludes:</p>
<ul>
<li><em>Big Vehicle Prelude</em> - Fix most of the deficiencies in the Prelude by introducing new abstractions that replace large portions of the basic types and class, and generally redefine the way we write Haskell. See <a href="https://hackage.haskell.org/package/numeric-prelude">numeric-prelude</a>.</li>
<li><em>Small Vehicle Prelude</em> - Fix the broken parts of the Prelude by building on existing types and classes and masking broken bits. See <a href="https://hackage.haskell.org/package/numeric-prelude">basic-prelude</a>.</li>
</ul>
<p>I don’t prescribe to the large vehicle approach, a lot of the default Prelude is not ideal but good enough to get the job done. And interoperability with the rest of the ecosystem, which typically uses default Base and Prelude, is incredibly important.</p>
<p>In <a href="http://www.stephendiehl.com/posts/production.html">previous posts</a> I’ve written about how rolling our own small-vehicle Prelude is a good idea for large teams working in industry but I left it somewhat ambiguous about what to include. Obviously everyone’s company is different so I thought I’d expand on what I consider a sensible set of defaults that one could use to then build a custom Prelude. We’ll call this a <em>Protolude</em>.</p>
<p style="text-align:center">
<strong><a href="https://github.com/sdiehl/protolude">Git Project</a></strong>
</p>
<h4 id="module-structure">Module Structure</h4>
<p>The basic module structure is consists of a main module reexport which we’ll dump everything in called <code>X</code>. And various miscellaneous functions which we’ll reexport from the root module. Off of this we’ll have several utilities modules which have domain specific functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span>

<span class="kw">module</span> <span class="dt">Protolude</span> (
  <span class="kw">module</span> <span class="dt">X</span>,
  identity,
  bool,
  (<span class="fu">&amp;</span>),
  uncons,
  applyN,
  print,

  <span class="dt">LText</span>,
  <span class="dt">LByteString</span>,
) <span class="kw">where</span>

<span class="kw">import qualified</span> <span class="dt">Prelude</span> <span class="kw">as</span> <span class="dt">P</span>

<span class="kw">import qualified</span> <span class="dt">List</span> <span class="kw">as</span> <span class="dt">X</span>
<span class="kw">import qualified</span> <span class="dt">Show</span> <span class="kw">as</span> <span class="dt">X</span>
<span class="kw">import qualified</span> <span class="dt">Bool</span> <span class="kw">as</span> <span class="dt">X</span>
<span class="kw">import qualified</span> <span class="dt">Debug</span> <span class="kw">as</span> <span class="dt">X</span>
<span class="kw">import qualified</span> <span class="dt">Monad</span> <span class="kw">as</span> <span class="dt">X</span>
<span class="kw">import qualified</span> <span class="dt">Applicative</span> <span class="kw">as</span> <span class="dt">X</span></code></pre></div>
<h4 id="base-types">Base Types</h4>
<p>The Basic types (<code>Int</code>, <code>Integer</code>, <code>Float</code>, <code>Char</code>) we reexport wholesale along with their associated functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Base types</span>
<span class="kw">import </span><span class="dt">Data.Int</span> <span class="kw">as</span> <span class="dt">X</span>
<span class="kw">import </span><span class="dt">Data.Bits</span> <span class="kw">as</span> <span class="dt">X</span>
<span class="kw">import </span><span class="dt">Data.Word</span> <span class="kw">as</span> <span class="dt">X</span>
<span class="kw">import </span><span class="dt">Data.Bool</span> <span class="kw">as</span> <span class="dt">X</span> <span class="kw">hiding</span> (bool)
<span class="kw">import </span><span class="dt">Data.Char</span> <span class="kw">as</span> <span class="dt">X</span> (<span class="dt">Char</span>)
<span class="kw">import </span><span class="dt">Data.Maybe</span> <span class="kw">as</span> <span class="dt">X</span> <span class="kw">hiding</span> (fromJust)
<span class="kw">import </span><span class="dt">Data.Either</span> <span class="kw">as</span> <span class="dt">X</span>
<span class="kw">import </span><span class="dt">Data.Complex</span> <span class="kw">as</span> <span class="dt">X</span>

<span class="kw">import </span><span class="dt">Data.Function</span> <span class="kw">as</span> <span class="dt">X</span> (
    id
  , const
  , (<span class="fu">.</span>)
  , flip
  , fix
  , on
  )</code></pre></div>
<p>We define the flipped application operator for GHC &lt; 7.10 which does not provide this be default.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&amp;) ::</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b
x <span class="fu">&amp;</span> f <span class="fu">=</span> f x</code></pre></div>
<p>We rename the <code>id</code> function to identity since it’s far more likely we’ll have variable names called <code>id</code> over the identity function. This is a contentious point and your mileage may vary with this change.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">identity ::</span> a <span class="ot">-&gt;</span> a
identity x <span class="fu">=</span> x</code></pre></div>
<p>The bool function (the combinator analogue of <code>maybe</code> and <code>either</code>) is provided by GHC 7.10, but we reexport it for earlier versions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bool ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a
bool f t b <span class="fu">=</span> <span class="kw">if</span> b <span class="kw">then</span> t <span class="kw">else</span> f</code></pre></div>
<p>The <code>uncons</code> function is not provided by default, but it unpacks a list into a Maybe tuple containing the head in the first tuple parameter if it exists.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">uncons ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, [a])
uncons []     <span class="fu">=</span> <span class="dt">Nothing</span>
uncons (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Just</span> (x, xs)</code></pre></div>
<p>The <code>applyN</code> function takes a function and a count and applies it <code>n</code> number of times.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">applyN ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
applyN n f <span class="fu">=</span> X.foldr (<span class="fu">.</span>) id (X.replicate n f)</code></pre></div>
<p>And then we reexport various boolean combinators for working with branching monadic logic.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">whenM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()
whenM p m <span class="fu">=</span>
  p <span class="fu">&gt;&gt;=</span> flip when m

<span class="ot">unlessM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()
unlessM p m <span class="fu">=</span>
  p <span class="fu">&gt;&gt;=</span> flip unless m

<span class="ot">ifM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m a
ifM p x y <span class="fu">=</span> p <span class="fu">&gt;&gt;=</span> \b <span class="ot">-&gt;</span> <span class="kw">if</span> b <span class="kw">then</span> x <span class="kw">else</span> y

<span class="ot">guardM ::</span> <span class="dt">MonadPlus</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m ()
guardM f <span class="fu">=</span> guard <span class="fu">=&lt;&lt;</span> f</code></pre></div>
<h4 id="safe">Safe</h4>
<p><a href="https://hackage.haskell.org/package/safe">Safe</a> provides Maybe versions of many of the various partial functions (<code>head</code>, <code>tail</code>) that are shipped by default. Wrapping it up in a Maybe is widely considered the right approach and if Haskell were designed today, they would not be present.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Maybe&#39;ized version of partial functions</span>
<span class="kw">import </span><span class="dt">Safe</span> <span class="kw">as</span> <span class="dt">X</span> (
  headMay,
  initMay,
  tailMay
  )</code></pre></div>
<h4 id="debugging">Debugging</h4>
<p>Various debugging and trap commands are still provided since they are useful for partial code and various fatal program logic. However now they have a warning emitted by the compiler if they are left in place, with position information about where they are used. This can be toggled between production code and debugging code.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# WARNING undefined &quot;&#39;undefined&#39; remains in code&quot; #-}</span>
undefined<span class="ot"> ::</span> a
undefined <span class="fu">=</span> P.undefined

<span class="ot">{-# WARNING error &quot;&#39;error&#39; remains in code&quot; #-}</span>
error<span class="ot"> ::</span> <span class="dt">P.String</span> <span class="ot">-&gt;</span> a
error <span class="fu">=</span> P.error

<span class="ot">{-# WARNING trace &quot;&#39;trace&#39; remains in code&quot; #-}</span>
<span class="ot">trace ::</span> <span class="dt">P.String</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
trace <span class="fu">=</span> T.trace

<span class="ot">{-# WARNING traceShow &quot;&#39;traceShow&#39; remains in code&quot; #-}</span>
<span class="ot">traceShow ::</span> <span class="dt">P.Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a
traceShow a <span class="fu">=</span> T.trace (P.show a) a

<span class="ot">{-# WARNING traceShowM &quot;&#39;traceShowM&#39; remains in code&quot; #-}</span>
<span class="ot">traceShowM ::</span> (<span class="dt">P.Show</span> a, <span class="dt">P.Monad</span> m) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> m ()
traceShowM a <span class="fu">=</span> T.traceM (P.show a)

<span class="ot">{-# WARNING traceM &quot;&#39;traceM&#39; remains in code&quot; #-}</span>
<span class="ot">traceM ::</span> <span class="dt">P.Monad</span> m <span class="ot">=&gt;</span> <span class="dt">P.String</span> <span class="ot">-&gt;</span> m ()
traceM <span class="fu">=</span> T.traceM

<span class="ot">{-# WARNING traceIO &quot;&#39;traceIO&#39; remains in code&quot; #-}</span>
<span class="ot">traceIO ::</span> <span class="dt">P.String</span> <span class="ot">-&gt;</span> <span class="dt">P.IO</span> ()
traceIO <span class="fu">=</span> T.traceIO

<span class="ot">{-# WARNING notImplemented &quot;&#39;notImplemented&#39; remains in code&quot; #-}</span>
<span class="ot">notImplemented ::</span> a
notImplemented <span class="fu">=</span> P.error <span class="st">&quot;Not implemented&quot;</span></code></pre></div>
<h4 id="either">Either</h4>
<p>Various either combinators to convert between Maybe and Either probably should be provided but are not, there are four various combinations of these. Handling a maybe which happens to have a monoidal instance for mempty in Left is also fairly common task.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">leftToMaybe ::</span> <span class="dt">Either</span> l r <span class="ot">-&gt;</span> <span class="dt">Maybe</span> l
leftToMaybe <span class="fu">=</span> either <span class="dt">Just</span> (const <span class="dt">Nothing</span>)

<span class="ot">rightToMaybe ::</span> <span class="dt">Either</span> l r <span class="ot">-&gt;</span> <span class="dt">Maybe</span> r
rightToMaybe <span class="fu">=</span> either (const <span class="dt">Nothing</span>) <span class="dt">Just</span>

<span class="ot">maybeToRight ::</span> l <span class="ot">-&gt;</span> <span class="dt">Maybe</span> r <span class="ot">-&gt;</span> <span class="dt">Either</span> l r
maybeToRight l <span class="fu">=</span> maybe (<span class="dt">Left</span> l) <span class="dt">Right</span>

<span class="ot">maybeToLeft ::</span> r <span class="ot">-&gt;</span> <span class="dt">Maybe</span> l <span class="ot">-&gt;</span> <span class="dt">Either</span> l r
maybeToLeft r <span class="fu">=</span> maybe (<span class="dt">Right</span> r) <span class="dt">Left</span>

<span class="ot">maybeToEither ::</span> <span class="dt">Monoid</span> b <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> b
maybeToEither <span class="fu">=</span> maybe mempty</code></pre></div>
<h4 id="list">List</h4>
<p>The various list functions are exported wholesale excpet for the ones which are generalized by Foldable and Traversable. head is reexported as a total function written in terms of foldr. The <code>ordNub</code> function is accidentally quadratic in the Prelude is replaced by a logarithmic variant using a hashmap underneath.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">head<span class="ot"> ::</span> (<span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
head <span class="fu">=</span> foldr (\x _ <span class="ot">-&gt;</span> return x) <span class="dt">Nothing</span>

<span class="ot">sortOn ::</span> (<span class="dt">Ord</span> o) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> o) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
sortOn <span class="fu">=</span> sortBy <span class="fu">.</span> comparing

<span class="co">-- O(n * log n)</span>
<span class="ot">ordNub ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]
ordNub l <span class="fu">=</span> go Set.empty l
  <span class="kw">where</span>
    go _ []     <span class="fu">=</span> []
    go s (x<span class="fu">:</span>xs) <span class="fu">=</span>
      <span class="kw">if</span> x <span class="ot">`Set.member`</span> s
      <span class="kw">then</span> go s xs
      <span class="kw">else</span> x <span class="fu">:</span> go (Set.insert x s) xs</code></pre></div>
<h4 id="monad">Monad</h4>
<p>The core moand class, functions, and combinators are reexported wholesale. Variants like <code>mapM</code> are provided by <code>Data.Traversable</code> instead of <code>Control.Monad</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Monad</span> (
    <span class="dt">Monad</span>(<span class="fu">..</span>)
  , <span class="dt">MonadPlus</span>(<span class="fu">..</span>)

  , (<span class="fu">=&lt;&lt;</span>)
  , (<span class="fu">&gt;=&gt;</span>)
  , (<span class="fu">&lt;=&lt;</span>)
  , forever

  , join
  , mfilter
  , filterM
  , mapAndUnzipM
  , zipWithM
  , zipWithM_
  , foldM
  , foldM_
  , replicateM
  , replicateM_
  , concatMapM

  , guard
  , when
  , unless

  , liftM
  , liftM2
  , liftM3
  , liftM4
  , liftM5
  , liftM&#39;
  , liftM2&#39;
  , ap

  , (<span class="fu">&lt;$!&gt;</span>)
  ) <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Prelude</span> (concat, seq)
<span class="kw">import </span><span class="dt">Control.Monad</span>

<span class="ot">concatMapM ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m [b]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [b]
concatMapM f xs <span class="fu">=</span> liftM concat (mapM f xs)</code></pre></div>
<p>Strict versions of <code>liftM</code> are also provided by default since this is a common source of unexpected laziness.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">liftM&#39; ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m b
liftM&#39; <span class="fu">=</span> (<span class="fu">&lt;$!&gt;</span>)
<span class="ot">{-# INLINE liftM&#39; #-}</span>

<span class="ot">liftM2&#39; ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m c
liftM2&#39; f a b <span class="fu">=</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> a
  y <span class="ot">&lt;-</span> b
  <span class="kw">let</span> z <span class="fu">=</span> f x y
  z <span class="ot">`seq`</span> return z
<span class="ot">{-# INLINE liftM2&#39; #-}</span></code></pre></div>
<h4 id="applicative">Applicative</h4>
<p>The applicative module core types are reexported wholesale. Unlike in 7.8 we have the Applicative class in scope by default, as it should be in this day and age.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Applicatives</span>
<span class="kw">import </span><span class="dt">Control.Applicative</span> <span class="kw">as</span> <span class="dt">X</span> (
    <span class="dt">Applicative</span>(<span class="fu">..</span>)
  , <span class="dt">Alternative</span>(<span class="fu">..</span>)
  , <span class="dt">Const</span>(<span class="fu">..</span>)
  , <span class="dt">ZipList</span>(<span class="fu">..</span>)
  , (<span class="fu">&lt;**&gt;</span>)
  , liftA
  , liftA2
  , liftA3
  , optional
  )</code></pre></div>
<h4 id="typeclasses">Typeclasses</h4>
<p>The core GHC typeclasses for ordering and numeric tower are reexported wholesale. We also bring Traversable and Foldable into scope masking a few of the partial functions which generally should be avoided. Semiring is also common enough these days that it should be in scope implicitly.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Base typeclasses</span>
<span class="kw">import </span><span class="dt">Data.Eq</span> <span class="kw">as</span> <span class="dt">X</span>
<span class="kw">import </span><span class="dt">Data.Ord</span> <span class="kw">as</span> <span class="dt">X</span>
<span class="kw">import </span><span class="dt">Data.Monoid</span> <span class="kw">as</span> <span class="dt">X</span>
<span class="kw">import </span><span class="dt">Data.Traversable</span> <span class="kw">as</span> <span class="dt">X</span>
<span class="kw">import </span><span class="dt">Data.Foldable</span> <span class="kw">as</span> <span class="dt">X</span> <span class="kw">hiding</span> (
    foldr1
  , foldl1
  , maximum
  , maximumBy
  , minimum
  , minimumBy
  )
<span class="kw">import </span><span class="dt">Data.Semiring</span> <span class="kw">as</span> <span class="dt">X</span>
<span class="kw">import </span><span class="dt">Data.Functor.Identity</span> <span class="kw">as</span> <span class="dt">X</span>
<span class="kw">import </span><span class="dt">Data.Functor</span> <span class="kw">as</span> <span class="dt">X</span> (
    <span class="dt">Functor</span>(<span class="fu">..</span>)
  , (<span class="fu">$&gt;</span>)
  , (<span class="fu">&lt;$&gt;</span>)
  , void
  )</code></pre></div>
<h4 id="deepseq">Deepseq</h4>
<p>Deepseq is usually an important typeclass to derive for various usecases, and so we bring in the <code>deepseq</code> library and it’s various functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Deepseq</span>
<span class="kw">import </span><span class="dt">Control.DeepSeq</span> <span class="kw">as</span> <span class="dt">X</span> (
    <span class="dt">NFData</span>(<span class="fu">..</span>)
  , (<span class="fu">$!!</span>)
  , deepseq
  , force
  )</code></pre></div>
<h4 id="data-structures">Data Structures</h4>
<p>The core data structures provided by GHC are reexported, but with List we make sure to mask the partial functions, and operators are provided in more general interfaces.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Data structures</span>
<span class="kw">import </span><span class="dt">Data.Tuple</span> <span class="kw">as</span> <span class="dt">X</span>
<span class="kw">import </span><span class="dt">Data.List</span> <span class="kw">as</span> <span class="dt">X</span> (
    splitAt
  , break
  , intercalate
  , isPrefixOf
  , drop
  , filter
  , reverse
  , replicate
  )</code></pre></div>
<p>The containers library all provide functions which overlap with each other (lookup, insert, etc) so we just export the types for these structures so we can use them in signatures. On a module level these would then be typically imported using a qualified import like <code>import qualified Data.Map as Map</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">X</span> (<span class="dt">Map</span>)
<span class="kw">import </span><span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">X</span> (<span class="dt">Set</span>)
<span class="kw">import </span><span class="dt">Data.Sequence</span> <span class="kw">as</span> <span class="dt">X</span> (<span class="dt">Seq</span>)
<span class="kw">import </span><span class="dt">Data.IntMap</span> <span class="kw">as</span> <span class="dt">X</span> (<span class="dt">IntMap</span>)
<span class="kw">import </span><span class="dt">Data.IntSet</span> <span class="kw">as</span> <span class="dt">X</span> (<span class="dt">IntSet</span>)</code></pre></div>
<h4 id="monad-transformers">Monad Transformers</h4>
<p>The basic <code>mtl</code> transformer stack are usually ubiqitious in modern Haskell, specifically StateT, ReaderT and ExceptT. We don’t export all functions in these modules but just enough that most uses cases of the common transformers are brought into scope.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Monad transformers</span>
<span class="kw">import </span><span class="dt">Control.Monad.State</span> <span class="kw">as</span> <span class="dt">X</span> (
    <span class="dt">MonadState</span>,
    <span class="dt">State</span>,
    <span class="dt">StateT</span>,
    put,
    get,
    gets,
    modify,
    withState,

    runStateT,
    execStateT,
    evalStateT,
  )

<span class="kw">import </span><span class="dt">Control.Monad.Reader</span> <span class="kw">as</span> <span class="dt">X</span> (
    <span class="dt">MonadReader</span>,
    <span class="dt">Reader</span>,
    <span class="dt">ReaderT</span>,
    ask,
    asks,
    local,
    runReader,
    runReaderT,
  )

<span class="kw">import </span><span class="dt">Control.Monad.Except</span> <span class="kw">as</span> <span class="dt">X</span> (
    <span class="dt">MonadError</span>,
    <span class="dt">Except</span>,
    <span class="dt">ExceptT</span>,
    throwError,
    catchError,
    runExcept,
    runExceptT,
  )

<span class="kw">import </span><span class="dt">Control.Monad.Trans</span> <span class="kw">as</span> <span class="dt">X</span> (
    <span class="dt">MonadIO</span>,
    lift,
    liftIO,
  )</code></pre></div>
<h4 id="wired-in-types">Wired-In Types</h4>
<p>Several basic types (IO, Show) are necessary to do anything so we obviously bring these in. The <code>Exts</code> provides the various pointer types for working with FFI as well as the Constraint type which is somewhat common in the presence of <code>-XConstraintKinds</code> and more advanced type family techniques.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Base GHC types</span>
<span class="kw">import </span><span class="dt">GHC.IO</span> <span class="kw">as</span> <span class="dt">X</span> (<span class="dt">IO</span>)
<span class="kw">import </span><span class="dt">GHC.Num</span> <span class="kw">as</span> <span class="dt">X</span>
<span class="kw">import </span><span class="dt">GHC.Real</span> <span class="kw">as</span> <span class="dt">X</span>
<span class="kw">import </span><span class="dt">GHC.Float</span> <span class="kw">as</span> <span class="dt">X</span>
<span class="kw">import </span><span class="dt">GHC.Show</span> <span class="kw">as</span> <span class="dt">X</span>
<span class="kw">import </span><span class="dt">GHC.Exts</span> <span class="kw">as</span> <span class="dt">X</span> (
    <span class="dt">Constraint</span>
  , <span class="dt">Ptr</span>
  , <span class="dt">FunPtr</span>
  , the
  )</code></pre></div>
<h4 id="generics">Generics</h4>
<p>Generics are also ubiqitious in modern Haskell and the various typeclasses and type synonyms should be provided so that we can <code>-XDeriveGeneric</code> as well as implement default instances for Generic classes.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Generics</span>
<span class="kw">import </span><span class="dt">GHC.Generics</span> (
    <span class="dt">Generic</span>(<span class="fu">..</span>)
  , <span class="dt">Rep</span>
  , <span class="dt">K1</span>(<span class="fu">..</span>)
  , <span class="dt">M1</span>(<span class="fu">..</span>)
  , <span class="dt">U1</span>(<span class="fu">..</span>)
  , <span class="dt">V1</span>
  , <span class="dt">D1</span>
  , <span class="dt">C1</span>
  , <span class="dt">S1</span>
  , (<span class="fu">:+:</span>)
  , (<span class="fu">:*:</span>)
  , <span class="dt">NoSelector</span>
  , <span class="dt">Rec0</span>
  , <span class="dt">Par0</span>
  , <span class="dt">Constructor</span>(<span class="fu">..</span>)
  , <span class="dt">Selector</span>(<span class="fu">..</span>)
  , <span class="dt">Arity</span>(<span class="fu">..</span>)
  , <span class="dt">Fixity</span>(<span class="fu">..</span>)
  )</code></pre></div>
<h4 id="string-types">String Types</h4>
<p>Strings in Haskell are a giant fractal of suffering. In a just world, we would all just use Text most of the time, and ByteString when we needed to deal with network but we don’t live in that world an large portions of Hasell ecosystem still use the wildly-inefficient linked-list of Char.</p>
<p>Controversially we just reexport the Lazy text type as a type synonym <code>LText</code> and provide the <code>string-conv</code> library function <code>toS</code> which automatically converts between any two string types using a multiparam typeclass. String heavy programs might also consider reexporting the various Text and ByteString builder classes.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- ByteString</span>
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy</span>
<span class="kw">import qualified</span> <span class="dt">Data.ByteString</span> <span class="kw">as</span> <span class="dt">X</span> (<span class="dt">ByteString</span>)

<span class="co">-- Text</span>
<span class="kw">import </span><span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">X</span> (<span class="dt">Text</span>)
<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text.IO</span>
<span class="kw">import </span><span class="dt">Text.Printf</span> <span class="kw">as</span> <span class="dt">X</span> (printf)

<span class="kw">import </span><span class="dt">Data.Text.Lazy</span> (
    toStrict
  , fromStrict
  )

<span class="kw">import </span><span class="dt">Data.String.Conv</span> <span class="kw">as</span> <span class="dt">X</span> (
    strConv
  , toS
  , toSL
  , <span class="dt">Leniency</span>(<span class="fu">..</span>)
  )

<span class="co">-- Printf</span>
<span class="kw">import </span><span class="dt">Text.Printf</span> <span class="kw">as</span> <span class="dt">Exports</span> (
    <span class="dt">PrintfArg</span>
  , printf
  , hPrintf
  )</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">LText</span> <span class="fu">=</span> <span class="dt">Data.Text.Lazy.Text</span>
<span class="kw">type</span> <span class="dt">LByteString</span> <span class="fu">=</span> <span class="dt">Data.ByteString.Lazy.ByteString</span></code></pre></div>
<h4 id="io">IO</h4>
<p>IO is essentially obvious, so we reexport the various IO operations and command low-level command line option and file handler functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- IO</span>
<span class="kw">import </span><span class="dt">System.Exit</span> <span class="kw">as</span> <span class="dt">X</span>
<span class="kw">import </span><span class="dt">System.Environment</span> <span class="kw">as</span> <span class="dt">X</span> (getArgs)
<span class="kw">import </span><span class="dt">System.IO</span> <span class="kw">as</span> <span class="dt">X</span> (
    <span class="dt">Handle</span>
  , hClose
  )</code></pre></div>
<p>In a just world we’d have a generic <code>putStr</code> that didn’t require us to put boilerplate imports in every damn module just to print a string, but alas we don’t live in that world. But we can implement a basic class to do this for the common text representation and then just export the class instead of the four libraries that all provide the same interface.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Print</span> a <span class="kw">where</span>
<span class="ot">  putStr ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> m ()
<span class="ot">  putStrLn ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> m ()

<span class="kw">instance</span> <span class="dt">Print</span> <span class="dt">T.Text</span> <span class="kw">where</span>
  putStr <span class="fu">=</span> liftIO <span class="fu">.</span> T.putStr
  putStrLn <span class="fu">=</span> liftIO <span class="fu">.</span> T.putStrLn

<span class="kw">instance</span> <span class="dt">Print</span> <span class="dt">TL.Text</span> <span class="kw">where</span>
  putStr <span class="fu">=</span> liftIO <span class="fu">.</span> TL.putStr
  putStrLn <span class="fu">=</span> liftIO <span class="fu">.</span> TL.putStrLn

<span class="kw">instance</span> <span class="dt">Print</span> <span class="dt">BS.ByteString</span> <span class="kw">where</span>
  putStr <span class="fu">=</span> liftIO <span class="fu">.</span> BS.putStr
  putStrLn <span class="fu">=</span> liftIO <span class="fu">.</span> BS.putStrLn

<span class="kw">instance</span> <span class="dt">Print</span> <span class="dt">BL.ByteString</span> <span class="kw">where</span>
  putStr <span class="fu">=</span> liftIO <span class="fu">.</span> BL.putStr
  putStrLn <span class="fu">=</span> liftIO <span class="fu">.</span> BL.putStrLn

<span class="kw">instance</span> <span class="dt">Print</span> [<span class="dt">Char</span>] <span class="kw">where</span>
  putStr <span class="fu">=</span> liftIO <span class="fu">.</span> Prelude.putStr
  putStrLn <span class="fu">=</span> liftIO <span class="fu">.</span> Prelude.putStrLn

<span class="co">-- For forcing type inference</span>
<span class="ot">putText ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> m ()
putText <span class="fu">=</span> putStrLn
<span class="ot">{-# SPECIALIZE putText :: T.Text -&gt; IO () #-}</span>

<span class="ot">putLText ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">TL.Text</span> <span class="ot">-&gt;</span> m ()
putLText <span class="fu">=</span> putStrLn
<span class="ot">{-# SPECIALIZE putLText :: TL.Text -&gt; IO () #-}</span></code></pre></div>
<p>Like the functions above we automatically lift print and the various string IO operations into a generic <code>MonadIO</code> instance so we can embed them in transformer stacks.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">print<span class="ot"> ::</span> (<span class="dt">X.MonadIO</span> m, <span class="dt">P.Show</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> m ()
print <span class="fu">=</span> liftIO <span class="fu">.</span> P.print</code></pre></div>
<h4 id="concurrency">Concurrency</h4>
<p>The basic thread primitives are common enough that they should be brought into scope implicitly. The <code>async</code> library provides the preferred method of interacting with concurrent logic and so we export this wholesale as well.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- ST</span>
<span class="kw">import </span><span class="dt">Control.Monad.ST</span> <span class="kw">as</span> <span class="dt">ST</span>

<span class="co">-- Concurrency and Parallelism</span>
<span class="kw">import </span><span class="dt">Control.Exception</span> <span class="kw">as</span> <span class="dt">X</span>
<span class="kw">import </span><span class="dt">Control.Concurrent</span> <span class="kw">as</span> <span class="dt">X</span>
<span class="kw">import </span><span class="dt">Control.Concurrent.Async</span> <span class="kw">as</span> <span class="dt">X</span></code></pre></div>
<hr/>
<p>Now in our cabal file we can just add:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">default<span class="fu">-</span>extensions<span class="fu">:</span>
  <span class="dt">NoImplicitPrelude</span></code></pre></div>
<p>And then include your sensible Prelude in your modules. You can escape hatch out of this choice on a module-by-module basis by just pulling in Prelude explicitly using <code>import Prelude</code>.</p>
<p>So that’s the basic proto-prelude I use for my large multi-cabal-file projects. Your mileage by vary on some of these choices, but I consider this a pretty sensible and practical foundational set of functions and types that should at least provide a good starting point.</p>]]></summary>
</entry>
<entry>
    <title>Sunsetting "What I Wish I Knew"</title>
    <link href="http://www.stephendiehl.com/posts/docs.html" />
    <id>http://www.stephendiehl.com/posts/docs.html</id>
    <published>2016-03-25T00:00:00Z</published>
    <updated>2016-03-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="sunsetting-what-i-wish-i-knew">Sunsetting “What I Wish I Knew”</h3>
<p>Today I finally cut a new release of “What I Wish I Knew When Learning Haskell”. I added a lot of new modern topics, stack projects for all example source code, a new cross-referenced language extension guide and a lovely new stylesheet. I’m happy with this release, but it’s likely the last version I’ll write.</p>
<p style="text-align:center">
Version 2.3 : <strong><a href="http://dev.stephendiehl.com/hask/">HTML</a></strong> <strong><a href="http://dev.stephendiehl.com/hask/tutorial.pdf">PDF</a></strong> <strong><a href="https://github.com/sdiehl/wiwinwlh">SRC</a></strong>
</p>
<p>It started out literally as, as the namesake implies, a list of things that I wish I knew when learning Haskell. That was almost six years ago though now, I wrote the first draft on a whim in a little coffee shop in Harvard Square after drinking too many espressos. That was a different time for the language and Haskell really suffered from the problem that it was hard to get an overview of the ecosystem and current practices. Now a couple years later now I consistently get hundreds of emails telling me it’s been invaluable for many people in helping them transition from the novice books like <em>Learn You a Haskell</em> to working on full Modern Haskell. Which is good, if a few more people have gotten into Haskell because of it I consider that a success.</p>
<p>To make a contrived metaphor: Haskell has a lot of parallels to nuclear fusion work. It has the capacity to change the world, is always 10-15 years out from widespread use and requires an enormous influx of time and capital to make it viable. I’ve always felt <em>documentation is the best way to bootstrap this process</em> and this has been my motivation for writing. The more people who can learn the language and use it in industry the more resources get poured back into letting people have free time to contribute back. Just like a reaction, eventually this will become self-sustaining and produce more energy than it takes in.</p>
<p>But personally now I’m getting older and with that you find yourself reflecting on what matters and what you want to spend your finite number of days doing. I have a lot of other projects that I’m excited about working on over the next couple years, but maintaining unofficial documentation for a growing programming language ecosystem just isn’t a great time investment anymore.</p>]]></summary>
</entry>
<entry>
    <title>Cooking Classes with Datatype Generic Programming</title>
    <link href="http://www.stephendiehl.com/posts/generics.html" />
    <id>http://www.stephendiehl.com/posts/generics.html</id>
    <published>2016-03-03T00:00:00Z</published>
    <updated>2016-03-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="cooking-classes-with-datatype-generic-programming">Cooking Classes with Datatype Generic Programming</h3>
<p>Haskell Generics are a somewhat misunderstood topic but are an extremely powerful technique for writing reusable and comparable interfaces across an enormous universe of types with very little effort. They are probably my favorite example of the advantages of an expressive type system endows us with.</p>
<p>Source for examples code is <a href="https://github.com/sdiehl/cooking-generics">available here</a>.</p>
<p>Generics are a form of <em>datatype-generic programming</em>, which although the namesake has some similarity to Java Generics they are different concepts entirely. GHC’s implementation of Generics fall out of the simple observation that all datatypes in Haskell can be written as a combination of a <em>sum of products</em>.</p>
<p>A <strong>sum type</strong>, is a data structure used to hold a value that could take on several different, but fixed, types. For example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Pastry</span>
  <span class="fu">=</span> <span class="dt">Turnover</span>
  <span class="fu">|</span> <span class="dt">Macaroon</span>
  <span class="fu">|</span> <span class="dt">Brownie</span>
  <span class="fu">|</span> <span class="dt">Cookie</span></code></pre></div>
<p>A <strong>product type</strong>, is a data structure used to hold a fixed ordered set of several types. Selecting a single field is called projection.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span>
  {<span class="ot"> firstName       ::</span> <span class="dt">String</span>
  ,<span class="ot"> lastName        ::</span> <span class="dt">String</span>
  ,<span class="ot"> age             ::</span> <span class="dt">Int</span>
  ,<span class="ot"> height          ::</span> <span class="dt">Float</span>
  ,<span class="ot"> phoneNumber     ::</span> <span class="dt">String</span>
  ,<span class="ot"> flavor          ::</span> <span class="dt">String</span>
  }</code></pre></div>
<!--
In C the approximation of these concepts is in *struct* and *union* types.

<img src="/images/memory_layout.png"></img>
-->
<p>In Haskell all datatypes can be expressed as sums of products:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="dt">Add</span> {<span class="ot"> l ::</span> <span class="dt">Expr</span>,<span class="ot"> r ::</span> <span class="dt">Expr</span> }
  <span class="fu">|</span> <span class="dt">Mul</span> {<span class="ot"> l ::</span> <span class="dt">Expr</span>,<span class="ot"> r ::</span> <span class="dt">Expr</span> }
  <span class="fu">|</span> <span class="dt">Sub</span> {<span class="ot"> l ::</span> <span class="dt">Expr</span>,<span class="ot"> r ::</span> <span class="dt">Expr</span> }
  <span class="fu">|</span> <span class="dt">Div</span> {<span class="ot"> l ::</span> <span class="dt">Expr</span>,<span class="ot"> r ::</span> <span class="dt">Expr</span> }
  <span class="fu">|</span> <span class="dt">Number</span> {<span class="ot"> val ::</span> <span class="dt">Int</span> }</code></pre></div>
<p>During compilation most of the information about the structure of the datatypes is thrown out, by design Haskell erases all type information. Prior to type-checking a phase known as <strong>elaboration</strong> expands out all record selectors into toplevel functions which extract the named fields of a product.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Point</span> a b <span class="fu">=</span> <span class="dt">Point</span> {<span class="ot"> x ::</span> a,<span class="ot"> y ::</span> b }</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">x ::</span> <span class="dt">Point</span> a b <span class="ot">-&gt;</span> a
x (<span class="dt">Point</span> a _) <span class="fu">=</span> a

<span class="ot">y ::</span> <span class="dt">Point</span> a b <span class="ot">-&gt;</span> b
y (<span class="dt">Point</span> _ b) <span class="fu">=</span> b</code></pre></div>
<p>The rest of the information about products largely gets thrown out after compilation, and the product just get expanded into pattern matching code. For sum types the only information that is kept around is the tag for each constructor of the sum type. For instance <code>Add</code> is assigned the tag 1, <code>Mul</code> is assigned 2 etc. In a case statement the only information that is available at runtime is which branch we’re scrutinizing.</p>
<p>So what if consider not tossing out all this information and instead exposed it to our program so that we could write generic logic that can introspect the “structure” of our datatypes.</p>
<!--
For instance if we were to translate the above expression language into a rough
approximation of how it's evaluated by the GHC runtime it would look like the
following C code:

```cpp
typedef struct T {
    enum { ADD, MUL, DIV, SUB, NUM } tag;
    union {
        struct {
            struct T *left, *right;
        } node;
        int value;
    };
} Expr;

int eval(Expr t)
{
    switch (t.tag) {
        case ADD:
            return eval(*t.node.left) + eval(*t.node.right);
            break;
        case MUL:
            return eval(*t.node.left) * eval(*t.node.right);
            break;
        case DIV:
            return eval(*t.node.left) / eval(*t.node.right);
            break;
        case SUB:
            return eval(*t.node.left) - eval(*t.node.right);
            break;
        case NUM:
            return t.value;
            break;
    }
}
```
-->
<h4 id="compiler-hooks">Compiler Hooks</h4>
<p>Since GHC 6.10 we’ve had type families which, among other things, allow us to associate data types with our typeclass. So the structure of our Generic class can have a associated <code>Rep</code> type which can carry information along with the typeclass.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Generic</span> a <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Rep</span><span class="ot"> a ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>
<span class="ot">  from ::</span> a <span class="ot">-&gt;</span> (<span class="dt">Rep</span> a) x
<span class="ot">  to ::</span> (<span class="dt">Rep</span> a) x <span class="ot">-&gt;</span> a</code></pre></div>
<p>To represent the structure of our datatype we need to set up several datatypes to encode, sums, products, empty branches and various metadata about the names of fields, constructors and their types. All of which have a free parameter <code>p</code> which is bound to the head of typeclass instance when used in the associated datatype <code>Rep a</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span>    <span class="dt">V1</span>        p                       <span class="co">-- Empty</span>
<span class="kw">data</span>    <span class="dt">U1</span>        p <span class="fu">=</span> <span class="dt">U1</span>                  <span class="co">-- ()</span>
<span class="kw">data</span>    (<span class="fu">:+:</span>) f g p <span class="fu">=</span> <span class="dt">L1</span> (f p) <span class="fu">|</span> <span class="dt">R1</span> (g p) <span class="co">-- Sum</span>
<span class="kw">data</span>    (<span class="fu">:*:</span>) f g p <span class="fu">=</span> (f p) <span class="fu">:*:</span> (g p)     <span class="co">-- Product</span>
<span class="kw">newtype</span> <span class="dt">K1</span>    i c p <span class="fu">=</span> <span class="dt">K1</span> {<span class="ot"> unK1 ::</span> c }    <span class="co">-- a container for a c</span>
<span class="kw">newtype</span> <span class="dt">M1</span>  i t f p <span class="fu">=</span> <span class="dt">M1</span> {<span class="ot"> unM1 ::</span> f p }  <span class="co">-- metadata wrapper</span></code></pre></div>
<p>Now we could write this instance by hand for all of our datatypes, and for a simple enumeration it would look like the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Ingredient</span>
  <span class="fu">=</span> <span class="dt">Flour</span>
  <span class="fu">|</span> <span class="dt">Sugar</span>

<span class="kw">instance</span> <span class="dt">Generic</span> <span class="dt">Ingredient</span> <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Rep</span> <span class="dt">Ingredient</span> <span class="fu">=</span> <span class="dt">M1</span> <span class="dt">D</span> (<span class="dt">T_Ingredient</span> ((<span class="dt">M1</span> <span class="dt">C</span> (<span class="dt">C_Flour</span> <span class="dt">U1</span>)) <span class="fu">:+:</span> (<span class="dt">M1</span> <span class="dt">C</span> (<span class="dt">C_Sugar</span> <span class="dt">U1</span>))))

  from <span class="dt">Flour</span> <span class="fu">=</span> <span class="dt">M1</span> (<span class="dt">L1</span> (<span class="dt">M1</span> <span class="dt">U1</span>))
  from <span class="dt">Sugar</span> <span class="fu">=</span> <span class="dt">M1</span> (<span class="dt">R1</span> (<span class="dt">M1</span> <span class="dt">U1</span>))

  to (<span class="dt">M1</span> (<span class="dt">L1</span> (<span class="dt">M1</span> <span class="dt">U1</span>))) <span class="fu">=</span> <span class="dt">Flour</span>
  to (<span class="dt">M1</span> (<span class="dt">R1</span> (<span class="dt">M1</span> <span class="dt">U1</span>))) <span class="fu">=</span> <span class="dt">Sugar</span>

<span class="kw">data</span> <span class="dt">T_Ingredient</span>
<span class="kw">data</span> <span class="dt">C_Flour</span>
<span class="kw">data</span> <span class="dt">C_Sugar</span></code></pre></div>
<p>The instance here is purely mechanical and can be derived from GHC’s internal representation of it’s syntax tree, namely the types <a href="https://downloads.haskell.org/~ghc/7.10.2/docs/html/libraries/ghc-7.10.2/DataCon.html">GHC.DataCon</a> and <a href="https://downloads.haskell.org/~ghc/7.10.2/docs/html/libraries/ghc-7.10.2/TyCon.html">GHC.TypeCon</a>. Using the <code>-XDeriveGeneric</code> extension we can have GHC crank this typeclass out automatically:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span>

<span class="kw">data</span> <span class="dt">Ingredient</span>
  <span class="fu">=</span> <span class="dt">Flour</span>
  <span class="fu">|</span> <span class="dt">Sugar</span>
  <span class="kw">deriving</span> (<span class="dt">Generic</span>)</code></pre></div>
<p>Lest we not handwave away the work that GHC is doing, let’s actually recreate the introspection logic that GHC uses when instantiating a Generic class from a module’s data definitions. Let’s load a module dynamically, intercept the compilation and dump out the internal structure of the it’s datatypes to see how this would be mechanically translated into a typeclass instance.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">GHC</span>
<span class="kw">import </span><span class="dt">GHC.Paths</span> <span class="kw">as</span> <span class="dt">Paths</span>

<span class="kw">import </span><span class="dt">Name</span>
<span class="kw">import </span><span class="dt">TyCon</span>
<span class="kw">import </span><span class="dt">TypeRep</span>
<span class="kw">import </span><span class="dt">DataCon</span>
<span class="kw">import </span><span class="dt">HscTypes</span>

<span class="kw">import </span><span class="dt">Text.Show.Pretty</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>

  <span class="co">-- Inside the GHC Monad</span>
  rep <span class="ot">&lt;-</span> runGhc (<span class="dt">Just</span> Paths.libdir) <span class="fu">$</span> <span class="kw">do</span>

    <span class="co">-- Spin up a GHC compiler environment</span>
    dflags <span class="ot">&lt;-</span> getSessionDynFlags
    setSessionDynFlags dflags

    <span class="co">-- Make a dummy module to inject</span>
    <span class="kw">let</span> mn <span class="fu">=</span> mkModuleName <span class="st">&quot;Test&quot;</span>

    <span class="co">-- Make a dummy target</span>
    addTarget <span class="dt">Target</span> {
      targetId <span class="fu">=</span> <span class="dt">TargetModule</span> mn
    , targetAllowObjCode <span class="fu">=</span> <span class="dt">True</span>
    , targetContents <span class="fu">=</span> <span class="dt">Nothing</span>
    }

    <span class="co">-- Run the GHC pipeline</span>
    load <span class="dt">LoadAllTargets</span>
    modSum <span class="ot">&lt;-</span> getModSummary mn
    p <span class="ot">&lt;-</span> parseModule modSum
    t <span class="ot">&lt;-</span> typecheckModule p

    <span class="co">-- Pluck out the module tycons after we&#39;re done type-checking</span>
    <span class="dt">DesugaredModule</span> tcmod modguts <span class="ot">&lt;-</span> desugarModule t
    <span class="kw">let</span> tycons <span class="fu">=</span> mg_tcs modguts

    <span class="co">-- Deconstruct all datatypes into their sums-of-products.</span>
    return (deconstruct tycons)

  putStrLn (ppShow rep)</code></pre></div>
<p>Now that we have access to GHC’s internal representation of the “module guts” we can write our deconstructor logic. The logic is a slim few hundred lines of mostly ADT munging.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">deconstruct ::</span> [<span class="dt">TyCon</span>] <span class="ot">-&gt;</span> [<span class="dt">Data</span>]
deconstruct <span class="fu">=</span> fmap go
  <span class="kw">where</span>
    go x
      <span class="fu">|</span> isProduct x <span class="fu">=</span> <span class="dt">M1</span> <span class="fu">$</span> <span class="dt">D</span> <span class="dt">Datatype</span>
        { dataTypeName <span class="fu">=</span> getOccString (tyConName x)
        , modName      <span class="fu">=</span> modString x
        , isNewtype    <span class="fu">=</span> isNewTyCon x
        , datatype     <span class="fu">=</span> <span class="dt">Product</span> (mkProduct x)
        , recursive    <span class="fu">=</span> isRecursiveTyCon x
        }

      <span class="fu">|</span> isVoid x <span class="fu">=</span> <span class="dt">M1</span> <span class="fu">$</span> <span class="dt">D</span> <span class="dt">Datatype</span>
        { dataTypeName <span class="fu">=</span> getOccString (tyConName x)
        , modName      <span class="fu">=</span> modString x
        , isNewtype    <span class="fu">=</span> isNewTyCon x
        , datatype     <span class="fu">=</span> <span class="dt">V1</span>
        , recursive    <span class="fu">=</span> isRecursiveTyCon x
        }

      <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">M1</span> <span class="fu">$</span> <span class="dt">D</span> <span class="dt">Datatype</span>
        { dataTypeName <span class="fu">=</span> getOccString (tyConName x)
        , modName      <span class="fu">=</span> modString x
        , isNewtype    <span class="fu">=</span> isNewTyCon x
        , datatype     <span class="fu">=</span> <span class="dt">Sum</span> (mkProduct x)
        , recursive    <span class="fu">=</span> isRecursiveTyCon x
        }

<span class="ot">mkRecord ::</span> <span class="dt">TyCon</span> <span class="ot">-&gt;</span> [<span class="dt">Data</span>]
mkRecord x <span class="fu">=</span> concatMap mkRProduct (tyConDataCons x)

<span class="ot">mkProduct ::</span> <span class="dt">TyCon</span> <span class="ot">-&gt;</span> [<span class="dt">Data</span>]
mkProduct x <span class="fu">=</span> fmap go (tyConDataCons x)
  <span class="kw">where</span>
<span class="ot">    go ::</span> <span class="dt">DataCon</span> <span class="ot">-&gt;</span> <span class="dt">Data</span>
    go x <span class="fu">|</span> isRecord x   <span class="fu">=</span> <span class="dt">Product</span> (mkRProduct x)
    go x <span class="fu">|</span> isDProduct x <span class="fu">=</span> <span class="dt">Product</span> (mkDProduct x)
    go x                <span class="fu">=</span> <span class="dt">M1</span> (<span class="dt">C</span> (<span class="dt">Constructor</span> (conNames x)))

<span class="ot">mkDProduct ::</span> <span class="dt">DataCon</span> <span class="ot">-&gt;</span> [<span class="dt">Data</span>]
mkDProduct xs <span class="fu">=</span> [<span class="dt">K1</span> (showType x) <span class="fu">|</span> x <span class="ot">&lt;-</span> dataConOrigArgTys xs]

<span class="ot">mkRProduct ::</span> <span class="dt">DataCon</span> <span class="ot">-&gt;</span> [<span class="dt">Data</span>]
mkRProduct x <span class="fu">=</span> [<span class="dt">M1</span> (<span class="dt">S</span> (<span class="dt">Selector</span> (getOccString fld)) ty) <span class="fu">|</span> (fld, ty) <span class="ot">&lt;-</span> zip (fieldNames x) (mkDProduct x)]</code></pre></div>
<p>Setting up the dummy module <code>Test.hs</code> to run our decompilation script:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">PlatonicSolid</span>
  <span class="fu">=</span> <span class="dt">Tetrahedron</span>
  <span class="fu">|</span> <span class="dt">Cube</span>
  <span class="fu">|</span> <span class="dt">Octahedron</span>
  <span class="fu">|</span> <span class="dt">Dodecahedron</span>
  <span class="fu">|</span> <span class="dt">Icosahedron</span>

<span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span>
  {<span class="ot"> firstName       ::</span> <span class="dt">String</span>
  ,<span class="ot"> lastName        ::</span> <span class="dt">String</span>
  ,<span class="ot"> age             ::</span> <span class="dt">Int</span>
  ,<span class="ot"> height          ::</span> <span class="dt">Float</span>
  ,<span class="ot"> phoneNumber     ::</span> <span class="dt">String</span>
  ,<span class="ot"> flavor          ::</span> <span class="dt">String</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="kw">data</span> <span class="dt">T</span>
  <span class="fu">=</span> <span class="dt">T1</span> {<span class="ot"> a ::</span> <span class="dt">Int</span>,<span class="ot"> b ::</span> <span class="dt">Float</span> }
  <span class="fu">|</span> <span class="dt">T2</span> {<span class="ot"> c ::</span> <span class="dt">Int</span>,<span class="ot"> d ::</span> <span class="dt">Double</span> }</code></pre></div>
<p>For <code>PlatonicSolid</code> we get the representation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">M1</span>
   (<span class="dt">D</span> <span class="dt">Datatype</span>
        { dataTypeName <span class="fu">=</span> <span class="st">&quot;PlatonicSolid&quot;</span>
        , modName <span class="fu">=</span> <span class="st">&quot;Test&quot;</span>
        , isNewtype <span class="fu">=</span> <span class="dt">False</span>
        , datatype <span class="fu">=</span>
            <span class="dt">Sum</span>
              [ <span class="dt">M1</span> (<span class="dt">C</span> <span class="dt">Constructor</span> { conName <span class="fu">=</span> <span class="st">&quot;Tetrahedron&quot;</span> })
              , <span class="dt">M1</span> (<span class="dt">C</span> <span class="dt">Constructor</span> { conName <span class="fu">=</span> <span class="st">&quot;Cube&quot;</span> })
              , <span class="dt">M1</span> (<span class="dt">C</span> <span class="dt">Constructor</span> { conName <span class="fu">=</span> <span class="st">&quot;Octahedron&quot;</span> })
              , <span class="dt">M1</span> (<span class="dt">C</span> <span class="dt">Constructor</span> { conName <span class="fu">=</span> <span class="st">&quot;Dodecahedron&quot;</span> })
              , <span class="dt">M1</span> (<span class="dt">C</span> <span class="dt">Constructor</span> { conName <span class="fu">=</span> <span class="st">&quot;Icosahedron&quot;</span> })
              ]
        , recursive <span class="fu">=</span> <span class="dt">False</span>
        })</code></pre></div>
<p>For <code>Person</code> we get the representation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">M1</span>
    (<span class="dt">D</span> <span class="dt">Datatype</span>
         { dataTypeName <span class="fu">=</span> <span class="st">&quot;Person&quot;</span>
         , modName <span class="fu">=</span> <span class="st">&quot;Test&quot;</span>
         , isNewtype <span class="fu">=</span> <span class="dt">False</span>
         , datatype <span class="fu">=</span>
             <span class="dt">Product</span>
               [ <span class="dt">M1</span> (<span class="dt">S</span> <span class="dt">Selector</span> { selName <span class="fu">=</span> <span class="st">&quot;firstName&quot;</span> } (<span class="dt">K1</span> <span class="st">&quot;String&quot;</span>))
               , <span class="dt">M1</span> (<span class="dt">S</span> <span class="dt">Selector</span> { selName <span class="fu">=</span> <span class="st">&quot;lastName&quot;</span> } (<span class="dt">K1</span> <span class="st">&quot;String&quot;</span>))
               , <span class="dt">M1</span> (<span class="dt">S</span> <span class="dt">Selector</span> { selName <span class="fu">=</span> <span class="st">&quot;age&quot;</span> } (<span class="dt">K1</span> <span class="st">&quot;Int&quot;</span>))
               , <span class="dt">M1</span> (<span class="dt">S</span> <span class="dt">Selector</span> { selName <span class="fu">=</span> <span class="st">&quot;height&quot;</span> } (<span class="dt">K1</span> <span class="st">&quot;Float&quot;</span>))
               , <span class="dt">M1</span> (<span class="dt">S</span> <span class="dt">Selector</span> { selName <span class="fu">=</span> <span class="st">&quot;phoneNumber&quot;</span> } (<span class="dt">K1</span> <span class="st">&quot;String&quot;</span>))
               , <span class="dt">M1</span> (<span class="dt">S</span> <span class="dt">Selector</span> { selName <span class="fu">=</span> <span class="st">&quot;flavor&quot;</span> } (<span class="dt">K1</span> <span class="st">&quot;String&quot;</span>))
               ]
         , recursive <span class="fu">=</span> <span class="dt">False</span>
       })</code></pre></div>
<p>For the sum of products <code>T</code> we get the representation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">M1</span>
  (<span class="dt">D</span> <span class="dt">Datatype</span>
       { dataTypeName <span class="fu">=</span> <span class="st">&quot;T&quot;</span>
       , modName <span class="fu">=</span> <span class="st">&quot;Test&quot;</span>
       , isNewtype <span class="fu">=</span> <span class="dt">False</span>
       , datatype <span class="fu">=</span>
           <span class="dt">Sum</span>
             [ <span class="dt">Product</span>
                 [ <span class="dt">M1</span> (<span class="dt">S</span> <span class="dt">Selector</span> { selName <span class="fu">=</span> <span class="st">&quot;a&quot;</span> } (<span class="dt">K1</span> <span class="st">&quot;Int&quot;</span>))
                 , <span class="dt">M1</span> (<span class="dt">S</span> <span class="dt">Selector</span> { selName <span class="fu">=</span> <span class="st">&quot;b&quot;</span> } (<span class="dt">K1</span> <span class="st">&quot;Float&quot;</span>))
                 ]
             , <span class="dt">Product</span>
                 [ <span class="dt">M1</span> (<span class="dt">S</span> <span class="dt">Selector</span> { selName <span class="fu">=</span> <span class="st">&quot;c&quot;</span> } (<span class="dt">K1</span> <span class="st">&quot;Int&quot;</span>))
                 , <span class="dt">M1</span> (<span class="dt">S</span> <span class="dt">Selector</span> { selName <span class="fu">=</span> <span class="st">&quot;d&quot;</span> } (<span class="dt">K1</span> <span class="st">&quot;Double&quot;</span>))
                 ]
             ]
       , recursive <span class="fu">=</span> <span class="dt">False</span>
       })</code></pre></div>
<p>These data points are then used to generate the Rep instance in the derived Generic instances. So that’s a <em>rough approximation</em> of how <code>-XDeriveGeneric</code> works under the hood, nothing terribly complicated just book keeping.</p>
<h4 id="ghc.generics">GHC.Generics</h4>
<p>From the internal representation we crank out several typeclass instances which store the metadata about the various constructors.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Datatype</span> d <span class="kw">where</span>
<span class="ot">  datatypeName ::</span> t d f a <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="ot">  moduleName   ::</span> t d f a <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="ot">  isNewtype    ::</span> t d f a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
  isNewtype _ <span class="fu">=</span> <span class="dt">False</span>

<span class="kw">class</span> <span class="dt">Selector</span> s <span class="kw">where</span>
<span class="ot">  selName ::</span> t s f a <span class="ot">-&gt;</span> <span class="dt">String</span>

<span class="kw">class</span> <span class="dt">Constructor</span> c <span class="kw">where</span>
<span class="ot">  conName ::</span> t c f a <span class="ot">-&gt;</span> <span class="dt">String</span>

<span class="ot">  conFixity ::</span> t c f a <span class="ot">-&gt;</span> <span class="dt">Fixity</span>
  conFixity _ <span class="fu">=</span> <span class="dt">Prefix</span>

<span class="ot">  conIsRecord ::</span> t c f a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
  conIsRecord _ <span class="fu">=</span> <span class="dt">False</span></code></pre></div>
<p>For example, for <code>Ingredient</code> example from before, we’d have several constructor instances automatically generated by which we could query the names from the AST.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Rep</span> <span class="dt">Ingredient</span> <span class="fu">=</span> <span class="dt">M1</span> <span class="dt">D</span> (<span class="dt">T_Ingredient</span> ((<span class="dt">M1</span> <span class="dt">C</span> (<span class="dt">C_Flour</span> <span class="dt">U1</span>)) <span class="fu">:+:</span> (<span class="dt">M1</span> <span class="dt">C</span> (<span class="dt">C_Sugar</span> <span class="dt">U1</span>))))

<span class="kw">data</span> <span class="dt">T_Ingredient</span>
<span class="kw">data</span> <span class="dt">C_Flour</span>
<span class="kw">data</span> <span class="dt">C_Sugar</span>

<span class="kw">instance</span> <span class="dt">Datatype</span> <span class="dt">T_Ingredient</span> <span class="kw">where</span>
  datatypeName _ <span class="fu">=</span> <span class="st">&quot;Ingredient&quot;</span>
  moduleName _ <span class="fu">=</span> <span class="st">&quot;Main&quot;</span>

<span class="kw">instance</span> <span class="dt">Constructor</span> <span class="dt">C_Flour</span> <span class="kw">where</span>
  conName _ <span class="fu">=</span> <span class="st">&quot;Flour&quot;</span>

<span class="kw">instance</span> <span class="dt">Constructor</span> <span class="dt">C_Sugar</span> <span class="kw">where</span>
  conName _ <span class="fu">=</span> <span class="st">&quot;Sugar&quot;</span></code></pre></div>
<p>Unlike reflection in languages like Java, Generics are not pushing type information into the runtime. Apart from a dictionary lookup for they are a effectively free abstraction that has no overhead. We’re simply making more information from the compiler manifest in the types during the type-checking phase, all of which gets erased during compilation.</p>
<h4 id="example">Example</h4>
<p>I tried to come up a non-contrived example for illustrating the usefulness of generics, and there are plenty of examples (serializes for JSON, Protocol Buffers, SQL Generation, traversals, command line parsers, etc) that are well-documented elsewhere on the web. So let’s consider an example based on the silly pun in the title of this article, namely cooking typeclasses.</p>
<p>So we have a Pie type, naturally.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Pie</span> <span class="fu">=</span> <span class="dt">Pie</span>
  {<span class="ot"> filling ::</span> <span class="dt">Filling</span>
  ,<span class="ot"> topping ::</span> <span class="dt">Maybe</span> <span class="dt">Topping</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>)

<span class="kw">data</span> <span class="dt">Filling</span> <span class="fu">=</span> <span class="dt">Apple</span> <span class="fu">|</span> <span class="dt">Cherry</span> <span class="fu">|</span> <span class="dt">Pumpkin</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>)

<span class="kw">data</span> <span class="dt">Topping</span> <span class="fu">=</span> <span class="dt">IceCream</span> <span class="fu">|</span> <span class="dt">WhipCream</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>)</code></pre></div>
<p><a href="https://www.flickr.com/photos/theleggett/4409912246"><img src="/images/pie.jpg"></img></a></p>
<p>Using generics we’d like to a generate a list of the types of pie that we can put on a menu from the structure of the Haskell types. Records will denote named variations (“filling” vs “topping”) of the menu item, while sum types denote the various options in the variations (“cherry filling” vs “apple filling”).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Item</span>
  <span class="fu">=</span> <span class="dt">Item</span> <span class="dt">Text</span> [<span class="dt">Item</span>]
  <span class="fu">|</span> <span class="dt">Variant</span> <span class="dt">Text</span> [<span class="dt">Item</span>]
  <span class="fu">|</span> <span class="dt">Choice</span> <span class="dt">Text</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>)</code></pre></div>
<p>We implement a typeclass with a <strong>default signature</strong> which gives us the option to manually specify how a type gets converted into a menu item, or fall back on using it’s generic representation to automatically generate it.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Menu</span> a <span class="kw">where</span>
<span class="ot">  menu ::</span> a <span class="ot">-&gt;</span> [<span class="dt">Item</span>]
  default<span class="ot"> menu ::</span> (<span class="dt">Generic</span> a, <span class="dt">GMenu</span> (<span class="dt">Rep</span> a)) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [<span class="dt">Item</span>]
  menu _ <span class="fu">=</span> gmenu (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> a)

<span class="ot">gmenu ::</span> forall a<span class="fu">.</span> (<span class="dt">Generic</span> a, <span class="dt">GMenu</span> (<span class="dt">Rep</span> a)) <span class="ot">=&gt;</span> <span class="dt">Proxy</span> a <span class="ot">-&gt;</span> [<span class="dt">Item</span>]
gmenu _ <span class="fu">=</span> gopts (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Rep</span> a))</code></pre></div>
<p>Our generic menu operates over various GHC.Generics types to expand out the sums and products into the Item categories that correspond to the menu. The instance for <code>GMenu (K1 R f)</code> has a Menu constraint which allows manual override for specific datatypes. Since we’re passing around a proxy we’ll have to manually thread the dictionary around sometimes by passing an <code>undefined</code> cast to the type of the instance we need to resolve.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Generic Menu</span>
<span class="kw">class</span> <span class="dt">GMenu</span> a <span class="kw">where</span>
<span class="ot">  gopts ::</span> <span class="dt">Proxy</span> a <span class="ot">-&gt;</span> [<span class="dt">Item</span>]

<span class="co">-- Datatype</span>
<span class="kw">instance</span> <span class="dt">GMenu</span> f <span class="ot">=&gt;</span> <span class="dt">GMenu</span> (<span class="dt">M1</span> <span class="dt">D</span> x f) <span class="kw">where</span>
  gopts _ <span class="fu">=</span> gopts (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> f)

<span class="co">-- Constructor Metadata</span>
<span class="kw">instance</span> (<span class="dt">GMenu</span> f, <span class="dt">Constructor</span> c) <span class="ot">=&gt;</span> <span class="dt">GMenu</span> (<span class="dt">M1</span> <span class="dt">C</span> c f) <span class="kw">where</span>
  gopts x
    <span class="fu">|</span> conIsRecord (undefined<span class="ot"> ::</span> t c f a) <span class="fu">=</span>
      [<span class="dt">Item</span> (pack (conName m)) (gopts (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> f))]

    <span class="fu">|</span> otherwise <span class="fu">=</span> [<span class="dt">Choice</span> (pack (conName m))]
    <span class="kw">where</span> m <span class="fu">=</span> (undefined<span class="ot"> ::</span> t c f a)

<span class="co">-- Selector Metadata</span>
<span class="kw">instance</span> (<span class="dt">GMenu</span> f, <span class="dt">Selector</span> c) <span class="ot">=&gt;</span> <span class="dt">GMenu</span> (<span class="dt">M1</span> <span class="dt">S</span> c f) <span class="kw">where</span>
  gopts _ <span class="fu">=</span> [<span class="dt">Variant</span> (pack (selName m)) (gopts (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> f))]
    <span class="kw">where</span> m <span class="fu">=</span> (undefined<span class="ot"> ::</span> t c f a)

<span class="co">-- Constructor Paramater</span>
<span class="kw">instance</span> (<span class="dt">GMenu</span> (<span class="dt">Rep</span> f), <span class="dt">Menu</span> f) <span class="ot">=&gt;</span> <span class="dt">GMenu</span> (<span class="dt">K1</span> <span class="dt">R</span> f) <span class="kw">where</span>
  gopts _ <span class="fu">=</span> menu (undefined<span class="ot"> ::</span> f)

<span class="co">-- Sum branch</span>
<span class="kw">instance</span> (<span class="dt">GMenu</span> a, <span class="dt">GMenu</span> b) <span class="ot">=&gt;</span> <span class="dt">GMenu</span> (a <span class="fu">:+:</span> b) <span class="kw">where</span>
  gopts _ <span class="fu">=</span> gopts (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> a) <span class="fu">++</span> gopts (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> b)

<span class="co">-- Product branch</span>
<span class="kw">instance</span> (<span class="dt">GMenu</span> a, <span class="dt">GMenu</span> b) <span class="ot">=&gt;</span> <span class="dt">GMenu</span> (a <span class="fu">:*:</span> b) <span class="kw">where</span>
  gopts _ <span class="fu">=</span> gopts (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> a) <span class="fu">++</span> gopts (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> b)

<span class="co">-- Void branch</span>
<span class="kw">instance</span> <span class="dt">GMenu</span> <span class="dt">U1</span> <span class="kw">where</span>
  gopts _ <span class="fu">=</span> []</code></pre></div>
<p>Specifically we’ll override the <code>Maybe</code> type so that it simply expands out to a choice of either “AsIs” of the variant or just the list of choices endowed by the inner parameter.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Menu</span> a <span class="ot">=&gt;</span> <span class="dt">Menu</span> (<span class="dt">Maybe</span> a) <span class="kw">where</span>
  menu _ <span class="fu">=</span> [<span class="dt">Choice</span> (pack <span class="st">&quot;AsIs&quot;</span>)] <span class="fu">++</span> (menu (undefined<span class="ot"> ::</span> a))</code></pre></div>
<p>As an example <code>Maybe Topping</code> expands out into three choices.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">menu (<span class="ot">a ::</span> <span class="dt">Maybe</span> <span class="dt">Topping</span>) <span class="fu">~</span> [<span class="dt">Choice</span> <span class="st">&quot;AsIs&quot;</span>, <span class="dt">Choice</span> <span class="st">&quot;IceCream&quot;</span>, <span class="dt">Choice</span> <span class="st">&quot;whipCream&quot;</span>]</code></pre></div>
<p>Using GHC 7.10’s new <code>-XDeriveAnyClass</code> extension we can actually go back and automatically derive Menu inside the deriving clause.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Pie</span> <span class="fu">=</span> <span class="dt">Pie</span>
  {<span class="ot"> filling ::</span> <span class="dt">Filling</span>
  ,<span class="ot"> topping ::</span> <span class="dt">Maybe</span> <span class="dt">Topping</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>, <span class="dt">Menu</span>)</code></pre></div>
<p>Now synthesizing a dictionary for Pie we can get a menu</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">menu (undefined<span class="ot"> ::</span> <span class="dt">Pie</span>)</code></pre></div>
<p>And voila:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[ <span class="dt">Item</span>
    <span class="st">&quot;Pie&quot;</span>
    [ <span class="dt">Variant</span>
        <span class="st">&quot;filling&quot;</span> [ <span class="dt">Choice</span> <span class="st">&quot;Apple&quot;</span> , <span class="dt">Choice</span> <span class="st">&quot;Cherry&quot;</span> , <span class="dt">Choice</span> <span class="st">&quot;Pumpkin&quot;</span> ]
    , <span class="dt">Variant</span>
        <span class="st">&quot;topping&quot;</span>
        [ <span class="dt">Choice</span> <span class="st">&quot;AsIs&quot;</span> , <span class="dt">Choice</span> <span class="st">&quot;IceCream&quot;</span> , <span class="dt">Choice</span> <span class="st">&quot;WhipCream&quot;</span> ]
    ]
]</code></pre></div>
<p>Since our logic is datatype generic, any Haskell we can write down can be automatically translated to a Menu just by <code>deriving Menu</code>. So now we can a new <code>Crisp</code> desert (my favorite!) <em>and we get everything for free</em>!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Crisp</span> <span class="fu">=</span> <span class="dt">Crisp</span>
  {<span class="ot"> contents ::</span> <span class="dt">Filling</span>
  ,<span class="ot"> temperature ::</span> <span class="dt">Temperature</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>, <span class="dt">Menu</span>)

<span class="kw">data</span> <span class="dt">Temperature</span> <span class="fu">=</span> <span class="dt">Warm</span> <span class="fu">|</span> <span class="dt">Cold</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>, <span class="dt">Menu</span>)

<span class="co">-- Add an instance for a pair of menu items. That expands into multiple items.</span>
<span class="kw">instance</span> (<span class="dt">Menu</span> a, <span class="dt">Menu</span> b) <span class="ot">=&gt;</span> <span class="dt">Menu</span> (a,b) <span class="kw">where</span>
  menu _ <span class="fu">=</span> menu (undefined<span class="ot"> ::</span> a) <span class="fu">++</span> menu (undefined<span class="ot"> ::</span> b)</code></pre></div>
<p>And we can generate the composite menu of both deserts:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">menu (undefined<span class="ot"> ::</span> (<span class="dt">Pie</span>, <span class="dt">Crisp</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[ <span class="dt">Item</span>
    <span class="st">&quot;Pie&quot;</span>
    [ <span class="dt">Variant</span>
        <span class="st">&quot;filling&quot;</span> [ <span class="dt">Choice</span> <span class="st">&quot;Apple&quot;</span> , <span class="dt">Choice</span> <span class="st">&quot;Cherry&quot;</span> , <span class="dt">Choice</span> <span class="st">&quot;Pumpkin&quot;</span> ]
    , <span class="dt">Variant</span>
        <span class="st">&quot;topping&quot;</span>
        [ <span class="dt">Choice</span> <span class="st">&quot;AsIs&quot;</span> , <span class="dt">Choice</span> <span class="st">&quot;IceCream&quot;</span> , <span class="dt">Choice</span> <span class="st">&quot;WhipCream&quot;</span> ]
    ]
, <span class="dt">Item</span>
    <span class="st">&quot;Crisp&quot;</span>
    [ <span class="dt">Variant</span>
        <span class="st">&quot;contents&quot;</span> [ <span class="dt">Choice</span> <span class="st">&quot;Apple&quot;</span> , <span class="dt">Choice</span> <span class="st">&quot;Cherry&quot;</span> , <span class="dt">Choice</span> <span class="st">&quot;Pumpkin&quot;</span> ]
    , <span class="dt">Variant</span> <span class="st">&quot;temperature&quot;</span> [ <span class="dt">Choice</span> <span class="st">&quot;Warm&quot;</span> , <span class="dt">Choice</span> <span class="st">&quot;Cold&quot;</span> ]
    ]
]</code></pre></div>
<p>So that’s generics. One of the best goto examples of how an expressive type system and a few clever compiler hooks can make programmers lives easier by cooking our boilerplate for us and giving tastier more correct code.</p>
<p><a href="https://www.flickr.com/photos/theleggett/4409912246"><img src="/images/pie2.jpg"></img></a></p>]]></summary>
</entry>
<entry>
    <title>The Joy and Agony of Haskell in Production</title>
    <link href="http://www.stephendiehl.com/posts/production.html" />
    <id>http://www.stephendiehl.com/posts/production.html</id>
    <published>2016-02-16T00:00:00Z</published>
    <updated>2016-02-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="the-joy-and-agony-of-haskell-in-production">The Joy and Agony of Haskell in Production</h3>
<p>There have been <a href="https://www.youtube.com/watch?v=AZQLkkDXy68">several</a> <a href="https://www.youtube.com/watch?v=mlTO510zO78">good talks</a> about using Haskell in industry lately, and several people asked me to write about my personal experiences. Although I can’t give specific details I will speak broadly about some things I’ve learned and experienced.</p>
<p><strong>The myths are true.</strong> Haskell code tends to be much more reliable, performant, easy to refactor, and easier to incorporate with coworkers code without too much thinking. It’s also just enjoyable to write.</p>
<p><strong>The myths are sometimes trueisms.</strong> Haskell code tends to be of high quality by construction, but for several reasons that are only correlated; not causally linked to the technical merits of Haskell. Just by virtue of language being esoteric and having a relatively higher barrier to entry we’ll end up working with developers who would write above average code in <em>any</em> language. That said, the language actively encourage thoughtful consideration of abstractions and a “brutal” (as John Carmack noted) level of discipline that high quality code in other languages would require, but are enforced in Haskell.</p>
<p><strong>Prefer to import libraries as qualified.</strong> Typically this is just considered good practice for business logic libraries, it makes it easier to locate the source of symbol definitions. The only point of ambiguity I’ve seen is disagreement amongst developers on which core libraries are common enough to import unqualified and how to handle symbols. This ranges the full spectrum from fully qualifying everything <code>(Control.Monad.&gt;&gt;=)</code> to common things like <code>(Data.Maybe.maybe)</code> or just disambiguating names like <code>(Map.lookup)</code>.</p>
<p><strong>Consider rolling an internal prelude</strong>. As we’ve all learned the hard way, the Prelude is not your friend. The consensus historically has favored the “Small Prelude Assumption” which presupposes that tools get pushed out into third party modules, even the core tools that are necessary to do anything (text, bytestring, vector, etc). This makes life easier for library authors at the cost of some struggle for downstream users.</p>
<p>In practice any non-trivial business logic module can very easily have 100+ lines just of imports, and frankly it gets tiring. One common way of abstracting this is by rolling a custom prelude using module reexports. Consider a minimal use case like the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">MegaCorpPrelude</span> ( 
  <span class="kw">module</span> <span class="dt">Exports</span>,
) <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Int</span> <span class="kw">as</span> <span class="dt">Exports</span>
<span class="kw">import </span><span class="dt">Data.Tuple</span> <span class="kw">as</span> <span class="dt">Exports</span>
<span class="kw">import </span><span class="dt">Data.Maybe</span> <span class="kw">as</span> <span class="dt">Exports</span>
<span class="kw">import </span><span class="dt">Data.String</span> <span class="kw">as</span> <span class="dt">Exports</span>
<span class="kw">import </span><span class="dt">Data.Foldable</span> <span class="kw">as</span> <span class="dt">Exports</span>
<span class="kw">import </span><span class="dt">Data.Traversable</span> <span class="kw">as</span> <span class="dt">Exports</span>

<span class="kw">import </span><span class="dt">Control.Monad.Trans.Except</span>
  as <span class="dt">Exports</span>
  (<span class="dt">ExceptT</span>(<span class="dt">ExceptT</span>), <span class="dt">Except</span>, except, runExcept, runExceptT, 
   mapExcept, mapExceptT, withExcept, withExceptT)</code></pre></div>
<p>This can be put into a cabal package which transitively pulls in the core dependencies and then is used in our downstream module.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span>

<span class="kw">import </span><span class="dt">MegaCorpPrelude</span></code></pre></div>
<p>There are several custom preludes that are available on Hackage in the <a href="https://hackage.haskell.org/packages/#cat:Prelude">Prelude</a> category.</p>
<p><strong>Haskell has world class libraries</strong>. There is an abundance of riches on Hackage in libraries like quickcheck, mtl, pipes, conduit, tasty, attoparsec, sbv and many more. Knowing <a href="http://www.haskellforall.com/2015/08/state-of-haskell-ecosystem-august-2015.html">where to start</a> with the ecosystem can be a little tricky, and there are sometimes multiple competing solutions. A conservative start to a library might consist of something like the following <code>build-depends</code> in our cabal file:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  build<span class="fu">-</span>depends<span class="fu">:</span>       
    base                 <span class="fu">&gt;=</span> <span class="fl">4.6</span>   <span class="fu">&amp;&amp;</span> <span class="fu">&lt;</span><span class="fl">4.9</span>,
    deepseq              <span class="fu">&gt;=</span> <span class="fl">1.3</span>   <span class="fu">&amp;&amp;</span> <span class="fu">&lt;</span><span class="fl">1.5</span>,
    hashable             <span class="fu">&gt;=</span> <span class="fl">1.2</span><span class="fu">.</span><span class="dv">2</span> <span class="fu">&amp;&amp;</span> <span class="fu">&lt;</span><span class="fl">1.3</span>,

    text                 <span class="fu">&gt;=</span> <span class="fl">1.1</span>   <span class="fu">&amp;&amp;</span> <span class="fu">&lt;</span><span class="fl">1.3</span>,
    bytestring           <span class="fu">&gt;=</span> <span class="fl">0.10</span>  <span class="fu">&amp;&amp;</span> <span class="fu">&lt;</span><span class="fl">0.11</span>,
    split                <span class="fu">&gt;=</span> <span class="fl">0.2</span>   <span class="fu">&amp;&amp;</span> <span class="fu">&lt;</span><span class="fl">0.3</span>,

    unordered<span class="fu">-</span>containers <span class="fu">&gt;=</span> <span class="fl">0.2</span>   <span class="fu">&amp;&amp;</span> <span class="fu">&lt;</span><span class="fl">0.3</span>,
    containers           <span class="fu">&gt;=</span> <span class="fl">0.5</span>   <span class="fu">&amp;&amp;</span> <span class="fu">&lt;</span><span class="fl">0.6</span>,
    vector               <span class="fu">&gt;=</span> <span class="fl">0.11</span>  <span class="fu">&amp;&amp;</span> <span class="fu">&lt;</span><span class="fl">0.12</span>

    mtl                  <span class="fu">&gt;=</span> <span class="fl">2.2</span>   <span class="fu">&amp;&amp;</span> <span class="fu">&lt;</span><span class="fl">3.0</span>,
    transformers         <span class="fu">&gt;=</span> <span class="fl">0.4</span>   <span class="fu">&amp;&amp;</span> <span class="fu">&lt;</span><span class="fl">0.6</span>,

    time                 <span class="fu">&gt;=</span> <span class="fl">1.6</span>   <span class="fu">&amp;&amp;</span> <span class="fu">&lt;</span><span class="fl">1.7</span>,
    process              <span class="fu">&gt;=</span> <span class="fl">1.1</span>   <span class="fu">&amp;&amp;</span> <span class="fu">&lt;</span><span class="fl">1.3</span>,
    directory            <span class="fu">&gt;=</span> <span class="fl">1.2</span>   <span class="fu">&amp;&amp;</span> <span class="fu">&lt;</span><span class="fl">1.3</span>,
    optparse<span class="fu">-</span>applicative <span class="fu">&gt;=</span> <span class="fl">0.10</span>  <span class="fu">&amp;&amp;</span> <span class="fu">&lt;</span><span class="fl">0.13</span></code></pre></div>
<p><strong>For many problem domains the libraries simply aren’t written yet.</strong> There are many domains that Haskell is used in, for tasks as diverse as trading systems, spam filtering, to web services. Chances are there are a plethora of libraries available some tasks. Yet it goes without saying that Haskell is not Java or Python and there simply isn’t an equivalent mindshare for certain tasks. If we need to connect to Microsoft SQL Server or a SOAP service, we’re probably going to have more trouble. The primitives are probably there to do it, but often there is no off-the-shelf solution.</p>
<p>Usually it boils down to: If you don’t write that library, no one else will.</p>
<p><strong>There isn’t a global concensus on how to write Haskell</strong>. Being an abnormally expressive languages means Haskell is written in such wildly different styles to the point of being almost a different language in some cases. There are wildly different views on how to structure large applications and not a whole lot is written about best practices for doing so. Most of the schools of thought differ about how far along the spectrum we should strive for correctness and what power-to-weight ratio is appropriate for certain tasks.</p>
<p>It’s hard to give universal advice about how to structure Haskell logic that applies to <em>all problems</em>, and I’d be skeptical of anyone who did. For a certain set of tasks that are command line utilities, processing pipelines, or web services it’s certainly possible to write applications that don’t involve monad transformers but there are certainly many other domain where the natural choice is to roll a tree-like structure of monad transformer objects that encapsulate common logic like Error and State.</p>
<p>If we look at the history of programming, there are many portents of the future of Haskell in the C++ community, another language where no two developers (that I’ve met) agree on which subset of the language to use.</p>
<p><strong>Configuration</strong> For configuration Bryan’s <code>configurator</code> library is invaluable. The library specifies an external configuration flat file which can hold credentials, connections and cluster topology information. A typical pattern is to embed this in a <code>ReaderT</code> and then <code>asks</code> for any field necessary in downstream logic.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ConfigM</span> a <span class="fu">=</span> <span class="dt">ConfigM</span> (<span class="dt">ReaderT</span> <span class="dt">ConnectInfo</span> a)
  <span class="kw">deriving</span> (<span class="dt">Monad</span>, <span class="dt">MonadReader</span> <span class="dt">ConnectInfo</span>)

<span class="ot">handleConfig ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ConnectInfo</span>
handleConfig config_filename <span class="fu">=</span> <span class="kw">do</span>
    config <span class="ot">&lt;-</span> Config.load [ <span class="dt">Config.Required</span> config_filename ]

    hostname <span class="ot">&lt;-</span> Config.require config <span class="st">&quot;database.hostname&quot;</span>
    username <span class="ot">&lt;-</span> Config.require config <span class="st">&quot;database.username&quot;</span>
    database <span class="ot">&lt;-</span> Config.require config <span class="st">&quot;database.database&quot;</span>
    password <span class="ot">&lt;-</span> Config.require config <span class="st">&quot;database.password&quot;</span>

    return <span class="fu">$</span> <span class="dt">ConnectInfo</span>
     { connectHost     <span class="fu">=</span> hostname
     , connectUser     <span class="fu">=</span> username
     , connectDatabase <span class="fu">=</span> database
     , connectPort     <span class="fu">=</span> <span class="dv">5432</span>
     , connectPassword <span class="fu">=</span> fromMaybe <span class="st">&quot;&quot;</span> password
     }</code></pre></div>
<p>The configuration file might look like the following:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">database
<span class="op">{</span>
  hostname <span class="op">=</span> <span class="st">&quot;mydb.rds.amazonaws.com&quot;</span>
  database <span class="op">=</span> <span class="st">&quot;employees&quot;</span>
  username <span class="op">=</span> <span class="st">&quot;stephen&quot;</span>
  password <span class="op">=</span> <span class="st">&quot;hunter2&quot;</span>
<span class="op">}</span></code></pre></div>
<p><strong>Haskell is full of distractions</strong>. There are plenty of distractions that will lead us down the wrong path or distract us from our core business. Working in industry means that ultimately our job is create software that drives the creation of revenue, not necessarily to advance the state of art. Although the two are not necessarily mutually incompatible.</p>
<p>With this in mind, it’s important to note there are plenty of vocal Haskellers who work under a value system that is largely incompatible with industrial practices. Much of which stems from hobbyists or academics who use Haskell as a vehicle for their work. Not to diminish this category people or their work, yet the metrics for success in this space are different enough that they tend to view the programming space from a perspective that can be incommensurable to industrial programmers.</p>
<p>The tensions of academic and industrial influences in Haskell is one of the strong driving forces for progress; but it also leads to conflicts of interest for many of us who write code to support ourselves. If one decides to engage with the community, it’s important to realize that many of the topics being actively discussed are likely 3+ years out from being at the point where one would want to bet the livelihood of a company on.</p>
<p><strong>Testing and building</strong>. For development builds using cabal sandboxes it’s usually essential to be able to pull in internal libraries that are not on Hackage. To do with cabal sandboxes this can be achieved with either a script to provision the dependencies.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> clone https://github.com/bscarlet/llvm-general
$ <span class="kw">cd</span> llvm-general
$ <span class="kw">git</span> checkout ca6489fdddde5c956a4032956e28099ff890a80b
$ <span class="kw">cd</span> ..
$ <span class="kw">cabal</span> sandbox add-source vendor/llvm-general-pure</code></pre></div>
<p>With stack this can actually all be configured in the stack.yaml file.</p>
<div class="sourceCode"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="fu">packages:</span>
<span class="kw">-</span> <span class="fu">location:</span>
    <span class="fu">git:</span> https://github.com/bscarlet/llvm-general
    <span class="fu">commit:</span> ca6489fdddde5c956a4032956e28099ff890a80b
  <span class="fu">subdirs:</span>
    <span class="kw">-</span> llvm-general-pure/</code></pre></div>
<p>Private TravisCI or Codeship are not worth the trouble of setting up if one ever envisions the project spanning multiple repos. Getting their virtual machine provisioned with the proper credentials to pull from multiple Github repos is still a source of trouble. For build slaves and continuous integration I’ve used BuildBot successfully to work with the usual cabal and stack toolchain.</p>
<p>For large multi-package builds, I can’t speak highly enough of Neil Mitchell’s build system <a href="http://shakebuild.com/">shake</a> which is itself written in Haskell. The shake build uses Shakefiles which are monadic description of a graph of dependencies to resolve and their artifacts. For a contrived example consider running a Markdown file through Pandoc.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Development.Shake</span>
<span class="kw">import </span><span class="dt">Development.Shake.FilePath</span>

main <span class="fu">=</span> shakeArgs shakeOptions <span class="fu">$</span> <span class="kw">do</span>
    want [<span class="st">&quot;book.html&quot;</span>]
    <span class="st">&quot;book.html&quot;</span> <span class="fu">*&gt;</span> \out <span class="ot">-&gt;</span> <span class="kw">do</span>
        need [<span class="st">&quot;book.md&quot;</span>]
        system&#39; <span class="st">&quot;pandoc&quot;</span> [<span class="st">&quot;book.md&quot;</span>,<span class="st">&quot;-o&quot;</span>,<span class="st">&quot;book.html&quot;</span>]</code></pre></div>
<p><strong>Fast builds lead to faster turnaround.</strong> If care isn’t taken, projects can quickly devolve to become unmanageably slow to compile, usually the problem is avoidable with some care. Deriving instances of Read/Show/Data/Generic for largely recursive ADTs can sometimes lead to quadratic memory behavior when the nesting gets deep. The somewhat ugly hack to speed up compile time here is to run <code>ghc -ddump-deriv Module.hs</code> and then manually insert the resulting code instead of deriving it everytime. Not a great solution, but I’ve seen it drastically improve compilation footprint and time. Also be tactical with uses of <code>INLINE</code> and <code>SPECIALIZE</code> as inlining at many call sites has a non-trivial cost. Avoid TemplateHaskell as it can cause ridiculously inflated build times and enormous memory footprints in GHCi.</p>
<p>I’ts pretty common to use ghci and ghcid to during development stage. Your mileage may also vary with ghc-mod support for Vim and Emacs which allows in-editor type introspection.</p>
<p>Pulling from cabal to provision our test server can take minutes to hours depending on the size of our dependency tree. Fortunately it’s easy to set up a <a href="https://github.com/haskell/hackage-server#mirroring">Hackage server mirror</a> that contains all of our internal dependencies that can be served quickly from our local servers or an <a href="https://hackage.haskell.org/package/hackage-mirror">S3 bucket</a>. We can then simply alter our <code>~/.cabal/config</code> to change the <code>remote-repo</code> to our custom mirror.</p>
<p><strong>Records</strong> The record system is a continual source of pain. It’s best to come up with an internal convention for naming record accessors and use qualified imports. It sucks for now, but there are some changes coming up the 8.0 release that will make life easier.</p>
<p>When using Generics to derive ToJSON and FromJSON instances there is <code>fieldLabelModifier</code> field that can be used to modify the derived field so the serialize does not have to match the Haskell record accessors. For example we’ll <code>drop</code> the first three characters:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Login</span> <span class="fu">=</span> <span class="dt">Login</span>
  { _<span class="ot">lgusername ::</span> <span class="dt">Text</span>
  , _<span class="ot">lgpassword ::</span> <span class="dt">Text</span>
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>, <span class="dt">Generic</span>)

<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Login</span> <span class="kw">where</span>
  toJSON <span class="fu">=</span> genericToJSON defaultOptions { fieldLabelModifier <span class="fu">=</span> drop <span class="dv">3</span> }</code></pre></div>
<p>This will serialize out to.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="op">{</span>
  <span class="st">&quot;username&quot;</span><span class="op">:</span> <span class="st">&quot;stephen&quot;</span>
  <span class="st">&quot;password&quot;</span><span class="op">:</span> <span class="st">&quot;hunter2&quot;</span>
<span class="op">}</span></code></pre></div>
<p><strong>Performance and Monitoring</strong> A common performance problem is that of many small updates updates to records with large numbers of fields. Records of hundreds of fields are somewhat pathological but in practice they show up in a lot of business logic that needs to interact with large database rows. Too much of this can very noticeable impact on GC pressure by doing allocations on each update. If you notice runaway memory performance, one of the first places to look (after the usual suspects) is look for overgrown records and possibly inside of StateT with use of lots of modify`` in sequence.</p>
<p>The other very common library for live performance monitoring is <code>ekg</code> which simply forks off a thread that manages the state of the GHC runtime internals and can serve this data to other logging services via HTTP + JSON or via a web server. For example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# Language OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">System.Remote.Monitoring</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  ekg <span class="ot">&lt;-</span> forkServer <span class="st">&quot;localhost&quot;</span> <span class="dv">8000</span>
  putStrLn <span class="st">&quot;Started server on http://localhost:8000&quot;</span>
  forever <span class="fu">$</span> getLine <span class="fu">&gt;&gt;=</span> putStrLn</code></pre></div>
<p>ekg has several large dependencies so sometimes its desirable to optionally enable it with a cabal configuration flag so that it’s not included unless we want a development build. We just qualify our build-depends to include it in the dependencies if the flag is set via <code>cabal configure -fekg</code>.</p>
<div class="sourceCode"><pre class="sourceCode yaml"><code class="sourceCode yaml">flag ekg
  <span class="fu">manual:</span> True
  <span class="fu">default:</span> True
  <span class="fu">description:</span> Compile with ekg monitoring.

<span class="fu">build-depends:</span>
  if flag(ekg)
    <span class="fu">build-depends:</span>
      ekg &gt;= 0.4 &amp;&amp; &lt; 0.5</code></pre></div>
<p><strong>Strings</strong> The strings types are mature, but unwieldy to work with in practice. It’s best to just make peace with the fact that in literally every module we’ll have boilerplate just to do simple manipulation and IO. <code>OverloadedStrings</code> overcomes some of the issues, but it’s still annoying that you’ll end up playing string type-tetris a lot.</p>
<p>If you end up rolling a custom prelude it’s worth just correcting <code>putStrLn</code> and <code>print</code> to what they should be in a just world:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- IO</span>
putStr<span class="ot"> ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> m ()
putStr <span class="fu">=</span> liftIO <span class="fu">.</span> Data.Text.IO.putStr

putStrLn<span class="ot"> ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> m ()
putStrLn <span class="fu">=</span> liftIO <span class="fu">.</span> Data.Text.IO.putStrLn

print<span class="ot"> ::</span> (<span class="dt">MonadIO</span> m, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> m ()
print <span class="fu">=</span> liftIO <span class="fu">.</span> Prelude.print</code></pre></div>
<p>A common pattern is to use a multiparamter typeclass to do string conversions between all the common (Data.Text.Text, Data.Text.Lazy, Data.ByteString.UTF8 Data.ByteString.Lazy.UTF8, [Char]) types. You’ll end up eating at least one typeclass dictionary lookup per call to <code>s</code> but this is fairly benign in most cases.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">StringConvert</span> a b <span class="kw">where</span>
<span class="ot">  s ::</span> a <span class="ot">-&gt;</span> b

<span class="kw">instance</span> (<span class="dt">ToString</span> a, <span class="dt">FromString</span> b) <span class="ot">=&gt;</span> <span class="dt">StringConvert</span> a b <span class="kw">where</span>
  s <span class="fu">=</span> fromString <span class="fu">.</span> toString

<span class="kw">instance</span> <span class="dt">FromString</span> <span class="dt">UTF8.ByteString</span> <span class="kw">where</span>
    fromString <span class="fu">=</span> UTF8.fromString

<span class="kw">instance</span> <span class="dt">FromString</span> <span class="dt">LUTF8.ByteString</span> <span class="kw">where</span>
    fromString <span class="fu">=</span> LUTF8.fromString

<span class="kw">instance</span> <span class="dt">ToString</span> <span class="dt">UTF8.ByteString</span> <span class="kw">where</span>
    toString <span class="fu">=</span> UTF8.toString

<span class="kw">instance</span> <span class="dt">ToString</span> <span class="dt">LUTF8.ByteString</span> <span class="kw">where</span>
    toString <span class="fu">=</span> LUTF8.toString</code></pre></div>
<p>There are libraries on hackage ( <a href="https://hackage.haskell.org/package/string-convert-2.0.1">string-convert</a>, <a href="https://hackage.haskell.org/package/string-conv-0.1">string-conv</a> ) that implement this pattern.</p>
<p><strong>Documentation is abysmal</strong>. Open source Haskell libraries are typically released with below average or non-existent documentation. The reasons for this are complicated confluence of technical and social phenomena that can’t really be traced back to one root cause. <em>Basically, it’s complicated.</em> What this means for industrial use is to always budget extra hours of lost productivity needed to reverse engineering libraries from their test suites just to get an minimal example running. It’s not great, but that’s the state of things.</p>
<p><strong>You own the transitive dependency tree</strong>. With such a small ecosystem, anything we pull in you have to be able to maintain and support should the upstream source dry up or wither on the vine. The cold truth is if there’s no community-provided documentation for the library and you depend on it for your product, you’ve just added technical debt to your company. The person you have to hand the code off to will have to read through your code and all it’s transitive dependencies, and while the undocumented upstream libs might make sense they may utterly confound your successor.</p>
<p>If you’re depending on your Haskell code being stable and supportable it’s worth being conservative in what dependencies you pull into your tree.</p>
<p><strong>Avoid TemplateHaskell</strong>. Enough said, it’s a eternal source of pain and sorrow that I never want to see anywhere near code that I had to maintain professionally. The best quote about this is found in this <a href="https://stackoverflow.com/questions/10857030/whats-so-bad-about-template-haskell">StackOverlow thread</a>:</p>
<blockquote>
<p>Think about it. Half the appeal of Haskell is that its high-level design allows you to avoid huge amounts of useless boilerplate code that you have to write in other languages. If you need compile-time code generation, you’re basically saying that either your language or your application design has failed you.</p>
</blockquote>
<p>If you need to crank out that much boilerplate just to get something done, go back and rethink. If a upstream library forces you to use it, don’t depend on that library. There is almost always a way to accomplish the task without falling back on TH.</p>
<p><strong>Don’t be afraid to train people.</strong> Contrary to a lot of popular myths, with the right direction people can indeed pick up Haskell quite quickly. There are great developers outside the community who given a little bit of insight into Haskell will turn into great Haskellers. People who have a little experience with Scheme, Clojure, Scala, Ocaml can pretty quickly learn the language.</p>
<p>I was fortunate enough to train an a very talented intern named Dan who came in not knowing any Haskell (was primarily a Java developer) and in two weeks had picked up the language and was amazingly productive. Learning on your own is much more time consuming than having a Haskell friend sitting next to you. It’s a time investment, but it can pay off exponentially with the right person and with Dan it most certainly did.</p>
<p><strong>Network with other industrial users.</strong> There is no shortage of hobbyist Haskell programmers to consult with about problems. Though by my estimates in the United States there are probably only around 70-100 people working on Haskell fulltime and a good deal more working part-time or anticipating using it. It’s worth networking with other industrial users to share best practices.</p>
<p>Eventually with enough use, many of these rough corners in the language will get polished over, best practices become absorbed, and libraries will get built.</p>]]></summary>
</entry>
<entry>
    <title>Vim and Haskell in 2016</title>
    <link href="http://www.stephendiehl.com/posts/vim_2016.html" />
    <id>http://www.stephendiehl.com/posts/vim_2016.html</id>
    <published>2016-01-24T00:00:00Z</published>
    <updated>2016-01-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="vim-and-haskell-in-2016">Vim and Haskell in 2016</h3>
<p>A couple of years I wrote about Haskell editor tooling and figured this deserved a bit of an update now that the tooling has become mature. So let’s walk through how we install an minimalist Haskell dev environment on Linux.</p>
<p>If you don’t want to build the individual components youself, you can just download <a href="https://github.com/sdiehl/haskell-vim-proto">the source code</a>.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> clone --recursive https://github.com/sdiehl/haskell-vim-proto.git 
$ <span class="kw">cd</span> haskell-vim-proto
$ <span class="kw">cp</span> -n vimrc ~/.vimrc 
$ <span class="kw">cp</span> -rn vim ~/.vim</code></pre></div>
<hr/>
<h4 id="dev-environment">Dev Environment</h4>
<p>We’ll presume Ubuntu 14.04 as the lowest common denominator, although nothing here is specific to any particular Linux. Obviously first we need to install the world’s greatest text editor, we’ll presume no base vim configuration and build everything from a clean slate.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">sudo</span> apt-get install vim</code></pre></div>
<p>Times have changed quite a bit, and the new preferred way of install GHC in 2016 is to forgo using the system package manager for installing ghc and use <a href="http://docs.haskellstack.org/en/stable/README.html">Stack</a> to manage the path to the compiler executable and sandboxes. To do this we pull in the FP Complete key and start the build. This will take a few minutes.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">sudo</span> apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 575159689BEFB442
$ <span class="kw">echo</span> <span class="st">&#39;deb http://download.fpcomplete.com/ubuntu trusty main&#39;</span><span class="kw">|sudo</span> tee /etc/apt/sources.list.d/fpco.list
$ <span class="kw">sudo</span> apt-get update <span class="kw">&amp;&amp;</span> <span class="kw">sudo</span> apt-get install stack -y
$ <span class="kw">stack</span> setup</code></pre></div>
<p>After all is said and done you should have the latest Haskell compiler installed in your home folder. Stack is all self-contained within the <code>~/.stack</code> and places its executables in <code>~/.local/bin</code>. For instance:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">stack</span> path
<span class="kw">Run</span> from outside a project, using implicit global project config
<span class="kw">Using</span> resolver: lts-3.14
<span class="kw">global-stack-root</span>: /home/user/.stack
<span class="kw">project-root</span>: /home/user/.stack/global-project
<span class="kw">config-location</span>: /home/user/.stack/global-project/stack.yaml
<span class="kw">local-bin-path</span>: /home/user/.local/bin</code></pre></div>
<p>All is well and we can launch the interactive shell with the latest GHC 7.10 compiler.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">stack</span> ghci
<span class="kw">Configuring</span> GHCi with the following packages: 
<span class="kw">GHCi</span>, version 7.10.3: http://www.haskell.org/ghc/  :? for help
<span class="kw">Ok</span>, modules loaded: none.
<span class="kw">Prelude&gt;</span> </code></pre></div>
<h4 id="pathogen">pathogen</h4>
<p>Pathogen is a bundling system for vim that will allow us to pull directly from Git repos to manage and update our vim packages off of the <code>bundles</code> directory.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">mkdir</span> -p ~/.vim/autoload ~/.vim/bundle
$ <span class="kw">curl</span> -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim</code></pre></div>
<p>Using pathogen we’ll install the following libraries.</p>
<ol style="list-style-type: decimal">
<li><code>ghcmod-vim</code></li>
<li><code>neco-ghc</code></li>
<li><code>vim-snipmate</code></li>
<li><code>syntastic</code></li>
<li><code>neocompletee.vim</code></li>
<li><code>ctrlp.vim</code></li>
<li><code>nerdtree</code></li>
<li><code>nerdcommenter</code></li>
<li><code>tabular</code></li>
<li><code>supertab</code></li>
<li><code>neocomplete</code></li>
</ol>
<p>To do this we simply mmove to our bundles directory and pull the repos.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cd</span> ~/.vim/bundle
$ <span class="kw">git</span> clone https://github.com/eagletmt/ghcmod-vim.git
$ <span class="kw">git</span> clone https://github.com/eagletmt/neco-ghc
$ <span class="kw">git</span> clone https://github.com/ctrlpvim/ctrlp.vim.git
$ <span class="kw">git</span> clone https://github.com/scrooloose/syntastic.git
$ <span class="kw">git</span> clone https://github.com/tomtom/tlib_vim.git
$ <span class="kw">git</span> clone https://github.com/MarcWeber/vim-addon-mw-utils.git
$ <span class="kw">git</span> clone https://github.com/garbas/vim-snipmate.git
$ <span class="kw">git</span> clone https://github.com/scrooloose/nerdtree.git
$ <span class="kw">git</span> clone https://github.com/scrooloose/nerdcommenter.git
$ <span class="kw">git</span> clone https://github.com/godlygeek/tabular.git
$ <span class="kw">git</span> clone https://github.com/ervandew/supertab.git
$ <span class="kw">git</span> clone https://github.com/Shougo/neocomplete.vim.git</code></pre></div>
<p>The one project that’s slightly special is vimproc which contains a C module which needs to be compiled. It can be installed with:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> clone https://github.com/Shougo/vimproc.vim.git
$ <span class="kw">cd</span> vimproc.vim
$ <span class="kw">make</span></code></pre></div>
<hr/>
<h4 id="ghc-mod">ghc-mod</h4>
<p>The preferred tool for background checking of Haskell syntax is still <code>ghc-mod</code>. Over the years it has become more featureful and more efficient. The hlint tool is also used to supplement and provide helpful hints about ways to refactor common code smells. We will integrate with ghc-mod in several ways, but the first step is to install the command-line tool <code>ghc-mod</code> which vim will send program changes to query information. To install it we use stack.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">stack</span> install hlint ghc-mod</code></pre></div>
<pre class="shell"><code>Copied executables to /home/user/.local/bin:
- ghc-mod
- ghc-modi
- hlint</code></pre>
<hr/>
<h4 id="vim-defaults">vim defaults</h4>
<p>Ok, now to the fun stuff. We’ll set up our basic vim configuration with some pretty sensible defaults that should work nicely in either terminal vim or gvim. Fairly standard stuff here to enable syntax highlighting, line numbers, tab completion and two space indentation. The last line enables the pathogen manager which pulls all the bundles into the environment.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl">syntax on
filetype plugin indent on

set nocompatible
set number
set nowrap
set showmode
set tw=<span class="dv">80</span>
set smartcase
set smarttab
set smartindent
set autoindent
set softtabstop=<span class="dv">2</span>
set shiftwidth=<span class="dv">2</span>
set expandtab
set incsearch
set mouse=a
set history=<span class="dv">1000</span>
set clipboard=unnamedplus,autoselect

set completeopt=menuone,menu,longest

set wildignore+=<span class="dt">*\</span>\tmp\\<span class="dt">*,*.</span>swp,<span class="dt">*.</span>swo,<span class="dt">*.</span>zip,.git,.cabal-sandbox
set wildmode=longest,list,full
set wildmenu
set completeopt+=longest

set t_Co=<span class="dv">256</span>

set cmdheight=<span class="dv">1</span>

execute pathogen<span class="co">#infect()</span></code></pre></div>
<hr/>
<h4 id="syntax-highlighting">syntax highlighting</h4>
<p>The best syntax highlighting that I know of is maintaind under the vim-scripts project on Github. We’ll download it and place them into <code>~/.vim/syntax/</code>.</p>
<ul>
<li><a href="https://github.com/sdiehl/haskell-vim-proto/blob/master/vim/syntax/haskell.vim">syntax/haskell.vim</a></li>
<li><a href="https://github.com/sdiehl/haskell-vim-proto/blob/master/vim/syntax/cabal.vim">syntax/cabal.vim</a></li>
</ul>
<hr/>
<h4 id="syntastic">syntastic</h4>
<p>Syntactic provides background syntax checking with line-by-line error reporting. It integrates with ghc-mod and hlint to provide semantic hinting about type errors and possible code corrections. To enable it we add the following lines to our <code>.vimrc</code>.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl"><span class="fu">map</span> &lt;Leader&gt;<span class="kw">s</span> <span class="kw">:</span><span class="ot">SyntasticToggleMode&lt;CR&gt;</span>

<span class="ot">set statusline</span><span class="ch">+</span><span class="ot">=%#warningmsg#</span>
<span class="ot">set statusline</span><span class="ch">+</span><span class="ot">=%{SyntasticStatuslineFlag</span><span class="ch">()</span><span class="ot">}</span>
<span class="ot">set statusline</span><span class="ch">+</span><span class="ot">=%</span><span class="ch">*</span>

<span class="ot">let g</span><span class="kw">:</span><span class="st">syntastic_always_populate_loc_list = 1</span>
<span class="st">let g</span><span class="kw">:s</span>yntastic_auto_loc_list = <span class="dv">0</span>
let g:syntastic_check_on_open = <span class="dv">0</span>
let g:syntastic_check_on_wq = <span class="dv">0</span></code></pre></div>
<p>Now when a syntax error, type error, or code smell is introduced the left gutter will highlight the line and show the error message from GHC in the status line.</p>
<p>For example a syntax error.</p>
<p>
<img src="/images/vim_err.png">
</p>
<p>Or a hlint error.</p>
<p>
<img src="/images/vim_hlint.png">
</p>
<hr/>
<h4 id="ghc-mod-1">ghc-mod</h4>
<p>To hook into GHC’s code competion capabilities we map several keyboard commands to ghc-mod functions.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl"><span class="fu">map</span> &lt;silent&gt; tw :GhcModTypeInsert<span class="kw">&lt;CR&gt;</span>
<span class="fu">map</span> &lt;silent&gt; ts :GhcModSplitFunCase<span class="kw">&lt;CR&gt;</span>
<span class="fu">map</span> &lt;silent&gt; tq :GhcModType<span class="kw">&lt;CR&gt;</span>
<span class="fu">map</span> &lt;silent&gt; te :GhcModTypeClear<span class="kw">&lt;CR&gt;</span></code></pre></div>
<p>Now to use ghc-mod’s case expand feature we simply highlight the scrutinized variable of case expression and type <kbd>t</kbd> + <kbd>s</kbd> to expand out the cases. For example:</p>
<p>
<img src="/images/vim_case_expand.png">
</p>
<p>To autofill in the type of an expression we simply highlight the name of toplevel expression and type <kbd>t</kbd> + <kbd>w</kbd> which will insert the signature on the line above. For example:</p>
<p>
<img src="/images/vim_sig.png">
</p>
<p>To query the type of a subexpression we highlight any term and type <kbd>t</kbd> + <kbd>q</kbd> to get the type of value under the cursor.</p>
<hr/>
<h4 id="supertab">supertab</h4>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl">let g:SuperTabDefaultCompletionType = <span class="kw">&#39;</span><span class="st">&lt;c-x&gt;&lt;c-o&gt;</span><span class="kw">&#39;</span>

<span class="kw">if</span> has(<span class="kw">&quot;</span><span class="st">gui_running</span><span class="kw">&quot;</span>)
  imap &lt;c-space&gt; &lt;c<span class="kw">-r</span>&gt;=SuperTabAlternateCompletion(<span class="kw">&quot;</span><span class="st">\&lt;lt&gt;c-x&gt;\&lt;lt&gt;c-o&gt;</span><span class="kw">&quot;</span>)&lt;cr&gt;
<span class="kw">else</span> <span class="kw">&quot;</span><span class="st"> no gui</span>
<span class="st">  if has(</span><span class="kw">&quot;</span>unix<span class="kw">&quot;</span><span class="st">)</span>
<span class="st">    inoremap &lt;Nul&gt; &lt;c-r&gt;=SuperTabAlternateCompletion(</span><span class="kw">&quot;</span>\&lt;<span class="kw">lt</span>&gt;c<span class="kw">-x</span>&gt;\&lt;<span class="kw">lt</span>&gt;c<span class="kw">-o</span>&gt;<span class="kw">&quot;</span><span class="st">)&lt;cr&gt;</span>
<span class="st">  endif</span>
<span class="st">endif</span></code></pre></div>
<p>To enable familiar tab completion we configure supertab to dispatch to neco-ghc’s tab completion routines instead of the usual local variable completion. After that we configure necoghc to be the default tab completion method.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl">let g:haskellmode_completion_ghc = <span class="dv">1</span>
autocmd FileType haskell setlocal omnifunc=necoghc<span class="co">#omnifunc</span></code></pre></div>
<p>So now pressing tab while in a LANGUAGE pragma, import statement, or anywhere in a subexpression will use neco-ghc’s tab completion routines to find the context appropriate statement that matches the partial expression under the cursor.</p>
<p>For example completing language extensions:</p>
<p>
<img src="/images/vim_ext.png">
</p>
<p>Or module import declarations:</p>
<p>
<img src="/images/vim_import.png">
</p>
<p>Or import name management:</p>
<p>
<img src="/images/vim_imports.png">
</p>
<h4 id="nerdtree">nerdtree</h4>
<p>Nerdtree is the standard file management plugin which replaces vim’s default left-hand file pile. It allows recursive directory traversal with folds and slew of other convenient features. It’s usually one of the first things installed in any respectable vim installation.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl"><span class="fu">map</span> &lt;Leader&gt;n :NERDTreeToggle<span class="kw">&lt;CR&gt;</span></code></pre></div>
<p>
<img src="/images/vim_nerdtree.png">
</p>
<h4 id="tabularize">tabularize</h4>
<p>Tabularize allows uniform aligned code formatting based on any textual regex pagttern. For Haskell there are several common identifiers that we typically align on; and we can map specific keys to these common patterns.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl">let g:haskell_tabular = <span class="dv">1</span>

vmap a= :Tabularize /=<span class="kw">&lt;CR&gt;</span>
vmap a; :Tabularize /::<span class="kw">&lt;CR&gt;</span>
vmap a- :Tabularize /-&gt;<span class="kw">&lt;CR&gt;</span></code></pre></div>
<p>For example typing <kbd>a</kbd> + <kbd>-</kbd> on the case arm branches will align on the right arrow.</p>
<p>
<img src="/images/vim_align.png">
</p>
<h4 id="vim-snipmate">vim-snipmate</h4>
<p>The best Haskell snippet collection that I know of is one I’ve curated over the years, that automates the insertion of many common insert statements, language extensions and instance declarations. This is placed in the <code>~/.vim/snippets</code> folder.</p>
<ul>
<li><a href="https://github.com/sdiehl/haskell-vim-proto/blob/master/vim/snippets/haskell.snippets">haskell.snippet</a></li>
</ul>
<p>The usage is simple, simply define a keyword in the <code>haskell.snippets</code> file of the form:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">snippet derive
	<span class="ot">{-# LANGUAGE DeriveDataTypeable #-}</span>
	<span class="ot">{-# LANGUAGE DeriveGeneric #-}</span>
	<span class="ot">{-# LANGUAGE DeriveFunctor #-}</span>
	<span class="ot">{-# LANGUAGE DeriveTraversable #-}</span>
	<span class="ot">{-# LANGUAGE DeriveFoldable #-}</span></code></pre></div>
<p>Then tab completing on the this phrase in Insert Mode will expand out the code block.</p>
<p>
<img src="/images/vim_snippet.png">
</p>
<hr/>
<h4 id="ctrl-p">ctrl-p</h4>
<p>Ctrl-p is a fuzzy file search plugin which allows quick browsing of a project based on a fuzzy text search of the filename or it’s contents. We’ll bind the ctrl-p panel launch to <kbd>\</kbd> + <kbd>t</kbd>.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl"><span class="fu">map</span> &lt;silent&gt; &lt;Leader&gt;t :CtrlP()<span class="kw">&lt;CR&gt;</span>
noremap &lt;leader&gt;b&lt;space&gt; :CtrlPBuffer&lt;cr&gt;
let g:ctrlp_custom_ignore = <span class="kw">&#39;</span><span class="st">\v[\/]dist$</span><span class="kw">&#39;</span></code></pre></div>
<p>
<img src="/images/vim_fuzzy.png">
</p>
<hr/>
<h4 id="summary">Summary</h4>
<p>In summary adding these plugins and lines to the <code>.vimrc</code> will introduce several Haskell specific commands which are bound to these keyboard shortcuts:</p>
<table>
<thead>
<tr class="header">
<th align="left">Command</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><kbd>t</kbd> + <kbd>w</kbd></td>
<td align="left">Insert type for toplevel declaration</td>
</tr>
<tr class="even">
<td align="left"><kbd>t</kbd> + <kbd>q</kbd></td>
<td align="left">Query type of expression under cursor</td>
</tr>
<tr class="odd">
<td align="left"><kbd>t</kbd> + <kbd>s</kbd></td>
<td align="left">Case split expression under cursor</td>
</tr>
<tr class="even">
<td align="left"><kbd>t</kbd> + <kbd>e</kbd></td>
<td align="left">Erase type query</td>
</tr>
<tr class="odd">
<td align="left"><kbd>a</kbd> + <kbd>=</kbd></td>
<td align="left">Align on equal sign</td>
</tr>
<tr class="even">
<td align="left"><kbd>a</kbd> + <kbd>-</kbd></td>
<td align="left">Align on case match</td>
</tr>
<tr class="odd">
<td align="left"><kbd>Ctrl</kbd> + <kbd>x</kbd> + <kbd>o</kbd></td>
<td align="left">Tab complete under cursor</td>
</tr>
<tr class="even">
<td align="left"><kbd>\</kbd> + <kbd>t</kbd></td>
<td align="left">Open fuzzy file finder</td>
</tr>
<tr class="odd">
<td align="left"><kbd>\</kbd> + <kbd>n</kbd></td>
<td align="left">Open file explorer</td>
</tr>
<tr class="even">
<td align="left"><kbd>\</kbd> + <kbd>c</kbd> + <kbd>Space</kbd></td>
<td align="left">Toggle comment of text under cursor</td>
</tr>
<tr class="odd">
<td align="left"><kbd>\</kbd> + <kbd>c</kbd> + <kbd>s</kbd></td>
<td align="left">Toggle “sexy” comment of text</td>
</tr>
</tbody>
</table>]]></summary>
</entry>
<entry>
    <title>Functional Programming, Abstraction, and Names</title>
    <link href="http://www.stephendiehl.com/posts/abstraction.html" />
    <id>http://www.stephendiehl.com/posts/abstraction.html</id>
    <published>2016-01-09T00:00:00Z</published>
    <updated>2016-01-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="functional-programming-abstraction-and-naming-things">Functional Programming, Abstraction, and Naming Things</h3>
<p>Some years ago - never mind how long precisely - having little or no money I found myself as a teaching assistant for an introductory course in algebra. In an event that I still recall, the instructor gave a lecture about the fundamentals definitions of a topic known as <strong>group theory</strong>. For those that don’t know, a group is an algebraic structure that consists of a set of elements together with an operation that combines any two elements to produce a third element; and where the operation satisfies four equational laws. The lecture was straightforward, but afterwards a student walked up to me and asked me question:</p>
<blockquote>
<p>So what’s a group … actually?</p>
</blockquote>
<p>That’s easy I thought, I’ll use the usual metaphor one uses to describe groups: modular arithmetic or clock arithmetic. If the hour hand of a clock is at 9 and 4 hours is added to it it loops back around to 1. One can never add time to the position outside of the 12-hour cycle. The addition of time always proceeds equally forward if equal intervals are added. If one advances the clock by no time, it remains at the same position. And regardless of what time you’re at there’s always some interval of time you can add to get to any other point in time.</p>
<p>This is a vague metaphor-heavily description of what a group is. More precisely it’s defined to be a combination of a set <span class="math inline">\(\text{G}\)</span> and an operation <span class="math inline">\(\star\)</span> written as <span class="math inline">\((\text{G}, \star)\)</span> with four laws:</p>
<table>
<thead>
<tr class="header">
<th align="left">Law</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><em>Closure</em></td>
<td align="left">For all <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span> in <span class="math inline">\(G\)</span>, the result of the operation, <span class="math inline">\(a \star b\)</span>, is also in <span class="math inline">\(G\)</span>.</td>
</tr>
<tr class="even">
<td align="left"><em>Associativity</em></td>
<td align="left">For all <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span> and <span class="math inline">\(c\)</span> in <span class="math inline">\(G\)</span>, <span class="math inline">\((a \star b) \star c = a \star (b \star c)\)</span>.</td>
</tr>
<tr class="odd">
<td align="left"><em>Identity</em></td>
<td align="left">For any element <span class="math inline">\(a\)</span> in <span class="math inline">\(G\)</span> there is an element <span class="math inline">\(e\)</span> where <span class="math inline">\(e \star a = a \star e = a\)</span>.</td>
</tr>
<tr class="even">
<td align="left"><em>Invertibility</em></td>
<td align="left">For each element <span class="math inline">\(a\)</span> in <span class="math inline">\(G\)</span> there is an element <span class="math inline">\(b\)</span> where <span class="math inline">\(a \star b = b \star a = e\)</span>, where <span class="math inline">\(e\)</span> is the identity.</td>
</tr>
</tbody>
</table>
<p>Groups are an extremely important concept that are integral to next generation of <a href="https://en.wikipedia.org/wiki/Elliptic_curve_cryptography">elliptic curve cryptography</a> that protect our internet transactions and banking, and on top of that show up constantly as part of our underlying description of the physical laws <a href="https://en.wikipedia.org/wiki/Wigner%27s_theorem">of the universe itself</a>.</p>
<p>After a half hour explanation of clock arithmetic, examples over the integers and hand waving wildly at blackboard, the student then asked me:</p>
<blockquote>
<p>I understand the equations, but what’s a group actually?</p>
</blockquote>
<p>At this point, I didn’t have much else to say. There really is nothing I can say, other than that a group <em>is the set of equations</em>, I can’t point at something in the classroom and say that this object fully embodies “groupiness”, nor can I pull out a dictionary and find a synonym for group that would in any way convey the essence of what a group is. Common English simply lacks a word for “set with operation satisfying closure, associativity, identity and invertibility”.</p>
<p>The concept is not particularly hard in retrospect, and indeed after a bit of quiet contemplation the topic eventually clicked for the student and she eventually went on to take other classes in higher mathematics, in particular <a href="http://www.math3ma.com/mathema/2015/8/31/what-is-galois-theory-anyway">Galois theory</a> which builds on these foundations. Since then I’ve left teaching math behind me and gone on to programming in industry.</p>
<p>So why do I bring this up? Groups, like many concepts in functional programming, are often some of the first concepts that we encounter that defy a reduction down to our everyday experience; and are a constant point of confusion because of it. Yet, for as long as I’ve been involved with industrial programmers it has been a constant point of contention that the names used in describing concepts like <em>Monad, Functor</em>, and <em>Category</em> are problematic because they don’t convey immediate (partial) understanding by reducing them down to concepts from our everyday experience. This thinking is not all that dissimilar from the mental gap that the student studying groups for the first time had to overcome.</p>
<blockquote>
<p>I understand the functions and laws, but what’s a monad actually?</p>
</blockquote>
<p>A monoid (or pick any of your favorite Haskell abstractions) is typically a small interface defined over a set of types that satisfies certain laws. This style of designing abstractions is often quite foreign in programming in the large, and other schools of thought (see <a href="https://en.wikipedia.org/wiki/Design_Patterns">Gang of Four</a>) actively encourage weaving cryptic metaphors and anthropomorphising code as a means to convey structure.</p>
<table>
<thead>
<tr class="header">
<th align="left">Law</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><em>Left Identity</em></td>
<td align="left"><code>mempty &lt;&gt; x = x</code></td>
</tr>
<tr class="even">
<td align="left"><em>Right Identity</em></td>
<td align="left"><code>x &lt;&gt; mempty = x</code></td>
</tr>
<tr class="odd">
<td align="left"><em>Associativity</em></td>
<td align="left"><code>(x &lt;&gt; y) &lt;&gt; z = x &lt;&gt; (y &lt;&gt; z)</code></td>
</tr>
</tbody>
</table>
<p>The argument that <strong>Monoid</strong> should be called something else (maybe <strong>Appendable</strong>) is about as convincing as the proposition that a <strong>Group</strong> should be <strong>Clock</strong>. A clock in a contrived sense can be considered a group and perhaps helps with some initial intuition, but the term is ultimately misleading. Similarly, if one expects that <em>all</em> constructs in programming be modeled on everyday concepts one will eventually hit up against the limitations of everyday experience to model higher abstractions. We would never arrive at complex numbers by counting scratches on a clay tablet, nor will would come up with Galois theory or elliptic curve cryptography by considering groups purely in terms of clocks.</p>
<p>The algebraic terminology was invented often hundred of years ago and is effectively arbitrary. Therein lies the strength though, it’s intentionally precise because it doesn’t come muddled in the baggage of everyday experience, which can confuse and mislead (i.e only special monoids have an append-like operation in their definition). Using the terminology of mathematics opens up hundreds of years of progress done by thousands of people discovering results we would never think of on our own. And on a larger scale often opens up <a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">surprising results</a> mapping between different disciplines and computer science.</p>
<p>Dijkstra’s quote is quite apt: “The purpose of abstraction is not to be vague, but to create a new semantic level in which one can be absolutely precise.” Programming with precise algebraic names and equational reasoning is here to stay, and the edifice of abstraction is only going to grow as programming becomes more precise and refined.</p>
<p>
<a href="https://wiki.haskell.org/Typeclassopedia"> <img src="/images/Typeclassopedia-diagram.png" width="100%"> </a>
</p>]]></summary>
</entry>
<entry>
    <title>Monads to Machine Code</title>
    <link href="http://www.stephendiehl.com/posts/monads_machine_code.html" />
    <id>http://www.stephendiehl.com/posts/monads_machine_code.html</id>
    <published>2016-01-04T00:00:00Z</published>
    <updated>2016-01-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="monads-to-machine-code">Monads to Machine Code</h3>
<p>Just-in-time or JIT compilation is compilation done by dynamically generating executable code. It’s a common technique used in many language runtimes to generate optimized code for hot code paths as well ahead of time compilation for various tasks.</p>
<p>So let’s build a small LLVM-like intermediate language and JIT execution engine in Haskell. This will only function with modern Linux and x86-64 architecture, although in principle this will work on any platform if you can make the appropriate FFI calls to <code>mmap</code> and <code>mprotect</code> syscalls on your respective platform.</p>
<p>Source code is <a href="https://github.com/sdiehl/tinyjit">available here</a>.</p>
<h4 id="types">Types</h4>
<p>The x86-x64 instruction set is the 64-bit revision of x86 instruction set which was first developed for the Intel 8086 CPU family. The base types which hardware operates over are integers and floating point types. Let us just consider the integral types for now, these come in four major varieties:</p>
<p><img src="/images/bits.png"></img></p>
<p>On the Intel architecture numbers are represented <em>little endian</em> meaning lower significant bytes are stored in lower memory addresses. The whole memory representation for a value is partitioned into <em>high bits</em> and <em>low bits</em>. For example the hexadecimal number <code>0xc0ffee</code> as a DWORD is stored in memory as:</p>
<p><img src="/images/coffee.png"></img></p>
<p>In Haskell unboxed integral machine types are provided by the <code>Data.Word</code> <a href="https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Word.html">module</a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Word8</span>  <span class="fu">=</span> <span class="dt">W8</span><span class="fu">#</span> <span class="dt">Word</span><span class="fu">#</span>
<span class="kw">data</span> <span class="dt">Word16</span> <span class="fu">=</span> <span class="dt">W16</span><span class="fu">#</span> <span class="dt">Word</span><span class="fu">#</span>
<span class="kw">data</span> <span class="dt">Word32</span> <span class="fu">=</span> <span class="dt">W32</span><span class="fu">#</span> <span class="dt">Word</span><span class="fu">#</span>
<span class="kw">data</span> <span class="dt">Word64</span> <span class="fu">=</span> <span class="dt">W64</span><span class="fu">#</span> <span class="dt">Word</span><span class="fu">#</span></code></pre></div>
<p>Pointers are simply literal addresses to main memory, where the underlying access and storage are managed by the Linux kernel. To model this abstractly in Haskell we’ll create a datatype containing the possible values we can operate over.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Val</span>
  <span class="fu">=</span> <span class="dt">I</span> <span class="dt">Int64</span>      <span class="co">-- Integer</span>
  <span class="fu">|</span> <span class="dt">R</span> <span class="dt">Reg</span>        <span class="co">-- Register</span>
  <span class="fu">|</span> <span class="dt">A</span> <span class="dt">Word32</span>     <span class="co">-- Addr</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>To convert from Haskell types into byte sequences we’ll use the binary library to convert integral types into little endian arrays of bytes.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bytes ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [<span class="dt">Word8</span>]
bytes x <span class="fu">=</span> fmap BS.c2w bs
  <span class="kw">where</span>
    bs <span class="fu">=</span> unpack <span class="fu">$</span> runPut <span class="fu">$</span> putWord32le (fromIntegral x)</code></pre></div>
<p>For example given a hexadecimal literal this will expand it out into an array of it’s bit components.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">val <span class="fu">=</span> bytes <span class="bn">0xc0ffee</span> <span class="co">-- [238,255,192,0]</span></code></pre></div>
<h4 id="registers">Registers</h4>
<p>The x64 architecture contains sixteen general purpose 64-bit registers capable of storing a quadword. They major ones are labeled <code>rax, rbx, rcx, rdx, rbp, rsi, rdi,</code> and <code>rsp</code>.</p>
<p>Each of the registers is given a specific index (<code>r</code>), which will be used in the binary representation of specific instructions that operate over these registers.</p>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">RAX</th>
<th align="left">RBX</th>
<th align="left">RCX</th>
<th align="left">RDX</th>
<th align="left">RBP</th>
<th align="left">RSI</th>
<th align="left">RDI</th>
<th align="left">RSP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">r =</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">5</td>
<td align="left">6</td>
<td align="left">7</td>
</tr>
</tbody>
</table>
<p>Each of these registers can be addressed as a smaller register containing a subset of the lower bits. The 32-bit register of <code>rax</code> is <code>eax</code>. These are shown in the table below.</p>
<p><img src="/images/registers.png"></img></p>
<p>These smaller registers are given specific names with modified prefixes.</p>
<table>
<thead>
<tr class="header">
<th align="left">64-bit</th>
<th align="left">32-bit</th>
<th align="left">16-bit</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">rax</td>
<td align="left">eax</td>
<td align="left">ax</td>
</tr>
<tr class="even">
<td align="left">rbx</td>
<td align="left">ebx</td>
<td align="left">bx</td>
</tr>
<tr class="odd">
<td align="left">rcx</td>
<td align="left">ecx</td>
<td align="left">cx</td>
</tr>
<tr class="even">
<td align="left">rdx</td>
<td align="left">edx</td>
<td align="left">dx</td>
</tr>
<tr class="odd">
<td align="left">rsp</td>
<td align="left">esp</td>
<td align="left">sp</td>
</tr>
<tr class="even">
<td align="left">rbp</td>
<td align="left">ebp</td>
<td align="left">bp</td>
</tr>
<tr class="odd">
<td align="left">rsi</td>
<td align="left">esi</td>
<td align="left">si</td>
</tr>
<tr class="even">
<td align="left">rdi</td>
<td align="left">edi</td>
<td align="left">di</td>
</tr>
<tr class="odd">
<td align="left">rip</td>
<td align="left">eip</td>
<td align="left">ip</td>
</tr>
</tbody>
</table>
<p>In Haskell we model this a sum type for each of the 64-bit registers. Consider just the 64-bit registers for now.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Reg</span>
  <span class="fu">=</span> <span class="dt">RAX</span>  <span class="co">-- Accumulator</span>
  <span class="fu">|</span> <span class="dt">RCX</span>  <span class="co">-- Counter (Loop counters)</span>
  <span class="fu">|</span> <span class="dt">RDX</span>  <span class="co">-- Data</span>
  <span class="fu">|</span> <span class="dt">RBX</span>  <span class="co">-- Base / General Purpose</span>
  <span class="fu">|</span> <span class="dt">RSP</span>  <span class="co">-- Current stack pointer</span>
  <span class="fu">|</span> <span class="dt">RBP</span>  <span class="co">-- Previous Stack Frame Link</span>
  <span class="fu">|</span> <span class="dt">RSI</span>  <span class="co">-- Source Index Pointer</span>
  <span class="fu">|</span> <span class="dt">RDI</span>  <span class="co">-- Destination Index Pointer</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>The index for each register is defined by a simple pattern match case expression.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">index<span class="ot"> ::</span> <span class="dt">Reg</span> <span class="ot">-&gt;</span> <span class="dt">Word8</span>
index x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span>
  <span class="dt">RAX</span> <span class="ot">-&gt;</span> <span class="dv">0</span>
  <span class="dt">RCX</span> <span class="ot">-&gt;</span> <span class="dv">1</span>
  <span class="dt">RDX</span> <span class="ot">-&gt;</span> <span class="dv">2</span>
  <span class="dt">RBX</span> <span class="ot">-&gt;</span> <span class="dv">3</span>
  <span class="dt">RSP</span> <span class="ot">-&gt;</span> <span class="dv">4</span>
  <span class="dt">RBP</span> <span class="ot">-&gt;</span> <span class="dv">5</span>
  <span class="dt">RSI</span> <span class="ot">-&gt;</span> <span class="dv">6</span>
  <span class="dt">RDI</span> <span class="ot">-&gt;</span> <span class="dv">7</span></code></pre></div>
<h4 id="monads">Monads</h4>
<p>Monads are an algebraic structure with two functions (<code>bind</code>) and (<code>return</code>) and three laws.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bind ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b
return<span class="ot"> ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> m a</code></pre></div>
<p>The compiler will desugar do-blocks of the form into a canonical form involving generic bind and return statements.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Int</span>
f <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> x
  b <span class="ot">&lt;-</span> y
  return (a<span class="fu">+</span>b)</code></pre></div>
<p>Is transformed into:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Int</span>
f <span class="fu">=</span> 
  bind x (\a <span class="ot">-&gt;</span> 
    bind y (\b <span class="ot">-&gt;</span> 
      return (a<span class="fu">+</span>b))</code></pre></div>
<p>Monad is implemented as a typeclass indexed by a parameter <code>m</code>, that when instantiated with a typeclass instances replaces the bind and return functions with a specific implementation of the two functions (like State or Reader).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">State</span> <span class="dt">MyState</span> <span class="dt">Int</span>
f <span class="fu">=</span> 
  bindState x (\a <span class="ot">-&gt;</span> 
    bindState y (\b <span class="ot">-&gt;</span> 
      returnState (a<span class="fu">+</span>b))</code></pre></div>
<p>The State monad is an instance of Monad with several functions for composing stateful logic.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">get ::</span> <span class="dt">State</span> s s                   <span class="co">-- get the state</span>
<span class="ot">put ::</span> s <span class="ot">-&gt;</span> <span class="dt">State</span> s ()             <span class="co">-- set the state</span>
<span class="ot">modify ::</span> (s <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">State</span> s ()   <span class="co">-- apply a function over the state</span></code></pre></div>
<p>For example a little state machine that holds a single Int value would be written like the following.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">machine ::</span> <span class="dt">State</span> <span class="dt">Int</span> <span class="dt">Int</span>
machine <span class="fu">=</span> <span class="kw">do</span>
  put <span class="dv">3</span>
  modify (<span class="fu">+</span><span class="dv">1</span>)
  get

<span class="ot">val ::</span> <span class="dt">Int</span>
val <span class="fu">=</span> execState machine <span class="dv">0</span></code></pre></div>
<p>More common would be to have the state variable <code>s</code> be a record with multiple fields that can be modified. For managing our JIT memory we’ll create a struct with the several fields.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">JITMem</span> <span class="fu">=</span> <span class="dt">JITMem</span>
 { _<span class="ot">instrs ::</span> [<span class="dt">Instr</span>]
 , _<span class="ot">mach   ::</span> [<span class="dt">Word8</span>]
 , _<span class="ot">icount ::</span> <span class="dt">Word32</span>
 , _<span class="ot">memptr ::</span> <span class="dt">Word32</span>
 , _<span class="ot">memoff ::</span> <span class="dt">Word32</span>
 } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>This will be composed into our X86 monad which will hold the JIT memory as we assemble individual machine instructions and the pointer and memory offsets for the sequence of assembled instructions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">X86</span> a <span class="fu">=</span> <span class="dt">StateT</span> <span class="dt">JITMem</span> (<span class="dt">Except</span> <span class="dt">String</span>) a</code></pre></div>
<h4 id="jit-memory">JIT Memory</h4>
<p>To start creating the JIT we first need to create a block of memory with executable permissions. Inside of <a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=bits/mman.h;h=1d9f6f8d9caba842983f98ff2f2dd5a776df054c;hb=HEAD#l32">C runtime</a> we can get the flags needed to be passed to the various <code>mmap</code> syscall to create the necessary memory block.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define PROT_NONE       0x00    </span><span class="co">/* No access.  */</span>
<span class="ot">#define PROT_READ       0x04    </span><span class="co">/* pages can be read */</span>
<span class="ot">#define PROT_WRITE      0x02    </span><span class="co">/* pages can be written */</span>
<span class="ot">#define PROT_EXEC       0x01    </span><span class="co">/* pages can be executed */</span>

<span class="ot">#define MAP_FILE        0x0001  </span><span class="co">/* mapped from a file or device */</span>
<span class="ot">#define MAP_ANON        0x0002  </span><span class="co">/* allocated from memory, swap space */</span>
<span class="ot">#define MAP_TYPE        0x000f  </span><span class="co">/* mask for type field */</span></code></pre></div>
<p>Then we simply allocate a given block of memory off the Haskell heap via mmap with the executable flags.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">MmapOption</span> <span class="fu">=</span> <span class="dt">MmapOption</span> <span class="dt">CInt</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Ord</span>, <span class="dt">Num</span>, <span class="dt">Bits</span>)

protExec    <span class="fu">=</span> <span class="dt">ProtOption</span> <span class="bn">0x01</span>
protWrite   <span class="fu">=</span> <span class="dt">ProtOption</span> <span class="bn">0x02</span>
mmapAnon    <span class="fu">=</span> <span class="dt">MmapOption</span> <span class="bn">0x20</span>
mmapPrivate <span class="fu">=</span> <span class="dt">MmapOption</span> <span class="bn">0x02</span>

<span class="ot">allocateMemory ::</span> <span class="dt">CSize</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Ptr</span> <span class="dt">Word8</span>)
allocateMemory size <span class="fu">=</span> mmap nullPtr size pflags mflags (<span class="fu">-</span><span class="dv">1</span>) <span class="dv">0</span>
  <span class="kw">where</span>
    pflags <span class="fu">=</span> protRead <span class="fu">&lt;&gt;</span> protWrite
    mflags <span class="fu">=</span> mapAnon <span class="fu">.|.</span> mapPrivate</code></pre></div>
<p>Haskell pointers can be passed to our JIT’d code by simply casting them into their respective addresses on the Haskell heap.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">heapPtr ::</span> <span class="dt">Ptr</span> a <span class="ot">-&gt;</span> <span class="dt">Word32</span>
heapPtr <span class="fu">=</span> fromIntegral <span class="fu">.</span> ptrToIntPtr</code></pre></div>
<p>For example if we want allocate a null-terminated character array and pass a pointer to it’s memory to our JIT’d code we can write down a <code>asciz</code> to synthesize this memory from a Haskell string and grab the heap pointer.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">asciz ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Word32</span>
asciz str <span class="fu">=</span> <span class="kw">do</span>
  ptr <span class="ot">&lt;-</span> newCString (str <span class="fu">++</span> [<span class="ch">&#39;\n&#39;</span>])
  return <span class="fu">$</span> heapPtr ptr</code></pre></div>
<p>For C functions we simply use the dynamic linker to grab the function pointer the given symbol in the memory space of the process. The Haskell runtime links against glibc’s <code>stdio.h</code> and <code>math.h</code> so these symbols will all be floating around in memory.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">extern ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Word32</span>
extern name <span class="fu">=</span> <span class="kw">do</span>
  dl <span class="ot">&lt;-</span> dlopen <span class="st">&quot;&quot;</span> [<span class="dt">RTLD_LAZY</span>, <span class="dt">RTLD_GLOBAL</span>]
  fn <span class="ot">&lt;-</span> dlsym dl name
  return <span class="fu">$</span> heapPtr <span class="fu">$</span> castFunPtrToPtr fn</code></pre></div>
<p>When we’ve compiled our byte vector of machine code we’ll copy into executable memory.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">jit ::</span> <span class="dt">Ptr</span> <span class="dt">Word8</span> <span class="ot">-&gt;</span> [<span class="dt">Word8</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IO</span> <span class="dt">Int</span>)
jit mem machCode <span class="fu">=</span> <span class="kw">do</span>
  code <span class="ot">&lt;-</span> codePtr machCode
  withForeignPtr (vecPtr code) <span class="fu">$</span> \ptr <span class="ot">-&gt;</span> <span class="kw">do</span>
    copyBytes mem ptr (<span class="dv">8</span><span class="fu">*</span><span class="dv">6</span>)
  return (getFunction mem)</code></pre></div>
<p>Then we’ll use the FFI to synthesize a function pointer to the memory and invoke it.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class="kw">import </span>ccall &quot;dynamic&quot;
<span class="ot">  mkFun ::</span> <span class="dt">FunPtr</span> (<span class="dt">IO</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int</span>

<span class="ot">getFunction ::</span> <span class="dt">Ptr</span> <span class="dt">Word8</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int</span>
getFunction mem <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> fptr <span class="fu">=</span> unsafeCoerce<span class="ot"> mem ::</span> <span class="dt">FunPtr</span> (<span class="dt">IO</span> <span class="dt">Int</span>)
  mkFun fptr</code></pre></div>
<h4 id="assembly">Assembly</h4>
<p>Before we start manually populating our executable code with instructions, let’s look at <em>assembly</em> form of what we’ll write and create a small little DSL in Haskell make this process closer to the problem domain. Assembly is the intermediate human readable representation of machine code. Both clang and gcc are capable of dumping out this representation before compilation. For example for the following C program takes two integers passed in registers, multiplies them respectively and adds the result.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> f(<span class="dt">int</span> x, <span class="dt">int</span> y)
{
    <span class="kw">return</span> (x*x)^y;
}</code></pre></div>
<p>Internally the C compiler is condensing the Destructuring the expressions into a linear sequence instructions storing the intermediate results in scratch registers and writing the end computed result to return register. It then selects appropriate machine instruction for each of the abstract operations.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// pseudocode for intermediate C representation</span>
<span class="dt">int</span> f() {
    <span class="dt">int</span> x = <span class="dt">register</span>(rdi); 
    <span class="dt">int</span> y = <span class="dt">register</span>(rsi); 
    <span class="dt">int</span> tmp1 = x*x;
    <span class="dt">int</span> tmp2 = tmp1^y;
    <span class="kw">return</span> tmp2;
}</code></pre></div>
<p>We can output the assembly to a file <code>add.s</code>. We’ll use the Intel Syntax which puts the destination operand before other operands. The alternate AT&amp;T syntax reverses this convention.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">clang</span> -O2 -S --x86-asm-syntax=intel xor.c</code></pre></div>
<p>The generated code will resemble the following. Notice that there are two kinds of statements: <em>directives</em> and <em>instructions</em>. Directive are prefixed with a period while instructions are an operation together with a list operands. Statements of instructions are grouped into labeled blocks are suffixed with a colon for example <code>f:</code> is the label containing the logic for the function <code>f</code>.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl">        .file   <span class="kw">&quot;</span><span class="st">xor.c</span><span class="kw">&quot;</span>
        .text
        .globl  f
        .type   f, <span class="dt">@function</span>
        .intel_syntax noprefix
f:
        mov     eax, edi
        imul    eax, edi
        xor     eax, esi
        ret</code></pre></div>
<p>The assembler will then turn this sequence of instructions into either an executable or an object file containing the generated machine code. To disassemble the output we can use objdump to view the hex sequence of machine instructions and the offsets within the file.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">objdump</span> -M intel -d xor.o

<span class="kw">xor</span>:     file format elf64-x86-64

<span class="kw">Disassembly</span> of section .text:

<span class="kw">0000000000000000</span> <span class="kw">&lt;</span>f<span class="kw">&gt;</span>:
   <span class="kw">0</span>:	89 f8                	mov    eax,edi
   <span class="kw">2</span>:	0f af c7             	imul   eax,edi
   <span class="kw">5</span>:	31 f0                	xor    eax,esi
   <span class="kw">7</span>:	c3                   	ret   </code></pre></div>
<p>The compiled program in memory is then a contiguous array of bytes, which is evaluated by moving the instruction pointer at the start address.</p>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="dv">89</span> f8 0f af c7 <span class="dv">31</span> f0 c3</code></pre></div>
<h4 id="instructions">Instructions</h4>
<p>Instructions consist of two parts, an <em>opcode</em> and a set of <em>operands</em> which specify labels, registers, or addresses to memory which the CPU will execute over for the give instruction. We’ll consider a subset of interesting operations which operate over integers and manipulate the call stack.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Instr</span>
  <span class="fu">=</span> <span class="dt">Ret</span>
  <span class="fu">|</span> <span class="dt">Mov</span> <span class="dt">Val</span> <span class="dt">Val</span>
  <span class="fu">|</span> <span class="dt">Add</span> <span class="dt">Val</span> <span class="dt">Val</span>
  <span class="fu">|</span> <span class="dt">Sub</span> <span class="dt">Val</span> <span class="dt">Val</span>
  <span class="fu">|</span> <span class="dt">Mul</span> <span class="dt">Val</span>
  <span class="fu">|</span> <span class="dt">IMul</span> <span class="dt">Val</span> <span class="dt">Val</span>
  <span class="fu">|</span> <span class="dt">Xor</span> <span class="dt">Val</span> <span class="dt">Val</span>
  <span class="fu">|</span> <span class="dt">Inc</span> <span class="dt">Val</span>
  <span class="fu">|</span> <span class="dt">Dec</span> <span class="dt">Val</span>
  <span class="fu">|</span> <span class="dt">Push</span> <span class="dt">Val</span>
  <span class="fu">|</span> <span class="dt">Pop</span> <span class="dt">Val</span>
  <span class="fu">|</span> <span class="dt">Call</span> <span class="dt">Val</span>
  <span class="fu">|</span> <span class="dt">Loop</span> <span class="dt">Val</span>
  <span class="fu">|</span> <span class="dt">Nop</span>
  <span class="fu">|</span> <span class="dt">Syscall</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>To add to the JIT memory we’ll simply modify the state by appending an instruction to the <code>_mach</code> field and adjusting the memory offset pointer by the length of instructions added.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">emit ::</span> [<span class="dt">Word8</span>] <span class="ot">-&gt;</span> <span class="dt">X86</span> ()
emit i <span class="fu">=</span> modify <span class="fu">$</span> \s <span class="ot">-&gt;</span> s
  { _mach   <span class="fu">=</span> _mach s <span class="fu">++</span> i
  , _memoff <span class="fu">=</span> _memoff s <span class="fu">+</span> fromIntegral (length i)
  }</code></pre></div>
<h4 id="operands">Operands</h4>
<p><strong>Registers</strong></p>
<p>Registers are identified as lowercase (i.e. <code>rbp</code>, <code>rsp</code>). In our expression builder we’ll simply write down several functions which construct a register value type from an underlying Reg value.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rax ::</span> <span class="dt">Val</span>
rax <span class="fu">=</span> <span class="dt">R</span> <span class="dt">RAX</span>

<span class="ot">rsi ::</span> <span class="dt">Val</span>
rsi <span class="fu">=</span> <span class="dt">R</span> <span class="dt">RSI</span></code></pre></div>
<p><strong>Immediate Operands</strong></p>
<p>Immediate operands are direct references to constants (literals or memory addresses) or labels. For example:</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl">add    eax,<span class="dv">42</span>
add    eax,<span class="bn">0xff</span></code></pre></div>
<p>For immediate values we simply push the array of bytes for the number directly on the byte sequence.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">imm ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">X86</span> ()
imm <span class="fu">=</span> emit <span class="fu">.</span> bytes</code></pre></div>
<h4 id="opcodes">Opcodes</h4>
<p>The full instruction set for x86 is vast and including AVX, SSE and other specialized intrinsics there is an extraordinary amount of complexity and quirky specifications. Each of these abstract instructions can have multiple opcodes for each type of operands it may take. For example the <code>mov</code> instruction for register to register movement has opcode <code>0x89</code> while moving immediate data into a register has opcode <code>0xC7</code>.</p>
<p>The reference for the most common operations the <a href="http://ref.x86asm.net/coder64.html">x86asm.net</a> site has a very useful quick reference. For the full set of possible instructions on your modern Intel processor refer to the 1500 page <a href="https://www-ssl.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf">Intel Software Developer’s Manual</a>.</p>
<p>To lookup the numerical opcodes for a given instructions, we use a specific naming conventions for the operands.</p>
<table>
<thead>
<tr class="header">
<th align="left">Prefix</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>r&lt;size&gt;</code></td>
<td align="left">Register Operand</td>
</tr>
<tr class="even">
<td align="left"><code>imm&lt;size&gt;</code></td>
<td align="left">Immediate Operand</td>
</tr>
<tr class="odd">
<td align="left"><code>m&lt;size&gt;</code></td>
<td align="left">Memory Operand</td>
</tr>
</tbody>
</table>
<p>So for example:</p>
<table>
<thead>
<tr class="header">
<th align="left">Prefix</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>r64</code></td>
<td align="left">64 bit register</td>
</tr>
<tr class="even">
<td align="left"><code>imm8</code></td>
<td align="left">8 immediate operand</td>
</tr>
<tr class="odd">
<td align="left"><code>m32</code></td>
<td align="left">32 memory operand</td>
</tr>
</tbody>
</table>
<p>For opcodes that operate over a set of possible operands, these are demarcated with a slash, in the form <code>r8/r16/r32</code>.</p>
<p>For our limited set of instructions there are two types of opcodes.</p>
<ol style="list-style-type: decimal">
<li>1-Byte Opcodes</li>
<li>2-Byte Opcodes</li>
</ol>
<table>
<thead>
<tr class="header">
<th align="left">Instruction</th>
<th align="left">Opcode</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">CALL</td>
<td align="left">E8</td>
</tr>
<tr class="even">
<td align="left">RET</td>
<td align="left">C3</td>
</tr>
<tr class="odd">
<td align="left">NOP</td>
<td align="left">0D</td>
</tr>
<tr class="even">
<td align="left">MOV</td>
<td align="left">89</td>
</tr>
<tr class="odd">
<td align="left">PUSH</td>
<td align="left">50</td>
</tr>
<tr class="even">
<td align="left">POP</td>
<td align="left">58</td>
</tr>
<tr class="odd">
<td align="left">LOOP</td>
<td align="left">E2</td>
</tr>
<tr class="even">
<td align="left">ADD</td>
<td align="left">83</td>
</tr>
<tr class="odd">
<td align="left">SUB</td>
<td align="left">29</td>
</tr>
<tr class="even">
<td align="left">MUL</td>
<td align="left">F7</td>
</tr>
<tr class="odd">
<td align="left">DIV</td>
<td align="left">F7</td>
</tr>
<tr class="even">
<td align="left">INC</td>
<td align="left">FF</td>
</tr>
<tr class="odd">
<td align="left">DEC</td>
<td align="left">FF</td>
</tr>
<tr class="even">
<td align="left">NEG</td>
<td align="left">F7</td>
</tr>
<tr class="odd">
<td align="left">CMP</td>
<td align="left">39</td>
</tr>
<tr class="even">
<td align="left">AND</td>
<td align="left">21</td>
</tr>
<tr class="odd">
<td align="left">OR</td>
<td align="left">09</td>
</tr>
<tr class="even">
<td align="left">XOR</td>
<td align="left">31</td>
</tr>
<tr class="odd">
<td align="left">NOT</td>
<td align="left">F7</td>
</tr>
<tr class="even">
<td align="left">ADC</td>
<td align="left">11</td>
</tr>
<tr class="odd">
<td align="left">IDIV</td>
<td align="left">F7</td>
</tr>
<tr class="even">
<td align="left">IMUL</td>
<td align="left">F7</td>
</tr>
<tr class="odd">
<td align="left">XCHG</td>
<td align="left">87</td>
</tr>
<tr class="even">
<td align="left">BSWAP</td>
<td align="left">C8</td>
</tr>
<tr class="odd">
<td align="left">SHR</td>
<td align="left">C1</td>
</tr>
<tr class="even">
<td align="left">SHL</td>
<td align="left">C1</td>
</tr>
<tr class="odd">
<td align="left">ROR</td>
<td align="left">C0</td>
</tr>
<tr class="even">
<td align="left">RCR</td>
<td align="left">C0</td>
</tr>
<tr class="odd">
<td align="left">BT</td>
<td align="left">BA</td>
</tr>
<tr class="even">
<td align="left">BTS</td>
<td align="left">BA</td>
</tr>
<tr class="odd">
<td align="left">BTR</td>
<td align="left">B3</td>
</tr>
<tr class="even">
<td align="left">JMP</td>
<td align="left">EB</td>
</tr>
<tr class="odd">
<td align="left">JE</td>
<td align="left">84</td>
</tr>
<tr class="even">
<td align="left">JNE</td>
<td align="left">85</td>
</tr>
<tr class="odd">
<td align="left">SYSCALL</td>
<td align="left">05</td>
</tr>
</tbody>
</table>
<p>On top of this opcodes may have an additional prefixes which modify the sizes of arguments involved. These were added to allow 32-bit compatibility in the transition between 32-bit and 64-bit systems and preserve the underlying opcodes of the 32-bit system. For instance the following <code>mov</code> instructions all operate over registers and perform the same action but over different sizes.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl">mov al,<span class="dv">255</span>
mov ax,<span class="dv">255</span>
mov eax,<span class="dv">255</span>
mov rax,<span class="dv">255</span></code></pre></div>
<p>But translate into different opcodes depending on size.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl">b0 ff                   mov    al,<span class="bn">0xff</span>
<span class="dv">66</span> b8 ff <span class="dv">00</span>             mov    ax,<span class="bn">0xff</span>
b8 ff <span class="dv">00</span> <span class="dv">00</span> <span class="dv">00</span>          mov    eax,<span class="bn">0xff</span>
<span class="dv">48</span> c7 c0 ff <span class="dv">00</span> <span class="dv">00</span> <span class="dv">00</span>    mov    rax,<span class="bn">0xff</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">prefix</th>
<th align="left">opcode</th>
<th align="left">data</th>
<th align="left">assembly</th>
<th align="left">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">66</td>
<td align="left">b0</td>
<td align="left">ff</td>
<td align="left">mov al, 0xff</td>
<td align="left">8-bit load</td>
</tr>
<tr class="even">
<td align="left">66</td>
<td align="left">b8</td>
<td align="left">ff 00</td>
<td align="left">mov ax, 0xff</td>
<td align="left">load with a 16-bit prefix (0x66)</td>
</tr>
<tr class="odd">
<td align="left">66</td>
<td align="left">b8</td>
<td align="left">ff 00 00 00</td>
<td align="left">mov eax, 0xff</td>
<td align="left">load with default size of 32 bits</td>
</tr>
<tr class="even">
<td align="left">48</td>
<td align="left">c7 c0</td>
<td align="left">ff 00 00 00</td>
<td align="left">mov rax, 0xff</td>
<td align="left">Sign-extended load using REX 64-bit prefix (0x48)</td>
</tr>
</tbody>
</table>
<h4 id="machine-code">Machine Code</h4>
<p>Ok, let’s look at the full structure of an instruction. It consists of several parts.</p>
<p><img src="/images/opcode.png" width=100%></img></p>
<!--
- Prefix
  - W
  - R
  - X
  - B
- Opcode
  - Opcode 1
  - Opcode 2
- ModRm
  - mod
  - reg
  - r/m
- SIB
  - scale
  - index
  - base
- Displacement Data
- Immediate Data
-->
<p>The sizes of these parts depend on the size and type of the opcode as well as prefix modifiers.</p>
<table>
<thead>
<tr class="header">
<th align="left">Prefix</th>
<th align="left">Opcode</th>
<th align="left">Mod R/M</th>
<th align="left">Scale Index Base</th>
<th align="left">Displacement</th>
<th align="left">Immediate</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1-4 bytes</td>
<td align="left">1-3 bytes</td>
<td align="left">1 Byte</td>
<td align="left">1 Byte</td>
<td align="left">1-4 Bytes</td>
<td align="left">1-4 Bytes</td>
</tr>
</tbody>
</table>
<hr/>
<p><strong>Prefix</strong></p>
<p><img src="/images/Prefix.png"></img></p>
<p>The header fixes the first four bits to be constant <code>0b0100</code> while the next four bits indicate the pretense of W/R/X/B extensions.</p>
<p>The W bit modifies the operation width. The R, X and B fields extend the register encodings.</p>
<ul>
<li>REX.W – Extends the operation width</li>
<li>REX.R – Extends ModRM.reg</li>
<li>REX.X – Extends SIB.index</li>
<li>REX.B – Extends SIB.base or ModRM.r/m</li>
</ul>
<!--
```
  7                           0
+---+---+---+---+---+---+---+---+
| 0   1   0   0 | W | R | X | B |
+---+---+---+---+---+---+---+---+
```
-->
<hr/>
<p><strong>ModR/M byte</strong></p>
<p><img src="/images/ModRM.png"></img></p>
<p>The Mod-Reg-R/M byte determines the instruction’s operands and the addressing modes. These are several variants of addressing modes.</p>
<ol style="list-style-type: decimal">
<li>Immediate mode - operand is part of the instruction</li>
<li>Register addressing - operand contained in register</li>
<li>Direct Mode - operand field of instruction contains address of the operand</li>
<li>Register Indirect Addressing - used for addressing data arrays with offsets</li>
<li>Indexing - constant base + register</li>
<li>Indexing With Scaling - Base + Register Offset * Scaling Factor</li>
<li>Stack Addressing - A variant of register indirect with auto increment/decrement using the RSP register implicitly</li>
<li>Jump relative addressing - RIP + offset</li>
</ol>
<!--
```
+---+---+---+
|mod|reg|r/m|
+---+---+---+
```
-->
<table>
<thead>
<tr class="header">
<th align="left">mod</th>
<th align="left">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">00</td>
<td align="left">Register indirect memory addressing mode</td>
</tr>
<tr class="even">
<td align="left">01</td>
<td align="left">Indexed or base/indexed/displacement addressing mode</td>
</tr>
<tr class="odd">
<td align="left">10</td>
<td align="left">Indexed or base/indexed/displacement addressing mode + displacement</td>
</tr>
<tr class="even">
<td align="left">11</td>
<td align="left">R/M denotes a register and uses the REG field</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th align="left">reg</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">rax</td>
<td align="left">000</td>
</tr>
<tr class="even">
<td align="left">rcx</td>
<td align="left">001</td>
</tr>
<tr class="odd">
<td align="left">rdx</td>
<td align="left">010</td>
</tr>
<tr class="even">
<td align="left">rbx</td>
<td align="left">011</td>
</tr>
<tr class="odd">
<td align="left">rsp</td>
<td align="left">100</td>
</tr>
<tr class="even">
<td align="left">rbp</td>
<td align="left">101</td>
</tr>
<tr class="odd">
<td align="left">rsi</td>
<td align="left">110</td>
</tr>
<tr class="even">
<td align="left">rdi</td>
<td align="left">111</td>
</tr>
</tbody>
</table>
<p>In the case of mod = 00, 01 or 10</p>
<table>
<thead>
<tr class="header">
<th align="left">r/m</th>
<th align="left">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">000</td>
<td align="left">[BX+SI] or DISP[BX][SI]</td>
</tr>
<tr class="even">
<td align="left">001</td>
<td align="left">[BX+DI] or DISP[BX+DI]</td>
</tr>
<tr class="odd">
<td align="left">010</td>
<td align="left">[BP+SI] or DISP[BP+SI]</td>
</tr>
<tr class="even">
<td align="left">011</td>
<td align="left">[BP+DI] or DISP[BP+DI]</td>
</tr>
<tr class="odd">
<td align="left">100</td>
<td align="left">[SI] or DISP[SI]</td>
</tr>
<tr class="even">
<td align="left">101</td>
<td align="left">[DI] or DISP[DI]</td>
</tr>
<tr class="odd">
<td align="left">110</td>
<td align="left">Displacement-only or DISP[BP]</td>
</tr>
<tr class="even">
<td align="left">111</td>
<td align="left">[BX] or DISP[BX]</td>
</tr>
</tbody>
</table>
<p>For example given the following instruction that uses register direct mode and specifies the register operand in r/m.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl">mov    rbx,rax</code></pre></div>
<p>We have:</p>
<pre><code>mod   = 0b11
reg   = 0b000
r/m   = rbx
r/m   = 0b011
ModRM = 0b11000011
ModRM = 0xc3</code></pre>
<p><img src="/images/ModRM_example.png"></img></p>
<hr/>
<p><strong>Scale Index Base</strong></p>
<p><img src="/images/Scale.png"></img></p>
<p>Scale is the factor by which index is multipled before being added to base to specify the address of the operand. Scale can have value of 1, 2, 4, or 8. If scale is not specified, the default value is 1.</p>
<!--
```
  7                           0
+---+---+---+---+---+---+---+---+
| scale |   index   |    base   |
+---+---+---+---+---+---+---+---+
```
-->
<table>
<thead>
<tr class="header">
<th align="left">scale</th>
<th align="left">factor</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0b00</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left">0b01</td>
<td align="left">2</td>
</tr>
<tr class="odd">
<td align="left">0b10</td>
<td align="left">4</td>
</tr>
<tr class="even">
<td align="left">0b11</td>
<td align="left">8</td>
</tr>
</tbody>
</table>
<p>Both the index and base refer to register in the usual index scheme.</p>
<table>
<thead>
<tr class="header">
<th align="left">scale/base</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">rax</td>
<td align="left">000</td>
</tr>
<tr class="even">
<td align="left">rcx</td>
<td align="left">001</td>
</tr>
<tr class="odd">
<td align="left">rdx</td>
<td align="left">010</td>
</tr>
<tr class="even">
<td align="left">rbx</td>
<td align="left">011</td>
</tr>
<tr class="odd">
<td align="left">rsp</td>
<td align="left">100</td>
</tr>
<tr class="even">
<td align="left">rbp</td>
<td align="left">101</td>
</tr>
<tr class="odd">
<td align="left">rsi</td>
<td align="left">110</td>
</tr>
<tr class="even">
<td align="left">rdi</td>
<td align="left">111</td>
</tr>
</tbody>
</table>
<hr/>
<h4 id="instruction-builder">Instruction Builder</h4>
<p>Moving forward we’ll create several functions mapping to X86 monadic operators which assemble instructions in the state monad. Let’s do some simple arithmetic logic first.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">arith ::</span> <span class="dt">X86</span> ()
arith <span class="fu">=</span> <span class="kw">do</span>
  mov rax (<span class="dt">I</span> <span class="dv">18</span>)
  add rax (<span class="dt">I</span> <span class="dv">4</span>)
  sub rax (<span class="dt">I</span> <span class="dv">2</span>)
  imul rax (<span class="dt">I</span> <span class="dv">2</span>)
  ret</code></pre></div>
<p>Each of these functions takes in some set of operands given by the algebraic datatype <code>Val</code> and pattern matches on the values to figure out which x86 opcode to use and how to render the values to bytes.</p>
<p><strong><code>ret</code></strong></p>
<p>The simplest cases is simply the return function which takes no operands and is a 1-bit opcode.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ret ::</span> <span class="dt">X86</span> ()
ret <span class="fu">=</span> <span class="kw">do</span>
  emit [<span class="bn">0xc3</span>]</code></pre></div>
<p><strong><code>add &lt;r64&gt; &lt;imm32&gt;</code></strong></p>
<p>Add for immediate values extends the operand with a REX.W flag to handle 64-bit immediate data.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl"><span class="dv">0</span>:  <span class="dv">48</span> <span class="dv">83</span> c0 <span class="bn">01</span>             add    rax,<span class="bn">0x1</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> <span class="dt">Val</span> <span class="ot">-&gt;</span> <span class="dt">Val</span> <span class="ot">-&gt;</span> <span class="dt">X86</span> ()
add (<span class="dt">R</span> l) (<span class="dt">I</span> r) <span class="fu">=</span> <span class="kw">do</span>
  emit [<span class="bn">0x48</span>]              <span class="co">-- REX.W prefix</span>
  emit [<span class="bn">0x05</span>]              <span class="co">-- ADD</span>
  imm r</code></pre></div>
<p><strong><code>add &lt;r64&gt; &lt;r64&gt;</code></strong></p>
<p>Register to register add uses the REX.W flag in the same manor but passes the source register in the ModRM.reg field using register direct mode. We do bitwise <code>or</code> over the mode <code>0xc0</code> and then shift 3 bits to specify the register in register index in the <code>reg</code> bits.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl"><span class="dv">0</span>:  <span class="dv">48</span> <span class="bn">01</span> e0                add    rax,rsp</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">add (<span class="dt">R</span> l) (<span class="dt">R</span> r) <span class="fu">=</span> <span class="kw">do</span>
  emit [<span class="bn">0x48</span>]              <span class="co">-- REX prefix</span>
  emit [<span class="bn">0x01</span>]              <span class="co">-- ADD</span>
  emit [<span class="bn">0xc0</span> <span class="fu">.|.</span> opcode r <span class="ot">`shiftL`</span> <span class="dv">3</span> <span class="fu">.|.</span> opcode l]</code></pre></div>
<p><strong><code>mov &lt;r64&gt;, &lt;r64&gt;</code></strong></p>
<p>Same logic applies for the mov instruction for both the register-to-register and immediate data cases.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl"><span class="dv">0</span>:  <span class="dv">48</span> <span class="dv">89</span> d8                mov    rax,rbx</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mov ::</span> <span class="dt">Val</span> <span class="ot">-&gt;</span> <span class="dt">Val</span> <span class="ot">-&gt;</span> <span class="dt">X86</span> ()
mov (<span class="dt">R</span> dst) (<span class="dt">R</span> src) <span class="fu">=</span> <span class="kw">do</span>
  emit [<span class="bn">0x48</span>]              <span class="co">-- REX.W prefix</span>
  emit [<span class="bn">0x89</span>]              <span class="co">-- MOV</span>
  emit [<span class="bn">0xC0</span> <span class="fu">.|.</span> opcode src <span class="ot">`shiftL`</span> <span class="dv">3</span> <span class="fu">.|.</span> opcode dst]</code></pre></div>
<p><strong><code>mov &lt;r64&gt;, &lt;imm32&gt;</code></strong></p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl"><span class="dv">0</span>:  <span class="dv">48</span> c7 c0 2a <span class="dv">00</span> <span class="dv">00</span> <span class="dv">00</span>    mov    rax,<span class="bn">0x2a</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">mov (<span class="dt">R</span> dst) (<span class="dt">I</span> src) <span class="fu">=</span> <span class="kw">do</span>
  emit [<span class="bn">0x48</span>]              <span class="co">-- REX.W prefix</span>
  emit [<span class="bn">0xC7</span>]              <span class="co">-- MOV</span>
  emit [<span class="bn">0xC0</span> <span class="fu">.|.</span> (opcode dst <span class="fu">.&amp;.</span> <span class="dv">7</span>)]
  imm src</code></pre></div>
<p><strong><code>inc &lt;r64&gt;</code>, <code>dec &lt;r64&gt;</code></strong></p>
<p>The inc and dec functions are slightly different in that they share the same opcode but modify the ModRM bit to specify the operation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">inc ::</span> <span class="dt">Val</span> <span class="ot">-&gt;</span> <span class="dt">X86</span>()
inc (<span class="dt">R</span> dst) <span class="fu">=</span> <span class="kw">do</span>
  emit [<span class="bn">0x48</span>]              <span class="co">-- REX prefix</span>
  emit [<span class="bn">0xFF</span>]              <span class="co">-- INC</span>
  emit [<span class="bn">0xc0</span> <span class="fu">+</span> index dst]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">dec (<span class="dt">R</span> dst) <span class="fu">=</span> <span class="kw">do</span>
  emit [<span class="bn">0x48</span>]              <span class="co">-- REX prefix</span>
  emit [<span class="bn">0xFF</span>]              <span class="co">-- DEC</span>
  emit [<span class="bn">0xc0</span> <span class="fu">+</span> (index dst <span class="fu">+</span> <span class="dv">8</span>)]</code></pre></div>
<p>Putting everything together we’ll JIT our function and call it from Haskell.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  mem <span class="ot">&lt;-</span> allocateMemory jitsize                <span class="co">-- create jit memory</span>
  <span class="kw">let</span> <span class="dt">Right</span> st <span class="fu">=</span> assemble mem arith            <span class="co">-- assemble symbolic program</span>
  fn  <span class="ot">&lt;-</span> jit mem (_mach st)                    <span class="co">-- jit compile</span>
  res <span class="ot">&lt;-</span> fn                                    <span class="co">-- call function</span>
  putStrLn <span class="fu">$</span> <span class="st">&quot;Result: &quot;</span> <span class="fu">&lt;&gt;</span> show res</code></pre></div>
<p>And running it we get the result.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">stack</span> exec example
<span class="kw">Result</span>: 40</code></pre></div>
<h4 id="jumps-loops">Jumps &amp; Loops</h4>
<p>Now let’s write some logic that uses control flow and jumps between labeled blocks of instructions. Consider the factorial function that takes the value to compute in the <code>rcx</code> register and computes the result my repeatedly multiply the <code>rax</code> until reaching one. To do this we create a block <code>.factor</code> and use the <code>loop</code> instruction.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl">factorial:
        mov rcx, <span class="dt">$5</span>
        mov rax, <span class="dt">$1</span>
.factor:
        mul rax
        loop .factor
        ret</code></pre></div>
<p>Let’s look at the machine code for this assembly. Notice that the loop instruction takes a relative address in memory <code>fc</code> (i.e. go back 4 instructions) as it’s operand.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl">00000000004004ed &lt;main&gt;:
  4004ed:       b9 <span class="bn">05</span> <span class="dv">00</span> <span class="dv">00</span> <span class="dv">00</span>          mov    ecx,<span class="bn">0x5</span>
  4004f2:       b8 <span class="bn">01</span> <span class="dv">00</span> <span class="dv">00</span> <span class="dv">00</span>          mov    eax,<span class="bn">0x1</span>

00000000004004f7 &lt;.factor&gt;:
  4004f7:       f7 e1                   mul    ecx
  4004f9:       e2 fc                   loop   4004f7 &lt;.factor&gt;
  4004fb:       c3                      ret    </code></pre></div>
<p>So let’s create a label function which simply reaches into the monad and grabs the current pointer location in the JIT memory that we’re at.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">label ::</span> <span class="dt">X86</span> <span class="dt">Val</span>
label <span class="fu">=</span> <span class="kw">do</span>
  addr <span class="ot">&lt;-</span> gets _memoff
  ptr  <span class="ot">&lt;-</span> gets _memptr
  return (<span class="dt">A</span> addr)</code></pre></div>
<p>When given an memory address, the <code>loop</code> instruction then simply emits the instruction simply emits the <code>0xE2</code> opcode and calculates the delta of the source and destination and the emits it’s value as the immediate data for the instruction.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">loop ::</span> <span class="dt">Val</span> <span class="ot">-&gt;</span> <span class="dt">X86</span>()
loop (<span class="dt">A</span> dst) <span class="fu">=</span> <span class="kw">do</span>
  emit [<span class="bn">0xE2</span>]
  src <span class="ot">&lt;-</span> gets _memoff
  ptr <span class="ot">&lt;-</span> gets _memptr
  emit [fromIntegral <span class="fu">$</span> dst <span class="fu">-</span> src]</code></pre></div>
<p>Now we’ll create the symbolic representation of this factorial assembly our in Haskell DSL and parameterize it by a Haskell integer to compute.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">factorial ::</span> <span class="dt">Int64</span> <span class="ot">-&gt;</span> <span class="dt">X86</span> ()
factorial n <span class="fu">=</span> <span class="kw">do</span>
  mov rcx (<span class="dt">I</span> n)
  mov rax (<span class="dt">I</span> <span class="dv">1</span>)
  l1 <span class="ot">&lt;-</span> label
  mul rcx
  loop l1
  ret</code></pre></div>
<p>Putting everything together we’ll JIT our function and call it from Haskell.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  mem <span class="ot">&lt;-</span> allocateMemory jitsize
  <span class="kw">let</span> <span class="dt">Right</span> st <span class="fu">=</span> assemble mem (factorial <span class="dv">5</span>)
  fn  <span class="ot">&lt;-</span> jit mem (_mach st)
  res <span class="ot">&lt;-</span> fn
  putStrLn <span class="fu">$</span> <span class="st">&quot;Result: &quot;</span> <span class="fu">&lt;&gt;</span> show res</code></pre></div>
<p>And running it we get the result.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">stack</span> exec example
<span class="kw">Result</span>: 120</code></pre></div>
<h4 id="calling-convention">Calling Convention</h4>
<p>Final task is to be able to call out of the JIT into either Haskell runtime or a given C function pointer. To do this we need to look at the <em>calling convention</em> for moving in out of other logic and setting up the registers so we can hand them off to another subroutine and restore then when we jump back. In the 64 bit <a href="http://x86-64.org/documentation/abi.pdf">System V ABI</a> calling convention, the first 5 arguments get passed in registers in order <code>rdi</code>, <code>rsi</code>, <code>rdx</code> <code>rcx</code>, <code>r8</code>, and <code>r9</code>. Subsequent arguments get passed on the stack.</p>
<p>For our call function we simply compute the delta of our given position and the address of the function we want to jump into.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">call ::</span> <span class="dt">Val</span> <span class="ot">-&gt;</span> <span class="dt">X86</span> ()
call (<span class="dt">A</span> dst) <span class="fu">=</span> <span class="kw">do</span>
  emit [<span class="bn">0xE8</span>]
  src <span class="ot">&lt;-</span> gets _memoff
  imm (dst <span class="fu">-</span> (src <span class="fu">+</span> <span class="dv">5</span>))
call _ <span class="fu">=</span> nodef</code></pre></div>
<p>Before and after we call the function we are responsible for handling it’s arguments and the push and popping the stack frame on entry and exit. On entry we call the function <em>prologue</em> and on exit we call the <em>epilogue</em>, in between lies the function logic.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prologue ::</span> <span class="dt">X86</span> ()
prologue <span class="fu">=</span> <span class="kw">do</span>
  push rbp
  mov rbp rsp

<span class="ot">epilogue ::</span> <span class="dt">X86</span> ()
epilogue <span class="fu">=</span> <span class="kw">do</span>
  pop rax
  mov rsp rbp
  pop rbp
  ret</code></pre></div>
<p>So for example let’s call out to the libc <code>printf</code> function passing a string pointer to it from inside our JIT. To do this we use <code>dlsym</code> to grab the symbol reference and then pass it as an address to the <code>call</code> instruction after pushing the string pointer on the argument stack.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">printf ::</span> <span class="dt">Word32</span> <span class="ot">-&gt;</span> <span class="dt">Word32</span> <span class="ot">-&gt;</span> <span class="dt">X86</span> ()
printf fnptr msg <span class="fu">=</span> <span class="kw">do</span>
  push rbp
  mov rbp rsp
  mov rdi (<span class="dt">A</span> msg)
  call (<span class="dt">A</span> fnptr)
  pop rbp
  mov rax (<span class="dt">I</span> <span class="dv">0</span>)
  ret</code></pre></div>
<p>Putting everything together we invoke it by grabbing the <code>printf</code> address and passing a pointer to Haskell string using our <code>asciz</code> function.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> jitsize <span class="fu">=</span> <span class="dv">256</span><span class="fu">*</span><span class="dv">1024</span>

  fn  <span class="ot">&lt;-</span> extern <span class="st">&quot;printf&quot;</span>
  msg <span class="ot">&lt;-</span> asciz <span class="st">&quot;Hello Haskell&quot;</span>
  mem <span class="ot">&lt;-</span> allocateMemory jitsize

  <span class="kw">let</span> <span class="dt">Right</span> st <span class="fu">=</span> assemble mem (printf fn msg)
  join <span class="fu">$</span> jit mem (_mach st)</code></pre></div>
<p>Running it we get our friendly greeting by reaching outside the JIT.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">stack</span> exec example
<span class="kw">Hello</span> Haskell</code></pre></div>
<p>So that’s basic JIT compilation in a nutshell.</p>]]></summary>
</entry>
<entry>
    <title>Reflecting on Haskell in 2015</title>
    <link href="http://www.stephendiehl.com/posts/haskell_2016.html" />
    <id>http://www.stephendiehl.com/posts/haskell_2016.html</id>
    <published>2015-12-23T00:00:00Z</published>
    <updated>2015-12-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="reflecting-on-haskell-in-2015">Reflecting on Haskell in 2015</h3>
<p>It’s been quite a year in the language we know and love called Haskell both for me personally and as a community. Personally I’ve been fortunate enough to write quite a bit of Haskell professionally. It’s an interesting experience and changed my perspective quite a bit on the state of our profession.</p>
<p>For the language and community side there’s been quite a bit of technical progress; probably not as much as some of us hope for, but Haskell is not a language of rapid hype, it’s a multi-decade engineering program. Avoiding success at all costs takes time and learning to accept the “long game” has been something I’ve come to accept with Haskell. Nevertheless I like to reflect on what’s changed and what I think will matter in 2016.</p>
<h4 id="ghc">GHC</h4>
<p>The Glorious Haskell Compiler 7.10 arrived in March and brought with it several major new features, as well as an abundance of bug fixes, changes to the backend compiler, code generation, and linker.</p>
<p>The <em>The Applicative Monad Proposal</em> landed finally making Applicative a superclass of Monad.</p>
<p>The <em>Burning Bridges Proposal</em> landed which reexported many of the monomorphic traversal functions found in the Prelude in favor of their polymorphic Traversable equivalents. There was much debate.</p>
<p>GHC 8.0 has several large changes that are in the works:</p>
<p><em><a href="http://www.well-typed.com/blog/2015/03/overloadedrecordfields-revived/">-XOverloadedRecordFields</a></em></p>
<p>The long awaited Overload Record Fields extension will likely land and address some of the issues found in the old record system with overloaded selector names.</p>
<p>For example given the two records with identical accessors.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">S</span> <span class="fu">=</span> <span class="dt">MkS</span> {<span class="ot"> x ::</span> <span class="dt">Int</span> }
  <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">data</span> <span class="dt">T</span> <span class="fu">=</span> <span class="dt">MkT</span> {<span class="ot"> x ::</span> <span class="dt">Bool</span>,<span class="ot"> y ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>,<span class="ot"> tField ::</span> <span class="dt">Bool</span> }</code></pre></div>
<p>The following program will typecheck since the accessors are unambiguous at their call sites.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">b <span class="fu">=</span> s { x <span class="fu">=</span> <span class="dv">3</span> }<span class="ot"> ::</span> <span class="dt">S</span>
c <span class="fu">=</span> (<span class="ot">t ::</span> <span class="dt">T</span>) { x <span class="fu">=</span> <span class="dt">False</span> }</code></pre></div>
<p>This doesn’t quite add first class records to the language yet, so code like the following polymorphic update of a field “x” can’t exist. There are some interesting proposals on the board about solutions to this though.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- hypothetical</span>
<span class="ot">b ::</span> r {<span class="ot"> x ::</span> <span class="dt">Int</span> } <span class="ot">-&gt;</span> <span class="dt">Int</span>
b r <span class="fu">=</span> x r</code></pre></div>
<p><em><a href="https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell/Phase1">-XTypeInType</a></em></p>
<p>The largest change pending is a particularly ambitious program to graft some features of dependent types onto Haskell. The Kind equalities patch pending in 8.0 at makes the type system (from values up) fully dependent, whereas before we would have to rely on particularly inelegant hacks. In GHC 7.x The type of of the kind ★ used to be the sort <code>BOX</code> under the old regime.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">GHC.Exts</span> (<span class="dt">BOX</span>, <span class="dt">Constraint</span>)
<span class="fu">&gt;</span> <span class="fu">:</span>kind <span class="dt">Constraint</span> 
<span class="dt">Constraint</span><span class="ot"> ::</span> <span class="dt">BOX</span>
<span class="fu">&gt;</span> <span class="fu">:</span>kind <span class="dt">BOX</span>
<span class="dt">BOX</span><span class="ot"> ::</span> <span class="dt">BOX</span></code></pre></div>
<p>Under the new work, <code>★</code> can be now represented by the identifier <code>Type</code>, and the type of <code>Type</code> is itself.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Constraint</span><span class="ot"> ::</span> <span class="fu">*</span>
<span class="kw">type</span> (<span class="fu">*</span>) <span class="fu">=</span> <span class="fu">*</span>
<span class="kw">type</span> <span class="dt">Type</span> <span class="fu">=</span> <span class="fu">*</span></code></pre></div>
<p>And more importantly type-level equalities concerning types are reflexive, so a proof that <code>t1 :: k1 ~ t2 :: k2</code> now proves that <code>t1</code> and <code>t2</code> are the same and that <code>k1</code> and <code>k2</code> are the same. So the two parameter dependent data type <code>Proxy</code> can now be represented:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Proxy</span> k (<span class="ot">a ::</span> k) <span class="fu">=</span> <span class="dt">P</span></code></pre></div>
<p>Has the following well-typed inhabitants:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">x ::</span> <span class="dt">Proxy</span> <span class="fu">*</span> <span class="dt">Int</span>
x <span class="fu">=</span> <span class="dt">P</span>

<span class="ot">y ::</span> <span class="dt">Proxy</span> <span class="dt">Bool</span> <span class="dt">True</span>
y <span class="fu">=</span> <span class="dt">P</span></code></pre></div>
<p>All types and all constructors can be promoted with -XDataKinds (which is implied by -XTypeInType), including GADT constructors!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">TyRep1</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">TyInt1</span><span class="ot"> ::</span> <span class="dt">TyRep1</span> <span class="dt">Int</span>
  <span class="dt">TyBool1</span><span class="ot"> ::</span> <span class="dt">TyRep1</span> <span class="dt">Bool</span>

<span class="kw">data</span> <span class="dt">TyRep</span><span class="ot"> ::</span> k <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">TyInt</span><span class="ot"> ::</span> <span class="dt">TyRep</span> <span class="dt">Int</span>
  <span class="dt">TyBool</span><span class="ot"> ::</span> <span class="dt">TyRep</span> <span class="dt">Bool</span>
  <span class="dt">TyMaybe</span><span class="ot"> ::</span> <span class="dt">TyRep</span> <span class="dt">Maybe</span>
  <span class="dt">TyApp</span><span class="ot"> ::</span> <span class="dt">TyRep</span> a <span class="ot">-&gt;</span> <span class="dt">TyRep</span> b <span class="ot">-&gt;</span> <span class="dt">TyRep</span> (a b)

<span class="ot">zero1 ::</span> forall a<span class="fu">.</span> <span class="dt">TyRep1</span> a <span class="ot">-&gt;</span> a
zero1 <span class="dt">TyInt1</span> <span class="fu">=</span> <span class="dv">0</span>
zero1 <span class="dt">TyBool1</span> <span class="fu">=</span> <span class="dt">False</span></code></pre></div>
<p>And type classes and families can be indexed by kinds now.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Proxy</span> a

<span class="kw">class</span> <span class="dt">C</span> t <span class="kw">where</span> 
<span class="ot">  f ::</span> <span class="dt">Proxy</span> (<span class="ot">a ::</span> t)

<span class="kw">instance</span> <span class="dt">C</span> <span class="dt">Type</span> <span class="kw">where</span> 
  f <span class="fu">=</span> undefined</code></pre></div>
<hr/>
<h4 id="stack">Stack</h4>
<ul>
<li><em><a href="https://github.com/commercialhaskell/stack">Stack</a></em></li>
</ul>
<p>Stack is an supplement to the Cabal build system, released by FPComplete, which greatly simplifies package installation and dependency resolution. I was particularly skeptical about yet another solution to packaging, but it has since become a regular part of my Haskell workflow.</p>
<p>The cost to migrating and existing codebase to it is often a single command (<code>stack init</code>). The one additional file that is required is a <code>stack.yaml</code> file in addition to cabal file.</p>
<div class="sourceCode"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="fu">resolver:</span> lts-3.16
<span class="fu">packages:</span>
<span class="kw">-</span> <span class="st">&#39;.&#39;</span>
<span class="fu">extra-deps:</span> <span class="kw">[]</span>
<span class="fu">flags:</span> <span class="kw">{}</span>
<span class="fu">extra-package-dbs:</span> <span class="kw">[]</span></code></pre></div>
<p>For new projects the setup process is very streamlined.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">stack</span> new scotty-hello-world</code></pre></div>
<p>The appropriate project directory is then automatically created according to the template.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">├── <span class="kw">app</span>
│   └── <span class="kw">Main.hs</span>
├── <span class="kw">LICENSE</span>
├── <span class="kw">scotty-hello-world.cabal</span>
├── <span class="kw">Setup.hs</span>
├── <span class="kw">src</span>
│   └── <span class="kw">Lib.hs</span>
├── <span class="kw">stack.yaml</span>
└── <span class="kw">test</span>
    └── <span class="kw">Spec.hs</span></code></pre></div>
<p>The equivalent cabal commands will launch the shells, compile the binary, and install; all while taking care of any dependencies involved to do these tasks.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">stack</span> repl
<span class="kw">Configuring</span> GHCi with the following packages: scotty-hello-world
<span class="kw">GHCi</span>, version 7.10.2: http://www.haskell.org/ghc/  :? for help
[<span class="kw">1</span> of 2] Compiling Lib              ( scotty-hello-world/src/Lib.hs, interpreted )
[<span class="kw">2</span> of 2] Compiling Main             ( scotty-hello-world/app/Main.hs, interpreted )
<span class="kw">Ok</span>, modules loaded: Lib, Main.
<span class="kw">*Main&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">stack</span> build
<span class="kw">Installing</span> executable(s) <span class="kw">in</span> <span class="kw">/.stack-work/install/x86_64-linux/lts-3.16/7.10.2/bin</span>
<span class="kw">Registering</span> scotty-hello-world-0.1.0.0...

$ <span class="kw">stack</span> install
<span class="kw">Copied</span> executables to /home/sdiehl/.local/bin:
<span class="kw">-</span> scotty-hello-world-exe</code></pre></div>
<p>Surprising to me lately was to find how simple integrating Stack and containers solutions has become.</p>
<div class="sourceCode"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="co"># stack.yaml</span>
<span class="fu">resolver:</span> lts-3.16
<span class="fu">packages:</span>
<span class="kw">-</span> <span class="st">&#39;.&#39;</span>
<span class="fu">extra-deps:</span> <span class="kw">[]</span>
<span class="fu">flags:</span> <span class="kw">{}</span>
<span class="fu">extra-package-dbs:</span> <span class="kw">[]</span>
<span class="fu">image:</span>
  <span class="fu">container:</span>
    <span class="fu">name:</span> example
    <span class="fu">base:</span> hello:base
    <span class="fu">entrypoints:</span>
      <span class="kw">-</span> hello</code></pre></div>
<p>And the Docker image can be created quite simply by the following commands.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">docker</span> build -t hello .
$ <span class="kw">stack</span> image container
$ <span class="kw">sudo</span> docker run -t -i example hello </code></pre></div>
<p>My skeleton <a href="https://github.com/sdiehl/skeleton">project template is available here</a>.</p>
<p>A particularly good blog post by Tim Dysinger outlines the <a href="https://www.fpcomplete.com/blog/2015/11/kubernetes">Haskell/Stack/Kubernetes</a> workflow that’s used to run Stackage.</p>
<hr/>
<h4 id="aeson">Aeson</h4>
<p><em><a href="https://hackage.haskell.org/package/aeson">Aeson</a></em></p>
<p>The bread and butter (and debatably alternative base) library Aeson got much better error reporting as of <code>aeson==0.10</code>. Before we would often get cryptic messages concerning attoparsec internals <code>Failed reading: satisfy</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> eitherDecode <span class="st">&quot;[]&quot;</span><span class="ot"> ::</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Float</span>
<span class="dt">Left</span> <span class="st">&quot;Error in $: expected Float, encountered Array&quot;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> set <span class="fu">-</span><span class="dt">XDeriveGeneric</span>

<span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Point</span> <span class="fu">=</span> <span class="dt">Point</span> {<span class="ot"> x ::</span> <span class="dt">Float</span>,<span class="ot"> y ::</span> <span class="dt">Float</span>}  <span class="kw">deriving</span> (<span class="dt">Generic</span>, <span class="dt">Show</span>)

<span class="fu">&gt;</span> <span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Point</span>

<span class="fu">&gt;</span> eitherDecode <span class="st">&quot;{\&quot;x\&quot;: 1}&quot;</span><span class="ot"> ::</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Point</span>
<span class="dt">Left</span> <span class="st">&quot;Error in $: The key \&quot;y\&quot; was not found&quot;</span></code></pre></div>
<hr/>
<h4 id="haskell-for-mac">Haskell for Mac</h4>
<p><em><a href="https://itunes.apple.com/au/app/haskell/id841285201">Haskell for Mac</a></em></p>
<p>Manuel M T Chakravarty et al. have released a new Playground environment aimed at lowering the barrier to entry in Haskell.</p>
<p><img src="https://images.typed.com/9df5078d-fbf8-4c17-8ef2-d19d47365f46/Haskell_Window_Anatomy.jpg" width=600></img></p>
<p>The platform is commercial software available on the Apple Store but is well worth the low cost for such a nicely integrated and polished introduction to the Haskell language.</p>
<hr/>
<h4 id="code-generation">Code Generation</h4>
<p><em><a href="https://www.cse.unsw.edu.au/~chak/papers/acc-llvm.pdf">Type-safe Runtime Code Generation</a></em></p>
<p>A topic of great interest to me is the Haskell interface to the LLVM code generation system, which is quickly the de-facto standard for backend intermediate languages. The <a href="https://hackage.haskell.org/package/llvm-general">llvm-general</a> provides a phenomenal interface to generating machine code from Haskell but the underlying C++ library itself is rather brittle under the ingestion of invalid LLVM IR. Trevor McDonell et al. provided a new approach by which many semantic guarantees of the IR can be represented in the Haskell type system.</p>
<p><em><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.129.8945&amp;rep=rep1&amp;type=pdf">Call-By-Push-Value</a></em></p>
<p>On the topic of evaluation methods there is interesting research opportunity into exploring an alternative evaluation methods for the lambda calculus under the so-called “Call-By-Push-Value” method. Surprisingly this technique has been around for 11 years but lacks an equivalent of SPJ’s seminal “stock hardware implementation” paper describing an end to end translation from CBPV to x86. This would be an interesting student project.</p>
<hr/>
<h4 id="web-programming">Web Programming</h4>
<ul>
<li><em><a href="https://github.com/haskell-servant/servant">Servant</a></em></li>
</ul>
<p>In typical Haskell tradition, Servant is a wildly different approach to designing type-safe Haskell web application interfaces. Using many of the promoted datatype techniques (DataKinds, PolyKinds, TypeOperators) it is able to statically guarantee many things that would be be pushed to runtime in other languages and make a large amount of invalid API states inexpressible. On top of that The capacity to automatically <a href="https://haskell-servant.github.io/tutorial/docs.html">generate HTTP documentation</a> that automatically evolves with the code is a killer feature.</p>
<p>I find Servant terribly interesting and will track it’s development over the next year, I think it’s certainly the shape of things to come in the Haskell web space. My only (non-technical) concern is that my applications are increasingly becoming impenetrable to those who are not deeply immersed in the lore of GHC extensions. It would be rather difficult to spin someone up on this who has not had at least several months of training about how to write Haskell and interpret the rather convoluted type-level programming error messages that often emerge.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ConstraintKinds       #-}</span>
<span class="ot">{-# LANGUAGE DataKinds             #-}</span>
<span class="ot">{-# LANGUAGE FlexibleContexts      #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances     #-}</span>
<span class="ot">{-# LANGUAGE GADTs                 #-}</span>
<span class="ot">{-# LANGUAGE KindSignatures        #-}</span>
<span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class="ot">{-# LANGUAGE OverloadedStrings     #-}</span>
<span class="ot">{-# LANGUAGE RankNTypes            #-}</span>
<span class="ot">{-# LANGUAGE ScopedTypeVariables   #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies          #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators         #-}</span></code></pre></div>
<p>The “Hello Web App” programs of unsafe Javascript definitely has a psychological appeal to current generation of developers over a wall of impenetrable type system extensions.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> http <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;http&#39;</span>)<span class="op">;</span>

<span class="kw">var</span> server <span class="op">=</span> <span class="va">http</span>.<span class="at">createServer</span>(<span class="kw">function</span> (request<span class="op">,</span> response) <span class="op">{</span>
  <span class="va">response</span>.<span class="at">writeHead</span>(<span class="dv">200</span><span class="op">,</span> <span class="op">{</span><span class="st">&quot;Content-Type&quot;</span><span class="op">:</span> <span class="st">&quot;text/plain&quot;</span><span class="op">}</span>)<span class="op">;</span>
  <span class="va">response</span>.<span class="at">end</span>(<span class="st">&quot;Hello World</span><span class="sc">\n</span><span class="st">&quot;</span>)<span class="op">;</span>
<span class="op">}</span>)<span class="op">;</span>

<span class="va">server</span>.<span class="at">listen</span>(<span class="dv">8000</span>)<span class="op">;</span></code></pre></div>
<p>This is not a critique of Servant, merely a retrospective about how far the gap between the Javascript and Haskell worlds is becoming and how much activation energy is required to cross the schism.</p>
<hr/>
<h4 id="numerical-programming">Numerical Programming</h4>
<ul>
<li><em><a href="https://hackage.haskell.org/package/dimensional-1.0.1.0/docs/Numeric-Units-Dimensional.html">Dimensional</a></em></li>
</ul>
<p>Dimensional finally takes many of the modern language extensions that have been present since 7.6 (type families, closed type families and promotion) and applies them to the problem of building semantically sound dimensional calculations. The example <a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/DougBurke/astro-haskell/master/html/angular%20diameter%20distance.html">astro haskell</a> notebooks by Doug Burke are a great example of these used to do calculations.</p>
<ul>
<li><em>Mythical Haskell Array Library</em></li>
</ul>
<p>On this topic, I’m a bit more pessimistic. I don’t forsee a complete story to the NumPy/Pandas story in Haskell anytime soon. I strongly suspect that it’s simply not possible to create a library in Haskell that would draw the same kind of man-hours from scientific practitioners to see the library to fruition. Progress in the numerical Python space was hard-won and usually built on the graves of academic careers of people who become community organizers around projects like NumPy and SciPy.</p>
<p>There are very few solutions for which I suggest dynamic typing is a good solution, but I’m coming more and more to believe that in the domain of ad-hoc data analysis, dynamic typing hits the local maxima of usability given our current understanding of languages.</p>
<p>My views on this topic are unconventional within the Haskell community. In 2015 Anthony Cowley has done a great deal of groundbreaking work on exploring <a href="https://acowley.github.io/Frames/">type framed structures</a> using an extensible record approach that is the farthest along and shows the most promise.</p>
<hr/>
<h4 id="javascript">Javascript</h4>
<blockquote>
<p>JavaScript, the language, has some issues that make working with it inconvenient and make developing software harder.</p>
</blockquote>
<p>The entire Javascript “phenomenon” is well described in <a href="https://www.youtube.com/watch?v=YyIQKBzIuBY">Alan Kay’s talk</a> on the results of <a href="http://cube-drone.com/comics/c/relentless-persistence">“incremental problem solving”</a> and the programming pop culture. Nevertheless JS exists, has universal browser support and is at least retargetable from more sensible languages.</p>
<p><em><a href="http://elm-lang.org/">Elm</a></em></p>
<p>Elm is another purely functional Javascript tranpiler, it uses Haskell like syntax but is semantically is closer to early ML dialects. As of yet, there is no rich polymorphism or higher-kinded types. As such a whole family of the usual functional constructions (monoids, functors, applicatives, monads) are inexpressible. In 2016 when the languages evolves a modern type system I will give it another look. At the moment it is hard to say much about Elm.</p>
<p><em><a href="http://www.purescript.org/">Purescript</a></em></p>
<p>Purescript has evolved into a very sensible transpiling solution in 2015, with a robust compiler and well structured set of base packages. The type system is superset of Haskell 2010 and expressive enough that the full set of common functional programming idioms are expressible.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span>
<span class="ot">  map ::</span> forall a b<span class="fu">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b

<span class="kw">class</span> (<span class="dt">Functor</span> f) <span class="fu">&lt;=</span> <span class="dt">Apply</span> f <span class="kw">where</span>
<span class="ot">  apply ::</span> forall a b<span class="fu">.</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b

<span class="kw">class</span> (<span class="dt">Apply</span> f) <span class="fu">&lt;=</span> <span class="dt">Applicative</span> f <span class="kw">where</span>
<span class="ot">  pure ::</span> forall a<span class="fu">.</span> a <span class="ot">-&gt;</span> f a

<span class="kw">class</span> (<span class="dt">Applicative</span> m, <span class="dt">Bind</span> m) <span class="fu">&lt;=</span> <span class="dt">Monad</span> m</code></pre></div>
<p>Beyond the Haskell scope, Purescript adds first class records and row polymorphism.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">point2D <span class="fu">=</span> { x<span class="fu">:</span> <span class="dv">3</span>, y<span class="fu">:</span> <span class="dv">4</span> }

point3D <span class="fu">=</span> { x<span class="fu">:</span> <span class="dv">3</span>, y<span class="fu">:</span> <span class="dv">4</span>, z<span class="fu">:</span> <span class="dv">5</span> }

<span class="ot">distance ::</span> {<span class="ot"> x ::</span> <span class="dt">Number</span>,<span class="ot"> y ::</span> <span class="dt">Number</span> } <span class="ot">-&gt;</span> <span class="dt">Number</span>
distance point <span class="fu">=</span> sqrt(point<span class="fu">.</span>x<span class="fu">^</span><span class="dv">2</span> <span class="fu">+</span> point<span class="fu">.</span>y<span class="fu">^</span><span class="dv">2</span>)</code></pre></div>
<p>Inspired by Daan Leijen’s “Programming with Row-polymorphic Effect Types”, Purescript uses a fine grained effect tracking system based on extensible rows. For instance the following two functions <code>print</code> and <code>random</code> have different effects during evaluation that are manifest explicitly in their type signature as a record inside of Eff.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">random ::</span> forall eff1<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">random ::</span> <span class="dt">RANDOM</span> <span class="fu">|</span> eff1) <span class="dt">Number</span>
print<span class="ot"> ::</span> forall eff2<span class="fu">.</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">console ::</span> <span class="dt">CONSOLE</span> <span class="fu">|</span> eff2) <span class="dt">Unit</span></code></pre></div>
<p>When composed inside of the Eff monad multiple types of native effect can be interleaved into the same computation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">Eff</span> (<span class="ot">console ::</span> <span class="dt">CONSOLE</span>,<span class="ot"> random ::</span> <span class="dt">RANDOM</span>) <span class="dt">Unit</span>
main <span class="fu">=</span> <span class="kw">do</span>
  n <span class="ot">&lt;-</span> random
  print n</code></pre></div>
<p>The code generation is fairly natural mapping of Haskell lambda to Javascript functions, delegation to underlying Javascript builtins for primitive operations, and the usual dictionary passing translation for typeclasses.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> $dollar <span class="op">=</span> <span class="kw">function</span> (f) <span class="op">{</span>
    <span class="cf">return</span> <span class="kw">function</span> (x) <span class="op">{</span>
        <span class="cf">return</span> <span class="at">f</span>(x)<span class="op">;</span>
    <span class="op">};</span>
<span class="op">};</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> show <span class="op">=</span> <span class="kw">function</span> (dict) <span class="op">{</span>
    <span class="cf">return</span> <span class="va">dict</span>.<span class="at">show</span><span class="op">;</span>
<span class="op">};</span>

<span class="kw">var</span> showNumber <span class="op">=</span> <span class="kw">new</span> <span class="at">Show</span>(<span class="va">$foreign</span>.<span class="at">showNumberImpl</span>)<span class="op">;</span>

<span class="kw">var</span> showBoolean <span class="op">=</span> <span class="kw">new</span> <span class="at">Show</span>(<span class="kw">function</span> (_35) <span class="op">{</span>
    <span class="cf">if</span> (_35) <span class="op">{</span>
        <span class="cf">return</span> <span class="st">&quot;true&quot;</span><span class="op">;</span>
    <span class="op">};</span>
    <span class="cf">if</span> (<span class="op">!</span>_35) <span class="op">{</span>
        <span class="cf">return</span> <span class="st">&quot;false&quot;</span><span class="op">;</span>
    <span class="op">};</span>
    <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&quot;...&quot;</span>)<span class="op">;</span>
<span class="op">}</span>)<span class="op">;</span></code></pre></div>
<p>There are a variety of bindings to external Javascript DOM libraries including <a href="https://github.com/purescript-contrib/purescript-react">React</a>. Until the browser becomes targetable in a way that <a href="https://hacks.mozilla.org/2015/12/compiling-to-webassembly-its-happening/">doesn’t involve</a> transpiling source code, Purescript is as state of the art as it gets.</p>
<hr/>
<h4 id="editor-integration">Editor Integration</h4>
<p><em><a href="https://github.com/begriffs/haskell-vim-now">haskel-vim-now</a></em></p>
<p>Vim integration with Haskell has never been easier and a lot of the problems around ghc-mod and syntax highlighting have been packaged up and managed by stack now by the <code>haskell-vim-now</code> package. This is markedly improved from when I last wrote about vim and Haskell in 2013.</p>
<p><em><a href="https://github.com/imeckler/mote">mote</a></em></p>
<p>With the advent of type holes (at both the value and type level now) there exists are an interesting set of opportunities for providing Agda-like editor integration that is syntax and type aware. Specifically case expansion is a much loved feature that is still missing from our current ghc-mod tooling. Mote is an exploration of such ideas.</p>
<p><em><a href="https://github.com/haskell/haskell-ide-engine">haskell-ide-engine</a></em></p>
<p>The Haskell IDE Engine is a community effort to provide a universal IDE interface that abstracts over the common functionality needed to build future tooling.</p>
<p>While this project is exciting, is a bit concerning to me how large this project has grown an enormous number <a href="https://github.com/haskell/haskell-ide-engine/blob/master/haskell-ide-engine.cabal#L27">of dependencies</a> including and is probably going to end up as a very heavy library and not a lightweight ghc-mod abstraction anytime soon.</p>
<hr/>
<h4 id="sql">SQL</h4>
<p>In the past SQL has been a particularly sore spot in the Haskell ecosystem, although typically the low-level bindings are present the problem of building a easy to use, type-safe, database-agnostic, language-integrated query system that maps to Haskell data structures has been ongoing. As of 2015 there are several new offerings for high level bindings, most of which offer an interesting new perspective on type-safe query generation. Uniquely Opaleye does not fall back on TemplateHaskell, and although not database agnostic, is closest to what I imagine the ideal solution would be.</p>
<ul>
<li><em><a href="https://hackage.haskell.org/package/esqueleto">esqueleto</a></em></li>
<li><em><a href="https://hackage.haskell.org/package/opaleye">opaleye</a></em></li>
<li><em><a href="https://hackage.haskell.org/package/relational-record">relational-record</a></em></li>
</ul>
<p>I have yet to encounter a set of abstractions that brings the ideas of Philip Wadler’s <a href="http://homepages.inf.ed.ac.uk/jcheney/publications/cheney13icfp.pdf">A Practical Theory of Language-Integrated Query</a> to fruition in Haskell. There is much work in this space on both the engineering and research side; yet I’m quite confident with some changes that are coming in GHC 8.0 that this will converge on a nice tight solution.</p>
<hr/>
<h4 id="programming-languages">Programming Languages</h4>
<p>Several new experimental languages have emerged that are looking into some radically different ideas about the way we structure programs. Not surprisingly many of them are bootstrapped on top of Haskell. It’s increasingly becoming simpler to build language prototypes as many of the component pieces are being abstracted out into libraries.</p>
<ul>
<li><em><a href="https://github.com/Gabriel439/Haskell-Morte-Library">Morte</a></em></li>
<li><em><a href="https://github.com/unisonweb/platform">Unison</a></em></li>
<li><em><a href="https://github.com/xixixao/Shem">Shem</a></em></li>
<li><em><a href="http://www.rise4fun.com/koka/tutorial">Koka</a></em></li>
<li><em><a href="https://hackage.haskell.org/package/egison">Egison</a></em></li>
<li><em><a href="https://github.com/mthom/shentong">Shentong</a></em></li>
</ul>
<p>For those who are <a href="https://www.reddit.com/r/haskell/comments/3qgsx1/whats_the_equivalent_of_modern_compiler/cwf3fhg">asking</a>, I am continuing to write the <a href="http://dev.stephendiehl.com/fun/">proto functional compiler tutorial</a> and will continue to do so in 2016. Technical writing is just a very thankless and time-consuming process.</p>
<hr/>
<h4 id="dependent-types">Dependent Types</h4>
<p><em><a href="https://github.com/idris-lang/Idris-dev">Idris</a></em></p>
<p>Although technically not a recent development, Idris has seen a lot of work in 2015. Idris is very promising foray into the next generation of dependently typed languages that actually aims for a full end-to-end compiler. Here is the clearest preview of what functional programming will look like in 2025.</p>
<p>That said, for the work that I do on a daily basis I’m a bit reserved about the offerings of dependently typed languages; having spent a fair bit of time investigating possible use cases for dependently typed numerical programming. This year may be the one that changes my mind on this, but for the moment dependent types don’t quite yet offer the same power to weight ratio as my usual System-F and ML derivative languages do. The primary criterion I would use for considering the next generation of dependently typed languages is when the first self-hosting optimizing compiler emerges. Until then I remain skeptical but optimistic about the advances in dependent types.</p>
<hr/>
<h4 id="education-community">Education &amp; Community</h4>
<p>It was good year for the community. There were at least 3 more books written, thousands of StackOveflow answers added, and the Haskell subreddit grew by 4,000 users.</p>
<p>Real World Haskell and What I Wish I Knew were translated into Chinese.</p>
<ul>
<li><a href="https://github.com/huangz1990/real-world-haskell-cn0">Real World Haskell-cn</a></li>
<li><a href="http://www.haskellcn.org/hask/">WIWIK-cn</a></li>
</ul>
<p>There is still some active debate concerning the interplay of types, laws, and documentation. Although the overall state of library documentation has gotten uniformly better over the last year. It certainly is much better than seven years ago when understanding any bit of Haskell code was more a test of one’s academic library skills than programming.</p>
<p>The <a href="https://skillsmatter.com/skillscasts/6739-park-bench-discussion">Haskell Exchange 2015 Park Bench</a> discussion is a very good representation of many of the concerns around the growing community and the debates around “Haskell as stable industrial language” and “Haskell as vehicle for compiler research” that often occur.</p>
<p>It was a good year for Haskell! :-)</p>]]></summary>
</entry>
<entry>
    <title>Influential Books</title>
    <link href="http://www.stephendiehl.com/posts/books.html" />
    <id>http://www.stephendiehl.com/posts/books.html</id>
    <published>2015-11-24T00:00:00Z</published>
    <updated>2015-11-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="books">Books</h3>
<p>Every couple of years I reflect on the most influential books that I’ve read. Going back several years these are the books that I most remember from my university days and time working in industry that have influenced how I think.</p>
<hr/>
<h4 id="hard">Hard</h4>
<p>Non-fiction and textbooks</p>
<p><strong>The Little MLer</strong> by Matthias Felleisen</p>
<p>A whimsical set of discussions around a set of small Standard ML projects. Convey’s the large ideas in typed functional programming, concerning polymorphism, higher order functions and algebraic datatypes.</p>
<p><strong>Gödel, Escher, Bach</strong> by Douglas Hofstadter</p>
<p>A strange discussion about formal systems and their occurrence in multiple domains of human thinking, from philosophy and linguistics to computer science. The book is highly non-linear and probably should be read in that fashion.</p>
<p><strong>Galois Theory</strong> by Ian Stewart</p>
<p>Stewart’s short presentation of the subject works up to Abel-Ruffini theorem in a particularly elegant way, and much more concisely than Artin’s presentation.</p>
<p><strong>Calculus</strong> by Michael Spivak</p>
<p>Although more a of a book on real analysis, it is a beautifully written book that covers the idea of calculus and real functions. The clarity of Spivak’s presentation and motivating examples is rare to find. Although it would be hard to teach this book in an introductory course, it is a must read after the fact.</p>
<p><strong>Mathematics, Form and Function</strong> by Saunders MacLane</p>
<p>MacLane’s popular discussion about the large-scale structure of mathematics and the underlying common ideas that gave rise to his formalization of category theory. Should be required reading for first year math undergraduates to understand the ideas that drive mathematical discovery and unification.</p>
<p><strong>Number, the Language of Science</strong> by Tobias Dantzig</p>
<p>Tobias discusses the historical concept of mathematics from the rudimentary counting of prehistoric man to the counterintuitive and bizarre ideas at the edges of modern math.</p>
<p><strong>The Book of Numbers</strong> by John Conway</p>
<p>A whimsical book on number theory that I remember distinctively from my childhood. Probably the only children’s book that touches on complex analysis and hypersurreal numbers.</p>
<p><strong>Structure and Interpretation of Computer Programs</strong> by Gerald Jay Sussman</p>
<p>The classical introductory computer science book in scheme. Widely considered a classic for good reasons, it really conveys the core ideas that underlying modern computing better than other introductory text. Even if you don’t know scheme, forcing yourself to implement the projects will increase your cross-language mental dexterity.</p>
<p><strong>Introduction to Functional Programming (1st Edition)</strong> by Richard Bird and Philip Wadler</p>
<p>The beautiful introductory text that really conveys the elegance of the core ideas of typed functional programming. Every core idea is precisely motivated by the most perfect example of usage. This was the book that really turned me on to programming in Haskell.</p>
<p><strong>Types and Programming Languages</strong> by Benjamin Pierce</p>
<p>Pierce’s book on type theory (TAPL) was revolutionary and has become the “bible” of programming language theory. Although some chapters are a little dated, the core ideas and algorithms are foundational to modern programming language design. Although this book is great at explaining the implementation of type-checkers there is not yet that covers the full end-to-end implementation of modern functional compilers.</p>
<p><strong>Software Foundations</strong> by Benjamin Pierce</p>
<p>Software is the ground-breaking book about the methods of constructing machine verifiably correct software using the Coq proof assistant. On top of this it’s also one of the only thorough introductions to the progress and preservation proofs that underlying the core verification of language semantics.</p>
<p><strong>Artificial Intelligence</strong> by Russell and Norvig</p>
<p>A great book on the many of the core ideas of Artificial Intelligence that emerged before the first AI winter. The chapter on knowledge representation is a bit dated and doesn’t yet cover some modern ideas like fluent calculus or advances in temporal logic.</p>
<p><strong>The Quest for Omega</strong> by Gregory Chaitin</p>
<p>Chaitin’s popularized account of information theory and the derivation of the constant of his namesakes, the halting probability that represents the probability that a randomly constructed program will halt. Does a great job of detailing the many paradoxes that arise out of simple questions about computing.</p>
<p><strong>The Structure of Scientific Revolutions</strong> by Thomas Kuhn</p>
<p>The most famous philosophy of science book of the last century. Kuhn challenged the then prevailing views of scientific progress and shed light on the social structure of how prevailing theories change and come to be accepted. Although many people disagree with some of the thesis, it’s a must read for any grad student working in the natural sciences.</p>
<p><strong>The Art of Doing Science and Engineering</strong> by Richard Hamming</p>
<p>The notes from Richard Hamming’s lecture series mentoring young scientists and engineers about his experiences at Bell Labs. In particular his lecture about <a href="https://www.youtube.com/watch?v=a1zDuOPkMSw">You and Your Research</a> should be watched by everyone regardless of involvement in science.</p>
<p><strong>Category Theory</strong> by Steve Awodey</p>
<p>Category theory is a outgrowth branch of abstract algebra with incredibly diverse applications. The most modern textbook on category, although the original MacLane texts are still excellent this tracks many of the more recent notational conventions and ideas.</p>
<p><strong>Visual Complex Analysis</strong> by Tristan Needham</p>
<p>Tristan’s groundbreaking book on complex analysis was one of the first texts on this subject written in the age of modern computer graphing tools and sheds an amazing amount of geometric insight into an otherwise very abstract field of analysis.</p>
<p><strong>Geometric Algebra for Physicists</strong> by Chris Doran</p>
<p>Doran’s book is the most thorough derivation of the core physical laws (Classical mechanics, Maxwell’s equations, Noether’s theorem, Dirac equation, Einstein field equation) from the geometric algebra perspective. There’s no new information per se, but the alternative formalism is often much more concise as in the case of the Maxwell’s equations.</p>
<p><strong>Tensor Calculus for Physics</strong> by Dwight Neuenschwander</p>
<p>I spent several months studying the formalism for tensor calculus from the traditional texts and it was terrible. Many years later I discovered this book which distills all the core ideas needed for general relativity down into a book 1/6th the size.</p>
<p><strong>Term Rewriting and all That</strong> by Franz Baader</p>
<p>A rather old book about a very niche topic: term rewriting. Term rewriting is a very general framework for building sets of transformations over symbols and their synthesis. It’s a very broad subject that finds applications compilers, type theory, knowledge representation and machine learning. It’s a shame it’s not studied more often.</p>
<p><strong>The Implementation of Functional Programming Languages</strong> by Simon Peyton Jones</p>
<p>One of the most important books written on compiler design and largely the only resource <em>ever</em> written the full engineering details going into functional compilers.</p>
<p><strong>An Introduction to Analysis</strong> Zaring</p>
<p>My favorite real analysis text that I read in conjunction to a course using Rudin. Has a much more casual presentation and motivates the core ideas much better than the usual lemma/proof chug of the canonical texts. This book has been out of print for 20 years, so good luck finding it.</p>
<p><strong>Functional Differential Geometry</strong> by Gerald Jay Sussman</p>
<p>A implementation of the core ideas of differential geometry implemented in a computable form as a Scheme program.</p>
<p><strong>The C Programming Language</strong> by Brian Kernighan and Dennis Ritchie</p>
<p>The book everyone learns C from, although a bit dated it still has a certain elegance to it’s minimalist approach to a minimalist language.</p>
<p><strong>Coders at Work</strong> by Peter Siebel</p>
<p>A collection of interviews with some of he greatest programmers of our generation, and their perspectives on the state of the craft of programming. Particularly the interviews with Simon Peyton Jones and Joe Armstrong are particularly good.</p>
<p><strong>The Demon-Haunted World</strong> Carl Sagan</p>
<p>Carl Sagan’s strangely prescient discussion about the role of science and scientific reasoning has in society. The main thesis is that the “candle” of scientific progress is a fragile construction that could very well be extinguished by ignorance and superstition.</p>
<hr/>
<h4 id="soft">Soft</h4>
<p>Fiction, graphic novels and biographies.</p>
<p><strong>Diaspora</strong> by Greg Egan</p>
<p>Diaspora focuses on post-human existence when humanity has “speciated” out into three separate transhuman species. It questions the meaning of human existence in a transhuman world where human desires are bound up up with ancestral human biology and what meaning do lives and desires have, and what serves as the basis of values when biology no longer forms a part of life. Also one of the only fiction to use the word “fiber bundle” as part of the story.</p>
<blockquote>
<p>Every tunnel in the Mines was built from the steps of a watertight proof; every theorem, however deeply buried, could be traced back to every one of its assumptions.</p>
</blockquote>
<p><strong>God Emperor of Dune</strong> by Frank Herbert</p>
<p>The Dune series traces the lives of the Atreides family, whose patriarch Paul discovers a psychoactive substance called “spice” which unlocks his ability to perceive the future. Paul discovers the terrible truth of being an Oracle - the more a prophetic vision is fulfilled, the harder it is to avoid the rest of the vision; and the terrible ramifications a prescient messiahs and hero worship has for humanity’s long term future. In the final book, humanity is ruled by a all-knowing worm god trapped in the existential nightmare of his own prescience. One of the greatest series ever written in my option.</p>
<blockquote>
<p>It has occurred to me more than once that holy boredom is good and sufficient reason for the invention of free will.</p>
</blockquote>
<p><strong>Prelude to Foundation</strong> by Issac Asimov</p>
<p>Asimov’s seminal work about the collapse and rebirth of a advanced galactic-spanning civilization and the mathematical cult that architects the future course of human history to a new golden age.</p>
<blockquote>
<p>We’ve been blinded by Seldon’s psychohistory, one of the first propositions of which is that the individual does not count, does not make history, and that complex social and economic factors override him, make a puppet out of him.</p>
</blockquote>
<p><strong>Anathem</strong> by Neal Stephenson</p>
<p>In a fictional world a series of technological catastrophes force the planet’s scientists, scholars and philosophers - known as the avout — to live apart from the ‘Sæcular world’ of society at large and are not permitted access to modern technology. The avout spend their days engaged in theoretical research until another plant-wide catastrophe forces them to emerge from their cloisted existence.</p>
<blockquote>
<p>And it happened all the time that the compromise between two perfectly rational alternatives was something that made no sense at all.</p>
</blockquote>
<p><strong>The Man Who Loved Only Numbers</strong> by Paul Hoffman</p>
<p>Paul Erdős was one of the most prolific mathematicians of the 20th century, and simultaneously one of the most eccentric people who ever lived. He’s particularly known for monumental contributions to Ramsey theory and combinatorics.</p>
<blockquote>
<p>As a joke I said, “What is the purpose of Life?” “Proof and conjecture, and keep the Supreme Fascist’s score low.”</p>
</blockquote>
<p><strong>Einstein</strong> by Walter Isaacson</p>
<p>Isaccson’s great biography of Einstein really outlines the struggle of Einstein’s life and the humanity of one of the greatest physicists beyond just the Annus Mirabilis years. In particular his accounts of the war and the details of his personal life are much more sad than one might expect.</p>
<blockquote>
<p>When you write biographies, whether it’s about Ben Franklin or Einstein, you discover something amazing: They are human.</p>
</blockquote>
<p><strong>The Culture Series</strong> by Iain Banks</p>
<p>The culture series is one of the few modern scifi that posit a post-scarcity interstellar utopia. In the far future the galaxy is largely dominated by an alliance of advanced races called The Culture. The civilization is grapples with the moral and systematic issues present with artificial super-intelligence, trans-humanism, and dealings with both less advanced and transcendent species.</p>
<blockquote>
<p>Reason shapes the future, but superstition infects the present.</p>
</blockquote>]]></summary>
</entry>
<entry>
    <title>Haskell Poll Results</title>
    <link href="http://www.stephendiehl.com/posts/poll.html" />
    <id>http://www.stephendiehl.com/posts/poll.html</id>
    <published>2014-12-21T00:00:00Z</published>
    <updated>2014-12-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="haskell-poll-results">Haskell Poll Results</h3>
<p>I put out a call for data and comments about topics that Haskell people felt were under represented. I’m sure I’ll take some flak for the informal poll and methodology, but I feel that having at least some concrete data about the Haskell zeitgeist is better than nothing.</p>
<p>As my friends have noted, baked into the poll is a hypothesis that people will give different responses based on which domain they use Haskell for ( i.e. compiler developers have different focus than web developers). This seems to be confirmed by the data, but at the same time also self-selects for people who have a narrow focus. Also given the nature of the collection, we’re only going to select people who are willing to respond and active on Haskell forums.</p>
<p>The total counts include all individuals, even those who gave a “None of the above” or write-in for their domain. These are some of the most bizarre results, but when these points are excluded and then factored on domain the results seem much more sensible.</p>
<p>Thanks again for all those who volunteered their opinions.</p>
<h4 id="domains">Domains</h4>
<blockquote>
<p>What category best classifies the domain of problems you use Haskell for?</p>
</blockquote>
<p>The first question concerned which domain of programming the questionee is involved in. This field was exclusive choice so that we could bin on it when doing statistics later. The most popular domains in order are:</p>
<ol style="list-style-type: decimal">
<li>Web Development</li>
<li>Compiler Design</li>
<li>Pure Mathematics or CS Theory</li>
<li>Data Analysis</li>
<li>Numerical Computing</li>
<li>Education</li>
<li>Financial Modeling</li>
</ol>
<p>The number of people involved in compiler development was somewhat surprising result to say the least. The other domains seemed to fall out fairly natural. There were also quite a few write-ins in various forms, and many comments indicating multidisciplinary fields. The write-ins were excluded from the later binning on the various factors and only included in the total count.</p>
<p>
<img src="/images/poll_domain.png">
</p>
<h4 id="skill-level">Skill Level</h4>
<blockquote>
<p>How would you subjectively rate your Haskell skill level?</p>
</blockquote>
<p>The self-rated skill level turned out to be a fairly typical distribution with a median of 5, mode of 5, and mean of 5.3. 53% of Haskellers in the poll rated themselves 5 or lower while 32% rated themselves as 7 or higher.</p>
<p>Given the self-selecting nature of this question, this result is probably not meaningful or accurate.</p>
<h4 id="type-system">Type System</h4>
<blockquote>
<p>What Haskell type system features do you feel are under represented or often misunderstood?</p>
</blockquote>
<p>The six most mentioned type systems features surprised me a bit, they were:</p>
<ol style="list-style-type: decimal">
<li><strong>Impredicative Types</strong></li>
<li><strong>Kind Polymorphism</strong></li>
<li><strong>Singletons</strong></li>
<li><strong>Rank-N Types</strong></li>
<li><strong>GADTs</strong></li>
<li><strong>Type Families</strong></li>
</ol>
<p><strong>Impredicative Types</strong> is a curious answer. I’m baffled why it seems so dominant. The extension is widely considered to be broken or a misfeature, and I don’t think I’ve never seen it used in the wild. My only guess is that it relates to it showing up so frequently in GHC error reporting that many people are curious about it having never actually used it.</p>
<p><strong>Kind Polymorphism</strong> is understandable since it’s a fairly recent addition to GHC and already there seems to a need for many poly-kinded versions of existing structures in Base. Kind promotion itself is still a very under-used feature.</p>
<p><strong>Singletons</strong> is also a rather fruitful modern area of research in bringing some semblance of dependent types to Haskell. The <a href="http://hackage.haskell.org/package/singletons">singletons</a> library has been the subject of several ICFP and meetup talks.</p>
<p><strong>Rank N-Types</strong> invariably seems to always be a point of confusion in some discussions. I would indeed say that higher-ranked polymorphism is not widely understood and can be very subtle.</p>
<p><strong>Type Families</strong> is also a fairly new feature in GHC, and the subject of much active exploration. Only a few months ago did GHC 7.8 get closed type families, giving us the ability to encode much more <a href="http://dev.stephendiehl.com/hask/#closed-type-families">complex logic</a> at the type level</p>
<p>Binned amongst the <strong>Web Development</strong> user group, the most mentioned topics are:</p>
<ol style="list-style-type: decimal">
<li>Impredicative Types</li>
<li>GADTs</li>
<li>Type Families</li>
</ol>
<p>Binned amongst the <strong>Compiler Design</strong> user group, the most mentioned topics are:</p>
<ol style="list-style-type: decimal">
<li>Impredicative Types</li>
<li>Kind Polymorphism</li>
<li>Type Families</li>
</ol>
<p>Binned amongst the <strong>Pure Mathematics or CS Theory</strong> user group, the most mentioned topics are:</p>
<ol style="list-style-type: decimal">
<li>Singletons</li>
<li>Kind Polymorphism</li>
<li>Type Families</li>
</ol>
<p>Binned amongst the <strong>Data Analysis</strong> user group, the most mentioned topics are:</p>
<ol style="list-style-type: decimal">
<li>Kind Polymorphism</li>
<li>Type Families</li>
<li>Rank-N Types</li>
</ol>
<p>Binned against individuals who self-rated themselves as <strong>7 or higher skill</strong> the most mentioned topics are:</p>
<ol style="list-style-type: decimal">
<li>Singletons</li>
<li>Impredicative Types</li>
<li>Kind Polymorphism</li>
</ol>
<p>
<img src="/images/TypeSystem_poll.png">
</p>
<h4 id="patterns">Patterns</h4>
<blockquote>
<p>Which common language patterns do you feel are under represented or misunderstood?</p>
</blockquote>
<p>The pattern results were also somewhat surprising as well, they were:</p>
<ol style="list-style-type: decimal">
<li>F-Algebras</li>
<li>Cont</li>
<li>GHC.Generics</li>
<li>Profunctors</li>
<li>Final Interpreters</li>
<li>Arrows</li>
</ol>
<p><strong>F-Algebras</strong> is also a puzzling response, but was overwhelming the most mentioned response from the total count. There are some <a href="https://www.fpcomplete.com/user/bartosz/understanding-algebras">great articles</a> about the relations between F-Algebras and catamorphisms. They are used somewhat rarely and I’m genuinely surprised about why this answer is the most popular in the total count.</p>
<p><strong>Continuation passing</strong> and CPS conversion seems to be one of those thuddingly concrete topics that seems to confuse more than it should. Continuations do invert the way we normally think about control flow which can be confusing.</p>
<p><strong>GHC.Generics</strong> are another topic which is indeed rather under represented, at the time of writing this I cannot actually think of a resource to point anyone at that explains how to use Generics beyond what the <a href="https://downloads.haskell.org/~ghc/7.6.1/docs/html/users_guide/generic-programming.html">GHC manual</a> explains. At the same time Generics are incredibly powerful and useful.</p>
<p><strong>Profunctors</strong> is understandably confusing, and puzzlingly it seems to be a dependency of a large number of libraries on Hackage while the library itself has limited documentation.</p>
<p><strong>Arrows</strong> is also very understandable. They seem to have been a very active area of research 10 or so years ago. Leaving us with a lot of half-baked libraries around seemingly beautiful ideas, that then died out leaving us only with hints of the possibilities of arrows. That and <code>ArrowSyntax</code> extensions which are very odd and seem to be understood or used by shockingly few people.</p>
<p>Binned amongst the <strong>Web Development</strong> user group, the most mentioned topics are:</p>
<ol style="list-style-type: decimal">
<li>van Laarhoven Lenses</li>
<li>Exception Handling</li>
<li>Template Haskell</li>
</ol>
<p>Binned amongst the <strong>Compiler Design</strong> user group, the most mentioned topics are:</p>
<ol style="list-style-type: decimal">
<li>Cont</li>
<li>Free Monads</li>
<li>Profunctors</li>
</ol>
<p>Binned amongst the <strong>Pure Mathematics or CS Theory</strong> user group, the most mentioned topics are:</p>
<ol style="list-style-type: decimal">
<li>F-Algebras</li>
<li>Cont</li>
<li>Profunctors</li>
</ol>
<p>Binned amongst the <strong>Data Analysis</strong> user group, the most mentioned topics are:</p>
<ol style="list-style-type: decimal">
<li>Free Monads</li>
<li>van Laarhoven Lenses</li>
<li>Heterogeneous Lists</li>
</ol>
<p>Binned against individuals who self-rated themselves as <strong>7 or higher skill</strong> the most mentioned topics are:</p>
<ol style="list-style-type: decimal">
<li>GHC.Generics</li>
<li>F-Algebras</li>
<li>Cont</li>
</ol>
<p>There were no write-ins for this category.</p>
<p>
<img src="/images/Patterns_poll.png">
</p>
<h4 id="libraries">Libraries</h4>
<blockquote>
<p>Which common ( non-web ) libraries do you feel are under represented or misunderstood? Be generous in your responses!</p>
</blockquote>
<p>The libraries section was admittedly a bit of a grab bag, there is no way to poll on all of Hackage so inevitably I had to chose an arbitrary sample of cross-domain libraries. A more exhaustive poll of all of Hackage libraries people are interested in is something I would be interested in doing, but I’m not sure how to do it in a methodological way.</p>
<p>I chose not to include web libraries since they often tend to fall under an umbrella project ( yesod, snap, happstack ) and exhibit some odd clustering behavior that makes them somewhat unique amongst other packages. The top 20 packages are listed below:</p>
<ol style="list-style-type: decimal">
<li><strong>repa</strong> - A numerical library for high performance, regular, multi-dimensional, shape polymorphic parallel arrays.</li>
<li><strong>uniplate</strong> - A generics library for traversals and rewrites.</li>
<li><strong>mmorph</strong> - Monad morphisms, a utility library for working with monad transformers.</li>
<li><strong>free</strong> - A implementation of free monads.</li>
<li><strong>lens-family</strong> - A lightweight minimalistic lens library in the van Laarhoven style.</li>
<li><strong>unbound</strong> - A binder library for capture avoiding substitution for building type checkers and interpreters.</li>
<li><strong>operational</strong> - A monadic utility library for building complex monadic control flow.</li>
<li><strong>pipes</strong> - A coroutine streaming library with strong categorical foundations.</li>
<li><strong>parsec</strong> - A parser combinator library.</li>
<li><strong>esqueleto</strong> - A SQL query embedded DSL.</li>
<li><strong>safe</strong> - A utility library providing total function variants for many Prelude partial functions.</li>
<li><strong>accelerate</strong> - A numerical library for parallel array computing with various backends.</li>
<li><strong>resourcet</strong> - Deterministic allocation and freeing of scarce resources</li>
<li><strong>fgl</strong> - Functional graph theory library.</li>
<li><strong>optparse-applicative</strong> - Command line option parsing.</li>
<li><strong>quickcheck</strong> - Property based testing framework.</li>
<li><strong>hakyll</strong> - Static website generator.</li>
<li><strong>vector</strong> - Generic computing library providing boxed and unboxed contigious memory arrays and fusion.</li>
<li><strong>llvm-general</strong> - Bindings to the LLVM code generation and compiler framework.</li>
<li><strong>diagrams</strong> - Drawing library and embedded domain language for vector graphics.</li>
</ol>
<p>Binned amongst the <strong>Web Development</strong> user group, the most mentioned libraries are:</p>
<ol style="list-style-type: decimal">
<li>pipes</li>
<li>esqueleto</li>
<li>mmorph</li>
</ol>
<p>Binned amongst the <strong>Compiler Design</strong> user group, the most mentioned libraries are:</p>
<ol style="list-style-type: decimal">
<li>uniplate</li>
<li>graphscc</li>
<li>llvm-general</li>
</ol>
<p>Binned amongst the <strong>Pure Mathematics or CS Theory</strong> user group, the most mentioned libraries are:</p>
<ol style="list-style-type: decimal">
<li>repa</li>
<li>uniplate</li>
<li>free</li>
</ol>
<p>Binned amongst the <strong>Data Analysis</strong> user group, the most mentioned libraries are:</p>
<ol style="list-style-type: decimal">
<li>repa</li>
<li>accelerate</li>
<li>lens-family</li>
</ol>
<p>Binned against individuals who self-rated themselves as <strong>7 or higher skill</strong> the most mentioned libraries are:</p>
<ol style="list-style-type: decimal">
<li>mmorph</li>
<li>repa</li>
<li>uniplate</li>
<li>free</li>
<li>alex/happy</li>
<li>criterion</li>
</ol>
<p>The most popular write-ins were:</p>
<ol style="list-style-type: decimal">
<li>reactive</li>
<li>uu-parsinglib</li>
<li>lambdacube-gl</li>
<li>trifecta</li>
<li>machines</li>
<li>recursion-schemes</li>
</ol>
<p>Most of these results are self explanatory and reflect my intuition about Hackage as well. There are some weird anomalies though:</p>
<p><strong>Repa</strong> seemingly has a large amount of <a href="https://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Repa_Tutorial">tutorials</a> and <a href="https://hackage.haskell.org/package/repa-examples">worked examples</a> so this result has me scratching my head a little bit.</p>
<p>On a personal note, I’m somewhat saddened by how often <strong>llvm-general</strong> shows up given how much time I spent on, what I thought, was a <a href="http://www.stephendiehl.com/llvm/">very extensive tutorial</a> on the subject.</p>
<p>
<img src="/images/Libraries_poll.png">
</p>
<blockquote>
<p>A lot of people don’t understand the difference between <code>mtl</code> and <code>transformers</code> and think <code>mtl</code> is the only way to do monad transformers</p>
</blockquote>
<blockquote>
<p>hsc3, the supercollider library, could really use some documentation IMO. One can rely on the supercollider docs, but that’s an extra layer of lookup, and you have to infer the meaning of arguments that don’t always correspond exactly. Seems to me sound is one area where new programmers might be interested in playing with haskell, unfortunately its not too noob friendly.</p>
</blockquote>
<h4 id="language-features">Language Features</h4>
<blockquote>
<p>Which aspects of GHC do you feel are under represented or misunderstood?</p>
</blockquote>
<p>For language features I tried to poll on topics specific to GHC’s implementation details. The results were overwhelmingly about performance and profiling:</p>
<ol style="list-style-type: decimal">
<li>Profiling Memory</li>
<li>Rewrite Rules / Fusion</li>
<li>Cross Compilation</li>
<li>Profiling CPU</li>
<li>Memory Representation</li>
<li>Inlining</li>
</ol>
<p>Binned amongst the <strong>Web Development</strong> user group, the most mentioned topics are:</p>
<ol style="list-style-type: decimal">
<li>Profiling Memory</li>
<li>Profiling CPU</li>
<li>Laziness ( Strictness Annotations )</li>
</ol>
<p>Binned amongst the <strong>Compiler Design</strong> user group, the most mentioned topics are:</p>
<ol style="list-style-type: decimal">
<li>Cmm</li>
<li>STG</li>
<li>Memory Representation</li>
</ol>
<p>Binned amongst the <strong>Pure Mathematics or CS Theory</strong> user group, the most mentioned topics are:</p>
<ol style="list-style-type: decimal">
<li>Profiling Memory</li>
<li>Profiling CPU</li>
<li>Inlining</li>
</ol>
<p>Binned amongst the <strong>Data Analysis</strong> user group, the most mentioned topics are:</p>
<ol style="list-style-type: decimal">
<li>Profiling Memory</li>
<li>Laziness ( Strictness Annotations )</li>
<li>Inlining</li>
</ol>
<p>Binned against individuals who self-rated themselves as <strong>7 or higher skill</strong> the most mentioned topics are:</p>
<ol style="list-style-type: decimal">
<li>Profiling Memory</li>
<li>Cross-Compilation</li>
<li>Inlining</li>
</ol>
<p>The most mentioned write-ins were:</p>
<ol style="list-style-type: decimal">
<li>SIMD</li>
<li>Compiler Passes</li>
<li>Compiler Plugins</li>
</ol>
<p>
<img src="/images/Features_poll.png">
</p>
<blockquote>
<p>Along the lines of performance profiling, I think GHC’s execution model and heap representation are discussed less frequently than they deserve.</p>
</blockquote>
<blockquote>
<p>Quality overviews on term rewriting and optimization steps on Haskell Core(System FC) in the GHC. I can tell it’s out there, but information seems fragmented and a good quality article on the wiki would be very appreciated.</p>
</blockquote>
<blockquote>
<p>Language interop, the C FFI is just the start of the story. How to play nice with the GC with foreign data? How to play nice with Haskell data from the other side?</p>
</blockquote>
<h4 id="critical-comments">Critical Comments</h4>
<blockquote>
<p>In my work, arrows and categories are most useful in constructing lenses. I think lenses are actually a pretty simple idea but the most popular lens library is bloated and defines a multitude of esoteric infix operators.</p>
</blockquote>
<blockquote>
<p>There doesn’t seem to be any areas in any of the categories above which wouldn’t benefit from more documentation. Almost all areas suffer from a lack of explained examples. The more I use almost any library, the more it seems to be lacking in good extensive documentation and examples.</p>
</blockquote>
<blockquote>
<p>Conventions in web API client design and trade offs for different choices. E.g. Typeclasses, free monads, etc. for example, suppose you want to make a web client agnostic of the underlying HTTP client, what’s the best approach? Most people use typeclasses for this, but Haskell has many tools to tackle this problem.</p>
</blockquote>
<blockquote>
<p>The “reactive” library seems to be very useful, but it is still very abstract. It would be nice to see more focus on this, providing more examples for how it can be used.</p>
</blockquote>
<blockquote>
<p>I think the biggest use to myself and the community would be more articles like Gabriel Gonzalez has done that show how to use important Haskell constructs, like monoids or free monads, to structure help program design.</p>
</blockquote>
<blockquote>
<p>There’s some exciting developments in this area–see the Haste presentation by StrangeLoop and others). And the efforts to bring React bindings to Haskell. All of the pieces exists in some form currently, but we have a ways to go before they mature.</p>
</blockquote>
<h4 id="takeaway">Takeaway</h4>
<p>This is of course an unscientific poll and please don’t read too much into the data. The goal was to generate a rough list of the topics that people are interested in and feel need some more context.</p>
<p>On that note, if you are looking for topics for your next blog and want to maximize the coverage of misunderstood topics and advance the state of Haskell knowledge; consider one of the following subjects:</p>
<ol style="list-style-type: decimal">
<li>Types: <strong>Impredicative Types</strong></li>
<li>Types: <strong>Kind Polymorphism</strong></li>
<li>Types: <strong>Singletons</strong></li>
<li>Language: <strong>Profiling Memory</strong></li>
<li>Language: <strong>Rewrite Rules / Fusion</strong></li>
<li>Language: <strong>Cross Compilation</strong></li>
<li>Library: <strong>repa</strong></li>
<li>Library: <strong>uniplate</strong></li>
<li>Library: <strong>mmorph</strong></li>
<li>Library: <strong>free</strong></li>
<li>Library: <strong>lens-family</strong></li>
<li>Pattern: <strong>F-Algebras</strong></li>
<li>Pattern: <strong>Cont Monad</strong></li>
<li>Pattern: <strong>GHC.Generics</strong></li>
</ol>]]></summary>
</entry>
<entry>
    <title>A Haskell Implementation Reading List</title>
    <link href="http://www.stephendiehl.com/posts/essential_compilers.html" />
    <id>http://www.stephendiehl.com/posts/essential_compilers.html</id>
    <published>2014-12-14T00:00:00Z</published>
    <updated>2014-12-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="a-haskell-implementation-reading-list">A Haskell Implementation Reading List</h3>
<p>A reading list for those interested in the implementation internals of Haskell compilers. The GHC Reading list is <a href="https://ghc.haskell.org/trac/ghc/wiki/ReadingList">more exhaustive</a>, these are simply the papers I think give a good high-level overview of the topics.</p>
<p><strong>Typeclass Inference</strong></p>
<ul>
<li><a href="http://ipaper.googlecode.com/git-history/969fbd798753dc0b10ea9efe5af7773ff10f728a/Mark-Jones/A-theory-of-qualified-types.pdf">A Theory Of Qualified Types</a></li>
<li><a href="http://cpsc.yale.edu/sites/default/files/files/tr900.pdf">Type Inference For Parametric Type Classes</a></li>
<li><a href="https://www4.in.tum.de/publ/papers/NipkowPrehofer_TRfT1995.pdf">Type Reconstruction For Type Classes</a></li>
<li><a href="http://www.computerscience.nl/wiki/pub/Ehc/GvdGeest/geest07cnstr-tycls-ext.pdf">Constraints For Type Class Extensions</a></li>
</ul>
<p><strong>Typeclass Elaboration</strong></p>
<ul>
<li><a href="http://202.3.77.10/users/karkare/courses/2010/cs653/Papers/ad-hoc-polymorphism.pdf">How to Make Ad-Hoc Polymorphism Less Ad-Hoc</a></li>
<li><a href="http://pdf.aminer.org/000/214/096/implementing_haskell_overloading.pdf">Implementing Haskell Overloading</a></li>
<li><a href="http://pdf.aminer.org/000/542/781/implementing_type_classes.pdf">Implementing Type Classes</a></li>
<li><a href="http://ropas.snu.ac.kr/lib/dock/HaHaJoWa1996.pdf">Typeclasses In Haskell</a></li>
</ul>
<p><strong>Rank-N Types</strong></p>
<ul>
<li><a href="http://repository.upenn.edu/cgi/viewcontent.cgi?article=1336&amp;context=cis_papers">Practical Type Inference For Arbitrary Rank Types</a></li>
</ul>
<p><strong>Core</strong></p>
<ul>
<li><a href="https://downloads.haskell.org/~ghc/6.10.4/docs/html/ext-core/core.pdf">An External Representation for the GHC Core Language</a></li>
</ul>
<p><strong>STG</strong></p>
<ul>
<li><a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/eval-apply/">Making A Fast Curry</a></li>
<li><a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/spineless-tagless-gmachine.ps.gz#26pub=34">Implementing Lazy Functional Languages On Stock Hardware</a></li>
<li><a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/pj-lester-book/student.djvu">Implementing functional languages: a tutorial</a></li>
</ul>
<p><strong>Cmm</strong></p>
<ul>
<li><a href="http://www.cs.tufts.edu/~nr/pubs/c--gc.pdf">C–: a portable assembly language that supports garbage collection</a></li>
</ul>
<p><strong>Compilation</strong></p>
<ul>
<li><a href="http://www.haskell.org/ghc/docs/papers/unboxed-values.ps.gz">Unboxed Types As First Class Values</a></li>
<li><a href="http://www.cse.unsw.edu.au/~pls/thesis/dons-thesis.ps.gz">Multi-paradigm Just-In-Time Compilation</a></li>
<li><a href="https://www.cse.unsw.edu.au/~pls/thesis/davidt-thesis.pdf">Low Level Virtual Machine For Glasgow Haskell Compiler</a></li>
<li><a href="http://mirror.seize.it/papers/The%20GRIN%20Project.pdf">The Grin Project: A Highly Optimising Back End for Lazy Functional Languages</a></li>
</ul>
<p><strong>Operational Details and Implementation</strong></p>
<ul>
<li><a href="http://arashrouhani.com/papers/master-thesis.pdf">Stack Traces In Haskell</a></li>
</ul>
<p><strong>Transformations</strong></p>
<ul>
<li><a href="http://research.microsoft.com/en-us/um/people/simonpj/Papers/inlining/inline.pdf">Secrets of the GHC Inliner</a></li>
</ul>
<p><strong>Garbage Collection</strong></p>
<ul>
<li><a href="http://community.haskell.org/~simonmar/papers/parallel-gc.pdf">Parallel Generational-Copying Garbage Collection with a Block-Structured Heap</a></li>
<li><a href="http://www.doc.ic.ac.uk/~amc4/Papers/thesis.pdf">Soft Real-time Garbage Collection for Dynamic Dispatch Languages</a></li>
</ul>
<p>A copy of all of the PDF papers is available in this <a href="https://github.com/sdiehl/papers">Git repo</a>.</p>]]></summary>
</entry>
<entry>
    <title>A Vim + Haskell Workflow</title>
    <link href="http://www.stephendiehl.com/posts/vim_haskell.html" />
    <id>http://www.stephendiehl.com/posts/vim_haskell.html</id>
    <published>2013-10-18T00:00:00Z</published>
    <updated>2013-10-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="a-vim-haskell-workflow">A Vim + Haskell Workflow</h3>
<p><b style="color:red">This post is out of date and has been <a href="/posts/vim_2016.html">updated</a> for modern workflow.This page is left for posterity.</b></p>
<hr/>
<p><strong>Hoogle</strong></p>
<p><a href="http://www.haskell.org/hoogle/">Hoogle</a> is a Haskell type search engine which can be used online or installed locally.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">$ cabal install hoogle</code></pre></div>
<p>Hoogle can be used from the command line as well from GHCi by adding the following lines to your <code>.ghc/ghci.conf</code></p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">:<span class="kw">def</span> hoogle \s -&gt; <span class="kw">return</span> $ <span class="st">&quot;:! hoogle --count=15 </span><span class="ch">\&quot;</span><span class="st">&quot;</span> ++ s ++ <span class="st">&quot;</span><span class="ch">\&quot;</span><span class="st">&quot;</span></code></pre></div>
<p><br />
 For instance if we forgot the name of the function associated with <code>(a -&gt; m b) -&gt; [a] -&gt; m b</code>) we could ask hoogle for functions matching. Indeed we see that <code>mapM_</code> is in the list.</p>
<p>
<img src="/images/hoogle.png"/>
</p>
<p><strong>syntastic</strong></p>
<p><a href="https://github.com/scrooloose/syntastic">Syntastic</a> is a syntax checking plugin for a variety of languages, including Haskell. It integrates with a either ghcmod or hdevtools to provide type errors inline.</p>
<p>
<img src="/images/loclist.png"/>
</p>
<p>
<img src="/images/errors.png"/>
</p>
<p>To toggle between active or passive type checking we can enable the following key bindings:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">map &lt;silent&gt; &lt;Leader&gt;e :Errors&lt;CR&gt;
map &lt;Leader&gt;s :SyntasticToggleMode&lt;CR&gt;</code></pre></div>
<p>To always show the errors list when editing we can set the following flag:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">let g:syntastic_auto_loc_list<span class="op">=</span><span class="dv">1</span></code></pre></div>
<p><strong>ghc-mod</strong></p>
<p>ghcmod is a command line tool to analyze Haskell source. It integrates with syntastic to provide integration with GHCi.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">$ cabal install ghc-mod</code></pre></div>
<p>Pressing ( <code>tu</code> ) can then be used to update the background GHC process with the file (from disk). This updates the tagbar and allows you to fill in any missing types by highlighting the toplevel function definition and pressing ( <code>tw</code> ) to infer the corresponding type signature of the highlighted toplevel function and add it to the line above. As usual the signature is the inferred by GHC is guaranteed to be the <em>most general type</em>, not necessarily the most usefull one.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="st">&quot; Reload</span>
map &lt;silent&gt; tu :call <span class="fu">GHC_BrowseAll</span>()&lt;CR&gt;
<span class="st">&quot; Type Lookup</span>
map &lt;silent&gt; tw :call <span class="fu">GHC_ShowType</span>(<span class="dv">1</span>)&lt;CR&gt;</code></pre></div>
<p><br />
 <strong>hdevtools</strong></p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">$ cabal install hdevtools</code></pre></div>
<p>To enable, first install syntastic and then add the following to your <code>.vimrc</code>.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">au FileType haskell nnoremap &lt;buffer&gt; &lt;F1&gt; :HdevtoolsType&lt;CR&gt;
au FileType haskell nnoremap &lt;buffer&gt; &lt;silent&gt; &lt;F2&gt; :HdevtoolsClear&lt;CR&gt;
au FileType haskell nnoremap &lt;buffer&gt; &lt;silent&gt; &lt;F3&gt; :HdevtoolsInfo&lt;CR&gt;</code></pre></div>
<p>Pressing ( <code>F1</code> ) in Normal mode shows the type under the cursor. Pressing it repeatedly expands the selection to the parent expression up to the toplevel function definition.</p>
<p>
<img src="/images/f1.png"/>
</p>
<p>Pressing ( <code>F3</code> ) in Normal mode will show further information about type classes, data constructors or functions, including the source location of definition.</p>
<p>
<img src="/images/f3.png"/>
</p>
<p><strong>hlint</strong></p>
<p>Hlint is a source linter for Haskell which can provide a selection of hints for helping improve your code stylistic and functionally. For instance if you happen to implement one of many Prelude functions it can suggest that you use the builtin instead.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">$ cabal install hlint</code></pre></div>
<p>
<img src="/images/hlint.png"/>
</p>
<p><strong>tagbar</strong></p>
<p><a href="http://majutsushi.github.io/tagbar/">Tagbar</a> is a plugin for browsing the toplevel definitions in a file. It integrates with ghcmod to generate the tags from</p>
<p>
<img src="/images/tagbar.png"/>
</p>
<p>The tags are updated upon write, to open the tagbar bind <code>:TagbarToggle</code> to your key of choice;</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">nmap &lt;leader&gt;= :TagbarToggle&lt;CR&gt;
let g:tagbar_autofocus = <span class="dv">1</span></code></pre></div>
<p><strong>vim-slime</strong></p>
<p><code>vim-slime</code> is a plugin to allow one-way communication between vim and a tmux shell, allowing you to interactively send code to ghci. To integrate with tmux add the following to your <code>.vimrc</code>, then start a separate terminal process running <code>tmux</code> and <code>ghci</code>.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">let g:slime_target = <span class="st">&quot;tmux&quot;</span>
let g:slime_paste_file = <span class="fu">tempname</span>()</code></pre></div>
<p>In visual mode you now press ( <code>Ctrl-C Ctrl-C</code> ) to send the current block to the tmux session. Upon initial load it will prompt you for the tmux session name and vim panel.</p>
<p>
<img src="/images/slime.png"/>
</p>
<p><strong>pointfree</strong></p>
<p>Pointfree is a syntax rewriter to eliminate unneccesary free variables from an expression.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">$ cabal install pointfree</code></pre></div>
<p><br />
 Then add the following to your <code>.vimrc</code>.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">autocmd BufEnter *.<span class="fu">hs</span> set formatprg=pointfree</code></pre></div>
<p><br />
</p>
<p>In visual mode you can now press <code>gq</code> to convert a expression to it’s pointfree form. Though quite often the resulting form is more obfuscated than the original.</p>
<p>
<img src="/images/pointfree.png"/>
</p>]]></summary>
</entry>
<entry>
    <title>From Adjunctions to Monads</title>
    <link href="http://www.stephendiehl.com/posts/adjunctions.html" />
    <id>http://www.stephendiehl.com/posts/adjunctions.html</id>
    <published>2013-08-29T00:00:00Z</published>
    <updated>2013-08-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="from-adjunctions-to-monads">From Adjunctions to Monads</h3>
<p>I thought I would share one of my favorite constructions in Haskell, namely that adjoint functors give rise to monads. Although it’s a trivial result in category theory how it manifests in Haskell is quite lovely.</p>
<p>A Functor in Haskell maps objects and morphism (i.e. functions) in a subcategory of <em>Hask</em> to objects and morphisms of another category.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span>
<span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre></div>
<p>And satisfies the functor laws:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap id <span class="fu">=</span> id
fmap (a <span class="fu">.</span> b) <span class="fu">=</span> (fmap a) <span class="fu">.</span> (fmap b)</code></pre></div>
<p>In commutative diagrams we draw objects as points and morphisms as arrows. In a string diagrams we invert this and draw morphisms as points and objects as lines.</p>
<p>
<img src="/images/string4.png"/>
</p>
<p>Functor composition is defined for <span class="math inline">\(F : \mathcal{A} \rightarrow \mathcal{B}\)</span>, <span class="math inline">\(G : \mathcal{B} \rightarrow \mathcal{C}\)</span> as <span class="math inline">\(G \circ F : \mathcal{A} \rightarrow \mathcal{C}\)</span>, and is drawn with parallel lines.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">FComp</span> f g a <span class="fu">=</span> <span class="dt">C</span> {<span class="ot"> unC ::</span> f (g a) }

<span class="kw">instance</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g) <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">FComp</span> f g) <span class="kw">where</span>
  fmap f (<span class="dt">C</span> x) <span class="fu">=</span> <span class="dt">C</span> (fmap (fmap f) x)</code></pre></div>
<p>
<img src="/images/string10.png"/>
</p>
<p>Generally the composition of functors <span class="math inline">\(F \circ G\)</span> is written simply as <span class="math inline">\(FG\)</span>. Composition diagrammatically allows us to collapse adjacent segments in our string diagram.</p>
<p>The identity functor ( <span class="math inline">\(\text{Id}\)</span> ) is the functor that maps each morphism and object to itself.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Id</span> a <span class="fu">=</span> <span class="dt">Identity</span> {<span class="ot"> unId ::</span> a }

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Id</span> <span class="kw">where</span>
    fmap f x <span class="fu">=</span> <span class="dt">Identity</span> (f (unId x))</code></pre></div>
<p>Composition with the identity functor forms an identity relation:</p>
<p><span class="math display">\[
F \circ \text{Id}_B = F \\
\text{Id}_A \circ F = F
\]</span></p>
<p>As witnessed by the expressions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">left ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">FComp</span> f <span class="dt">Id</span> a <span class="ot">-&gt;</span> f a
left (<span class="dt">C</span> a) <span class="fu">=</span> fmap unId a

<span class="ot">right ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">FComp</span> f <span class="dt">Id</span> a
right a <span class="fu">=</span> <span class="dt">C</span> <span class="fu">$</span> fmap <span class="dt">Identity</span> a</code></pre></div>
<p>We’ll follow the convention to omit the identity functor, and it is shown as a dotted line in subsequent string diagrams.</p>
<p>
<img src="/images/string6.png"/>
</p>
<p>A natural transformation in our context will be a polymorphic function associated with two Haskell functor instances <code>f</code> and <code>g</code> with type signature <code>(Functor f, Functor g) =&gt; forall a. f a -&gt; g a</code>. Which could be written with the following type synonym.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Nat</span> f g <span class="fu">=</span> forall a<span class="fu">.</span> f a <span class="ot">-&gt;</span> g a</code></pre></div>
<p>
<img src="/images/string5.png"/>
</p>
<p>The identity natural transform mapping a functor <span class="math inline">\(F\)</span> to itself is written <span class="math inline">\(1_F\)</span> and in Haskell is just (<code>id</code>). The composition of natural transformations follows the associativity laws, shown below:</p>
<p>
<img src="/images/string13.png"/>
</p>
<p>The final <em>interchange law</em> states that we can chase the natural transformations through the functors horizontally or compose natural transformation between functors vertically and still arrive at the same result.</p>
<p><span class="math display">\[
(\alpha \beta) \circ (\alpha&#39; \beta&#39;) = (\alpha \alpha&#39;) \circ (\beta \beta&#39;)
\]</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">NatComp</span> f f&#39; g g&#39; <span class="fu">=</span> forall a<span class="fu">.</span> f&#39; (f a) <span class="ot">-&gt;</span> g&#39; (g a)

<span class="ot">vert ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> f&#39;, <span class="dt">Functor</span> g, <span class="dt">Functor</span> g&#39;) <span class="ot">=&gt;</span>
         <span class="dt">Nat</span> f&#39; g&#39; <span class="ot">-&gt;</span> <span class="dt">Nat</span> f g <span class="ot">-&gt;</span> <span class="dt">NatComp</span> f f&#39; g g&#39;
vert a b x <span class="fu">=</span> a (fmap b x)

<span class="ot">horiz ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> f&#39;, <span class="dt">Functor</span> g, <span class="dt">Functor</span> g&#39;) <span class="ot">=&gt;</span>
          <span class="dt">Nat</span> f&#39; g&#39; <span class="ot">-&gt;</span> <span class="dt">Nat</span> f g <span class="ot">-&gt;</span> <span class="dt">NatComp</span> f f&#39; g g&#39;
horiz a b x <span class="fu">=</span> fmap b (a x)</code></pre></div>
<p>By the interchange law <code>horiz</code> and <code>vert</code> must be interchangable under composition. For natural transformations <code>a, b, a', b'</code> in Haskell we have the equation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(a <span class="fu">.</span> b) <span class="ot">`vert`</span> (a&#39; <span class="fu">.</span> b&#39;) <span class="fu">==</span> (a <span class="ot">`horiz`</span> a&#39;) <span class="fu">.</span> (b <span class="ot">`horiz`</span> b&#39;)</code></pre></div>
<p>A diagram example for a natural transformation <span class="math inline">\(\eta : 1_\mathcal{C} \rightarrow {FG}\)</span> between the identity functor and the composition functor of <span class="math inline">\(FG\)</span> would be drawn as:</p>
<p>
<img src="/images/string7.png"/>
</p>
<hr />
<p>An isomorphism <span class="math inline">\(F \cong G\)</span> implies that composition of functors is invertible in that <span class="math inline">\(F G = \text{Id}_C\)</span> and <span class="math inline">\(G F = \text{Id}_D\)</span>. An adjoint <span class="math inline">\(F ⊣ G\)</span> between a pair of functors <span class="math inline">\(F : D \rightarrow C\)</span> and <span class="math inline">\(G : C \rightarrow D\)</span> is a weaker statement that there exists a pair of associated natural transformations <span class="math inline">\((F, G, \epsilon, \eta)\)</span> with:</p>
<p><span class="math display">\[
\epsilon : FG \rightarrow 1_\mathcal{C} \\
\eta : 1_\mathcal{D} \rightarrow FG
\]</span></p>
<p>
<img src="/images/string8.png"/>
</p>
<p>Such that the following <em>triangle identities</em> hold:</p>
<p><span class="math display">\[
(\epsilon F) \circ (F \eta) = 1_F  \\
(G \epsilon) \circ (\eta G) = 1_G 
\]</span></p>
<p>These are drawn below:</p>
<p>
<img src="/images/string9.png"/>
</p>
<p>In terms of the categories <span class="math inline">\(C,D\)</span> an adjoint is in some sense a “half-isomorphism” or “almost inverse” but some structure is lost in one direction.</p>
<p><span class="math inline">\(\eta\)</span> and <span class="math inline">\(\epsilon\)</span> are also referred to respectively as the <em>unit</em> and <em>counit</em>.</p>
<p>In Haskell we have the following typeclass which unfortunately requires a functional dependency in order for type inferencer to deduce which <code>fmap</code> is to be used:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g) <span class="ot">=&gt;</span> <span class="dt">Adjoint</span> f g <span class="fu">|</span> f <span class="ot">-&gt;</span> g, g <span class="ot">-&gt;</span> f <span class="kw">where</span>
<span class="ot">  eta     ::</span> a <span class="ot">-&gt;</span> g (f a)
<span class="ot">  epsilon ::</span> f (g a) <span class="ot">-&gt;</span> a</code></pre></div>
<p>There are also two other natural transformations (<span class="math inline">\(\phi, \psi\)</span>) which together with the adjoint functor pair form an <em>adjunction</em>. The adjunction can be defined in terms of the adjoint pair and this is most convenient definition in Haskell</p>
<p><span class="math display">\[
\psi \epsilon = 1_F \\
\phi \eta = 1_G 
\]</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">phi ::</span> <span class="dt">Adjoint</span> f g <span class="ot">=&gt;</span> (f a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> g b
phi f <span class="fu">=</span> fmap f <span class="fu">.</span> eta

<span class="ot">psi ::</span> <span class="dt">Adjoint</span> f g <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> g b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> b
psi f <span class="fu">=</span> epsilon <span class="fu">.</span> fmap f</code></pre></div>
<p>Notably <span class="math inline">\(\phi\)</span> and <span class="math inline">\(\psi\)</span> form an isomorphism between the set of functions <code>(a -&gt; g b)</code> and <code>(f a -&gt; b)</code> which is the same relation as the above triangle identities. Alternatively <span class="math inline">\(\eta\)</span> and <span class="math inline">\(\epsilon\)</span> can be expressed in terms of <span class="math inline">\(\phi\)</span> and <span class="math inline">\(\psi\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">phi eta <span class="fu">=</span> id
psi epsilon <span class="fu">=</span> id </code></pre></div>
<hr />
<p>From the Haskell Prelude we have the canonical adjoint namely <code>curry</code> and <code>uncurry</code>:</p>
<p><span class="math display">\[
\text{curry} \quad ⊣ \quad \text{uncurry}
\]</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> ((,) a) <span class="kw">where</span>
  fmap f (x,y) <span class="fu">=</span> (x, f y)

<span class="kw">instance</span> <span class="dt">Functor</span> ((<span class="ot">-&gt;</span>) a) <span class="kw">where</span>
  fmap f g <span class="fu">=</span> \x <span class="ot">-&gt;</span> f (g x)</code></pre></div>
<p>Which we can construction an Adjoint instance from these two functor instances:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Adjoint</span> ((,) a) ((<span class="ot">-&gt;</span>) a) <span class="kw">where</span>
  eta x y <span class="fu">=</span> (y, x)
  epsilon (y, f) <span class="fu">=</span> f y</code></pre></div>
<p>We can check that the triangle equalities hold for this definition by showing both <span class="math inline">\((\epsilon F) \circ (F \eta)\)</span> and <span class="math inline">\((G \epsilon) \circ (\eta G)\)</span> reduce to the identity natural transformation ( <code>id</code> ).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">a0 ::</span> (a <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> c)) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> c)
a0 f <span class="fu">=</span> \f <span class="ot">-&gt;</span> fmap (epsilon <span class="fu">.</span> fmap f) <span class="fu">.</span> eta
a0 f <span class="fu">=</span> fmap (\(y, f) <span class="ot">-&gt;</span> g f y) <span class="fu">.</span> eta
a0 f <span class="fu">=</span> \x y <span class="ot">-&gt;</span> f x y

<span class="ot">a1 ::</span> ((a, b) <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a,b) <span class="ot">-&gt;</span> c
a1 f <span class="fu">=</span> epsilon <span class="fu">.</span> fmap (fmap f <span class="fu">.</span> eta)
a1 f <span class="fu">=</span> epsilon <span class="fu">.</span> fmap (\x y <span class="ot">-&gt;</span> f (y, x))
a1 f <span class="fu">=</span> \(x, y) <span class="ot">-&gt;</span> f (x, y)</code></pre></div>
<hr />
<p>We know a Monad is an endofunctor <span class="math inline">\(T : C \rightarrow C\)</span> with two natural transformations <span class="math inline">\((T, \mu, \eta)\)</span> with the usual laws:</p>
<p><span class="math display">\[
\mu \circ T \mu = \mu \circ \mu T \\
\mu \circ T \eta = \mu \circ \eta T = 1_T \\
\]</span></p>
<p>
<img src="/images/string3.png"/>
</p>
<p>The geometric intuition is that the monad laws are reflected as topological properties of the string diagrams. Both <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\eta\)</span> exhibit reflection symmetry and that we topologically straighten out <span class="math inline">\(\eta\)</span> to yield the identity functor.</p>
<p>
<img src="/images/string1.png"/>
</p>
<p>
<img src="/images/string2.png"/>
</p>
<p>In Haskell we can <a href="http://www.stephendiehl.com/posts/monads.html">normally construct</a> the Monad type class from an Endofunctor and (<span class="math inline">\(\mu, \eta\)</span>) or <code>join</code> and <code>return</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Functor</span> t) <span class="ot">=&gt;</span> <span class="dt">Monad</span> t <span class="kw">where</span>
<span class="ot">  eta ::</span> a <span class="ot">-&gt;</span> (t a)
<span class="ot">  mu  ::</span> (t (t a)) <span class="ot">-&gt;</span> (t a)

<span class="ot">  (&gt;&gt;=) ::</span> t a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> t b) <span class="ot">-&gt;</span> t b
  ma <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> mu <span class="fu">.</span> fmap f

return <span class="fu">=</span> eta
join <span class="fu">=</span> mu</code></pre></div>
<p>What is not immediately apparent though is that every adjoint pair of functors gives rise to a monad <span class="math inline">\((T, \mu, \eta)\)</span> over a category <span class="math inline">\(C\)</span> induced by the composition of the functors to give rise to a endofunctor and natural transformations in terms of the unit and counit of the underlying adjunction:</p>
<p><span class="math display">\[
\begin{align}
T &amp;= G \circ F &amp; : &amp;C \rightarrow C  \\
\mu &amp;= G \epsilon &amp; : &amp;T^2 \rightarrow T \\
\end{align}
\]</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Adjoint</span> f g <span class="ot">=&gt;</span> <span class="dt">Monad</span> f g <span class="kw">where</span>
<span class="ot">  muM ::</span> g (f (g (f a))) <span class="ot">-&gt;</span> g (f a)
  muM <span class="fu">=</span> fmap epsilon

<span class="ot">  etaM ::</span> a <span class="ot">-&gt;</span> g (f a)
  etaM <span class="fu">=</span> eta

<span class="ot">  (&gt;&gt;=) ::</span> g (f a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> g (f b)) <span class="ot">-&gt;</span> g (f b)
  x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> muM (fmap (fmap f) x)</code></pre></div>
<p>The geometric intution for this is clear:</p>
<p>
<img src="/images/string11.png"/>
</p>
<p>From the Monad we can then construct the Kleisli category in the usual way.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Adjoint</span> f g, <span class="dt">Category</span> c) <span class="ot">=&gt;</span> <span class="dt">Kleisli</span> c f g <span class="kw">where</span>
<span class="ot">  idK ::</span> c x (g (f x))
<span class="ot">  (&lt;=&lt;) ::</span> c y (g (f z)) <span class="ot">-&gt;</span> c x (g (f y)) <span class="ot">-&gt;</span> c x (g (f z))

<span class="kw">instance</span> <span class="dt">Monad</span> f g <span class="ot">=&gt;</span> <span class="dt">Kleisli</span> (<span class="ot">-&gt;</span>) f g <span class="kw">where</span>
  idK <span class="fu">=</span> eta
  g <span class="fu">&lt;=&lt;</span> f <span class="fu">=</span> muM <span class="fu">.</span> fmap (fmap g) <span class="fu">.</span> f

<span class="kw">instance</span> <span class="dt">Kleisli</span> c f g <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (c a (g (f a))) <span class="kw">where</span>
  mempty  <span class="fu">=</span> idK
  mappend <span class="fu">=</span> (<span class="fu">&lt;=&lt;</span>)</code></pre></div>
<p>In retrospect this is trivial, but importantly leads us to the more important question: Can we recover an adjunction from a monad. The answer is Yes…</p>]]></summary>
</entry>
<entry>
    <title>Haskell for Web Developers</title>
    <link href="http://www.stephendiehl.com/posts/haskell_web.html" />
    <id>http://www.stephendiehl.com/posts/haskell_web.html</id>
    <published>2013-07-18T00:00:00Z</published>
    <updated>2013-07-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="haskell-for-web-developers">Haskell for Web Developers</h2>
<p><b style="color:red">This blog post is somewhat dated and may not reflect changes to the ecosystem since 2013.</b></p>
<p>The perpetual myth persists that Haskell cannot be used for “real world applications”. Normally real world is usually left undefined in such a discussion, but can often be taken to mean that Haskell is not suited for database and web development work.</p>
<p>Haskell has a rich library ecosystem and is well-suited for these tasks but I concede that there might be a systemic lack of introductory material for many domain specific tasks. Something that many <a href="http://www.haskell.org/platform">projects</a> and <a href="https://www.fpcomplete.com">companies</a> are trying to remedy.</p>
<p>Haskell does indeed have several great web frameworks along the lines of RoR, Django, Flask, Pyramid etc.</p>
<ol style="list-style-type: decimal">
<li><a href="http://www.yesodweb.com/">Yesod</a></li>
<li><a href="http://www.snapframework.com/">Snap</a></li>
<li><a href="http://www.happstack.com/">Happstack</a></li>
</ol>
<p>I will not discuss these though because I really couldn’t give a better introduction than their own documentation. Instead I will focus on simple motivating examples for smaller libraries which provide a rich feature base for web development tasks while leveraging the strengths of Haskell language itself, and many of which can integrate with the larger frameworks.</p>
<h4 id="clay">Clay</h4>
<p>Clay is a library for programmatic generation of CSS. Is it an embedded DSL (EDSL) that exposes selectors and styles for the <a href="https://github.com/sebastiaanvisser/clay/tree/master/src/Clay">CSS3 grammmer</a>. Clay is designed to layer logic on top of the CSS as to encode variables, color mixing, complex selector logic and nested rules more easily than with base CSS. Clay can also be usefull as a lower-level combinator library to describe complex CSS layouts.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install clay</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Clay</span>
<span class="kw">import </span><span class="dt">Data.Text</span>
<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (div)

<span class="ot">bodyStyle ::</span> <span class="dt">Css</span>
bodyStyle <span class="fu">=</span> body <span class="fu">?</span> <span class="kw">do</span>
  background  aquamarine
  fontFamily  [<span class="st">&quot;Helvetica Neue&quot;</span>] [sansSerif]

<span class="ot">codeStyle ::</span> <span class="dt">Css</span>
codeStyle <span class="fu">=</span> code <span class="fu">?</span>
  <span class="kw">do</span> fontFamily  [<span class="st">&quot;Monaco&quot;</span>, <span class="st">&quot;Inconsolata&quot;</span>] [monospace]
     fontSize    (px <span class="dv">14</span>)
     lineHeight  (ex <span class="fl">1.8</span>)

<span class="ot">emphasis ::</span> <span class="dt">Css</span>
emphasis <span class="fu">=</span> <span class="kw">do</span> 
  fontWeight     bold
  color          black
  textTransform  uppercase

<span class="ot">container ::</span> <span class="dt">Selector</span>
container <span class="fu">=</span> div <span class="fu">#</span> <span class="st">&quot;.code&quot;</span>

<span class="ot">containerStyle ::</span> <span class="dt">Css</span>
containerStyle <span class="fu">=</span> container <span class="fu">?</span>
  <span class="kw">do</span> width (px <span class="dv">800</span>)
     borderColor gray

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> putCss <span class="fu">$</span> <span class="kw">do</span>
  bodyStyle
  codeStyle
  containerStyle</code></pre></div>
<p>The above will generate the following stylesheet:</p>
<div class="sourceCode"><pre class="sourceCode css"><code class="sourceCode css">body
<span class="kw">{</span>
  <span class="kw">background</span>  <span class="kw">:</span> <span class="dt">rgb(127</span>,<span class="dt">255</span>,<span class="dt">212)</span><span class="kw">;</span>
  <span class="kw">font-family</span> <span class="kw">:</span> <span class="st">&quot;Helvetica Neue&quot;</span>, <span class="dt">sans-serif</span><span class="kw">;</span>
<span class="kw">}</span>

code
<span class="kw">{</span>
  <span class="kw">font-family</span> <span class="kw">:</span> <span class="st">&quot;Monaco&quot;</span>,<span class="st">&quot;Inconsolata&quot;</span>, <span class="dt">monospace</span><span class="kw">;</span>
  <span class="kw">font-size</span>   <span class="kw">:</span> <span class="dt">14px</span><span class="kw">;</span>
  <span class="kw">line-height</span> <span class="kw">:</span> <span class="dt">1.80000ex</span><span class="kw">;</span>
<span class="kw">}</span>

div<span class="fl">.code</span>
<span class="kw">{</span>
  <span class="kw">width</span>        <span class="kw">:</span> <span class="dt">800px</span><span class="kw">;</span>
  <span class="kw">border-color</span> <span class="kw">:</span> <span class="dt">rgb(128</span>,<span class="dt">128</span>,<span class="dt">128)</span><span class="kw">;</span>
<span class="kw">}</span></code></pre></div>
<h4 id="blaze">Blaze</h4>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install blaze-html</code></pre></div>
<p>Blaze is the bread and butter of markup generation in Haskell. It is described as a “blazingly fast HTML combinator library” which programmtically generates HTML and several other markup languages from an embedded DSL.</p>
<p>In this module, the language extension <code>OverloadedStrings</code> is used so that the type inferencer can infer common coercions between String-like types without having to do explicit calls to boilerplate functions (<code>pack</code>, <code>unpack</code>, <code>html</code>) for each string-like literal. This will be pretty common use for all the examples from here out that use <code>ByteString</code> or HTML.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Data.Monoid</span>
<span class="kw">import </span><span class="dt">Text.Blaze</span> (<span class="dt">ToMarkup</span>(..))
<span class="kw">import </span><span class="dt">Text.Blaze.Html5</span> <span class="kw">hiding</span> (html, param)
<span class="kw">import </span><span class="dt">Text.Blaze.Html.Renderer.Text</span> (renderHtml)
<span class="kw">import qualified</span> <span class="dt">Text.Blaze.Html5</span> <span class="kw">as</span> <span class="dt">H</span>

<span class="ot">gen ::</span> <span class="dt">Html</span> <span class="ot">-&gt;</span> [<span class="dt">Html</span>] <span class="ot">-&gt;</span> <span class="dt">Html</span>
gen title elts  <span class="fu">=</span> H.html <span class="fu">$</span> <span class="kw">do</span>
  H.head <span class="fu">$</span>
    H.title title
  H.body <span class="fu">$</span>
    H.ul <span class="fu">$</span> mapM_ H.li elts

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  print <span class="fu">$</span> renderHtml <span class="fu">$</span> gen <span class="st">&quot;My Blog&quot;</span> [<span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;fizz&quot;</span>]</code></pre></div>
<p>This would output HTML like the following:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;html&gt;</span>
   <span class="kw">&lt;head&gt;</span>
      <span class="kw">&lt;title&gt;</span>My Blog<span class="kw">&lt;/title&gt;</span>
   <span class="kw">&lt;/head&gt;</span>
   <span class="kw">&lt;body&gt;</span>
      <span class="kw">&lt;ul&gt;</span>
          <span class="kw">&lt;li&gt;</span>foo<span class="kw">&lt;/li&gt;</span>
          <span class="kw">&lt;li&gt;</span>bar<span class="kw">&lt;/li&gt;</span>
          <span class="kw">&lt;li&gt;</span>fizz<span class="kw">&lt;/li&gt;</span>
      <span class="kw">&lt;/ul&gt;</span>
   <span class="kw">&lt;/body&gt;</span>
<span class="kw">&lt;/html&gt;</span></code></pre></div>
<p>In addition to generating HTML we can also derive from it’s internal ToMarkup classes to provide HTML representations for any datatype in Haskell. A silly example might be:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Example</span> <span class="fu">=</span> <span class="dt">A</span> <span class="fu">|</span> <span class="dt">B</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)
<span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Cons</span> a <span class="fu">|</span> <span class="dt">Nil</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">ToMarkup</span> <span class="dt">Animal</span> <span class="kw">where</span>
  toMarkup <span class="fu">=</span> toHtml <span class="fu">.</span> show

<span class="kw">instance</span> (<span class="dt">ToMarkup</span> a) <span class="ot">=&gt;</span> <span class="dt">ToMarkup</span> (<span class="dt">List</span> a) <span class="kw">where</span>
  toMarkup x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span>
      <span class="dt">Cons</span> a <span class="ot">-&gt;</span> H.ul <span class="fu">$</span> H.li <span class="fu">$</span> toHtml a
      <span class="dt">Nil</span> <span class="ot">-&gt;</span> <span class="st">&quot;&quot;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- Cons (Cons (Cons A)) --&gt;</span>
<span class="kw">&lt;ul&gt;</span>
   <span class="kw">&lt;li&gt;</span>
      <span class="kw">&lt;ul&gt;</span>
         <span class="kw">&lt;li&gt;</span>
            <span class="kw">&lt;ul&gt;</span>
               <span class="kw">&lt;li&gt;</span>A<span class="kw">&lt;/li&gt;</span>
            <span class="kw">&lt;/ul&gt;</span>
         <span class="kw">&lt;/li&gt;</span>
      <span class="kw">&lt;/ul&gt;</span>
   <span class="kw">&lt;/li&gt;</span>
<span class="kw">&lt;/ul&gt;</span></code></pre></div>
<p>It is worth noting that the Blaze builder overloads do-notation as some EDSLs do, but the <code>Html</code> type is not a monad. It is functionally a monoid.</p>
<p>For non-embedded template languages along the lines of <em>Jinja</em> or <em>erb</em> refer to the <a href="http://www.yesodweb.com/book/shakespearean-templates">Shakespearean templates</a> or <a href="http://hackage.haskell.org/package/happstack-heist">heist</a>.</p>
<h4 id="jmacro">JMacro</h4>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install jmacro</code></pre></div>
<p>JMacro is quasiquoter for Javascript code generation. The underlying implementation is rather clever and allows Haskell and Javascript to share functions and values across quotation boundaries. The end result is a fusion of Haskell and JavaScript that serves as a foundation to <a href="http://hackage.haskell.org/packages/archive/jmacro-rpc/0.2/doc/html/Network-JMacroRPC-Base.html">higher abstractions</a> and as a very convienant way to implement code generation for compilers targetting Javascript.</p>
<p>As an example of we’ll use JMacro to implement a simple translator for the untyped typed lambda calculus, something one might do if writing a language that transpiles to Javascript.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE QuasiQuotes, TypeSynonymInstances, FlexibleInstances, OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Data.String</span>
<span class="kw">import </span><span class="dt">Language.Javascript.JMacro</span>

<span class="ot">jref ::</span> <span class="dt">Sym</span> <span class="ot">-&gt;</span> <span class="dt">JExpr</span>
jref <span class="fu">=</span> <span class="dt">ValExpr</span> <span class="fu">.</span> <span class="dt">JVar</span> <span class="fu">.</span> <span class="dt">StrI</span>

<span class="ot">jvar ::</span> <span class="dt">Sym</span> <span class="ot">-&gt;</span> <span class="dt">JStat</span>
jvar sym <span class="fu">=</span> <span class="dt">DeclStat</span> (<span class="dt">StrI</span> sym) <span class="dt">Nothing</span>

jprint x <span class="fu">=</span> [jmacroE<span class="fu">|</span>console<span class="fu">.</span>log(x)<span class="fu">|</span>]

<span class="kw">instance</span> <span class="dt">IsString</span> <span class="dt">Expr</span> <span class="kw">where</span>
  fromString x <span class="fu">=</span> <span class="dt">Var</span> (<span class="dt">Sym</span> x)

<span class="kw">data</span> <span class="dt">Val</span> <span class="fu">=</span> <span class="dt">Sym</span> <span class="dt">Sym</span>
         <span class="fu">|</span> <span class="dt">Lit</span> <span class="dt">Lit</span>
         <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="kw">type</span> <span class="dt">Sym</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="kw">data</span> <span class="dt">Lit</span> <span class="fu">=</span> <span class="dt">LStr</span> <span class="dt">String</span>
         <span class="fu">|</span> <span class="dt">LInt</span> <span class="dt">Int</span>
         <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="kw">data</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
          <span class="fu">|</span> <span class="dt">Lam</span> <span class="dt">Sym</span> <span class="dt">Expr</span>
          <span class="fu">|</span> <span class="dt">Var</span> <span class="dt">Val</span>
          <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="co">-- Convert Haskell expressions to Javascript expressions</span>

<span class="kw">instance</span> <span class="dt">ToJExpr</span> <span class="dt">Val</span> <span class="kw">where</span>
  toJExpr (<span class="dt">Sym</span> s) <span class="fu">=</span> toJExpr s
  toJExpr (<span class="dt">Lit</span> l) <span class="fu">=</span> toJExpr l

<span class="kw">instance</span> <span class="dt">ToJExpr</span> <span class="dt">Lit</span> <span class="kw">where</span>
  toJExpr <span class="fu">=</span> toJExpr

<span class="kw">instance</span> <span class="dt">ToJExpr</span> <span class="dt">Sym</span> <span class="kw">where</span>
  toJExpr <span class="fu">=</span> jref

<span class="kw">instance</span> <span class="dt">ToJExpr</span> <span class="dt">Expr</span> <span class="kw">where</span>
  toJExpr (<span class="dt">Lam</span> s ex) <span class="fu">=</span> 
      [jmacroE<span class="fu">|</span> 
          function(arg) {
              <span class="ot">`(jvar s)`</span>;
              <span class="ot">`(jref s)`</span> <span class="fu">=</span> <span class="ot">`(arg)`</span>;
              return <span class="ot">`(ex)`</span>;
          }
      <span class="fu">|</span>]

  toJExpr (<span class="dt">App</span> f x) <span class="fu">=</span> 
      [jmacroE<span class="fu">|</span> <span class="ot">`(f)`</span>(<span class="ot">`(x)`</span>) <span class="fu">|</span>]

  toJExpr (<span class="dt">Var</span> v) <span class="fu">=</span>
      toJExpr v

<span class="ot">compile ::</span> <span class="dt">ToJExpr</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>
compile <span class="fu">=</span> show <span class="fu">.</span> renderJs <span class="fu">.</span> toJExpr

s, k, i0,<span class="ot"> i1 ::</span> <span class="dt">Expr</span>
s <span class="fu">=</span> <span class="dt">Lam</span> <span class="st">&quot;f&quot;</span> <span class="fu">$</span> <span class="dt">Lam</span> <span class="st">&quot;g&quot;</span> <span class="fu">$</span> <span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> <span class="fu">$</span> (<span class="dt">App</span> <span class="st">&quot;f&quot;</span> <span class="st">&quot;x&quot;</span>) <span class="ot">`App`</span> (<span class="dt">App</span> <span class="st">&quot;g&quot;</span> <span class="st">&quot;x&quot;</span>)
k <span class="fu">=</span> <span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> <span class="fu">$</span> <span class="dt">Lam</span> <span class="st">&quot;y&quot;</span> <span class="st">&quot;x&quot;</span>

i0 <span class="fu">=</span> <span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> <span class="st">&quot;x&quot;</span>
i1 <span class="fu">=</span> <span class="dt">App</span> (<span class="dt">App</span> s k) k

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  putStrLn <span class="fu">$</span> compile s
  putStrLn <span class="fu">$</span> compile k
  putStrLn <span class="fu">$</span> compile i0
  putStrLn <span class="fu">$</span> compile i1</code></pre></div>
<h4 id="fay">Fay</h4>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install fay</code></pre></div>
<p>Fay is a growing ecosystem of packages that can compile Haskell to Javascript. Fay works with a strict subset of Haskell that preserves Haskell semantics such as currying and laziness. In addition to the core language, ther are interfaces for <a href="https://github.com/faylang/fay-jquery">jquery</a> and <a href="https://github.com/faylang/fay-dom">DOM manipulation</a> so that Fay-compiled Haskell code can effectively access the browser internals.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install fay-dom fay-jquery</code></pre></div>
<p>The code generation is rather verbose given that it compiles quite a bit of the Haskell Prelude. The below example is very simple and only the interesting part of the outputted source is shown below. Notably the generated code is very readable.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- demo.hs</span>
<span class="kw">import </span><span class="dt">FFI</span>
<span class="kw">import </span><span class="dt">Prelude</span>
<span class="kw">import </span><span class="dt">JQuery</span>

<span class="ot">puts ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Fay</span> ()
puts <span class="fu">=</span> ffi <span class="st">&quot;console.log(%1)&quot;</span>

example <span class="fu">=</span> take <span class="dv">25</span> [<span class="dv">1</span><span class="fu">..</span>]

<span class="ot">main ::</span> <span class="dt">Fay</span> ()
main <span class="fu">=</span> ready <span class="fu">$</span> <span class="kw">do</span>
    el <span class="ot">&lt;-</span> select <span class="st">&quot;#mydiv&quot;</span>
    setCss <span class="st">&quot;background-color&quot;</span> <span class="st">&quot;red&quot;</span> el

    puts <span class="st">&quot;Hello World!&quot;</span>
    puts (show [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>])</code></pre></div>
<p>To compile invoke the compiler:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">fay</span> demo.hs --package fay-jquery</code></pre></div>
<p>Some of the generated code:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">
<span class="kw">var</span> Prelude$enumFrom <span class="op">=</span> <span class="kw">function</span> ($p1) <span class="op">{</span>
    <span class="cf">return</span> <span class="kw">new</span> <span class="at">Fay$$$</span>(<span class="kw">function</span> () <span class="op">{</span>
        <span class="kw">var</span> i <span class="op">=</span> $p1<span class="op">;</span>
        <span class="cf">return</span> <span class="at">Fay$$_</span>(<span class="at">Fay$$_</span>(
            Fay$$cons)(i))(<span class="at">Fay$$_</span>(
            Prelude$enumFrom)(
            <span class="at">Fay$$_</span>(<span class="at">Fay$$_</span>(
                Fay$$add)(i))(<span class="dv">1</span>)
        ))<span class="op">;</span>
    <span class="op">}</span>)<span class="op">;</span>
<span class="op">};</span>

<span class="kw">var</span> Main$example <span class="op">=</span> <span class="kw">new</span> <span class="at">Fay$$$</span>(
    <span class="kw">function</span> () <span class="op">{</span>
        <span class="cf">return</span> <span class="at">Fay$$_</span>(<span class="at">Fay$$_</span>(
            Prelude$take)(<span class="dv">25</span>))(
            <span class="at">Prelude$enumFrom</span>(<span class="dv">1</span>))<span class="op">;</span>
    <span class="op">}</span>)<span class="op">;</span></code></pre></div>
<p>To call this code from vanilla Javascript:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> main <span class="op">=</span> <span class="kw">new</span> <span class="at">Main</span>()<span class="op">;</span>
<span class="va">main</span>.<span class="at">_</span>(<span class="va">main</span>.<span class="at">Main$main</span>)<span class="op">;</span></code></pre></div>
<p>Fay is part of a larger community of compilers that transpile functional languages to Javascript. Another library of note is <a href="http://roy.brianmckenna.org/">Roy</a>. Although not Haskell, it has a sophisticated type system and notably an implementation of typeclasses, a feature that Fay currently does not implement.</p>
<h4 id="aeson">Aeson</h4>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install aeson</code></pre></div>
<p>Aeson is the de-facto JSON parsing and generation library for Haskell. It’s usage couldn’t be simpler, we simply declare instance of <code>toJSON</code> and <code>fromJSON</code> for our types and Aeson takes care of the mappings and exception handling. By using <code>DeriveGeneric</code> we can create instances with very little code.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings, DeriveGeneric #-}</span>

<span class="kw">import </span><span class="dt">Data.Aeson</span>

<span class="kw">import </span><span class="dt">GHC.Generics</span>
<span class="kw">import </span><span class="dt">Network.HTTP</span> 
<span class="kw">import </span><span class="dt">Control.Applicative</span>
<span class="kw">import </span><span class="dt">Data.ByteString</span> (<span class="dt">ByteString</span>)

<span class="kw">data</span> <span class="dt">Message</span> <span class="fu">=</span> <span class="dt">Message</span> { 
<span class="ot">      text ::</span> <span class="dt">ByteString</span>
    ,<span class="ot"> date ::</span> <span class="dt">ByteString</span>
    } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>)

<span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Message</span>
<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Message</span>

<span class="ot">fromStdin ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Message</span>)
fromStdin <span class="fu">=</span> eitherDecode <span class="fu">&lt;$&gt;</span> readLn</code></pre></div>
<h4 id="postgres-simple">postgres-simple</h4>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install postgres-simple</code></pre></div>
<p>Postgres-simple is a library for communicating with Postgres databases and mapping data between Haskell and SQL types. Although not an ORM, <code>postgres-simple</code> lets us generate and execute SQL queries and map result sets onto our algebraic datatypes very simply by deriving instances to declare schemas.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Data.Text</span>
<span class="kw">import </span><span class="dt">Control.Applicative</span>
<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Database.PostgreSQL.Simple</span>
<span class="kw">import </span><span class="dt">Database.PostgreSQL.Simple.FromRow</span>

<span class="kw">import qualified</span> <span class="dt">Data.ByteString</span> <span class="kw">as</span> <span class="dt">B</span>
<span class="kw">import qualified</span> <span class="dt">Database.PostgreSQL.Simple</span> <span class="kw">as</span> <span class="dt">Pg</span>

<span class="kw">data</span> <span class="dt">Client</span> <span class="fu">=</span> <span class="dt">Client</span> {<span class="ot"> firstName ::</span> <span class="dt">Text</span>
                     ,<span class="ot"> lastName ::</span> <span class="dt">Text</span>
                     ,<span class="ot"> clientLocation ::</span> <span class="dt">Location</span>
                     }

<span class="kw">data</span> <span class="dt">Location</span> <span class="fu">=</span> <span class="dt">Location</span> {<span class="ot"> address ::</span> <span class="dt">Text</span>
                         ,<span class="ot"> location ::</span> <span class="dt">Text</span>
                         }

<span class="kw">instance</span> <span class="dt">Pg.FromRow</span> <span class="dt">Location</span> <span class="kw">where</span>
  fromRow <span class="fu">=</span> <span class="dt">Location</span> <span class="fu">&lt;$&gt;</span> field <span class="fu">&lt;*&gt;</span> field

<span class="kw">instance</span> <span class="dt">Pg.FromRow</span> <span class="dt">Client</span> <span class="kw">where</span>
  fromRow <span class="fu">=</span> <span class="dt">Client</span> <span class="fu">&lt;$&gt;</span> field <span class="fu">&lt;*&gt;</span> field <span class="fu">&lt;*&gt;</span> liftM2 <span class="dt">Location</span> field field

<span class="ot">queryClients ::</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">Client</span>]
queryClients c <span class="fu">=</span> query_ c <span class="st">&quot;SELECT firstname, lastname, location FROM clients&quot;</span>

<span class="ot">main ::</span> <span class="dt">IO</span> [<span class="dt">Client</span>]
main <span class="fu">=</span> <span class="kw">do</span>
  uri <span class="ot">&lt;-</span> B.getLine
  conn <span class="ot">&lt;-</span> connectPostgreSQL uri
  queryClients conn</code></pre></div>
<h4 id="acid-state">Acid-State</h4>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install acid-state</code></pre></div>
<p>We can further exploit Haskell’s algebraic datatypes to give us a storage engine simply from the specification of our types and a little bit of <code>TemplateHaskell</code> usage. For instance, a simple <code>Map</code> container from <code>Data.Map</code> can be transformed to a disk-backed disk backed key-value store which can be interacted with as if it were a normal Haksell data structure.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Key</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">Value</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">data</span> <span class="dt">Database</span> <span class="fu">=</span> <span class="dt">Database</span> <span class="fu">!</span>(<span class="dt">Map.Map</span> <span class="dt">Key</span> <span class="dt">Value</span>)</code></pre></div>
<p>Like it’s name implies <code>acid-state</code> provides transactional guarantees for storage. Specifically that writes will be applied completely or not at all and that data will be consistent during reads.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings, TypeFamilies, DeriveDataTypeable, TemplateHaskell #-}</span>

<span class="kw">import </span><span class="dt">Data.Acid</span>
<span class="kw">import </span><span class="dt">Data.Typeable</span>
<span class="kw">import </span><span class="dt">Data.SafeCopy</span>
<span class="kw">import </span><span class="dt">Control.Monad.Reader</span> (ask)

<span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span>
<span class="kw">import qualified</span> <span class="dt">Control.Monad.State</span> <span class="kw">as</span> <span class="dt">S</span>

<span class="kw">type</span> <span class="dt">Key</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">Value</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="kw">data</span> <span class="dt">Database</span> <span class="fu">=</span> <span class="dt">Database</span> <span class="fu">!</span>(<span class="dt">Map.Map</span> <span class="dt">Key</span> <span class="dt">Value</span>)
    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Ord</span>, <span class="dt">Eq</span>, <span class="dt">Typeable</span>)

<span class="fu">$</span>(deriveSafeCopy <span class="dv">0</span> <span class="ch">&#39;base &#39;&#39;Database)</span>

<span class="ot">insertKey ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Update</span> <span class="dt">Database</span> ()
insertKey key value
    <span class="fu">=</span> <span class="kw">do</span> <span class="dt">Database</span> m <span class="ot">&lt;-</span> S.get
         S.put (<span class="dt">Database</span> (Map.insert key value m))

<span class="ot">lookupKey ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">Query</span> <span class="dt">Database</span> (<span class="dt">Maybe</span> <span class="dt">Value</span>)
lookupKey key
    <span class="fu">=</span> <span class="kw">do</span> <span class="dt">Database</span> m <span class="ot">&lt;-</span> ask
         return (Map.lookup key m)

<span class="ot">deleteKey ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">Update</span> <span class="dt">Database</span> ()
deleteKey key
    <span class="fu">=</span> <span class="kw">do</span> <span class="dt">Database</span> m <span class="ot">&lt;-</span> S.get
         S.put (<span class="dt">Database</span> (Map.delete key m))

<span class="ot">allKeys ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Query</span> <span class="dt">Database</span> [(<span class="dt">Key</span>, <span class="dt">Value</span>)]
allKeys limit
    <span class="fu">=</span> <span class="kw">do</span> <span class="dt">Database</span> m <span class="ot">&lt;-</span> ask
         return <span class="fu">$</span> take limit (Map.toList m)

<span class="fu">$</span>(makeAcidic <span class="ch">&#39;&#39;</span><span class="dt">Database</span> [<span class="ch">&#39;insertKey, &#39;</span>lookupKey, <span class="ch">&#39;allKeys, &#39;</span>deleteKey])

<span class="ot">fixtures ::</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">String</span>
fixtures <span class="fu">=</span> Map.empty

<span class="ot">test ::</span>  <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
test key val <span class="fu">=</span> <span class="kw">do</span>
    database <span class="ot">&lt;-</span> openLocalStateFrom <span class="st">&quot;db/&quot;</span> (<span class="dt">Database</span> fixtures)
    result <span class="ot">&lt;-</span> update database (<span class="dt">InsertKey</span> key val)
    result <span class="ot">&lt;-</span> query database (<span class="dt">AllKeys</span> <span class="dv">10</span>)
    print result</code></pre></div>
<h4 id="digestive-functors">Digestive Functors</h4>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install digestive-functors digestive-functors-blaze</code></pre></div>
<p>Digestive functors solve the very mundane but mechanical task of validating forms. The library provides a way to specify views and validation logic and handle the control flow of validation between the end-user and the server. There are several backends to render the form and handle request/response cycles depending on your choice of framework For arbitrary reasons we’ll choose Happstack for this example.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install digestive-functors-happstack</code></pre></div>
<p>We’ll build a simple signup page with username and email validation logic.</p>
<div class="figure">
<img src="/images/functorform.png" alt="" />

</div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Data.Maybe</span>
<span class="kw">import </span><span class="dt">Text.Printf</span>
<span class="kw">import </span><span class="dt">Control.Applicative</span>
<span class="kw">import </span><span class="dt">Data.Text</span> (<span class="dt">Text</span>, find, splitOn)

<span class="kw">import </span><span class="dt">Text.Digestive</span>
<span class="kw">import </span><span class="dt">Text.Digestive.Happstack</span>
<span class="kw">import </span><span class="dt">Text.Digestive.Blaze.Html5</span>
<span class="kw">import qualified</span> <span class="dt">Text.Blaze.Html5</span> <span class="kw">as</span> <span class="dt">H</span>

<span class="kw">import qualified</span> <span class="dt">Happstack.Server</span> <span class="kw">as</span> <span class="dt">HS</span>

<span class="kw">data</span> <span class="dt">User</span> <span class="fu">=</span> <span class="dt">User</span>
    {<span class="ot"> userName ::</span> <span class="dt">Text</span>
    ,<span class="ot"> userMail ::</span> <span class="dt">Text</span>
    } <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="ot">userForm ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Form</span> <span class="dt">Text</span> m <span class="dt">User</span>
userForm <span class="fu">=</span> <span class="dt">User</span>
  <span class="fu">&lt;$&gt;</span> <span class="st">&quot;name&quot;</span> <span class="fu">.:</span> check <span class="st">&quot;Name must be two words&quot;</span> checkName (text <span class="dt">Nothing</span>)
  <span class="fu">&lt;*&gt;</span> <span class="st">&quot;email&quot;</span> <span class="fu">.:</span> check <span class="st">&quot;Not a valid email address&quot;</span> checkEmail (text <span class="dt">Nothing</span>)

<span class="ot">checkEmail ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
checkEmail <span class="fu">=</span> isJust <span class="fu">.</span> find (<span class="fu">==</span> <span class="ch">&#39;@&#39;</span>)

<span class="ot">checkName ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
checkName s <span class="fu">=</span> length (splitOn <span class="st">&quot; &quot;</span> s) <span class="fu">==</span> <span class="dv">2</span>

<span class="ot">signupView ::</span> <span class="dt">View</span> <span class="dt">H.Html</span> <span class="ot">-&gt;</span> <span class="dt">H.Html</span>
signupView view <span class="fu">=</span> form view <span class="st">&quot;/&quot;</span> <span class="fu">$</span> <span class="kw">do</span>

    label     <span class="st">&quot;name&quot;</span> view <span class="st">&quot;Full Name:&quot;</span>
    inputText <span class="st">&quot;name&quot;</span> view
    H.br

    label     <span class="st">&quot;email&quot;</span> view <span class="st">&quot;Email:&quot;</span>
    inputText <span class="st">&quot;email&quot;</span> view
    H.br

    childErrorList <span class="st">&quot;&quot;</span> view

    inputSubmit <span class="st">&quot;Signup&quot;</span>

<span class="ot">template ::</span> <span class="dt">H.Html</span> <span class="ot">-&gt;</span> <span class="dt">H.Html</span>
template body <span class="fu">=</span> H.docTypeHtml <span class="fu">$</span> <span class="kw">do</span>
    H.head <span class="fu">$</span> H.title <span class="st">&quot;Example form:&quot;</span>
    H.body body

reply m <span class="fu">=</span> HS.ok <span class="fu">$</span> HS.toResponse <span class="fu">$</span> template m

<span class="ot">page ::</span> <span class="dt">HS.ServerPart</span> <span class="dt">HS.Response</span>
page <span class="fu">=</span> <span class="kw">do</span>
  HS.decodeBody <span class="fu">$</span> HS.defaultBodyPolicy <span class="st">&quot;/tmp/&quot;</span> <span class="dv">0</span> <span class="dv">40960</span> <span class="dv">40960</span>
  r <span class="ot">&lt;-</span> runForm <span class="st">&quot;test&quot;</span> userForm
  <span class="kw">case</span> r <span class="kw">of</span>

      (view, <span class="dt">Nothing</span>) <span class="ot">-&gt;</span> <span class="kw">do</span>
          <span class="kw">let</span> view&#39; <span class="fu">=</span> fmap H.toHtml view
          reply <span class="fu">$</span> form view&#39; <span class="st">&quot;/&quot;</span> (signupView view&#39;)

      (_, <span class="dt">Just</span> response) <span class="ot">-&gt;</span>
          reply <span class="fu">$</span> <span class="kw">do</span>
            H.h1 <span class="st">&quot;Form is valid.&quot;</span>
            H.p <span class="fu">$</span> H.toHtml <span class="fu">$</span> show response

<span class="ot">config ::</span> <span class="dt">HS.Conf</span>
config <span class="fu">=</span> HS.nullConf { HS.port <span class="fu">=</span> <span class="dv">5000</span> }

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  printf <span class="st">&quot;Listening on port %d\n&quot;</span> (HS.port config)
  HS.simpleHTTP config page</code></pre></div>
<h4 id="servers">Servers</h4>
<p>A great deal of effort has been put into making the <a href="http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/pubs/archive/36841.pdf">Haskell runtime</a> implement efficient event driven programming such that applications can take advantage of the Haskell threading support.</p>
<p>A simple single-threaded Hello World might be written like the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Network</span>
<span class="kw">import </span><span class="dt">Data.ByteString.Char8</span>
<span class="kw">import </span><span class="dt">System.IO</span> (hClose, hSetBuffering, <span class="dt">Handle</span>, <span class="dt">BufferMode</span>(<span class="dt">LineBuffering</span>))

msg <span class="fu">=</span> <span class="st">&quot;HTTP/1.0 200 OK\r\nContent-Length: 12\r\n\r\nHello World!\r\n&quot;</span>
 
<span class="ot">handleClient ::</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
handleClient handle <span class="fu">=</span> <span class="kw">do</span>
  hSetBuffering handle <span class="dt">LineBuffering</span>
  hGetLine handle
  hPutStrLn handle msg
  hClose handle

<span class="ot">listenLoop ::</span> <span class="dt">Socket</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
listenLoop asock <span class="fu">=</span> <span class="kw">do</span>
  (handle, _, _) <span class="ot">&lt;-</span> accept asock
  handleClient handle
  listenLoop asock
 
<span class="ot">main ::</span>  <span class="dt">IO</span> ()
main <span class="fu">=</span> withSocketsDo <span class="fu">$</span> <span class="kw">do</span>
  sock <span class="ot">&lt;-</span> listenOn <span class="fu">$</span> <span class="dt">PortNumber</span> <span class="dv">5000</span>
  listenLoop sock</code></pre></div>
<p>To make this concurrent we use the function <code>forkIO</code> which utilizes the event-driven IO manager in GHC’s runtime system to spawn lightweight user threads which are distributed across multiple system threads. When compiled with <code>-threaded</code> the Haskell standard library also will use non-blocking system calls which are scheduled by the IO manager ( with <code>epoll()</code> under the hood ) and can transparently switch to threaded scheduling for other blocking operations.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Network</span>
<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Control.Concurrent</span>
<span class="kw">import </span><span class="dt">Data.ByteString.Char8</span>
<span class="kw">import </span><span class="dt">GHC.Conc</span> (numCapabilities)
<span class="kw">import </span><span class="dt">System.IO</span> (hClose, hSetBuffering, <span class="dt">Handle</span>, <span class="dt">BufferMode</span>(<span class="dt">LineBuffering</span>))

numCores <span class="fu">=</span> numCapabilities <span class="fu">-</span> <span class="dv">1</span>

msg <span class="fu">=</span> <span class="st">&quot;HTTP/1.0 200 OK\r\nContent-Length: 12\r\n\r\nHello World!\r\n&quot;</span>
 
<span class="ot">handleClient ::</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
handleClient handle <span class="fu">=</span> <span class="kw">do</span>
  hSetBuffering handle <span class="dt">LineBuffering</span>
  hGetLine handle
  hPutStrLn handle msg
  hClose handle

<span class="ot">listenLoop ::</span> <span class="dt">Socket</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
listenLoop asock <span class="fu">=</span> <span class="kw">do</span>
  (handle, _, _) <span class="ot">&lt;-</span> accept asock
  forkIO (handleClient handle)
  listenLoop asock
 
<span class="ot">main ::</span>  <span class="dt">IO</span> ()
main <span class="fu">=</span> withSocketsDo <span class="fu">$</span> <span class="kw">do</span>
  sock <span class="ot">&lt;-</span> listenOn <span class="fu">$</span> <span class="dt">PortNumber</span> <span class="dv">5000</span>
  forM_ [<span class="dv">0</span><span class="fu">..</span>numCores] <span class="fu">$</span> \n <span class="ot">-&gt;</span>
    forkOn n (listenLoop sock)
  threadDelay maxBound</code></pre></div>
<p>This example is admittedly very simple but does illustrate that we can switch from serial to concurrent code in Haskell while still preserving sequential logic. Notably this server isn’t really doing anything terribly clever to get performance, it’s simply just spawning threads and all the heavy lifting is handled by the RTS. Yet with only a three line change the server can utilize all available cores.</p>
<p>Compiling with <code>-O2</code> and running with <code>+RTS -N4 -qm -qa</code> I get the following numbers on my Intel Core i5:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">Requests</span> per second:    12446.25 [#/sec] (mean)</code></pre></div>
<p>There are other Haskell servers which do <a href="http://www.yesodweb.com/blog/2012/11/warp-posa">much more clever things</a> such as the Warp server.</p>
<h4 id="websockets">Websockets</h4>
<p>The Warp server can utilize the async event notification system to implement asynchronous applications using <code>Control.Concurrent</code> primitives. The prime example is so called “realtime web programming” using websockets. In this example we’ll implement a chat room with a mutable MVar which synchronizes messages across all threads in the server and broadcasts messages to the clients.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install wai-websockets</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Text.Printf</span>
<span class="kw">import </span><span class="dt">Data.Text</span> (<span class="dt">Text</span>)
<span class="kw">import </span><span class="dt">Control.Concurrent</span>
<span class="kw">import </span><span class="dt">Control.Monad.IO.Class</span> (liftIO)

<span class="kw">import </span><span class="dt">Data.Aeson</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text.IO</span> <span class="kw">as</span> <span class="dt">T</span>

<span class="kw">import qualified</span> <span class="dt">Network.Wai</span>
<span class="kw">import qualified</span> <span class="dt">Network.WebSockets</span> <span class="kw">as</span> <span class="dt">WS</span>
<span class="kw">import qualified</span> <span class="dt">Network.Wai.Handler.Warp</span> <span class="kw">as</span> <span class="dt">Warp</span>
<span class="kw">import qualified</span> <span class="dt">Network.Wai.Handler.WebSockets</span> <span class="kw">as</span> <span class="dt">WaiWS</span>
<span class="kw">import </span><span class="dt">Network.Wai.Application.Static</span> (defaultFileServerSettings, staticApp)

<span class="kw">type</span> <span class="dt">Msg</span> <span class="fu">=</span> <span class="dt">Text</span>
<span class="kw">type</span> <span class="dt">Room</span> <span class="fu">=</span> [<span class="dt">Client</span>]
<span class="kw">type</span> <span class="dt">Client</span> <span class="fu">=</span> (<span class="dt">Text</span>, <span class="dt">WS.Sink</span> <span class="dt">WS.Hybi00</span>)

<span class="ot">broadcast ::</span> <span class="dt">Msg</span> <span class="ot">-&gt;</span> <span class="dt">Room</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
broadcast message clients <span class="fu">=</span> <span class="kw">do</span>
  T.putStrLn message
  forM_ clients <span class="fu">$</span> \(_, sock) <span class="ot">-&gt;</span> WS.sendSink sock <span class="fu">$</span> WS.textData message

<span class="ot">app ::</span> <span class="dt">MVar</span> <span class="dt">Room</span> <span class="ot">-&gt;</span> <span class="dt">WS.Request</span> <span class="ot">-&gt;</span> <span class="dt">WS.WebSockets</span> <span class="dt">WS.Hybi00</span> ()
app state req <span class="fu">=</span> <span class="kw">do</span>
  WS.acceptRequest req
  sock <span class="ot">&lt;-</span> WS.getSink
  msg <span class="ot">&lt;-</span> WS.receiveData
  userHandler msg sock

  <span class="kw">where</span>
    userHandler msg sock <span class="fu">=</span> <span class="kw">do</span>
      <span class="kw">let</span> client <span class="fu">=</span> (msg, sock)
      liftIO <span class="fu">$</span> T.putStrLn msg
      liftIO <span class="fu">$</span> modifyMVar_ state <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">do</span>
          <span class="kw">let</span> s&#39; <span class="fu">=</span> client <span class="fu">:</span> s
          WS.sendSink sock <span class="fu">$</span> WS.textData <span class="fu">$</span>
              encode <span class="fu">$</span> map fst s
          return s&#39;
      userLoop state client

<span class="ot">userLoop ::</span> <span class="dt">WS.Protocol</span> p <span class="ot">=&gt;</span> <span class="dt">MVar</span> <span class="dt">Room</span> <span class="ot">-&gt;</span> <span class="dt">Client</span> <span class="ot">-&gt;</span> <span class="dt">WS.WebSockets</span> p ()
userLoop state client <span class="fu">=</span> forever <span class="fu">$</span> <span class="kw">do</span>
  msg <span class="ot">&lt;-</span> WS.receiveData
  liftIO <span class="fu">$</span> readMVar state <span class="fu">&gt;&gt;=</span> broadcast (T.concat [fst client, <span class="st">&quot; : &quot;</span>, msg])

<span class="ot">staticContent ::</span> <span class="dt">Network.Wai.Application</span>
staticContent <span class="fu">=</span> staticApp <span class="fu">$</span> defaultFileServerSettings <span class="st">&quot;.&quot;</span>

<span class="ot">config ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">MVar</span> <span class="dt">Room</span> <span class="ot">-&gt;</span> <span class="dt">Warp.Settings</span>
config port state <span class="fu">=</span> Warp.defaultSettings
    { Warp.settingsPort <span class="fu">=</span> port
    , Warp.settingsIntercept <span class="fu">=</span> WaiWS.intercept (app state)
    }

<span class="ot">port ::</span> <span class="dt">Int</span>
port <span class="fu">=</span> <span class="dv">5000</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  state <span class="ot">&lt;-</span> newMVar []
  printf <span class="st">&quot;Starting server on port %d\n&quot;</span> port
  Warp.runSettings (config <span class="dv">5000</span> state) staticContent</code></pre></div>
<p>In the browser we can connet to our server using Javascript:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">ws <span class="op">=</span> <span class="kw">new</span> <span class="at">WebSocket</span>(<span class="st">&#39;ws://localhost:5000&#39;</span>)

<span class="va">ws</span>.<span class="at">onmessage</span>(<span class="kw">function</span>(msg)<span class="op">{</span><span class="va">console</span>.<span class="at">log</span>(msg)<span class="op">}</span>)<span class="op">;</span>
<span class="va">ws</span>.<span class="at">send</span>(<span class="st">&#39;User271828&#39;</span>)
<span class="va">ws</span>.<span class="at">send</span>(<span class="st">&#39;My message!&#39;</span>)</code></pre></div>
<h4 id="cloud-haskell">Cloud Haskell</h4>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install distributed-process distributed-process-simplelocalnet</code></pre></div>
<p>One of the most exciting projects in Haskell is a collections of projects developed under the <a href="http://haskell-distributed.github.io/">Cloud Haskell</a> metaproject. Cloud haskell brings language integrated messaging passing capability to Haskell under a very simple API which provides a foundation to build all sorts of distributed computations on top of simple actor primitives.</p>
<p>The core mechanism of action is a <code>Process</code> monad which encapsulates a actor-like computation that can exchange messages across an abstract network backend. On top of this the <code>distributed-process</code> library provides the language-integrated ability to send arbitrary Haskell functions back and forth between processes much like one can move code in Erlang, but while still persiving Haskell type-safety across the message layer. The signatures for the messaging functions are:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">send ::</span> <span class="dt">Serializable</span> a <span class="ot">=&gt;</span> <span class="dt">ProcessId</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Process</span> ()
<span class="ot">expect ::</span> forall a<span class="fu">.</span> <span class="dt">Serializable</span> a <span class="ot">=&gt;</span> <span class="dt">Process</span> a</code></pre></div>
<p>The network backend is an abstract protocol that specific libraries ( i.e. <code>distributed-process-simplelocalnet</code>) can implement to provide the transport layer indepenent of the rest of the stack. Many other protocols like TCP, IPC, and ZeroMQ can be used for the network transport.</p>
<p>The simplest possible example is a simple ping and pong between between several <code>Process</code>. Notably we don’t encode any mechanism for binary serialization of code or data since Haskell can derive these for us.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TemplateHaskell, DeriveDataTypeable, DeriveGeneric, GeneralizedNewtypeDeriving #-}</span>

<span class="kw">import </span><span class="dt">Text.Printf</span>
<span class="kw">import </span><span class="dt">Data.Binary</span>
<span class="kw">import </span><span class="dt">Data.Typeable</span>
<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">System.Environment</span> (getArgs)
<span class="kw">import </span><span class="dt">Control.Concurrent</span> (threadDelay)

<span class="kw">import </span><span class="dt">Control.Distributed.Process</span>
<span class="kw">import </span><span class="dt">Control.Distributed.Process.Closure</span>
<span class="kw">import </span><span class="dt">Control.Distributed.Process.Backend.SimpleLocalnet</span>
<span class="kw">import </span><span class="dt">Control.Distributed.Process.Node</span> (initRemoteTable,)

<span class="kw">newtype</span> <span class="dt">Message</span> <span class="fu">=</span> <span class="dt">Ping</span> <span class="dt">ProcessId</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Binary</span>, <span class="dt">Typeable</span>)

<span class="ot">pingLoop ::</span> <span class="dt">Process</span> ()
pingLoop <span class="fu">=</span> <span class="kw">do</span>
  liftIO <span class="fu">$</span> putStrLn <span class="st">&quot;Connected with master node.&quot;</span>
  forever <span class="fu">$</span> <span class="kw">do</span>
    (<span class="dt">Ping</span> remote_pid) <span class="ot">&lt;-</span> expect
    say <span class="fu">$</span> printf <span class="st">&quot;Ping from %s&quot;</span> (show remote_pid)

    local_pid <span class="ot">&lt;-</span> getSelfPid
    send remote_pid (<span class="dt">Ping</span> local_pid)

    liftIO <span class="fu">$</span> putStrLn <span class="st">&quot;Pong!&quot;</span>

remotable [ <span class="ch">&#39;pingLoop ]</span>

<span class="ot">master ::</span> [<span class="dt">NodeId</span>] <span class="ot">-&gt;</span> <span class="dt">Process</span> ()
master peers <span class="fu">=</span> <span class="kw">do</span>
  pids <span class="ot">&lt;-</span> forM peers <span class="fu">$</span> \nid <span class="ot">-&gt;</span> <span class="kw">do</span>
      say <span class="fu">$</span> printf <span class="st">&quot;Executing remote function on %s&quot;</span> (show nid)
      spawn nid <span class="fu">$</span>(mkStaticClosure <span class="ch">&#39;pingLoop)</span>

  local_pid <span class="ot">&lt;-</span> getSelfPid

  forever <span class="fu">$</span> <span class="kw">do</span>
    forM_ pids <span class="fu">$</span> \pid <span class="ot">-&gt;</span> <span class="kw">do</span>
      say <span class="fu">$</span> printf <span class="st">&quot;Pinging remote node %s&quot;</span> (show pid)
      send pid (<span class="dt">Ping</span> local_pid)

    forM_ pids <span class="fu">$</span> \_ <span class="ot">-&gt;</span> <span class="kw">do</span>
      (<span class="dt">Ping</span> pid) <span class="ot">&lt;-</span> expect
      say <span class="fu">$</span> printf <span class="st">&quot;Received pong from %s&quot;</span>  (show pid)

    liftIO <span class="fu">$</span> threadDelay <span class="dv">1000000</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  args <span class="ot">&lt;-</span> getArgs

  <span class="kw">let</span> host <span class="fu">=</span> <span class="st">&quot;localhost&quot;</span>
  <span class="kw">let</span> rtable <span class="fu">=</span> <span class="dt">Main</span><span class="fu">.</span>__remoteTable initRemoteTable

  <span class="kw">case</span> args <span class="kw">of</span>
    [<span class="st">&quot;master&quot;</span>, port] <span class="ot">-&gt;</span> <span class="kw">do</span>
      printf <span class="st">&quot;Starting master on %s:%s\n&quot;</span> host port
      ctx <span class="ot">&lt;-</span> initializeBackend host port rtable
      startMaster ctx master

    [<span class="st">&quot;worker&quot;</span>, port] <span class="ot">-&gt;</span> <span class="kw">do</span>
      printf <span class="st">&quot;Starting client on %s:%s\n&quot;</span> host port

      ctx <span class="ot">&lt;-</span> initializeBackend host port rtable
      startSlave ctx 

    otherwise <span class="ot">-&gt;</span> error <span class="st">&quot;Invalid arguments: master|worker &lt;port&gt;&quot;</span></code></pre></div>
<p>We can then spawn any number of instances from the shell:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">runhaskell</span> cloud.hs worker 5001
$ <span class="kw">runhaskell</span> cloud.hs worker 5002
$ <span class="kw">runhaskell</span> cloud.hs master 5003</code></pre></div>
<h4 id="conclusion">Conclusion</h4>
<p>Hopefully you feel for what exists in the ecosystem and feel slightly more empowered to use the amazing tools we have.</p>]]></summary>
</entry>
<entry>
    <title>Monads Made Difficult</title>
    <link href="http://www.stephendiehl.com/posts/monads.html" />
    <id>http://www.stephendiehl.com/posts/monads.html</id>
    <published>2013-07-07T00:00:00Z</published>
    <updated>2013-07-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="monads-made-difficult">Monads Made Difficult</h3>
<p><em style="color:green"> Caveat: This is not a monad tutorial, you should not read this to understand monads initially. If you aren’t already comfortable with monads and have used them in production code, please don’t read this. It will not impart any intution. </em></p>
<hr/>
<p>This is a short, fast and analogy-free introduction to Haskell monads derived from a categorical perspective. This assumes you are familiar with Haskell and basic category theory.</p>
<h5 id="categories">Categories</h5>
<hr />
<p>We have a abstract <strong>category</strong> <span class="math inline">\(\mathcal{C}\)</span> which consists of objects and morphisms.</p>
<ul>
<li>Objects : <span class="math inline">\(●\)</span></li>
<li>Morphisms : <span class="math inline">\(● \rightarrow ●\)</span></li>
</ul>
<p>For each object there is an identity morphism <code>id</code> and a composition rule <span class="math inline">\((\circ)\)</span> for combining morphisms associatively. We can model this with the following type class in Haskell with kind polymorphism.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Morphisms</span>
<span class="kw">type</span> (a <span class="fu">~&gt;</span> b) c <span class="fu">=</span> c a b

<span class="kw">class</span> <span class="dt">Category</span> (<span class="ot">c ::</span> k <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="kw">where</span>
<span class="ot">  id ::</span> (a <span class="fu">~&gt;</span> a) c
<span class="ot">  (.) ::</span> (y <span class="fu">~&gt;</span> z) c <span class="ot">-&gt;</span> (x <span class="fu">~&gt;</span> y) c <span class="ot">-&gt;</span> (x <span class="fu">~&gt;</span> z) c</code></pre></div>
<p>In Haskell we call this category <em>Hask</em>, over the type constructor <code>(-&gt;)</code> of function types between Haskell types.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Hask</span> <span class="fu">=</span> (<span class="ot">-&gt;</span>)
 
<span class="kw">instance</span> <span class="dt">Category</span> <span class="dt">Hask</span> <span class="kw">where</span>
  id x <span class="fu">=</span> x
  (f <span class="fu">.</span> g) x <span class="fu">=</span> f (g x)</code></pre></div>
<p>The constructor <code>(-&gt;)</code> is sometimes confusing to read in typeclass signatures as a typelevel operator since it’s first argument usually appears to the left of it in infix form and the second to the right. For example the following are equivalent.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="ot">-&gt;</span>) ((<span class="ot">-&gt;</span>) a b) ((<span class="ot">-&gt;</span>) a c)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> c)</code></pre></div>
<h5 id="functors">Functors</h5>
<hr />
<p>Between two categories we can construct a <strong>functor</strong> denoted <span class="math inline">\(T\)</span>, which maps between objects and morphisms of categories that preserves morphism composition and identities.</p>
<ul>
<li>Objects : <span class="math inline">\(T(●)\)</span></li>
<li>Morphisms : <span class="math inline">\(T (● \rightarrow ●)\)</span></li>
</ul>
<p>Represented in Haskell by:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Category</span> c, <span class="dt">Category</span> d) <span class="ot">=&gt;</span> <span class="dt">Functor</span> c d t <span class="kw">where</span>
<span class="ot">  fmap ::</span> c a b <span class="ot">-&gt;</span> d (t a) (t b)</code></pre></div>
<p>With the familiar functors laws:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap id ≡ id
fmap (a <span class="fu">.</span> b) ≡ (fmap a) <span class="fu">.</span> (fmap b)</code></pre></div>
<p>The identity functor <span class="math inline">\(1_\mathcal{C}\)</span> for a category <span class="math inline">\(\mathcal{C}\)</span> is a functor mapping all objects to themselves and all morphisms to themselves.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Id</span> a <span class="fu">=</span> <span class="dt">Id</span> a

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Hask</span> <span class="dt">Hask</span> <span class="dt">Id</span> <span class="kw">where</span>
  fmap f (<span class="dt">Id</span> a) <span class="fu">=</span> <span class="dt">Id</span> (f a)

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Hask</span> <span class="dt">Hask</span> [] <span class="kw">where</span>
  fmap f [] <span class="fu">=</span> []
  fmap f (x<span class="fu">:</span>xs) <span class="fu">=</span> f x <span class="fu">:</span> (fmap f xs)

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Hask</span> <span class="dt">Hask</span> <span class="dt">Maybe</span> <span class="kw">where</span>
  fmap f <span class="dt">Nothing</span> <span class="fu">=</span> <span class="dt">Nothing</span>
  fmap f (<span class="dt">Just</span> x) <span class="fu">=</span> <span class="dt">Just</span> (f x)</code></pre></div>
<p>An <strong>endofunctor</strong> is a functor from a category to itself, i.e. (<span class="math inline">\(T : \mathcal{C} \to \mathcal{C}\)</span>).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Endofunctor</span> c t <span class="fu">=</span> <span class="dt">Functor</span> c c t</code></pre></div>
<p>The composition of two functors is itself a functor as well. Convincing Haskell of this fact requires some trickery with constraint kinds and scoped type variables.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">FComp</span> g f x <span class="fu">=</span> <span class="dt">C</span> {<span class="ot"> unC ::</span> g (f x) }
<span class="kw">newtype</span> <span class="dt">Hom</span> (<span class="ot">c ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span>) a b <span class="fu">=</span> <span class="dt">Hom</span> (a <span class="ot">-&gt;</span> b)

<span class="kw">instance</span> (<span class="dt">Functor</span> a b f, <span class="dt">Functor</span> b c g, c <span class="fu">~</span> <span class="dt">Hom</span> k) <span class="ot">=&gt;</span> <span class="dt">Functor</span> a c (<span class="dt">FComp</span> g f) <span class="kw">where</span>
  fmap f <span class="fu">=</span> (<span class="dt">Hom</span> <span class="dt">C</span>) <span class="fu">.</span> (fmapg (fmapf f) <span class="fu">.</span> (<span class="dt">Hom</span> unC))
    <span class="kw">where</span>
      fmapf <span class="fu">=</span><span class="ot"> fmap ::</span> a x y <span class="ot">-&gt;</span> b (f x) (f y)
      fmapg <span class="fu">=</span><span class="ot"> fmap ::</span> b s t <span class="ot">-&gt;</span> c (g s) (g t)</code></pre></div>
<p>The repeated composition of an endofunctor over a category is written with exponential notation:</p>
<p><span class="math display">\[
\begin{align*}
T^2 &amp;= T T : \mathcal{C} \rightarrow \mathcal{C} \\
T^3 &amp;= T T T: \mathcal{C} \rightarrow \mathcal{C}
\end{align*}
\]</span></p>
<p>The category of small categories <span class="math inline">\(\textbf{Cat}\)</span> is a category with categories as objects and functors as morphisms between categories.</p>
<h5 id="natural-transformations">Natural Transformations</h5>
<hr />
<p>For two functors <span class="math inline">\(F,G\)</span> between two categories <span class="math inline">\(\mathcal{A,B}\)</span>:</p>
<p><span class="math display">\[
F : \mathcal{A} \rightarrow \mathcal{B} \\
G : \mathcal{A} \rightarrow \mathcal{B}
\]</span></p>
<p>We can construct a mapping called a <strong>natural transformation</strong> <span class="math inline">\(\eta\)</span> which is a mapping between functors <span class="math inline">\(\eta : F \rightarrow G\)</span> that associates every object <span class="math inline">\(X\)</span> in <span class="math inline">\(\mathcal{A}\)</span> to a morphism in <span class="math inline">\(\mathcal{B}\)</span>:</p>
<p><span class="math display">\[
\eta_X : F(X) \rightarrow G(X)
\]</span></p>
<p>Such that the following <em>naturality condition</em> holds for any morphism <span class="math inline">\(f : X \rightarrow Y\)</span>. Shown as a <em>naturality square</em>:</p>
<p><span class="math display">\[
\eta_Y \circ F(f) = G(f) \circ \eta_X
\]</span></p>
<p>
<img src="/images/naturality.svg" width="200px"/>
</p>
<p>The natural transformation itself is shown diagrammatically between two functors as:</p>
<p>
<img src="/images/nat.svg" width="150px"/>
</p>
<p>This is expressible in our general category class as the following existential type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Nat</span> c f g <span class="fu">=</span> forall a<span class="fu">.</span> c (f a) (g a)</code></pre></div>
<p>In the case of <em>Hask</em> we a family of polymorphic functions with signature:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">NatHask</span> f g <span class="fu">=</span> forall a<span class="fu">.</span> (f a) <span class="ot">-&gt;</span> (g a)</code></pre></div>
<p>With the naturality condition as the following law for a natural transformation (<code>h</code>), which happens to be a free theorem in Haskell’s type system.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap f <span class="fu">.</span> h ≡ h <span class="fu">.</span> fmap f </code></pre></div>
<p>The canonical example is the natural transformation between the List functor and the Maybe functor ( where f = <code>List</code>, g = <code>Maybe</code> ).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">headMay ::</span> forall a<span class="fu">.</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
headMay []     <span class="fu">=</span> <span class="dt">Nothing</span>
headMay (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Just</span> x</code></pre></div>
<p>Either way we chase the diagram we end up at the same place.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap f (headMay xs) ≡ headMay (fmap f xs)</code></pre></div>
<p>Run through each of the cases of the naturality square for <code>headMay</code> if you need to convince yourself of this.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap f (headMay [])
<span class="fu">=</span> fmap f <span class="dt">Nothing</span>
<span class="fu">=</span> <span class="dt">Nothing</span>

headMay (fmap f [])
<span class="fu">=</span> headMay []
<span class="fu">=</span> <span class="dt">Nothing</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap f (headMay (x<span class="fu">:</span>xs))
<span class="fu">=</span> fmap f (<span class="dt">Just</span> x)
<span class="fu">=</span> <span class="dt">Just</span> (f x)

headMay (fmap f (x<span class="fu">:</span>xs))
<span class="fu">=</span> headMay [f x]
<span class="fu">=</span> <span class="dt">Just</span> (f x)</code></pre></div>
<h5 id="functor-categories">Functor Categories</h5>
<hr />
<p>A natural transformation <span class="math inline">\(\eta : C \rightarrow D\)</span> is itself a morphism in the <strong>functor category</strong> <span class="math inline">\(\textbf{Fun}(\mathcal{C}, \mathcal{D})\)</span> of functors between <span class="math inline">\(\mathcal{C}\)</span> and <span class="math inline">\(\mathcal{D}\)</span>. The category <span class="math inline">\(\textbf{End}\)</span> is the category of endofunctors between a category and itself.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Functor category</span>
<span class="kw">newtype</span> <span class="dt">Fun</span> f g a b <span class="fu">=</span> <span class="dt">FNat</span> (f a <span class="ot">-&gt;</span> g b)

<span class="co">-- Endofunctor category</span>
<span class="kw">type</span> <span class="dt">End</span> f <span class="fu">=</span> <span class="dt">Fun</span> f f

<span class="kw">instance</span> <span class="dt">Category</span> (<span class="dt">End</span> f) <span class="kw">where</span>
  id <span class="fu">=</span> <span class="dt">FNat</span> id
  (<span class="dt">FNat</span> f) <span class="fu">.</span> (<span class="dt">FNat</span> g) <span class="fu">=</span> <span class="dt">FNat</span> (f <span class="fu">.</span> g)</code></pre></div>
<h5 id="monads">Monads</h5>
<hr />
<p>We can finally define a <em>monad</em> over a category <span class="math inline">\(\mathcal{C}\)</span> to be a triple <span class="math inline">\((T, \eta, \mu)\)</span> of:</p>
<ol style="list-style-type: decimal">
<li>An endofunctor <span class="math inline">\(T: \mathcal{C} \rightarrow \mathcal{C}\)</span></li>
<li>A natural transformation <span class="math inline">\(\eta : 1_\mathcal{C} \rightarrow T\)</span></li>
<li>A natural transformation <span class="math inline">\(\mu : T^2 \rightarrow T\)</span></li>
</ol>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Endofunctor</span> c t <span class="ot">=&gt;</span> <span class="dt">Monad</span> c t <span class="kw">where</span>
<span class="ot">  eta ::</span> c a (t a)
<span class="ot">  mu  ::</span> c (t (t a)) (t a)</code></pre></div>
<p>With an associativity square:</p>
<p><span class="math display">\[
\mu \circ T \mu = \mu \circ \mu T \\
\]</span></p>
<p>
<img src="/images/coherence1.svg" width="150x"/>
</p>
<p>And a triangle equality:</p>
<p><span class="math display">\[
\mu \circ T \eta = \mu \circ \eta T = 1_C \\
\]</span></p>
<p>
<img src="/images/coherence2.svg" width="200px"/>
</p>
<p>Alternatively we can express our triple as a series of <strong>string diagrams</strong> in which we invert the traditional commutative diagram of lines as morphism and objects as points and morphisms as points and objects as lines. In this form the monad laws have a nice geometric symmetry.</p>
<p>
<img src="/images/string3.svg"/>
</p>
<p>With the coherence conditions given diagrammatically:</p>
<p>
<img src="/images/string1.svg"/>
</p>
<p>
<img src="/images/string2.svg"/>
</p>
<h5 id="bindreturn-formulation">Bind/Return Formulation</h5>
<hr />
<p>There is an equivalent formulations of monads in terms of two functions (<code>(&gt;&gt;=), return</code>) which can be written in terms of <code>mu, eta</code>)</p>
<p>In Haskell we define a bind <code>(&gt;&gt;=)</code> operator defined in terms of the natural transformations and <code>fmap</code> of the underlying functor. The <code>join</code> and <code>return</code> functions can be defined in terms of <code>mu</code> and <code>eta</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&gt;&gt;=) ::</span> (<span class="dt">Monad</span> c t) <span class="ot">=&gt;</span> c a (t b) <span class="ot">-&gt;</span> c (t a) (t b)
(<span class="fu">&gt;&gt;=</span>) f <span class="fu">=</span> mu <span class="fu">.</span> fmap f
 
return<span class="ot"> ::</span> (<span class="dt">Monad</span> c t) <span class="ot">=&gt;</span> c a (t a)
return <span class="fu">=</span> eta</code></pre></div>
<p>In this form equivalent naturality conditions for the monad’s natural transformations give rise to the regular monad laws by substitution with our new definitions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap f <span class="fu">.</span> return  ≡  return <span class="fu">.</span> f          
fmap f <span class="fu">.</span> join    ≡  join <span class="fu">.</span> fmap (fmap f)</code></pre></div>
<p>And the equivalent coherence conditions expressed in terms of bind and return are the well known Monad laws:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">return a <span class="fu">&gt;&gt;=</span> f   ≡  f a
m <span class="fu">&gt;&gt;=</span> return     ≡  m
(m <span class="fu">&gt;&gt;=</span> f) <span class="fu">&gt;&gt;=</span> g  ≡  m <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> f x <span class="fu">&gt;&gt;=</span> g)</code></pre></div>
<h5 id="kleisli-category">Kleisli Category</h5>
<hr />
<p>The final result is given a monad we can form a new category called the <em>Kleisli category</em> from the monad. The objects are embedded in our original <code>c</code> category, but our arrows are now Kleisli arrows <code>a -&gt; T b</code>. Given this class of “actions” we’d like to write an operator which combined these morphisms just like we combine functions in our host category.</p>
<p><span class="math display">\[
\begin{align}
&amp; (b \to T c) \to (a \to T b) \to (a \to T c) \\
&amp; (b \to c) \to (a \to b) \to (a \to c)
\end{align}
\]</span></p>
<p>In turns we out can for a specific function <code>(&lt;=&lt;)</code> expressed in terms of <span class="math inline">\(\mu\)</span> and the underlying functor, which gives associative composition operator of Kleisli arrows. The Kleisli category models “composition of actions” and form a very general model of computation.</p>
<p>The mapping between a Kleisli category formed from a category <span class="math inline">\(\mathcal{C}\)</span> is that:</p>
<ol style="list-style-type: decimal">
<li>Objects in the Kleisli category are objects from the underlying category.</li>
<li>Morphisms are Kleisli arrows of the form : <span class="math inline">\(f : A \rightarrow  T B\)</span></li>
<li>Identity morphisms in the Kleisli category are precisely <span class="math inline">\(\eta\)</span> in the underlying category.</li>
<li>Composition of morphisms <span class="math inline">\(f \circ g\)</span> in terms of the host category is defined by the mapping:</li>
</ol>
<p><span class="math display">\[
f \circ g = \mu ( T f ) g
\]</span></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Kleisli category</span>
<span class="kw">newtype</span> <span class="dt">Kleisli</span> c t a b <span class="fu">=</span> <span class="dt">K</span> (c a (t b))

<span class="co">-- Kleisli morphisms ( c a (t b) )</span>
<span class="kw">type</span> (a <span class="fu">:~&gt;</span> b) c t <span class="fu">=</span> <span class="dt">Kleisli</span> c t a b

<span class="co">-- Kleisli morphism composition</span>
<span class="ot">(&lt;=&lt;) ::</span> (<span class="dt">Monad</span> c t) <span class="ot">=&gt;</span> c y (t z) <span class="ot">-&gt;</span> c x (t y) <span class="ot">-&gt;</span> c x (t z)
f <span class="fu">&lt;=&lt;</span> g <span class="fu">=</span> mu <span class="fu">.</span> fmap f <span class="fu">.</span> g 

<span class="kw">instance</span> <span class="dt">Monad</span> c t <span class="ot">=&gt;</span> <span class="dt">Category</span> (<span class="dt">Kleisli</span> c t) <span class="kw">where</span>
  <span class="co">-- id :: (Monad c t) =&gt; c a (t a)</span>
  id <span class="fu">=</span> <span class="dt">K</span> eta

  <span class="co">-- (.) :: (Monad c t) =&gt; c y (t z) -&gt; c x (t y) -&gt; c x (t z)</span>
  (<span class="dt">K</span> f) <span class="fu">.</span> (<span class="dt">K</span> g) <span class="fu">=</span> <span class="dt">K</span> ( f <span class="fu">&lt;=&lt;</span> g )</code></pre></div>
<p>In the case of Hask where <code>c = (-&gt;)</code> we see the usual instances:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Kleisli category</span>
<span class="kw">newtype</span> <span class="dt">Kleisli</span> m a b <span class="fu">=</span> <span class="dt">K</span> (a <span class="ot">-&gt;</span> m b)

<span class="co">-- Kleisli morphisms ( a -&gt; m b )</span>
<span class="kw">type</span> (a <span class="fu">:~&gt;</span> b) m <span class="fu">=</span> <span class="dt">Kleisli</span> m a b

<span class="ot">(&lt;=&lt;) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> m c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m c
f <span class="fu">&lt;=&lt;</span> g <span class="fu">=</span> mu <span class="fu">.</span> fmap f <span class="fu">.</span> g 

<span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Category</span> (<span class="dt">Kleisli</span> m) <span class="kw">where</span>
  id            <span class="fu">=</span> <span class="dt">K</span> return
  (<span class="dt">K</span> f) <span class="fu">.</span> (<span class="dt">K</span> g) <span class="fu">=</span> <span class="dt">K</span> (f <span class="fu">&lt;=&lt;</span> g)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> t <span class="kw">where</span>
<span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t b

<span class="kw">class</span> <span class="dt">Functor</span> t <span class="ot">=&gt;</span> <span class="dt">Monad</span> t <span class="kw">where</span>
<span class="ot">  eta ::</span> a <span class="ot">-&gt;</span> (t a)
<span class="ot">  mu  ::</span> t (t a) <span class="ot">-&gt;</span> (t a)

<span class="ot">(&gt;&gt;=) ::</span> <span class="dt">Monad</span> t <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> t b) <span class="ot">-&gt;</span> t b
ma <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> join <span class="fu">.</span> fmap f</code></pre></div>
<p><em>Stated simply that the monad laws above are just the category laws in the Kleisli category</em>, specifically the monad laws in terms of the Kleisli category of a monad <code>m</code> are:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(f <span class="fu">&gt;=&gt;</span> g) <span class="fu">&gt;=&gt;</span> h ≡ f <span class="fu">&gt;=&gt;</span> (g <span class="fu">&gt;=&gt;</span> h)
return <span class="fu">&gt;=&gt;</span> f ≡ f
f <span class="fu">&gt;=&gt;</span> return ≡  f</code></pre></div>
<p>For example, <code>Just</code> is just an identity morphism in the Kleisli category of the <code>Maybe</code> monad.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Just</span> <span class="fu">&gt;=&gt;</span> f <span class="fu">=</span> f
f <span class="fu">&gt;=&gt;</span> <span class="dt">Just</span> <span class="fu">=</span> f</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">just ::</span> (a <span class="fu">:~&gt;</span> a) <span class="dt">Maybe</span>
just <span class="fu">=</span> <span class="dt">K</span> <span class="dt">Just</span>

<span class="ot">left ::</span> forall a b<span class="fu">.</span> (a <span class="fu">:~&gt;</span> b) <span class="dt">Maybe</span> <span class="ot">-&gt;</span> (a <span class="fu">:~&gt;</span> b) <span class="dt">Maybe</span>
left f <span class="fu">=</span> just <span class="fu">.</span> f

<span class="ot">right ::</span> forall a b<span class="fu">.</span> (a <span class="fu">:~&gt;</span> b) <span class="dt">Maybe</span> <span class="ot">-&gt;</span> (a <span class="fu">:~&gt;</span> b) <span class="dt">Maybe</span>
right f <span class="fu">=</span> f <span class="fu">.</span> just</code></pre></div>
<h5 id="haskell-monads">Haskell Monads</h5>
<hr />
<p>For instance the <strong>List monad</strong> would have:</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\eta\)</span> returns a singleton list from a single element.</li>
<li><span class="math inline">\(\mu\)</span> turns a nested list into a flat list.</li>
<li><span class="math inline">\(\mathtt{fmap}\)</span> applies a function over the elements of a list.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> [] <span class="kw">where</span>
  <span class="co">-- fmap :: (a -&gt; b) -&gt; [a] -&gt; [b]</span>
  fmap f (x<span class="fu">:</span>xs) <span class="fu">=</span> f x <span class="fu">:</span> fmap f xs

<span class="kw">instance</span> <span class="dt">Monad</span> [] <span class="kw">where</span>
  <span class="co">-- eta :: a -&gt; [a]</span>
  eta x <span class="fu">=</span> [x]

  <span class="co">-- mu :: [[a]] -&gt; [a]</span>
  mu <span class="fu">=</span> concat</code></pre></div>
<p>The <strong>Maybe monad</strong> would have:</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\eta\)</span> is the Just constructor.</li>
<li><span class="math inline">\(\mu\)</span> combines two levels of Just constructors yielding the inner value or Nothing.</li>
<li><span class="math inline">\(\mathtt{fmap}\)</span> applies a function under the Just constructor or nothing for Nothing.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> [] <span class="kw">where</span>
  <span class="co">-- fmap :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b</span>
  fmap f (<span class="dt">Just</span> x) <span class="fu">=</span> <span class="dt">Just</span> (f x)
  fmap f <span class="dt">Nothing</span> <span class="fu">=</span> <span class="dt">Nothing</span>

<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Maybe</span> <span class="kw">where</span>
  <span class="co">-- eta :: a -&gt; Maybe a</span>
  eta x <span class="fu">=</span> <span class="dt">Just</span> x

  <span class="co">-- mu :: (Maybe (Maybe a)) -&gt; Maybe a</span>
  mu (<span class="dt">Just</span> (<span class="dt">Just</span> x)) <span class="fu">=</span> <span class="dt">Just</span> x
  mu (<span class="dt">Just</span> <span class="dt">Nothing</span>) <span class="fu">=</span> <span class="dt">Nothing</span></code></pre></div>
<p>The <strong>IO monad</strong> would intuitively have the implementation:</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\eta\)</span> returns a pure value to a value within the context of the computation.</li>
<li><span class="math inline">\(\mu\)</span> turns a sequence of IO operation into a single IO operation.</li>
<li><span class="math inline">\(\mathtt{fmap}\)</span> applies a function over the result of the computation.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">IO</span> <span class="kw">where</span>
  <span class="co">-- fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b</span>

<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Maybe</span> <span class="kw">where</span>
  <span class="co">-- eta :: a -&gt; IO a</span>
  <span class="co">-- mu :: (IO (IO a)) -&gt; IO a</span></code></pre></div>]]></summary>
</entry>
<entry>
    <title>A Haskell Reading List</title>
    <link href="http://www.stephendiehl.com/posts/essential_haskell.html" />
    <id>http://www.stephendiehl.com/posts/essential_haskell.html</id>
    <published>2012-08-15T00:00:00Z</published>
    <updated>2012-08-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="a-haskell-reading-list">A Haskell Reading List</h3>
<p>Here is a list of papers and writings of what I consider are essential Haskell reading.</p>
<ul>
<li><a href="http://www.haskell.org/onlinereport/haskell2010/">Haskell 2010 Language Specification</a></li>
<li><a href="http://www.haskell.org/haskellwiki/Typeclassopedia">Typeclassopedia</a></li>
<li><a href="http://homepages.inf.ed.ac.uk/wadler/papers/essence/essence.ps.gz">The Essence of Functional Programming</a></li>
<li><a href="http://homepages.inf.ed.ac.uk/wadler/papers/class/class.ps.gz">How to make ad-hoc polymorphism less ad hoc</a></li>
<li><a href="http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf">Monads for functional programming</a></li>
<li><a href="http://catamorph.de/documents/Transformers.pdf">Monad Transformers: Step-By-Step</a></li>
<li><a href="https://jeltsch.wordpress.com/2013/02/09/some-interesting-features-of-haskells-type-system/">Some interesting features of Haskell’s type system</a></li>
<li><a href="http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf">Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire</a></li>
<li><a href="http://strictlypositive.org/IdiomLite.pdf">Applicative Programming with Effects</a></li>
<li><a href="http://chris-taylor.github.com/blog/2013/02/10/the-algebra-of-algebraic-data-types/">The Algebra of Algebraic Datatypes</a></li>
<li><a href="http://personal.cis.strath.ac.uk/~conor/Kleisli.pdf">Kleisli Arrows of Outrageous Fortune</a></li>
<li><a href="http://homepages.inf.ed.ac.uk/wadler/papers/free/free.ps.gz">Theorems for free!</a></li>
<li><a href="http://research.microsoft.com/pubs/74063/beautiful.pdf">Beautiful Concurrency</a></li>
<li><a href="http://research.microsoft.com/pubs/67066/imperative.ps.z">Imperative Functional Programming</a></li>
<li><a href="http://blog.sigfpe.com/2006/11/yoneda-lemma.html">Reverse Engineering Machines with the Yoneda Lemma</a></li>
<li><a href="http://blog.sigfpe.com/2008/11/from-monoids-to-monads.html">From Monoids to Monads</a></li>
<li><a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/">Tackling the awkward squad</a></li>
<li><a href="http://conal.net/papers/icfp97/icfp97.pdf">Functional Reactive Animation</a></li>
<li><a href="http://blog.ezyang.com/2010/07/flipping-arrows-in-coburger-king/">Flipping Arrows in coBurger King</a></li>
<li><a href="http://blog.ezyang.com/2012/10/duality-for-haskellers/">Duality for Haskellers</a></li>
<li><a href="http://chimera.labs.oreilly.com/books/1230000000929">Parallel and Concurrent Programming in Haskell</a></li>
<li><a href="http://conal.net/blog/posts/beautiful-differentiation">Beautiful Differentiation</a></li>
<li><a href="http://okmij.org/ftp/tagless-final/">Typed Tagless Interpretations and Typed Compilation</a></li>
<li><a href="http://repository.upenn.edu/cgi/viewcontent.cgi?article=1774&amp;context=cis_papers">Species and Functors and Types, Oh My!</a></li>
<li><a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/">The Implementation of Functional Programming Languages</a></li>
<li><a href="http://www.andres-loeh.de/DGP-Intro.pdf">Datatype-generic Programming in Haskell</a></li>
<li><a href="https://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf">Giving Haskell a Promotion</a></li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.22.2636&amp;rep=rep1&amp;type=pdf">Faking It: Simulating Dependent Types in Haskell</a></li>
<li><a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/constraints/jfp-outsidein.pdf">OutsideIn(X): Modular Type Inference with Local Assumptions</a></li>
</ul>]]></summary>
</entry>

</feed>
