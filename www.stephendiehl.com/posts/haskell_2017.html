<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->

<!-- Mirrored from www.stephendiehl.com/posts/haskell_2017.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 30 Dec 2016 15:42:10 GMT -->
<head>

    <!-- Basic Page Needs
  ================================================== -->
    <meta charset="utf-8">
    <title>Reflecting on Haskell in 2016</title>
    <meta name="description" content="{{description}}">
    <meta name="author" content="{{author}}">

    <!-- Mobile Specific Metas
  ================================================== -->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!-- CSS
  ================================================== -->
    <link rel="stylesheet" href="../css/base.css">
    <link rel="stylesheet" href="../css/skeleton.css">
    <link rel="stylesheet" href="../css/typography.css">
    <link rel="stylesheet" href="../css/layout.css">
    <link rel="stylesheet" href="../css/syntax.css">
    <link rel="stylesheet" href="../css/custom.css">

    <link href="http://fonts.googleapis.com/css?family=Droid+Sans:400,700|Droid+Serif:400,400italic|Inconsolata" rel="stylesheet">
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <script type="text/x-mathjax-config">
    </script>

    <!-- Google Analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-49839533-1', 'stephendiehl.com');
      ga('send', 'pageview');
    </script>

    <!--[if lt IE 9]>
        <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Favicons
    ================================================== -->
    <link rel="shortcut icon" href="images/favicon.html">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.html">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.html">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.html">

    <link rel="alternate" title="Stephen Diehl" type="application/atom+xml" href="feed.html">
    <link rel="alternate" title="Stephen Diehl" type="application/rss+xml" href="feed-2.html">
</head>
<body>

    <div class="container">
        <div class="three columns sidebar">
            <nav>
                <h3 id="logo">Stephen Diehl</h3>
                <ul>
                    <li><a href="../index.html">Index</a></li>
                    <li><a href="../posts.html">Blog</a></li>
                    <li><a href="../pages/writings.html">Writings</a></li>
                    <li><a href="../pages/hire.html">Contact Me</a></li>
                    <li><a href="../pages/pgp.html">PGP Key</a></li>
                    <li><a href="https://github.com/sdiehl">Github</a></li>
                    <li><a href="../feed.rss">RSS</a></li>
                    <li><a href="https://twitter.com/#!/smdiehl">Twitter</a></li>
                </ul>
            </nav>
            &nbsp;
        </div>

        <div class="twelve columns offset-by-one content">
            <h3 id="reflecting-on-haskell-in-2016">Reflecting on Haskell in 2016</h3>
<p>Well, 2016 … that just happened. About the only thing I can put in perspective at closing of this year is progress and innovation in Haskell ecosystem. There was a lot inspiring work and progress that pushed the state of the art forward.</p>
<p>This was a monumental year of Haskell in production. There were dozens of talks given about success stories with an unprecedented amount of commercially funded work from small startups to international banks. Several very honest accounts of the good and the bad were published, which gave us a rare glimpse into what it takes to plant Haskell in a corporate environment and foster it’s growth.</p>
<ol style="list-style-type: decimal">
<li><a href="http://baatz.io/posts/haskell-in-a-startup/">A Founder’s Perspective on 4 Years With Haskell</a> by Carl Baatz</li>
<li><a href="https://chadaustin.me/2016/06/the-story-of-haskell-at-imvu/">The Story of Haskell at IMVU</a> by Chad Austin</li>
<li><a href="https://lexi-lambda.github.io/blog/2016/06/12/four-months-with-haskell/">Four Months with Haskell</a> by Alexis King</li>
<li><a href="production.html">The Joy and Agony of Haskell in Production</a> by Stephen Diehl</li>
<li><a href="https://www.youtube.com/watch?v=AZQLkkDXy68&amp;t=1s">Production Haskell</a> by Reid Draper</li>
<li><a href="https://skillsmatter.com/skillscasts/9098-haskell-in-the-large-the-day-to-day-practice-of-using-haskell-to-write-large-systems">The day to day practice of using Haskell to write large systems</a> by Don Stewart</li>
</ol>
<h4 id="writing">Writing</h4>
<p>There was a lot of excellent Haskell writing this year. One can’t possible enumerate all of them, but several stood out as concise and mind-bending examples of practical Haskell:</p>
<ol style="list-style-type: decimal">
<li><a href="https://flannelhead.github.io/projects/blackstar.html">Raytracing Black Holes with Haskell</a> by Sakari Kapanen</li>
<li><a href="http://www.parsonsmatt.org/2015/12/09/exploratory_haskell.html">Exploratory Haskell</a> by Parsons Matt</li>
<li><a href="http://www.haskellforall.com/2016/02/state-of-haskell-ecosystem-february.html?m=1">State of the Haskell Ecosystem</a> by Gabriel Gonzalez</li>
<li><a href="https://blog.jle.im/entry/introducing-the-hamilton-library.html">Introducing the Hamilton Library</a> by Justin Le</li>
<li><a href="https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html">Practical Dependent Types in Haskell: Type Safe Neural Networks</a> by Justin Le</li>
<li><a href="https://aherrmann.github.io/programming/2016/05/28/mutual-recursion-in-final-encoding/">Mutual Recursion in Final Encoding</a> by Andreas Herrmann</li>
<li><a href="https://blogs.ncl.ac.uk/andreymokhov/an-algebra-of-graphs/">An Algebra of Graphs</a> by Andrey Mokhov</li>
<li><a href="../../www.stackbuilders.com/tutorials/haskell/ghc-optimization-and-fusion/index.html">GHC optimization and fusion</a> by Mark Karpov</li>
<li><a href="https://github.com/quchen/articles/tree/master/hindley-milner#readme">Hindley-Damas-Milner tutorial</a> by David Luposchainsky</li>
<li><a href="https://wespiser.com/writings/wyas/home.html">Write You a Scheme 2.0</a> by Adam Wespiser</li>
<li><a href="http://madsbuch.com/blog/proving-stuff-in-haskell/">Proving Stuff in Haskell</a> by Mads Buch</li>
<li><a href="https://lettier.github.io/posts/2016-08-15-making-movie-monad.html">Making Movie Monad</a> by David Lettier<br />
</li>
<li><a href="https://neilmitchell.blogspot.com/2016/02/selling-haskell-in-pub.html">Selling Haskell in the Pub</a> by Neil Mitchell</li>
<li><a href="http://dlaing.org/little-languages/">Little Languages</a> by David Laing</li>
</ol>
<p>The second edition of Graham Hutton’s book <a href="https://www.amazon.com/Programming-Haskell-Graham-Hutton/dp/1316626229/ref=dp_ob_title_bk">Programming in Haskell</a> was released, which updated the presentation to include modern Haskell including recent changes concerning applicative, monadic, foldable, and traversable types.</p>
<p>In addition there were several great lecture series by Bartosz Milewski on relevant Haskell topics that are generally underserved in writing.</p>
<ol style="list-style-type: decimal">
<li><a href="https://www.youtube.com/watch?v=N6sOMGYsvFA">Parallel and Concurrent Programming in Haskell</a></li>
<li><a href="https://www.youtube.com/watch?v=I8LbkfSSR58&amp;t=221s&amp;index=1&amp;list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_">Category Theory</a></li>
</ol>
<h4 id="uncategorized-projects">Uncategorized Projects</h4>
<p>There was a lot of open source work done this year, a few that stood out as particularly novel ideas or interesting ways of looking at problems through a Haskell lens:</p>
<ol style="list-style-type: decimal">
<li><a href="https://github.com/HuwCampbell/grenade">grenade</a> A dependently typed, practical, and fast neural network library.</li>
<li><a href="https://github.com/colah/ImplicitCAD">implicitCAD</a> A math-inspired CAD engine in Haskell.</li>
<li><a href="https://github.com/sleexyz/hylogen">hylogen</a> GLSL embedded in Haskell.</li>
<li><a href="https://github.com/tweag/sparkle">sparkle</a> Haskell on Apache Spark.</li>
<li><a href="https://github.com/Gabriel439/bench">bench</a> Command-line benchmark tool.</li>
<li><a href="https://github.com/oblivia-simplex/roper">roper</a> A return-oriented programming exploit toolkit using genetic programming.</li>
<li><a href="https://github.com/mstksg/tensor-ops">tensor-ops</a> Type-safe tensor manipulation operations in Haskell</li>
<li><a href="https://github.com/alexbecker/formal-morality/">formal-morality</a> A Pseudo-Rawlsian domain language in Haskell.</li>
<li><a href="https://github.com/sru-systems/protobuf-simple">protobuf-simple</a> A simpler Protocol Buffers library for Haskell.</li>
<li><a href="https://github.com/DanielG/rts-loader">rts-loader</a> A Haskell dynamic RTS loader supporting multiple GHC APIs.</li>
<li><a href="https://github.com/I3ck/HGE2D">hge2d</a> 2D game engine written in Haskell.</li>
</ol>
<h4 id="haskell-sucks">Haskell Sucks</h4>
<p>On a reflective note, there were quite a few <a href="https://www.reddit.com/r/haskell/comments/4f47ou/why_does_haskell_in_your_opinion_suck/">dogpile threads</a> in which we collectively ripped on our beloved language for it’s many flaws. The responses ranged from the obvious to the absurd, but the most voted flaws (in order) were:</p>
<ol style="list-style-type: decimal">
<li>Strings</li>
<li>No documentation</li>
<li>Records</li>
<li>Prelude with partial functions</li>
<li>Ambigious space/time complexity</li>
<li>No stack traces</li>
<li>Language extension overload</li>
<li>Long compilation times</li>
<li>No IDE</li>
</ol>
<p>There’s some truth to most of these. There’s also a answer or workaround to all of them except documentation.</p>
<h4 id="editor-ides">Editor &amp; IDEs</h4>
<p>The traditional editors saw incremental improvements and much was written about provisioning development environments for Haskell.</p>
<ol style="list-style-type: decimal">
<li><a href="https://rikvdkleij.github.io/intellij-haskell/">IntelliJ plugin for Haskell</a></li>
<li><a href="http://www.prigrammer.com/?p=332">Setting Up A Haskell Development Environment (Mac OS)</a></li>
<li><a href="http://blog.jez.io/2016/08/03/vim-and-haskell-in-2016-on-os-x/">Vim and Haskell in 2016 on OS X</a></li>
</ol>
<p>FP Complete released the wonderful <a href="https://github.com/commercialhaskell/intero">Intero</a> a background process for interacting with Emacs to do type assisted programming and completion. Plugins were also created to integrate Intero with the <a href="https://github.com/parsonsmatt/intero-neovim">Neovim editor</a>.</p>
<p><a href="http://haskellformac.com/">Haskell for Mac</a> continued to develop this year adding new tutorial content and an interactive playground for live programming using HTML and SVG. It remains probably the simplest way to teach students using the Macintosh operating system.</p>
<p>I gave a talk on <a href="http://dev.stephendiehl.com/editor_talk.html">editor tooling</a> in Boston and updated the <a href="vim_2016.html">vim tutorial</a> as well.</p>
<p><a href="https://github.com/HeinrichApfelmus/hyper-haskell">HyperHaskell</a> was released which provides an IPython/Mathematica style workbook for interactive Haskell development. It is cross-platform and runs on Linux, Mac and Windows. Hyper extends Haskell’s Show mechanism to support with a <code>Display</code> typeclass which can be overloaded to display graphics, mathematics, diagrams or structured HTML when rendering Haskell values to the workbook.</p>
<p><img src="https://github.com/HeinrichApfelmus/hyper-haskell/raw/master/docs/screenshots/worksheet-diagrams.png" width="400/"></p>
<p>On a future note, industry programmers using tools like Slack, Atom, and Visual Studio Code seem quite happy using web applications disguised in Chromium disguised as a native application using frameworks like <a href="http://electron.atom.io/">Electron</a>. Obviously this isn’t a perfectly optimal solution, but there is definitely room for an ambitious team to take the prebuilt haskell-ide-engine, FP Complete <a href="https://github.com/fpco/haskell-ide">haskell-ide</a> or intero backends and shape it into an Haskell specialized IDE environment developers who like such a fully featured environment. Perhaps the FP Complete IDE was a good idea, just a bit early.</p>
<h4 id="ghc">GHC</h4>
<p>The Glorious Glasgow Haskell Compiler had it’s 8.0 release, and landed to to much rejoicing. It was a big release and landed quite a few new features. It also staged quite a bit of partial work that will be manifest in the 8.2 which is tentatively scheduled for release candidate in mid-February 2017 and release in mid-April 2017. The GHC core development team did some truly progressive work this year.</p>
<p><strong>Type In Type</strong></p>
<p>Haskell’s pseudo-dependent type solution <code>TypeInType</code> landed. The initial solution was a bit brittle and is not actively used too much in the wild. Simply put the <code>TypeInType</code> extension removed the distinction between types of kind <code>*</code> and types of other kinds.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="fu">:</span>set <span class="fu">-</span><span class="dt">XTypeInType</span> 
λ<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Data.Kind</span> 
λ<span class="fu">&gt;</span> <span class="fu">:</span>info <span class="dt">Type</span>
<span class="kw">type</span> <span class="dt">Type</span> <span class="fu">=</span> <span class="fu">*</span> 	<span class="co">-- Defined in ‘GHC.Types’</span>
λ<span class="fu">&gt;</span> <span class="fu">:</span>kind <span class="dt">Type</span>
<span class="dt">Type</span><span class="ot"> ::</span> <span class="fu">*</span></code></pre></div>
<p>Richard Eisenberg finished up the work for his <a href="https://github.com/goldfirere/thesis/blob/master/built/thesis.pdf">thesis</a> and released a status report on the <a href="https://typesandkinds.wordpress.com/2016/07/24/dependent-types-in-haskell-progress-report/">efforts</a>.</p>
<p><strong>Type Family Dependencies</strong></p>
<p>Type families historically have not been injective, i.e. they are not guaranteed to maps distinct elements of its arguments to the same element of its result. The syntax is similar to the multiparmater typeclass functional dependencies in that the resulting type is uniquely determined by a set of the type families parameters. GHC 8.0 added support for this with the <code>TypeFamilyDependencies</code> extension.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">F</span> a b c <span class="fu">=</span> (<span class="ot">result ::</span> k) <span class="fu">|</span> result <span class="ot">-&gt;</span> a b c
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">F</span> <span class="dt">Int</span>  <span class="dt">Char</span> <span class="dt">Bool</span> <span class="fu">=</span> <span class="dt">Bool</span>
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">F</span> <span class="dt">Char</span> <span class="dt">Bool</span> <span class="dt">Int</span>  <span class="fu">=</span> <span class="dt">Int</span>
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">F</span> <span class="dt">Bool</span> <span class="dt">Int</span>  <span class="dt">Char</span> <span class="fu">=</span> <span class="dt">Char</span></code></pre></div>
<p><strong>Kind Equalities</strong></p>
<p>Up until GHC 8.0, we’ve not been able to express explicit kind equality proofs. As a result, type-level computation does not have access to kind level functions or promoted GADTs, the type-level analogues to expression-level features that have been so useful.</p>
<p>For instance in Agda if we wanted to write down a type-level proof about the commutativity of addition over the natural numbers we can do this quite simply. We use the usual propositional equality to express the type that two things are equal using substitutivity (<code>subst</code>): for any proposition (type), we can replace a term with a propositionally equal one, without changing the meaning of the proposition. And relatedly congruence (<code>cong</code>): if any function f respects propositional equality, it yields propositionally equal results if applied to propositionally equal arguments.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> ℕ <span class="fu">:</span> <span class="dt">Set</span> <span class="kw">where</span>
  zero <span class="fu">:</span> ℕ
  suc  <span class="fu">:</span> ℕ <span class="ot">→</span> ℕ

<span class="ot">{-# BUILTIN NATURAL ℕ #-}</span>

<span class="kw">infixl</span> <span class="dv">6</span> _<span class="fu">+</span>_

_<span class="fu">+</span>_ <span class="fu">:</span> ℕ <span class="ot">→</span> ℕ <span class="ot">→</span> ℕ
<span class="dv">0</span> <span class="fu">+</span> n <span class="fu">=</span> n
suc m <span class="fu">+</span> n <span class="fu">=</span> suc (m <span class="fu">+</span> n)

infix <span class="dv">4</span> _≡_

<span class="kw">data</span> _≡_ {<span class="dt">A</span> <span class="fu">:</span> <span class="dt">Set</span>} (x <span class="fu">:</span> <span class="dt">A</span>) <span class="fu">:</span> <span class="dt">A</span> <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span>
  refl <span class="fu">:</span> x ≡ x

subst <span class="fu">:</span> {<span class="dt">A</span> <span class="fu">:</span> <span class="dt">Set</span>} <span class="ot">→</span> (<span class="dt">P</span> <span class="fu">:</span> <span class="dt">A</span> <span class="ot">→</span> <span class="dt">Set</span>) <span class="ot">→</span> <span class="ot">∀</span>{x y} <span class="ot">→</span> x ≡ y <span class="ot">→</span> <span class="dt">P</span> x <span class="ot">→</span> <span class="dt">P</span> y
subst <span class="dt">P</span> refl p <span class="fu">=</span> p

cong <span class="fu">:</span> {<span class="dt">A</span> <span class="dt">B</span> <span class="fu">:</span> <span class="dt">Set</span>} (f <span class="fu">:</span> <span class="dt">A</span> <span class="ot">→</span> <span class="dt">B</span>) <span class="ot">→</span> {x y <span class="fu">:</span> <span class="dt">A</span>} <span class="ot">→</span> x ≡ y <span class="ot">→</span> f x ≡ f y
cong f refl <span class="fu">=</span> refl

assoc <span class="fu">:</span> (m n p <span class="fu">:</span> ℕ) <span class="ot">→</span> (m <span class="fu">+</span> n) <span class="fu">+</span> p ≡ m <span class="fu">+</span> (n <span class="fu">+</span> p)
assoc zero    _ _ <span class="fu">=</span> refl
assoc (suc m) n p <span class="fu">=</span> cong suc (assoc n p)</code></pre></div>
<p>As of GHC 8.0 we now have enough to do this kind of kind-level reasoning using propositional equality with <code>TypeInType</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">{-# LANGUAGE RankNTypes #-}</span>
<span class="ot">{-# LANGUAGE TypeInType #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>

<span class="kw">import </span><span class="dt">Data.Kind</span>

 <span class="co">-- pattern matching on Refl introduces proof</span>
<span class="kw">data</span><span class="ot"> (==) ::</span> forall (<span class="ot">t ::</span> <span class="fu">*</span>)<span class="fu">.</span> t <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">Refl</span><span class="ot"> ::</span> x <span class="fu">==</span> x

<span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Nat</span>

<span class="kw">infixl</span> <span class="dv">6</span> <span class="fu">+</span>
<span class="kw">type</span> family (<span class="fu">+</span>) a b <span class="kw">where</span>
  <span class="dt">Z</span>   <span class="fu">+</span> b <span class="fu">=</span> b
  <span class="dt">S</span> a <span class="fu">+</span> b <span class="fu">=</span> <span class="dt">S</span> (a <span class="fu">+</span> b)

<span class="kw">type</span> family <span class="dt">Sym</span> (<span class="ot">eq ::</span> (<span class="ot">x ::</span> a) <span class="fu">==</span> (<span class="ot">y ::</span> a))<span class="ot"> ::</span> y <span class="fu">==</span> x <span class="kw">where</span>
  <span class="dt">Sym</span> <span class="dt">Refl</span> <span class="fu">=</span> <span class="dt">Refl</span>

<span class="kw">type</span> family <span class="dt">Cong</span> (<span class="ot">f ::</span> a <span class="ot">-&gt;</span> b) (<span class="ot">p ::</span> x <span class="fu">==</span> y)<span class="ot"> ::</span> f x <span class="fu">==</span> f y <span class="kw">where</span>
  <span class="dt">Cong</span> f <span class="dt">Refl</span> <span class="fu">=</span> <span class="dt">Refl</span>

<span class="kw">type</span> family <span class="dt">Assoc</span>
  (<span class="ot">a ::</span> <span class="dt">Nat</span>) (<span class="ot">b ::</span> <span class="dt">Nat</span>) (<span class="ot">c ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> (a <span class="fu">+</span> b <span class="fu">+</span> c) <span class="fu">==</span> ((a <span class="fu">+</span> b) <span class="fu">+</span> c)
  <span class="kw">where</span> 
    <span class="dt">Assoc</span> <span class="dt">Z</span>     b c <span class="fu">=</span> <span class="dt">Refl</span>
    <span class="dt">Assoc</span> (<span class="dt">S</span> a) b c <span class="fu">=</span> <span class="dt">Cong</span> <span class="dt">S</span> (<span class="dt">Assoc</span> a b c)</code></pre></div>
<p><strong>Visible Type Applications</strong></p>
<p>Visible Type Applications was added with the <code>-XTypeApplications</code> flag to allow the addition of explicit type arguments directly to polymorphic call-sites. For instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">show (read <span class="fu">@</span><span class="dt">Int</span> <span class="dv">42</span><span class="st">&quot;)</span></code></pre></div>
<p><strong>Custom Type Errors</strong></p>
<p>As of GHC 8.0 we have the capacity to provide custom type error using type families. The messages themselves hook into GHC and expressed using the small datatype found in <code>GHC.TypeLits</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ErrorMessage</span> <span class="kw">where</span>
  <span class="dt">Text</span><span class="ot"> ::</span> <span class="dt">Symbol</span> <span class="ot">-&gt;</span> <span class="dt">ErrorMessage</span>
  <span class="dt">ShowType</span><span class="ot"> ::</span> t <span class="ot">-&gt;</span> <span class="dt">ErrorMessage</span>

  <span class="co">-- Put two messages next to each other</span>
<span class="ot">  (:&lt;&gt;:) ::</span> <span class="dt">ErrorMessage</span> <span class="ot">-&gt;</span> <span class="dt">ErrorMessage</span> <span class="ot">-&gt;</span> <span class="dt">ErrorMessage</span>

  <span class="co">-- Put two messages on top of each other</span>
<span class="ot">  (:$$:) ::</span> <span class="dt">ErrorMessage</span> <span class="ot">-&gt;</span> <span class="dt">ErrorMessage</span> <span class="ot">-&gt;</span> <span class="dt">ErrorMessage</span></code></pre></div>
<p>An example would be creating a type-safe embedded DSL that enforces invariants about the semantics at the type-level. We’ve been able to do this sort of thing using GADTs and type-families for a while but the error reporting has been horrible. With 8.0 we can have type-families that emit useful type errors that reflect what actually goes wrong and integrate this inside of GHC. This is going to a <em>big deal</em> for embedded DSL design in Haskell where failures were typically opaque and gnarly.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>

<span class="kw">import </span><span class="dt">GHC.TypeLits</span>

<span class="kw">type</span> family <span class="dt">Coerce</span> a b <span class="kw">where</span>
  <span class="dt">Coerce</span> <span class="dt">Int</span> <span class="dt">Int</span>     <span class="fu">=</span> <span class="dt">Int</span>
  <span class="dt">Coerce</span> <span class="dt">Float</span> <span class="dt">Float</span> <span class="fu">=</span> <span class="dt">Float</span>
  <span class="dt">Coerce</span> <span class="dt">Int</span> <span class="dt">Float</span>   <span class="fu">=</span> <span class="dt">Float</span>
  <span class="dt">Coerce</span> <span class="dt">Float</span> <span class="dt">Int</span>   <span class="fu">=</span> <span class="dt">TypeError</span> (<span class="dt">Text</span> <span class="st">&quot;Cannot cast to smaller type&quot;</span>)

<span class="kw">data</span> <span class="dt">Expr</span> a <span class="kw">where</span>
  <span class="dt">EInt</span><span class="ot">    ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Int</span>
  <span class="dt">EFloat</span><span class="ot">  ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Float</span>
  <span class="dt">ECoerce</span><span class="ot"> ::</span> <span class="dt">Expr</span> b <span class="ot">-&gt;</span> <span class="dt">Expr</span> c <span class="ot">-&gt;</span> <span class="dt">Expr</span> (<span class="dt">Coerce</span> b c)

<span class="ot">foo ::</span> <span class="dt">Expr</span> <span class="dt">Int</span>
foo <span class="fu">=</span> <span class="dt">ECoerce</span> (<span class="dt">EFloat</span> <span class="dv">3</span>) (<span class="dt">EInt</span> <span class="dv">4</span>)</code></pre></div>
<p><strong>OverloadedRecordFields</strong></p>
<p>This was a source of great pain in previous releases where common identifiers like <code>id</code> would have to have superfluous prefixes associated with each record, this is no longer an issue with the <code>OverloadedRecordFields</code> extension.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="kw">data</span> <span class="dt">A</span> <span class="fu">=</span> <span class="dt">A</span>
  {<span class="ot"> a ::</span> <span class="dt">Int</span>
  ,<span class="ot"> b ::</span> <span class="dt">Double</span>
  } <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">data</span> <span class="dt">B</span> <span class="fu">=</span> <span class="dt">B</span>
  {<span class="ot"> a ::</span> <span class="dt">String</span>
  ,<span class="ot"> c ::</span> <span class="dt">Char</span>
  } <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="ot">mkA ::</span> <span class="dt">A</span>
mkA <span class="fu">=</span> <span class="dt">A</span> {a <span class="fu">=</span> <span class="dv">23</span>, b <span class="fu">=</span> <span class="dv">42</span>}

<span class="ot">upA ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">A</span>
upA x <span class="fu">=</span> x {a <span class="fu">=</span> <span class="dv">12</span>}

<span class="ot">sel ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
sel <span class="fu">=</span> a

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> print <span class="fu">$</span> sel <span class="fu">$</span> upA <span class="fu">$</span> mkA</code></pre></div>
<p>GHC 8.0 also introduced the <code>OverloadedLabels</code> extension which allows a limited form of polymorphism over record selectors and updators that share the same name.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">IsLabel</span> (<span class="ot">x ::</span> <span class="dt">Symbol</span>) a <span class="kw">where</span>
<span class="ot">  fromLabel ::</span> <span class="dt">Proxy</span><span class="fu">#</span> x <span class="ot">-&gt;</span> a</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">IsLabel</span> <span class="st">&quot;true&quot;</span> <span class="dt">Bool</span> <span class="kw">where</span>
  fromLabel _ <span class="fu">=</span> <span class="dt">True</span>

<span class="kw">instance</span> <span class="dt">IsLabel</span> <span class="st">&quot;false&quot;</span> <span class="dt">Bool</span> <span class="kw">where</span>
  fromLabel _ <span class="fu">=</span> <span class="dt">False</span>

<span class="kw">instance</span> <span class="dt">IsLabel</span> <span class="st">&quot;true&quot;</span> <span class="dt">Int</span> <span class="kw">where</span>
  fromLabel _ <span class="fu">=</span> <span class="dv">1</span>

<span class="ot">a ::</span> <span class="dt">Bool</span>
a <span class="fu">=</span> <span class="fu">#</span>false

<span class="ot">b ::</span> <span class="dt">IsLabel</span> <span class="st">&quot;true&quot;</span> t <span class="ot">=&gt;</span> t
b <span class="fu">=</span> <span class="fu">#</span>true</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span> 
  print a
  print (<span class="ot">b ::</span> <span class="dt">Bool</span>)
  print (<span class="ot">b ::</span> <span class="dt">Int</span>)</code></pre></div>
<p><strong>MonadFail</strong></p>
<p>The MonadFail Proposal finally removed the ugly <code>fail</code> function that was historical cruft from the 90s. A new class <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad-Fail.html"><code>MonadFail</code></a> was implemented along with a set of warning flags pattern matching or guard would introduce a <code>fail</code> occurrence.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadFail</span> m <span class="kw">where</span>
<span class="ot">    fail ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> m a</code></pre></div>
<p><strong>DeriveLift</strong></p>
<p>8.0 added yet another automatic deriving mechanism. This time we can now automatically derive the boilerplate for TH Lift instances allowing us to embed free variables containing <code>Lift</code> instances inside of the Oxford brackets.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveLift #-}</span>

<span class="kw">module</span> <span class="dt">Lift</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Language.Haskell.TH.Syntax</span>

<span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="dt">Zero</span>
  <span class="fu">|</span> <span class="dt">Succ</span> <span class="dt">Expr</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Lift</span>)</code></pre></div>
<p>And in a separate module:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>

<span class="kw">module</span> <span class="dt">Exp</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Lift</span>
<span class="kw">import </span><span class="dt">Language.Haskell.TH.Syntax</span>

<span class="ot">zero ::</span> <span class="dt">Q</span> <span class="dt">Exp</span>
zero  <span class="fu">=</span> [<span class="fu">|</span><span class="dt">Zero</span><span class="fu">|</span>]

<span class="ot">suc ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span>
suc x <span class="fu">=</span> [<span class="fu">|</span><span class="dt">Succ</span> x<span class="fu">|</span>]

<span class="ot">x ::</span> <span class="dt">Expr</span>
x <span class="fu">=</span> <span class="fu">$</span>( [<span class="fu">|</span><span class="dt">Succ</span> <span class="dt">Zero</span><span class="fu">|</span>] )</code></pre></div>
<p><strong>Strict Haskell</strong></p>
<p>Haskell is normally uses a call-by-need semantics such that arguments passed to functions are only evaluated if their value is used. Bang patterns (written as <code>!x</code>) are explicit annotations that can force a specific to be evaluated before entering the function instead of as needed. GHC 8.0 introduced the ability to enable this for all functions in a specific module.</p>
<p>For example given the following set of definitions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">T</span> <span class="fu">=</span> <span class="dt">C</span> a
f x <span class="fu">=</span> y x
<span class="kw">let</span> x <span class="fu">=</span> y <span class="kw">in</span> rhs
<span class="kw">case</span> x <span class="kw">of</span> y <span class="ot">-&gt;</span> rhs
<span class="kw">case</span> x <span class="kw">of</span> (<span class="dt">NewType</span> y) <span class="ot">-&gt;</span> rhs</code></pre></div>
<p>Enable <code>-XStrict</code> will automatically performs the equivalent of adding strictness annotations to the every argument source. Effectively transforming the above into the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">T</span> <span class="fu">=</span> <span class="dt">C</span> <span class="fu">!</span>a
f <span class="fu">!</span>x <span class="fu">=</span> y x
<span class="kw">let</span> <span class="fu">!</span>x <span class="fu">=</span> y <span class="kw">in</span> rhs
<span class="kw">case</span> x <span class="kw">of</span> <span class="fu">!</span>y <span class="ot">-&gt;</span> rhs
<span class="kw">case</span> x <span class="kw">of</span> <span class="fu">!</span>(<span class="dt">NewType</span> y) <span class="ot">-&gt;</span> rhs</code></pre></div>
<p>Enabling will not uniformly increase the performance of code as some care is required when enabling it. It simply makes a slightly alters the behavior to one extreme of the space-time compromise spectrum, optimal performance still requires a clever mix of both laziness and strictness.</p>
<p><strong>Stack Traces</strong></p>
<p>Simon Marlow cracked the perpetual <a href="https://simonmar.github.io/posts/2016-02-12-Stack-traces-in-GHCi.html">stack trace problem</a> allowing a variety of approaches to getting detailed stack trace informations when we have to panic or unwind the stack.</p>
<p>For explicitly defined functions we can annotate call sites with a <code>HasCallStack</code> constraint which can be used to to obtain a partial call-stack at any point in the program. HasCallStack is a type constraint synonym for threading an implicit parameter <code>?callStack</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">HasCallStack</span> <span class="fu">=</span> <span class="fu">?</span><span class="ot">callStack ::</span> <span class="dt">CallStack</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">GHC.Stack</span>

<span class="ot">f ::</span> <span class="dt">HasCallStack</span> <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
f x <span class="fu">=</span> error (<span class="st">&quot;Error: &quot;</span> <span class="fu">++</span> show x)

<span class="ot">g ::</span> <span class="dt">HasCallStack</span> <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
g <span class="fu">=</span> withFrozenCallStack f

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> print <span class="fu">$</span> g <span class="dv">23</span></code></pre></div>
<p>For automatic stack traces across the entire program in GHCi we can compile the with a specific set of flags and profiling enabled. The precise stack trace from the closure where assertion was called will then be printed if the term is evaluated. Currently this introduces a 2-3x runtime overhead when compiled.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">ghci</span> -fexternal-interpreter -prof </code></pre></div>
<p><strong>Unboxed Sum Types</strong></p>
<p>GHC 8.2 will have <code>UnboxedSums</code>, that enables unboxed representation for non-recursive sum types. The extension will be enabled as an opt-in annotation with new to explicitly unpack selected datatypes for high-performance structures.</p>
<p>Unboxed types are those which instead of being represented by a pointer to heap value are passed directly in a CPU register. The usual numerics types in Haskell can be considered to be a regular algebraic datatype with special constructor arguments for their underlying unboxed values.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Int</span> <span class="fu">=</span> <span class="dt">I</span><span class="fu">#</span> <span class="dt">Int</span><span class="fu">#</span>

<span class="kw">data</span> <span class="dt">Integer</span>
  <span class="fu">=</span> <span class="dt">S</span><span class="fu">#</span> <span class="dt">Int</span><span class="fu">#</span>              <span class="co">-- Small integers</span>
  <span class="fu">|</span> <span class="dt">J</span><span class="fu">#</span> <span class="dt">Int</span><span class="fu">#</span> <span class="dt">ByteArray</span><span class="fu">#</span>   <span class="co">-- Large GMP integers</span>

<span class="kw">data</span> <span class="dt">Float</span> <span class="fu">=</span> <span class="dt">F</span><span class="fu">#</span> <span class="dt">Float</span><span class="fu">#</span></code></pre></div>
<p>The syntax introduced allows sums to be explicitly unboxed by delimiters <code>(# ...  #)</code>. Pattern matching syntax follows the same form, and allows explicit unpacking of the unboxed sum in case statements.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Sum1</span> <span class="fu">=</span> 
  (<span class="fu">#</span> 
    (<span class="fu">#</span> <span class="dt">Int</span><span class="fu">#</span>, <span class="dt">Int</span> <span class="fu">#</span>)
    <span class="fu">|</span> (<span class="fu">#</span> <span class="dt">Int</span><span class="fu">#</span>, <span class="dt">Int</span><span class="fu">#</span> <span class="fu">#</span>)
    <span class="fu">|</span> (<span class="fu">#</span> <span class="dt">Int</span>, <span class="dt">Int</span><span class="fu">#</span> <span class="fu">#</span>) 
  <span class="fu">#</span>)

<span class="ot">showSum1 ::</span> <span class="dt">Sum1</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
showSum1 (<span class="fu">#</span> p1 <span class="fu">|</span> <span class="fu">|</span> <span class="fu">#</span>) <span class="fu">=</span> showP1 p1
showSum1 (<span class="fu">#</span> <span class="fu">|</span> p2 <span class="fu">|</span> <span class="fu">#</span>) <span class="fu">=</span> showP2 p2
showSum1 (<span class="fu">#</span> <span class="fu">|</span> <span class="fu">|</span> p3 <span class="fu">#</span>) <span class="fu">=</span> showP3 p3</code></pre></div>
<p>The usual ( <code>Maybe a</code> ) type was traditionally represented by a tagged closure, with a two pointer lookups to the parameter <code>a</code>. With unboxed sums we simply store the pointer to the value a alongside the flag for the sum type without the need for extra indirection. This would effectively allow a ‘zero-cost abstraction’ (with full type safety) use of the Maybe monad when fully optimized.</p>
<p><strong>Compact Regions</strong></p>
<p>Support for ‘Compact Regions’ is planned for GHC 8.2. Compact regions are manually allocated regions where the data allocated inside it are compacted and not traversed by the GC. This is amenable for long-lived data structures that are resident in memory without mutation frequently occurring. William Sewell gave a great <a href="https://blog.pusher.com/latency-working-set-ghc-gc-pick-two/">talk</a> at the London Haskell meetup where the issues with large <code>Data.Map</code> structures used for a message bus system caused non-optimal GC performance</p>
<p>The proposed API has been <a href="http://ezyang.com/compact/Data-Compact.html">expressed</a> as well as a paper on the details on extensions to the GC and <a href="http://ezyang.com/papers/ezyang15-cnf.pdf">runtime system</a>.</p>
<p><strong>GHC Education</strong></p>
<p>At the beginning of the year I felt one of the larger looming issues is that GHC internals are too opaque. However there was a lot of great writing and talks given this year about practical examples of extending and exploring the GHC internals.</p>
<p>Simon Petyon Jones gave a brilliant talk on <a href="https://www.youtube.com/watch?v=uR_VzYxvbxg">Into the Core</a>, describing the System-FC core language at the heart of all of Haskell. He also then described the new work on the <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/sequent-core/scfp_ext.pdf">Sequent calculus</a> as a compiler intermediate language for future work.</p>
<p>I wrote a three part blog series on the internal GHC types, pipeline, and gave some practical tutorials on augmenting the compiler with custom logic. Work permitting I’ll try to extend this series next year with posts on CMM and RTS internals.</p>
<ol style="list-style-type: decimal">
<li><a href="ghc_01.html">Dive into GHC: Part 1</a></li>
<li><a href="ghc_02.html">Dive into GHC: Part 2</a></li>
<li><a href="ghc_03.html">Dive into GHC: Part 3</a></li>
</ol>
<p>Takenobu Tani published a lovely slide deck on <a href="../../takenobu-hs.github.io/downloads/haskell_ghc_illustrated.pdf">GHC internals illustrated</a>.</p>
<p>David Luposchainsky released a <a href="https://github.com/quchen/stgi">STGj</a>, a visual STG (Spineless Tagless G-Machine) implementation to help understand Haskell’s execution model. A talk on the subject was also given at <a href="https://www.youtube.com/watch?v=-MFk7PIKYsg">ZuriHac</a>.</p>
<p>Alberto Sade wrote a short tutorial on manipulating the <a href="http://aesadde.xyz/posts/ghc_core.html">GHC Core</a> types from inside Haskell programs.</p>
<p>Christiaan Baaij wrote a <a href="https://christiaanb.github.io/posts/type-checker-plugin/">detailed tutorial</a> on extending the GHC typechecker with a custom plugins which allow more complex logic to be embedded in the type system.</p>
<h4 id="stack">Stack</h4>
<p>Since last year Stack has become near ubiquitous. Every company that I’ve come in contact with in the last year is using it internally for their builds. The tooling makes some compromises on version bounds and compatibility that are ‘pragmatic’ and actively debated, but overall the tooling has brought more people into the language and vastly decreased a lot of the friction we once had. The innovation of Stack can be put quite simply as making all build commands idempotent and sandboxes as stateless, which was a vast improvement over stateful sandboxes which would quickly become corrupted or inconsistent and needed to be rebuilt constantly.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">stack</span> ghci --package protolude</code></pre></div>
<p>Stack has since grown a rich set of integrations with tooling such as Nix, GHCjs, TravisCI, CircleCI, Docker, Kubernetes as well as broad set of templates for <a href="https://github.com/commercialhaskell/stack-templates">quickly starting</a> Haskell projects.</p>
<p>The alternative <code>cabal new-build</code> build system is under active development. The new build system uses Nix-style local builds which makes a distinction between local packages and external packages. Local packages, which users edit and recompile and must be built per-project whereas external packages are cached across projects and retrieved from Hackage.</p>
<ol style="list-style-type: decimal">
<li><a href="https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html">New-Build Documentation</a></li>
<li><a href="http://blog.ezyang.com/2016/05/announcing-cabal-new-build-nix-style-local-builds/">Announcing Cabal New-Build</a></li>
</ol>
<p>There will likely still be healthy debate about best practices, but despite whatever approach converges much of the Cabal-hell problems of years past are a distant memory. We have ubiquitous cached builds, stateless sandboxing and easy to use-tooling.</p>
<h4 id="probabilistic-programming">Probabilistic Programming</h4>
<p>Probabilistic domain languages are designed to describe probabilistic models by allowing variables defined in the language to represent stochastic quantities, and then perform inference (Markov Chain Monte-Carlo, Gibbs Sampling, etc) on combinations of these stochastic models according to the structure of the their combination in the program. Probabilistic programming is an exciting, and growing, area of research, with fantastic people in both AI/ML and PL working together and making big strides. It is especially finding uses in quantitative finance as of late.</p>
<p>Jared Tobin has written some <a href="https://jtobin.io/simple-probabilistic-programming">excellent articles</a> on the topic of building minimalist domain languages to model probabilistic models. There’s also been several other encodings in libraries like <a href="https://hakaru-dev.github.io/">hakaru</a> and <a href="https://github.com/adscib/monad-bayes">monad-bayes</a>.</p>
<h4 id="llvm">LLVM</h4>
<p>LLVM is a compiler toolchain and intermediate language used in most modern compilers. Since Haskell is heavily used in compiler and language work, the LLVM bindings are of great interest to a lot of Haskellers. This year saw quite a few new compilers and derived work.</p>
<p>Roberto Castañeda Lozano released <a href="https://github.com/unison-code/unison/tree/master/src/unison">Unison</a> a new Haskell library which integrates with the LLVM toolchain as an alternative or as a complementary approach to default register allocation algorithms which are suboptimal for embedded or low-power systems.</p>
<p>Moritz Angermann gave a lovely talk on using embedded DSLs in Haskell to generate <a href="https://github.com/angerman/data-bitcode-llvm">LLVM bitcode</a> and presented at <a href="https://www.youtube.com/watch?v=mrJUjlxoTTY">ICFP</a>.</p>
<p>I travelled to Paris and Berlin this autumn and gave a short talk on compiling small native languages using llvm-general Haskell bindings to build a small compiler called ‘Petit’. Andreas Herrmann also gave a brilliant talk on the subject in Zurich with a more detailed <a href="https://www.youtube.com/watch?v=Re3XgFfflzg">dive through</a> through the internals of a simple LLVM compiler backend.</p>
<p>The Summer of Code sponsored work on the LLVM backend to Accelerate, one of Haskell’s array computing librarys. The work <a href="https://github.com/AccelerateHS/accelerate-llvm/commits?author=ZihengJiang">implemented all</a> of the core operators and the project should be ready widespread soon.</p>
<h4 id="mathematics">Mathematics</h4>
<p>The <a href="https://github.com/cartazio/arithmoi">arithmoi</a> number theory library found new maintainers and is being actively developed once again.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Math.NumberTheory.Zeta</span>
<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Math.NumberTheory.Primes.Sieve</span>

<span class="fu">&gt;</span> take <span class="dv">10</span> primes
[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">11</span>,<span class="dv">13</span>,<span class="dv">17</span>,<span class="dv">19</span>,<span class="dv">23</span>,<span class="dv">29</span>]

<span class="fu">&gt;</span> take <span class="dv">3</span> (zetas 1e<span class="fu">-</span><span class="dv">14</span>)<span class="ot"> ::</span> [<span class="dt">Double</span>]
[<span class="fu">-</span><span class="fl">0.5</span>,<span class="dt">Infinity</span>,<span class="fl">1.6449340668482262</span>]</code></pre></div>
<p>A rather popular student project this year was a <a href="https://github.com/jyh1/mmaclone">implementation of the Wolfram Language</a>, a simple M-Expression language based on term rewriting. The project demonstrated the obvious strength Haskell has for modeling mathematical domain languages. There is most definitely a lot of low-hanging fruit for building the core machinery for classic computer algebra problems. A basic implementation of the following would go quite far toward advancing Haskell in computational algebra:</p>
<ol style="list-style-type: decimal">
<li><em>Gröbner basis</em> calculation for solving systems of polynomials in commutative algebras.</li>
<li><em>Normal-Risch algorithm</em> for symbolic integration.</li>
<li><em>Strong Generating Sets/Coset</em> algorithms for tensor index canonicalization.</li>
<li><em>Horner scheme</em> for evaluation of univariate polynomials over arbitrary domains.</li>
</ol>
<h4 id="cryptography">Cryptography</h4>
<p>Due to commercial investment, cryptography libraries in Haskell have gotten much more mature this year. We have a complete complement of the industry standard algorithms for various tasks:</p>
<ol style="list-style-type: decimal">
<li><a href="https://hackage.haskell.org/package/cryptonite-0.21/docs/Crypto-MAC-Poly1305.html#g:1">Poly1305</a> for message authentication codes.</li>
<li><a href="https://hackage.haskell.org/package/cryptonite-0.21/docs/Crypto-Hash-Algorithms.html#g:1">Blake2b</a> or <a href="https://hackage.haskell.org/package/cryptonite-0.21/docs/Crypto-Hash-Algorithms.html#t:Keccak_256">Keccak-256</a> for hashing.</li>
<li><a href="https://hackage.haskell.org/package/cryptonite-0.21/docs/Crypto-KDF-Scrypt.html">Scrypt</a> or <a href="https://hackage.haskell.org/package/argon2-1.2.0/docs/Crypto-Argon2.html">Argon2</a> for password key derivation.</li>
<li><a href="https://hackage.haskell.org/package/cryptonite-0.21/docs/Crypto-Cipher-ChaCha.html#g:1">Chacha20-256</a> for symmetric key encryption.</li>
<li><a href="https://hackage.haskell.org/package/cryptonite-0.21/docs/Crypto-PubKey-Curve25519.html">Curve25519</a> for elliptic curve public key cryptography.</li>
</ol>
<p>Also a friendly reminder that the NSA has likely developed the capability to decrypt a large number of HTTPS, SSH, and VPN connections using an attack on common primes used in the parameters of the Diffie-Hellman key exchange algorithm with keys less than 2048 bits. Some estimates also put decryption with the D-Wave computers within 10 years which poses a threat to current cryptographic approaches based on the discrete-logarithm problem in finite fields and elliptic curves. Be safe as we go into uncertain territory in 2017.</p>
<p>At ICFP there was a <a href="https://www.youtube.com/watch?v=RA0DsMrwcxo">fascinating presentation</a> on interesting work on implementing <a href="https://eprint.iacr.org/2015/1134.pdf#page=24">somewhat homomorphic encryption (SHE)</a> and lattice cryptography in Haskell.</p>
<h4 id="committees">Committees</h4>
<p>The Haskell 2020 committee formed with the goal of forming a new language report that GHC 8.8 would implement. There is a mailing list for <a href="https://mail.haskell.org/pipermail/haskell-prime/">haskell prime</a> as well as several RFC projects on Github to track the progress. The GHC project also started tracking proposal discussion on Github using pull requests in a more public <a href="https://github.com/ghc-proposals/ghc-proposals/pulls">forum</a>.</p>
<p>The <a href="https://github.com/DataHaskell">DataHaskell</a> github organization was formed with the stated goal of improving the environment for data science in Haskell. It has since become an incubator for several ambitious projects to advance the state of numerical computing libraries and documentation.</p>
<h4 id="serialization">Serialization</h4>
<p>Well-Typed and FPComplete both released two binary serialization libraries.</p>
<ol style="list-style-type: decimal">
<li><a href="https://github.com/well-typed/binary-serialise-cbor">binary-serialise-cbor</a></li>
<li><a href="https://hackage.haskell.org/package/store">store</a></li>
</ol>
<p>Both are high performance serialization libraries with different encodings, endianness choices and performance characteristics, especially around fixed-size vectors and traversals times of input types.</p>
<h4 id="halvm">HalVM</h4>
<p>Development on HalVM out of Galois picked up with some public statements on project. HalVM is a framework for writing Haskell programs that run lightweight virtual machines run directly on the Xen hypervisor. This potentially opens up the opportunity for deploying “containers” that are single purpose programs with minimal exposure to the usual baggage Linux operating system carry and their potential exploits.</p>
<ol style="list-style-type: decimal">
<li><a href="http://uhsure.com/halvm-status1.html">HalVM Status 1</a></li>
<li><a href="http://uhsure.com/halvm3.html">HalVM: The Vision</a></li>
</ol>
<p>Tooling was also published to deploy these Unikernels to standard Amazon EC2 infrastructure. See: <a href="https://github.com/GaloisInc/ec2-unikernel">ec2-unikernel</a></p>
<h4 id="languages">Languages</h4>
<p>Los Alamos National Laboratory released an interesting <a href="https://tfp2016.org/papers/TFP_2016_paper_14.pdf">auto-parallelizing</a> Haskell subset called <a href="https://github.com/losalamos/APPFL">APPFL</a>.</p>
<p><a href="https://github.com/kellino/microML">microML</a> is a simple functional programming language designed for teaching at University College of London for the BBC micro:bit microcomputer.</p>
<p>Fugue developed an internal language called <a href="https://fugue.co/">Fugue</a> which is used for automating cloud deployments. The technology was demoed at <a href="https://www.youtube.com/watch?v=rIphd57Sm1U">ICFP talk</a> this year.</p>
<p>Summer of Code sponsored work on a <a href="https://code.world/blocks">“blocky” interface</a> for composing Haskell programmers, used for teaching basic functional programming.</p>
<p>Swift Navigation released <a href="https://github.com/swift-nav/plover">Plover</a>, an embedded Haskell DSL for compiling linear algebra routines into C for running on embedded systems.</p>
<p>Daan Leijen continued development on <a href="https://github.com/koka-lang/koka">Koka</a> an experiment in effect typing using row polymorphism.</p>
<p><a href="https://github.com/jameysharp/corrode">The Corrode</a> project was introduced which provided a semantics-preserving automatic translation tool from C to Rust, for migrating legacy code. Using Haskell to remove legacy C code from this world can only be a good thing.</p>
<p>Paul Chiusano continued development on <a href="http://unisonweb.org/2016-10-12/search.html#post-start">Unison</a> a ‘next generation programming platform’ implemented in Haskell and designed for building large-scale distributed systems.</p>
<p>Gabriel Gonzalez released <a href="https://hackage.haskell.org/package/dhall-1.0.1/docs/Dhall-Tutorial.html">Dhall</a>, a total non-Turing complete programming language specialized for configuration files. Including a standard library hosted on permanent web <a href="https://ipfs.io/ipfs/QmcTbCdS21pCxXysTzEiucDuwwLWbLUWNSKwkJVfwpy2zK/Prelude">IPFS</a> node.</p>
<h4 id="prelude">Prelude</h4>
<p>The single largest reported pain point for the Haskell language is simply from certain “naughty” historical things in the Prelude which no longer reflect modern thinking. The default Prelude makes it much too accidentally shoot oneself in the foot by using suboptimal String types, partial functions, impure exception throwing, and a variety of other paper cuts.</p>
<p>Earlier this year I released my perspective on the issue: <a href="https://github.com/sdiehl/protolude">Protolude</a>. Protolude is likely the least ambitious alt-prelude ever. It doesn’t do anyting new, just fixes Base exports with the legacy bits masked and much of the mental overload of String conversions smoothed over. Notably it maintains ABI compatibility with existing Haskell code. Judging by the number of uses of Github it seems well-received and is being used in the core of major projects like PostgREST and Purescript.</p>
<p>There are plenty of other approaches to <a href="https://hackage.haskell.org/packages/#cat:Prelude">prelude design</a> and I believe the explosion is a healthy reaction to a standard library which many users consider not suitable for industrial use. No one prelude will be suitable for everyone for all use cases. The two concerning factors to keep in mind when exploring this space are:</p>
<ol style="list-style-type: decimal">
<li>Keep the transitive dependency tree small.</li>
<li>Maintain compatibility with base whenever possible.</li>
</ol>
<p>For a new projects in 2017, consider just starting with <code>NoImplicitPrelude</code> in your cabal file and importing a sensible set of defaults from your library of choice.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">default<span class="fu">-</span>extensions<span class="fu">:</span>
  <span class="dt">NoImplicitPrelude</span></code></pre></div>
<p>Or use a stack template like:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">stack</span> new protolude</code></pre></div>
<h4 id="foundation">Foundation</h4>
<p>Alternate preludes are only routing around the problem because of the constraints of being unable to fix problems upstream. The <a href="http://www.stephendiehl.com/posts/library is https://github.com/haskell-foundation/foundation">Foundation</a> bit grander in scope and aims to fix quite a few of the overarching problems with the ecosystem.</p>
<ol style="list-style-type: decimal">
<li>UTF8 based strings are default and are stored as packed array of codepoints.</li>
<li>FilePath are algebraic datatypes and can be manipulated and inspected without string munging.</li>
<li>IO actions read into ByteStrings and conversion into the appropriate type is left to the user.</li>
<li>Partial functions are either removed or wrapped in a <code>Partial</code> monad. Non-empty datatypes are provided by default.</li>
<li>An abstract container interface is provided that allows multiple data structures (Set, Map, Vector, etc) to use the same functions overloaded by a type class with associated data families to track elements or index types.</li>
<li>More granular numerical tower that doesn’t require partial implementations of functions that aren’t relevant.</li>
</ol>
<p>For a quick taste:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span>

<span class="kw">import </span><span class="dt">Foundation</span>
<span class="kw">import </span><span class="dt">Foundation.IO</span>
<span class="kw">import </span><span class="dt">Foundation.String</span>
<span class="kw">import </span><span class="dt">Foundation.VFS.FilePath</span>

<span class="kw">import </span><span class="dt">Foundation.Collection</span>

<span class="ot">example ::</span> <span class="dt">String</span>
example <span class="fu">=</span> <span class="st">&quot;Violence is the last refuge of the incompetent.&quot;</span>

<span class="ot">bytes ::</span> <span class="dt">UArray</span> <span class="dt">Word8</span>
bytes <span class="fu">=</span> toBytes <span class="dt">UTF8</span> example

<span class="ot">file ::</span> <span class="dt">IO</span> (<span class="dt">UArray</span> <span class="dt">Word8</span>)
file <span class="fu">=</span> readFile <span class="st">&quot;foundation.hs&quot;</span>

<span class="ot">fileString ::</span> <span class="dt">IO</span> (<span class="dt">String</span>, <span class="dt">Maybe</span> <span class="dt">ValidationFailure</span>, <span class="dt">UArray</span> <span class="dt">Word8</span>)
fileString <span class="fu">=</span> fromBytes <span class="dt">UTF8</span> <span class="fu">&lt;$&gt;</span> file

<span class="ot">xs ::</span> <span class="dt">NonEmpty</span> [<span class="dt">Int</span>]
xs <span class="fu">=</span> fromList [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]

<span class="ot">x ::</span> <span class="dt">Int</span>
x <span class="fu">=</span> head xs</code></pre></div>
<p>I’m not aware anyone currently using this library, but it most certainly something to watch as it matures in 2017. It might be the “new hope” we’ve been looking for which consolidates industrial Haskell best practices.</p>
<h4 id="generics">Generics</h4>
<p>Generics in 8.0 extended the generics structure to include a richer set of queryable data. We now have full access to the lifted status, strictness annotations, datatype names, selector names, constructors, and newtype status of all symbols in a Generic instance.</p>
<p>The implementation of <code>DeriveAnyClass</code> pragma has also allowed classes which provide fully default signatures to automatically derived without empty instance declarations. Aeson for instance can now automatically derive JSON serializes and de serializes for any instance of Generic for free.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span>
<span class="ot">{-# LANGUAGE DeriveAnyClass #-}</span>

<span class="kw">import </span><span class="dt">Data.Text</span>
<span class="kw">import </span><span class="dt">Data.Aeson</span>

<span class="kw">data</span> <span class="dt">Sample</span> <span class="fu">=</span> <span class="dt">Sample</span>
  {<span class="ot"> a ::</span> <span class="dt">Text</span>
  ,<span class="ot"> b ::</span> <span class="dt">Text</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Generic</span>,<span class="dt">FromJSON</span>,<span class="dt">ToJSON</span>)

<span class="co">-- decode { &quot;a&quot;: &quot;foo&quot;, &quot;b&quot;: &quot;bar&quot; } :: Sample</span></code></pre></div>
<p>Libraries like <code>optparse-generic</code> have implemented prototypes of building entire command line interfaces using generics on top of vanilla Haskell data structures.</p>
<p>Andres Löh gave an hour long lecture on the new approach of using generic sums-of-products with generics-sop at <a href="https://www.youtube.com/watch?v=sQxH349HOik">ZuriHac 2016</a>.</p>
<p>I wrote a <a href="generics.html">short blog</a> post amount implementing custom generics functionality and how the internals of Generic deriving works.</p>
<p>Ryan Scott wrote a detailed blog post detailing all of the <a href="https://ryanglscott.github.io/2016/05/12/whats-new-with-ghc-generics-in-80/">substantial changes</a> in GHC 8.2 and changes to metadata format.</p>
<h4 id="idris">Idris</h4>
<p>Idris is a pure functional language with full dependent types, and is itself written in Haskell. Idris is not likely to be the tool I’ll reach for most of my day-to-day work, but it’s maturing quite rapidly and pushing the envelope of practicality in dependent types more so than any other language. It was announced that Idris is heading toward a <a href="http://www.idris-lang.org/towards-version-1-0/">1.0 milestone</a>.</p>
<p>There is also initial work on a <a href="https://github.com/mmhelloworld/idris-jvm">Java Virtual Machine backend</a> to Idris to supplement the builtin native code generator and Javascript backends.</p>
<p>There is also work on porting Benjamin Pierce’s seminal work ‘Software Foundations’ into <a href="https://github.com/idris-hackers/software-foundations">Idris</a>.</p>
<p>Most notably 0.9 introduced elaboration reflection using Idris as its own metalanguage. To explain, Idris is type checked in two stages: first, a metaprogram known as an elaborator translates the surface language into a small core language (called TT), after which the resulting TT program is type checked . Incomplete programs can be introduced as holes, which in the context of the rest of the program, have a set of unification constraints to be solved.</p>
<p>Elaboration allows us to ‘script’ the automatic completion of these holes with reusable logic that can access the full typing environment. This used to exist in a dedicated <a href="http://docs.idris-lang.org/en/latest/reference/tactics.html">tactic system</a> (ala Coq) but now these tactics can themselves be expressed using the elaborators reflection in Idris itself using a small set of monadic combinators.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Convert a hole to make it suitable for bindings</span>
attack <span class="fu">:</span> <span class="dt">Elab</span> ()

<span class="co">-- Introduce a lambda binding around the current hole and focus on the body</span>
intro <span class="fu">:</span> (n <span class="fu">:</span> <span class="dt">TTName</span>) <span class="ot">-&gt;</span> <span class="dt">Elab</span> ()

<span class="co">-- Place a term into a hole, unifying its type.</span>
fill <span class="fu">:</span> <span class="dt">Raw</span> <span class="ot">-&gt;</span> <span class="dt">Elab</span> ()

<span class="co">-- Substitute a guess into a hole.</span>
solve <span class="fu">:</span> <span class="dt">Elab</span> ()</code></pre></div>
<p>For example to elaborate a polymorphic identity function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">mkId <span class="fu">:</span> <span class="dt">Elab</span> ()
mkId <span class="fu">=</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> gensym <span class="st">&quot;x&quot;</span>
  attack
  intro x
  fill (<span class="dt">Var</span> x); solve
  solve

idNat <span class="fu">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span>
idNat <span class="fu">=</span> <span class="fu">%</span>runElab mkId</code></pre></div>
<p>The latest version now ships with a standard library of proof tactics called <a href="https://github.com/idris-lang/Idris-dev/tree/master/libs/pruviloj">Pruviloj</a> that work with Idris’s elaborator. For example we can automate induction proofs to prove associativity of numerical operations.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Pruviloj</span>

auto <span class="fu">:</span> <span class="dt">Elab</span> ()
auto <span class="fu">=</span> <span class="kw">do</span>
  compute
  attack
  try intros
  hs <span class="ot">&lt;-</span> map fst <span class="fu">&lt;$&gt;</span> getEnv
  for_ hs <span class="fu">$</span> \ih <span class="ot">=&gt;</span> try (rewriteWith (<span class="dt">Var</span> ih))
  hypothesis <span class="fu">&lt;|&gt;</span> search
  solve

ind <span class="fu">:</span> <span class="dt">Elab</span> ()
ind <span class="fu">=</span> <span class="kw">do</span>
  attack
  n <span class="ot">&lt;-</span> gensym <span class="st">&quot;x&quot;</span>
  intro n
  try intros
  ignore <span class="fu">$</span> induction (<span class="dt">Var</span> n) <span class="ot">`andThen`</span> auto
  solve

assoc <span class="fu">:</span> (j, k, l <span class="fu">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> plus (plus j k) l <span class="fu">=</span> plus j (plus k l)
assoc <span class="fu">=</span> <span class="fu">%</span>runElab ind</code></pre></div>
<p>Will then automatically fill in the term:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">assoc <span class="fu">:</span> (j, k, l <span class="fu">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> plus (plus j k) l <span class="fu">=</span> plus j (plus k l)
assoc <span class="dt">Z</span>     k l <span class="fu">=</span> <span class="dt">Refl</span>
assoc (<span class="dt">S</span> j) k l <span class="fu">=</span> <span class="kw">let</span> rec <span class="fu">=</span> assoc j k l <span class="kw">in</span> rewrite rec <span class="kw">in</span> <span class="dt">Refl</span></code></pre></div>
<h4 id="agda">Agda</h4>
<p>Agda is the most mature dependently typed functional programming language, and is itself written in Haskell. It is regularly used for research and for build complex type-level constructions to extract into Haskell.</p>
<p>Agda actually has quite lovely <a href="https://agda.readthedocs.io/en/latest/">documentation now</a> and is far more approachable than 5-6 years ago. There was recently a full course entitled Agda from Nothing (<a href="https://www.youtube.com/watch?v=-i-QQ36Nfsk">video</a>, <a href="https://github.com/scott-fleischman/agda-from-nothing">source</a>) by which walks one Scott Fleischman through the basics of dependently typed programming from first principles. It’s never been easier to learn.</p>
<h4 id="javascript">Javascript</h4>
<p>Javascript unfortunately continues to exist. While I remain skeptical of the entire transpiling phenomenon and think it will lead to an endless amount of wasted person-hours and legacy code. However the pragmatist in me also knows that the browser vendors are not economically incentivized to change the status quo, so nothing will change quickly and we should adapt ourselves to the least worst solution.</p>
<p>Last year I said I would revisit Elm if anything changed. Nothing has changed. It’s as uninteresting a language as it was last year. It’s 2017, languages should have a coherent story for polymorphism that doesn’t involve manual code duplication. I remain unconvinced by arguments attempting to reframe ‘primitive’ technology as ‘simple’.</p>
<p>Purescript on the other hand is increasingly becoming a more mature and robust language fully grounded in modern ideas. There was a <a href="https://leanpub.com/purescript/read">lovely book written</a> this year as well as variety of language improvements like newtype deriving, generics, type directed search, source maps, better error reporting, and custom package manager.</p>
<p>The Purescript community developed <a href="https://github.com/slamdata/purescript-halogen/blob/master/GUIDE.md">Halogen</a> which is a a toolkit for building reactive web apps using signal functions and a virtual DOM. It exposes a set of combinator for acting on signals which vary over time and dispatch to DOM event changes. This provides a proposal to the current trend of React/Redux-style application construction.</p>
<p>The GHCjs solutuion has gotten more mature and stable, and integrated with the Stack ecosystem. There were some impressive demos on compiling the entirety of <a href="http://markup.rocks/">Pandoc</a> into Javascript, which is quite a feat of engineering. Nevertheless, I remain somewhat skeptical that compiling Haskell to enormous blobs of auto-generated Javascript that contain the entire Haskell runtime is a sustainable solution for large commercial codebases. With WebAssembly on the horizon I might be convinced otherwise in 2017.</p>
<h4 id="eta">Eta</h4>
<p><a href="https://github.com/typelead/eta">Eta</a> is a Java Virtual Machine Backend for GHC 7.10. The stated goal of the project is to compile the entirety of Haskell to run with full core library and concurrent runtime support. The first release is estimated in January of 2017. The codebase is under active development by Rahul Muttineni and taking contributions.</p>
<p>Most notably the library will first class support for integrating with existing Java libraries through FFI, much like we do with C today.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Java</span>

<span class="kw">data</span> <span class="ot">{-# CLASS &quot;java.util.List&quot; #-}</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">List</span> (<span class="dt">Object</span><span class="fu">#</span> (<span class="dt">List</span> a))
  <span class="kw">deriving</span> <span class="dt">Class</span>

foreign <span class="kw">import </span>java unsafe &quot;@new&quot; newArrayList :: <span class="dt">Java</span> c (<span class="dt">ArrayList</span> a)</code></pre></div>
<h4 id="formal-verification">Formal Verification</h4>
<p>Haskell continues to find use in verification and auditing of cryptography. Although not new developments, both the Galois Cryptol library and Tamarin Prover (both Haskell-based tools) are being used for industrial strength uses in high-assurance work. Haskell continues to have best in class integration with external solvers such as Z3 and CVC4.</p>
<ol style="list-style-type: decimal">
<li><a href="https://tamarin-prover.github.io/">Tamarin</a></li>
<li><a href="https://github.com/GaloisInc/cryptol">Cryptol</a></li>
</ol>
<p>The National Science Foundation is currently funding work out of University of Pennsylvania and MIT to build an entire ecosystem of language tools that have end-to-end correctness proofs called DeepSpec. The <a href="http://www.deepspec.org/research/Haskell/">CoreSpec</a> program aims to develop a formal Coq specification of the GHC Core Language, type system, and semantics.</p>
<p>The Lean theorem prove recently added a complete <a href="https://github.com/leanprover/lean2/blob/master/hott/hott.md">Homotopy Type Theory</a> library with a complete <a href="https://github.com/leanprover/lean2/blob/master/hott/book.md">mapping of the chapters</a> from the textbook.</p>
<h4 id="liquid-haskell">Liquid Haskell</h4>
<p>Refinement types allow us to enrich Haskell’s type system with predicates that precisely describe the sets of valid inputs and outputs of functions These predicates are compiled down into a specific core language which can be discharged to an SMT solver for which there are fast decision procedures for testing the validity of the type.</p>
<p>For example we can construct refinements over a <code>Int</code> variable <code>v</code> .</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">{-@ type Zero    = {v:Int | v == 0} @-}</span>
<span class="co">{-@ type NonZero = {v:Int | v /= 0} @-}</span></code></pre></div>
<p>And constrain our function definitions so that the functions carry around a proof that a non-zero term will not be passed to it.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">{-@ zero :: Zero @-}</span>
zero  <span class="fu">=</span> <span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Int</span>

<span class="co">{-@ one, two, three :: NonZero @-}</span>
one   <span class="fu">=</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>
two   <span class="fu">=</span> <span class="dv">2</span><span class="ot"> ::</span> <span class="dt">Int</span>
three <span class="fu">=</span> <span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Int</span></code></pre></div>
<p>We can combine these predicates to prove non-trivial properties about arithmetic relations, properties about data structures and pointer <a href="https://ucsd-progsys.github.io/liquidhaskell-tutorial/11-case-study-pointers.html#/heartbleeds-in-haskell">memory access</a> to prevent bugs like Heartbleed.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (mod, gcd)

<span class="co">{-@ mod :: a:Nat -&gt; b:{v:Nat| 0 &lt; v} -&gt; {v:Nat | v &lt; b} @-}</span>
mod<span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
mod a b
  <span class="fu">|</span> a <span class="fu">&lt;</span> b <span class="fu">=</span> a
  <span class="fu">|</span> otherwise <span class="fu">=</span> mod (a <span class="fu">-</span> b) b

<span class="co">{-@ gcd :: a:Nat -&gt; b:{v:Nat | v &lt; a} -&gt; Int @-}</span>
gcd<span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
gcd a <span class="dv">0</span> <span class="fu">=</span> a
gcd a b <span class="fu">=</span> gcd b (a <span class="ot">`mod`</span> b)</code></pre></div>
<p>LiquidHaskell has developed a lovely and approachable <a href="https://ucsd-progsys.github.io/liquidhaskell-tutorial/02-logic.html">set of documentation</a> this year, and is now quite usable in production.</p>
<h4 id="linear-types">Linear Types</h4>
<p>Intuitively linear types model finite resources by a notion of <em>consumption</em> of variables in scope. A linear variable needs to be consumed in the same concept it was introduced and can not be “duplicated” or “destroyed”. In a linear λ-calculus we have typing rules in which statements such as “this function will use its argument exactly once” can be checked which can be used to enforce invariants on resource usage such as memory, channels, sockets, tokens, file descriptors, etc.</p>
<p>At the Haskell Exchange and ICFP there was some very early discussion about the possibility of introducing linear types into GHC. The proposed addition would allow weight inference and annotations to variables allowing users to constrain variable usage. The proposal and semantics are being actively discussed on the <a href="https://ghc.haskell.org/trac/ghc/wiki/LinearTypes#Semantics">issue tracker</a>. An implementation likely remains in the far future.</p>
<p>An undergraduate project at Chalmers presented a simple prototype Haskell-like language <a href="https://github.com/m0ar/lollipop">Lollipop</a> using linear typing.</p>
<p>Jeff Polokow presented <a href="http://functorial.com/Embedding-a-Full-Linear-Lambda-Calculus-in-Haskell/linearlam.pdf">a construction</a> by which a full linear lambda calculus can be deeply embedded in the current type system using advanced type features.</p>
<h4 id="backpack">Backpack</h4>
<p>Backpack is Haskell’s partial answer to “module problem”, of having cross-package libraries which are currently duplicated to provide similar interfaces. Backpack will allow libraries which are parametrized by signatures, letting users decide how to instantiate them at a later point in time.</p>
<p>This work is still very early, but Edward Yang gave a insightful talk at NYC <a href="https://www.youtube.com/watch?v=s_geh6SlGuM">Haksell Meetup</a> on the current design decisions taken in the prototype implementation. There is also a thorough description of the applications of Backpack to solve the problem of reusable <a href="http://blog.ezyang.com/2016/09/the-base-of-a-string-theory-for-haskell/">string libraries</a> that work over different underlying string representations.</p>
<p>In the early prototype we can construct an abstract <code>Str</code> signature module which provides a set of types:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">signature <span class="dt">Str</span> <span class="kw">where</span>

  <span class="kw">data</span> <span class="dt">Str</span>
  <span class="kw">data</span> <span class="dt">Elem</span>

  <span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Str</span>
  <span class="kw">instance</span> <span class="dt">Ord</span> <span class="dt">Str</span>
  <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Str</span>
  <span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">Str</span>

<span class="ot">  empty ::</span> <span class="dt">Str</span>
<span class="ot">  length ::</span> <span class="dt">Str</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></code></pre></div>
<p>This is then exposed in the cabal file for the library in the <code>signatures</code> field.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">name<span class="fu">:</span> str<span class="fu">-</span>sig<span class="fu">-</span>major1

library
  signatures<span class="fu">:</span>          <span class="dt">Str</span>
  build<span class="fu">-</span>depends<span class="fu">:</span>       base <span class="fu">&gt;=</span> <span class="fl">4.9</span> <span class="fu">&amp;&amp;</span> <span class="fu">&lt;</span> <span class="fl">4.10</span>,
                       deepseq
  default<span class="fu">-</span>language<span class="fu">:</span>    <span class="dt">Haskell2010</span></code></pre></div>
<p>An implementation of this signature then imports then library, and can then be implement the interface downstream by using a <code>mixin</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">name<span class="fu">:</span> str<span class="fu">-</span>text

library
  mixins<span class="fu">:</span>
    str<span class="fu">-</span>text (<span class="dt">Str.Text</span> as <span class="dt">Str</span>)
  build<span class="fu">-</span>depends<span class="fu">:</span>
    base,
    str<span class="fu">-</span>sig<span class="fu">-</span>major1</code></pre></div>
<p>The concrete implementation of the module would look like the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Str.Text</span> (
  <span class="dt">Str</span>,
  <span class="dt">Elem</span>,
  empty,
  length,
) <span class="kw">where</span>

<span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>

<span class="kw">type</span> <span class="dt">Str</span> <span class="fu">=</span> <span class="dt">T.Text</span>
<span class="kw">type</span> <span class="dt">Elem</span> <span class="fu">=</span> <span class="dt">Char</span>

<span class="ot">empty ::</span> <span class="dt">Str</span>
empty <span class="fu">=</span> T.empty

length<span class="ot"> ::</span> <span class="dt">Str</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
length <span class="fu">=</span> T.empty</code></pre></div>
<p>The work is still early, so this precise form may or may not end up in the final release of Backpack.</p>
<h4 id="databases">Databases</h4>
<p>Earlier this year I commented that compromises in type-safe database libraries consisted of the following traedoffs:</p>
<blockquote>
<p>Haskell SQL libraries: endless boilerplate, opaque metaprogramming, or wall of 15 language exts and no inference. Pick two.</p>
</blockquote>
<p>A lot of industrial Haskell sadly still uses string interpolation for SQL synthesis, or fall back on libraries that use TemplateHaskell to unsafely lock a specific build to a snapshot of a database at compile-time. Both of these trade-offs are suboptimal and fall short of what we can do in other robust frameworks like SQLAlchemy in Python. There’s three different key points that need to be addressed:</p>
<ol style="list-style-type: decimal">
<li>Definition of a schema tied to a specific databases and migration handling that can done at runtime.</li>
<li>Consistency checking of schema against definitions of SQL statements with type-safety.</li>
<li>Composition and reuse of units of SQL statements and values that preserve type safety under composition.</li>
</ol>
<p>The challenge I continue to pose, that occurs quite frequently in data warehousing and ETL, is given a dynamic (i.e. at runtime) specification of a table in some embedding of DDL: create a table, query it, and dump the results into an existing table of the same schema. Doing this in a safe manor requires a rather complex <a href="http://docs.sqlalchemy.org/en/latest/core/reflection.html">reflection framework</a> by which a table object can load the <code>information_schema</code> and check the constancy of the query before evaluation.</p>
<p>I don’t think the ideal library is quite there yet, but year I was most impressed by Jake Wheat’s very early <a href="https://jakewheat.github.io/hssqlppp/0.6.0"><code>hssqlppp</code></a> which implements a restricted domain language for modeling and typechecking a Postgres SQL subset and generating queries. The full integration with a runtime SQL type-checker is a <a href="https://jakewheat.github.io/hssqlppp/latest/TypeCheckTests.html">lovely piece of work</a> and it would be follow naturally to lift this into a type-safe quasiquoter which would give the ideal solution of unifying both the dynamic and static semantics of SQL program synthesis at runtime and compile-time.</p>
<h4 id="industrial-users">Industrial Users</h4>
<p>Facebook quietly retains and recruits some of the legendary-level Haskell talent. See: <a href="https://simonmar.github.io/posts/2016-12-08-Haskell-in-the-datacentre.html">Haskell in the Datacentre</a></p>
<p>Barclay’s in the UK is also quietly building up an impressive team. See: <a href="https://neilmitchell.blogspot.co.uk/2016/09/full-time-haskell-jobs-in-london-at.html">Full-time Haskell jobs in London, at Barclays</a></p>
<p>JP Morgan funded development on a transaction modeling language <a href="https://github.com/hopper-lang/hopper-v0">Hopper</a>.</p>
<p>Ambiata presented at ICFP this year about a new query language <a href="https://github.com/ambiata/icicle">Icicle</a> for streaming time series, with a <a href="http://conf.researchr.org/event/icfp-2016/fhpc-2016-papers-icicle-write-once-run-once">novel approach to fusion</a> and <a href="https://github.com/ambiata/icicle">released source code</a>.</p>
<p>Awake Networks is building a next generation network security and analytics platform, utilizing using Purescript and Haskell.</p>
<p>Google has been pushing out Haskell bindings to some of their core infastructure, including Tensorflow. See: <a href="https://github.com/tensorflow/haskell">Haskell Tensorflow</a></p>
<p>There’s a fairly large group of Haskellers very quietly working on building smart contract solutions based on functional programming and formal methods. A lot of is happening behind doors at banks but some truly amazing work is being done in this space by singularly talented people. Watch for some amazing future-tech to drop in 2017.</p>
<p>Lots of exciting things going on at Barclay’s, Facebook, Target, Ambiata, Tweag, Takt, Zalora, Galois, JP Morgan, Helium, Silk, Lumi Guide, Awake Networks, FrontRow, Clearmatics, Standard Chartered, Digital Asset Holdings and Microsoft.</p>
<h4 id="stephen">Stephen</h4>
<p>Since last year I’ve been criss-crossing the globe through Germany, London, Paris, San Francisco, Zurich, Portland, New York and Boston doing some mix of advising, consulting, and investments. Late this year, I finally ended up starting a new company, which I’ll speak about publicly in the next few months.</p>
<p>I’m especially grateful for the warmth and kindness I felt traveling across European programming scene. I consistently always had a friend in whatever city I visited and it’s been a pleasure meeting many of you. Wish you all Merry Christmas and a Functional New Year!</p>
        </div>
    </div>

    <!-- JS
    ================================================== -->
    <script src="http://code.jquery.com/jquery-1.7.1.min.js"></script>

<!-- End Document
================================================== -->
</body>
