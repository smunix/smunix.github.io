<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->

Providence Salumu
<head>

    <!-- Basic Page Needs
  ================================================== -->
    <meta charset="utf-8">
    <title>Haskell for Web Developers</title>
    <meta name="description" content="{{description}}">
    <meta name="author" content="{{author}}">

    <!-- Mobile Specific Metas
  ================================================== -->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!-- CSS
  ================================================== -->
    <link rel="stylesheet" href="../css/base.css">
    <link rel="stylesheet" href="../css/skeleton.html">
    <link rel="stylesheet" href="../css/typography.html">
    <link rel="stylesheet" href="../css/layout.html">
    <link rel="stylesheet" href="../css/syntax.html">
    <link rel="stylesheet" href="../css/custom.html">

    <link href="http://fonts.googleapis.com/css?family=Droid+Sans:400,700|Droid+Serif:400,400italic|Inconsolata" rel="stylesheet">
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <script type="text/x-mathjax-config">
    </script>

    <!-- Google Analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-49839533-1', 'stephendiehl.com');
      ga('send', 'pageview');
    </script>

    <!--[if lt IE 9]>
        <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Favicons
    ================================================== -->
    <link rel="shortcut icon" href="images/favicon.html">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.html">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.html">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.html">

    <link rel="alternate" title="Stephen Diehl" type="application/atom+xml" href="feed.html">
    <link rel="alternate" title="Stephen Diehl" type="application/rss+xml" href="feed-2.html">
</head>
<body>

    <div class="container">
        <div class="three columns sidebar">
            <nav>
                <h3 id="logo">Stephen Diehl</h3>
                <ul>
                    <li><a href="../index.html">Index</a></li>
                    <li><a href="../posts.html">Blog</a></li>
                    <li><a href="../pages/writings.html">Writings</a></li>
                    <li><a href="../pages/hire.html">Contact Me</a></li>
                    <li><a href="../pages/pgp.html">PGP Key</a></li>
                    <li><a href="https://github.com/sdiehl">Github</a></li>
                    <li><a href="../feed.rss">RSS</a></li>
                    <li><a href="https://twitter.com/#!/smdiehl">Twitter</a></li>
                </ul>
            </nav>
            &nbsp;
        </div>

        <div class="twelve columns offset-by-one content">
            <h2 id="haskell-for-web-developers">Haskell for Web Developers</h2>
<p><b style="color:red">This blog post is somewhat dated and may not reflect changes to the ecosystem since 2013.</b></p>
<p>The perpetual myth persists that Haskell cannot be used for “real world applications”. Normally real world is usually left undefined in such a discussion, but can often be taken to mean that Haskell is not suited for database and web development work.</p>
<p>Haskell has a rich library ecosystem and is well-suited for these tasks but I concede that there might be a systemic lack of introductory material for many domain specific tasks. Something that many <a href="http://www.haskell.org/platform">projects</a> and <a href="https://www.fpcomplete.com/">companies</a> are trying to remedy.</p>
<p>Haskell does indeed have several great web frameworks along the lines of RoR, Django, Flask, Pyramid etc.</p>
<ol style="list-style-type: decimal">
<li><a href="http://www.yesodweb.com/">Yesod</a></li>
<li><a href="http://www.snapframework.com/">Snap</a></li>
<li><a href="http://www.happstack.com/">Happstack</a></li>
</ol>
<p>I will not discuss these though because I really couldn’t give a better introduction than their own documentation. Instead I will focus on simple motivating examples for smaller libraries which provide a rich feature base for web development tasks while leveraging the strengths of Haskell language itself, and many of which can integrate with the larger frameworks.</p>
<h4 id="clay">Clay</h4>
<p>Clay is a library for programmatic generation of CSS. Is it an embedded DSL (EDSL) that exposes selectors and styles for the <a href="https://github.com/sebastiaanvisser/clay/tree/master/src/Clay">CSS3 grammmer</a>. Clay is designed to layer logic on top of the CSS as to encode variables, color mixing, complex selector logic and nested rules more easily than with base CSS. Clay can also be usefull as a lower-level combinator library to describe complex CSS layouts.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install clay</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Clay</span>
<span class="kw">import </span><span class="dt">Data.Text</span>
<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (div)

<span class="ot">bodyStyle ::</span> <span class="dt">Css</span>
bodyStyle <span class="fu">=</span> body <span class="fu">?</span> <span class="kw">do</span>
  background  aquamarine
  fontFamily  [<span class="st">&quot;Helvetica Neue&quot;</span>] [sansSerif]

<span class="ot">codeStyle ::</span> <span class="dt">Css</span>
codeStyle <span class="fu">=</span> code <span class="fu">?</span>
  <span class="kw">do</span> fontFamily  [<span class="st">&quot;Monaco&quot;</span>, <span class="st">&quot;Inconsolata&quot;</span>] [monospace]
     fontSize    (px <span class="dv">14</span>)
     lineHeight  (ex <span class="fl">1.8</span>)

<span class="ot">emphasis ::</span> <span class="dt">Css</span>
emphasis <span class="fu">=</span> <span class="kw">do</span> 
  fontWeight     bold
  color          black
  textTransform  uppercase

<span class="ot">container ::</span> <span class="dt">Selector</span>
container <span class="fu">=</span> div <span class="fu">#</span> <span class="st">&quot;.code&quot;</span>

<span class="ot">containerStyle ::</span> <span class="dt">Css</span>
containerStyle <span class="fu">=</span> container <span class="fu">?</span>
  <span class="kw">do</span> width (px <span class="dv">800</span>)
     borderColor gray

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> putCss <span class="fu">$</span> <span class="kw">do</span>
  bodyStyle
  codeStyle
  containerStyle</code></pre></div>
<p>The above will generate the following stylesheet:</p>
<div class="sourceCode"><pre class="sourceCode css"><code class="sourceCode css">body
<span class="kw">{</span>
  <span class="kw">background</span>  <span class="kw">:</span> <span class="dt">rgb(127</span>,<span class="dt">255</span>,<span class="dt">212)</span><span class="kw">;</span>
  <span class="kw">font-family</span> <span class="kw">:</span> <span class="st">&quot;Helvetica Neue&quot;</span>, <span class="dt">sans-serif</span><span class="kw">;</span>
<span class="kw">}</span>

code
<span class="kw">{</span>
  <span class="kw">font-family</span> <span class="kw">:</span> <span class="st">&quot;Monaco&quot;</span>,<span class="st">&quot;Inconsolata&quot;</span>, <span class="dt">monospace</span><span class="kw">;</span>
  <span class="kw">font-size</span>   <span class="kw">:</span> <span class="dt">14px</span><span class="kw">;</span>
  <span class="kw">line-height</span> <span class="kw">:</span> <span class="dt">1.80000ex</span><span class="kw">;</span>
<span class="kw">}</span>

div<span class="fl">.code</span>
<span class="kw">{</span>
  <span class="kw">width</span>        <span class="kw">:</span> <span class="dt">800px</span><span class="kw">;</span>
  <span class="kw">border-color</span> <span class="kw">:</span> <span class="dt">rgb(128</span>,<span class="dt">128</span>,<span class="dt">128)</span><span class="kw">;</span>
<span class="kw">}</span></code></pre></div>
<h4 id="blaze">Blaze</h4>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install blaze-html</code></pre></div>
<p>Blaze is the bread and butter of markup generation in Haskell. It is described as a “blazingly fast HTML combinator library” which programmtically generates HTML and several other markup languages from an embedded DSL.</p>
<p>In this module, the language extension <code>OverloadedStrings</code> is used so that the type inferencer can infer common coercions between String-like types without having to do explicit calls to boilerplate functions (<code>pack</code>, <code>unpack</code>, <code>html</code>) for each string-like literal. This will be pretty common use for all the examples from here out that use <code>ByteString</code> or HTML.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Data.Monoid</span>
<span class="kw">import </span><span class="dt">Text.Blaze</span> (<span class="dt">ToMarkup</span>(..))
<span class="kw">import </span><span class="dt">Text.Blaze.Html5</span> <span class="kw">hiding</span> (html, param)
<span class="kw">import </span><span class="dt">Text.Blaze.Html.Renderer.Text</span> (renderHtml)
<span class="kw">import qualified</span> <span class="dt">Text.Blaze.Html5</span> <span class="kw">as</span> <span class="dt">H</span>

<span class="ot">gen ::</span> <span class="dt">Html</span> <span class="ot">-&gt;</span> [<span class="dt">Html</span>] <span class="ot">-&gt;</span> <span class="dt">Html</span>
gen title elts  <span class="fu">=</span> H.html <span class="fu">$</span> <span class="kw">do</span>
  H.head <span class="fu">$</span>
    H.title title
  H.body <span class="fu">$</span>
    H.ul <span class="fu">$</span> mapM_ H.li elts

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  print <span class="fu">$</span> renderHtml <span class="fu">$</span> gen <span class="st">&quot;My Blog&quot;</span> [<span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;fizz&quot;</span>]</code></pre></div>
<p>This would output HTML like the following:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;html&gt;</span>
   <span class="kw">&lt;head&gt;</span>
      <span class="kw">&lt;title&gt;</span>My Blog<span class="kw">&lt;/title&gt;</span>
   <span class="kw">&lt;/head&gt;</span>
   <span class="kw">&lt;body&gt;</span>
      <span class="kw">&lt;ul&gt;</span>
          <span class="kw">&lt;li&gt;</span>foo<span class="kw">&lt;/li&gt;</span>
          <span class="kw">&lt;li&gt;</span>bar<span class="kw">&lt;/li&gt;</span>
          <span class="kw">&lt;li&gt;</span>fizz<span class="kw">&lt;/li&gt;</span>
      <span class="kw">&lt;/ul&gt;</span>
   <span class="kw">&lt;/body&gt;</span>
<span class="kw">&lt;/html&gt;</span></code></pre></div>
<p>In addition to generating HTML we can also derive from it’s internal ToMarkup classes to provide HTML representations for any datatype in Haskell. A silly example might be:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Example</span> <span class="fu">=</span> <span class="dt">A</span> <span class="fu">|</span> <span class="dt">B</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)
<span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Cons</span> a <span class="fu">|</span> <span class="dt">Nil</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">ToMarkup</span> <span class="dt">Animal</span> <span class="kw">where</span>
  toMarkup <span class="fu">=</span> toHtml <span class="fu">.</span> show

<span class="kw">instance</span> (<span class="dt">ToMarkup</span> a) <span class="ot">=&gt;</span> <span class="dt">ToMarkup</span> (<span class="dt">List</span> a) <span class="kw">where</span>
  toMarkup x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span>
      <span class="dt">Cons</span> a <span class="ot">-&gt;</span> H.ul <span class="fu">$</span> H.li <span class="fu">$</span> toHtml a
      <span class="dt">Nil</span> <span class="ot">-&gt;</span> <span class="st">&quot;&quot;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- Cons (Cons (Cons A)) --&gt;</span>
<span class="kw">&lt;ul&gt;</span>
   <span class="kw">&lt;li&gt;</span>
      <span class="kw">&lt;ul&gt;</span>
         <span class="kw">&lt;li&gt;</span>
            <span class="kw">&lt;ul&gt;</span>
               <span class="kw">&lt;li&gt;</span>A<span class="kw">&lt;/li&gt;</span>
            <span class="kw">&lt;/ul&gt;</span>
         <span class="kw">&lt;/li&gt;</span>
      <span class="kw">&lt;/ul&gt;</span>
   <span class="kw">&lt;/li&gt;</span>
<span class="kw">&lt;/ul&gt;</span></code></pre></div>
<p>It is worth noting that the Blaze builder overloads do-notation as some EDSLs do, but the <code>Html</code> type is not a monad. It is functionally a monoid.</p>
<p>For non-embedded template languages along the lines of <em>Jinja</em> or <em>erb</em> refer to the <a href="http://www.yesodweb.com/book/shakespearean-templates">Shakespearean templates</a> or <a href="http://hackage.haskell.org/package/happstack-heist">heist</a>.</p>
<h4 id="jmacro">JMacro</h4>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install jmacro</code></pre></div>
<p>JMacro is quasiquoter for Javascript code generation. The underlying implementation is rather clever and allows Haskell and Javascript to share functions and values across quotation boundaries. The end result is a fusion of Haskell and JavaScript that serves as a foundation to <a href="http://hackage.haskell.org/packages/archive/jmacro-rpc/0.2/doc/html/Network-JMacroRPC-Base.html">higher abstractions</a> and as a very convienant way to implement code generation for compilers targetting Javascript.</p>
<p>As an example of we’ll use JMacro to implement a simple translator for the untyped typed lambda calculus, something one might do if writing a language that transpiles to Javascript.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE QuasiQuotes, TypeSynonymInstances, FlexibleInstances, OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Data.String</span>
<span class="kw">import </span><span class="dt">Language.Javascript.JMacro</span>

<span class="ot">jref ::</span> <span class="dt">Sym</span> <span class="ot">-&gt;</span> <span class="dt">JExpr</span>
jref <span class="fu">=</span> <span class="dt">ValExpr</span> <span class="fu">.</span> <span class="dt">JVar</span> <span class="fu">.</span> <span class="dt">StrI</span>

<span class="ot">jvar ::</span> <span class="dt">Sym</span> <span class="ot">-&gt;</span> <span class="dt">JStat</span>
jvar sym <span class="fu">=</span> <span class="dt">DeclStat</span> (<span class="dt">StrI</span> sym) <span class="dt">Nothing</span>

jprint x <span class="fu">=</span> [jmacroE<span class="fu">|</span>console<span class="fu">.</span>log(x)<span class="fu">|</span>]

<span class="kw">instance</span> <span class="dt">IsString</span> <span class="dt">Expr</span> <span class="kw">where</span>
  fromString x <span class="fu">=</span> <span class="dt">Var</span> (<span class="dt">Sym</span> x)

<span class="kw">data</span> <span class="dt">Val</span> <span class="fu">=</span> <span class="dt">Sym</span> <span class="dt">Sym</span>
         <span class="fu">|</span> <span class="dt">Lit</span> <span class="dt">Lit</span>
         <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="kw">type</span> <span class="dt">Sym</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="kw">data</span> <span class="dt">Lit</span> <span class="fu">=</span> <span class="dt">LStr</span> <span class="dt">String</span>
         <span class="fu">|</span> <span class="dt">LInt</span> <span class="dt">Int</span>
         <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="kw">data</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
          <span class="fu">|</span> <span class="dt">Lam</span> <span class="dt">Sym</span> <span class="dt">Expr</span>
          <span class="fu">|</span> <span class="dt">Var</span> <span class="dt">Val</span>
          <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="co">-- Convert Haskell expressions to Javascript expressions</span>

<span class="kw">instance</span> <span class="dt">ToJExpr</span> <span class="dt">Val</span> <span class="kw">where</span>
  toJExpr (<span class="dt">Sym</span> s) <span class="fu">=</span> toJExpr s
  toJExpr (<span class="dt">Lit</span> l) <span class="fu">=</span> toJExpr l

<span class="kw">instance</span> <span class="dt">ToJExpr</span> <span class="dt">Lit</span> <span class="kw">where</span>
  toJExpr <span class="fu">=</span> toJExpr

<span class="kw">instance</span> <span class="dt">ToJExpr</span> <span class="dt">Sym</span> <span class="kw">where</span>
  toJExpr <span class="fu">=</span> jref

<span class="kw">instance</span> <span class="dt">ToJExpr</span> <span class="dt">Expr</span> <span class="kw">where</span>
  toJExpr (<span class="dt">Lam</span> s ex) <span class="fu">=</span> 
      [jmacroE<span class="fu">|</span> 
          function(arg) {
              <span class="ot">`(jvar s)`</span>;
              <span class="ot">`(jref s)`</span> <span class="fu">=</span> <span class="ot">`(arg)`</span>;
              return <span class="ot">`(ex)`</span>;
          }
      <span class="fu">|</span>]

  toJExpr (<span class="dt">App</span> f x) <span class="fu">=</span> 
      [jmacroE<span class="fu">|</span> <span class="ot">`(f)`</span>(<span class="ot">`(x)`</span>) <span class="fu">|</span>]

  toJExpr (<span class="dt">Var</span> v) <span class="fu">=</span>
      toJExpr v

<span class="ot">compile ::</span> <span class="dt">ToJExpr</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>
compile <span class="fu">=</span> show <span class="fu">.</span> renderJs <span class="fu">.</span> toJExpr

s, k, i0,<span class="ot"> i1 ::</span> <span class="dt">Expr</span>
s <span class="fu">=</span> <span class="dt">Lam</span> <span class="st">&quot;f&quot;</span> <span class="fu">$</span> <span class="dt">Lam</span> <span class="st">&quot;g&quot;</span> <span class="fu">$</span> <span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> <span class="fu">$</span> (<span class="dt">App</span> <span class="st">&quot;f&quot;</span> <span class="st">&quot;x&quot;</span>) <span class="ot">`App`</span> (<span class="dt">App</span> <span class="st">&quot;g&quot;</span> <span class="st">&quot;x&quot;</span>)
k <span class="fu">=</span> <span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> <span class="fu">$</span> <span class="dt">Lam</span> <span class="st">&quot;y&quot;</span> <span class="st">&quot;x&quot;</span>

i0 <span class="fu">=</span> <span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> <span class="st">&quot;x&quot;</span>
i1 <span class="fu">=</span> <span class="dt">App</span> (<span class="dt">App</span> s k) k

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  putStrLn <span class="fu">$</span> compile s
  putStrLn <span class="fu">$</span> compile k
  putStrLn <span class="fu">$</span> compile i0
  putStrLn <span class="fu">$</span> compile i1</code></pre></div>
<h4 id="fay">Fay</h4>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install fay</code></pre></div>
<p>Fay is a growing ecosystem of packages that can compile Haskell to Javascript. Fay works with a strict subset of Haskell that preserves Haskell semantics such as currying and laziness. In addition to the core language, ther are interfaces for <a href="https://github.com/faylang/fay-jquery">jquery</a> and <a href="https://github.com/faylang/fay-dom">DOM manipulation</a> so that Fay-compiled Haskell code can effectively access the browser internals.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install fay-dom fay-jquery</code></pre></div>
<p>The code generation is rather verbose given that it compiles quite a bit of the Haskell Prelude. The below example is very simple and only the interesting part of the outputted source is shown below. Notably the generated code is very readable.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- demo.hs</span>
<span class="kw">import </span><span class="dt">FFI</span>
<span class="kw">import </span><span class="dt">Prelude</span>
<span class="kw">import </span><span class="dt">JQuery</span>

<span class="ot">puts ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Fay</span> ()
puts <span class="fu">=</span> ffi <span class="st">&quot;console.log(%1)&quot;</span>

example <span class="fu">=</span> take <span class="dv">25</span> [<span class="dv">1</span><span class="fu">..</span>]

<span class="ot">main ::</span> <span class="dt">Fay</span> ()
main <span class="fu">=</span> ready <span class="fu">$</span> <span class="kw">do</span>
    el <span class="ot">&lt;-</span> select <span class="st">&quot;#mydiv&quot;</span>
    setCss <span class="st">&quot;background-color&quot;</span> <span class="st">&quot;red&quot;</span> el

    puts <span class="st">&quot;Hello World!&quot;</span>
    puts (show [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>])</code></pre></div>
<p>To compile invoke the compiler:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">fay</span> demo.hs --package fay-jquery</code></pre></div>
<p>Some of the generated code:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">
<span class="kw">var</span> Prelude$enumFrom <span class="op">=</span> <span class="kw">function</span> ($p1) <span class="op">{</span>
    <span class="cf">return</span> <span class="kw">new</span> <span class="at">Fay$$$</span>(<span class="kw">function</span> () <span class="op">{</span>
        <span class="kw">var</span> i <span class="op">=</span> $p1<span class="op">;</span>
        <span class="cf">return</span> <span class="at">Fay$$_</span>(<span class="at">Fay$$_</span>(
            Fay$$cons)(i))(<span class="at">Fay$$_</span>(
            Prelude$enumFrom)(
            <span class="at">Fay$$_</span>(<span class="at">Fay$$_</span>(
                Fay$$add)(i))(<span class="dv">1</span>)
        ))<span class="op">;</span>
    <span class="op">}</span>)<span class="op">;</span>
<span class="op">};</span>

<span class="kw">var</span> Main$example <span class="op">=</span> <span class="kw">new</span> <span class="at">Fay$$$</span>(
    <span class="kw">function</span> () <span class="op">{</span>
        <span class="cf">return</span> <span class="at">Fay$$_</span>(<span class="at">Fay$$_</span>(
            Prelude$take)(<span class="dv">25</span>))(
            <span class="at">Prelude$enumFrom</span>(<span class="dv">1</span>))<span class="op">;</span>
    <span class="op">}</span>)<span class="op">;</span></code></pre></div>
<p>To call this code from vanilla Javascript:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> main <span class="op">=</span> <span class="kw">new</span> <span class="at">Main</span>()<span class="op">;</span>
<span class="va">main</span>.<span class="at">_</span>(<span class="va">main</span>.<span class="at">Main$main</span>)<span class="op">;</span></code></pre></div>
<p>Fay is part of a larger community of compilers that transpile functional languages to Javascript. Another library of note is <a href="http://roy.brianmckenna.org/">Roy</a>. Although not Haskell, it has a sophisticated type system and notably an implementation of typeclasses, a feature that Fay currently does not implement.</p>
<h4 id="aeson">Aeson</h4>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install aeson</code></pre></div>
<p>Aeson is the de-facto JSON parsing and generation library for Haskell. It’s usage couldn’t be simpler, we simply declare instance of <code>toJSON</code> and <code>fromJSON</code> for our types and Aeson takes care of the mappings and exception handling. By using <code>DeriveGeneric</code> we can create instances with very little code.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings, DeriveGeneric #-}</span>

<span class="kw">import </span><span class="dt">Data.Aeson</span>

<span class="kw">import </span><span class="dt">GHC.Generics</span>
<span class="kw">import </span><span class="dt">Network.HTTP</span> 
<span class="kw">import </span><span class="dt">Control.Applicative</span>
<span class="kw">import </span><span class="dt">Data.ByteString</span> (<span class="dt">ByteString</span>)

<span class="kw">data</span> <span class="dt">Message</span> <span class="fu">=</span> <span class="dt">Message</span> { 
<span class="ot">      text ::</span> <span class="dt">ByteString</span>
    ,<span class="ot"> date ::</span> <span class="dt">ByteString</span>
    } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>)

<span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Message</span>
<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Message</span>

<span class="ot">fromStdin ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Message</span>)
fromStdin <span class="fu">=</span> eitherDecode <span class="fu">&lt;$&gt;</span> readLn</code></pre></div>
<h4 id="postgres-simple">postgres-simple</h4>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install postgres-simple</code></pre></div>
<p>Postgres-simple is a library for communicating with Postgres databases and mapping data between Haskell and SQL types. Although not an ORM, <code>postgres-simple</code> lets us generate and execute SQL queries and map result sets onto our algebraic datatypes very simply by deriving instances to declare schemas.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Data.Text</span>
<span class="kw">import </span><span class="dt">Control.Applicative</span>
<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Database.PostgreSQL.Simple</span>
<span class="kw">import </span><span class="dt">Database.PostgreSQL.Simple.FromRow</span>

<span class="kw">import qualified</span> <span class="dt">Data.ByteString</span> <span class="kw">as</span> <span class="dt">B</span>
<span class="kw">import qualified</span> <span class="dt">Database.PostgreSQL.Simple</span> <span class="kw">as</span> <span class="dt">Pg</span>

<span class="kw">data</span> <span class="dt">Client</span> <span class="fu">=</span> <span class="dt">Client</span> {<span class="ot"> firstName ::</span> <span class="dt">Text</span>
                     ,<span class="ot"> lastName ::</span> <span class="dt">Text</span>
                     ,<span class="ot"> clientLocation ::</span> <span class="dt">Location</span>
                     }

<span class="kw">data</span> <span class="dt">Location</span> <span class="fu">=</span> <span class="dt">Location</span> {<span class="ot"> address ::</span> <span class="dt">Text</span>
                         ,<span class="ot"> location ::</span> <span class="dt">Text</span>
                         }

<span class="kw">instance</span> <span class="dt">Pg.FromRow</span> <span class="dt">Location</span> <span class="kw">where</span>
  fromRow <span class="fu">=</span> <span class="dt">Location</span> <span class="fu">&lt;$&gt;</span> field <span class="fu">&lt;*&gt;</span> field

<span class="kw">instance</span> <span class="dt">Pg.FromRow</span> <span class="dt">Client</span> <span class="kw">where</span>
  fromRow <span class="fu">=</span> <span class="dt">Client</span> <span class="fu">&lt;$&gt;</span> field <span class="fu">&lt;*&gt;</span> field <span class="fu">&lt;*&gt;</span> liftM2 <span class="dt">Location</span> field field

<span class="ot">queryClients ::</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">Client</span>]
queryClients c <span class="fu">=</span> query_ c <span class="st">&quot;SELECT firstname, lastname, location FROM clients&quot;</span>

<span class="ot">main ::</span> <span class="dt">IO</span> [<span class="dt">Client</span>]
main <span class="fu">=</span> <span class="kw">do</span>
  uri <span class="ot">&lt;-</span> B.getLine
  conn <span class="ot">&lt;-</span> connectPostgreSQL uri
  queryClients conn</code></pre></div>
<h4 id="acid-state">Acid-State</h4>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install acid-state</code></pre></div>
<p>We can further exploit Haskell’s algebraic datatypes to give us a storage engine simply from the specification of our types and a little bit of <code>TemplateHaskell</code> usage. For instance, a simple <code>Map</code> container from <code>Data.Map</code> can be transformed to a disk-backed disk backed key-value store which can be interacted with as if it were a normal Haksell data structure.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Key</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">Value</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">data</span> <span class="dt">Database</span> <span class="fu">=</span> <span class="dt">Database</span> <span class="fu">!</span>(<span class="dt">Map.Map</span> <span class="dt">Key</span> <span class="dt">Value</span>)</code></pre></div>
<p>Like it’s name implies <code>acid-state</code> provides transactional guarantees for storage. Specifically that writes will be applied completely or not at all and that data will be consistent during reads.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings, TypeFamilies, DeriveDataTypeable, TemplateHaskell #-}</span>

<span class="kw">import </span><span class="dt">Data.Acid</span>
<span class="kw">import </span><span class="dt">Data.Typeable</span>
<span class="kw">import </span><span class="dt">Data.SafeCopy</span>
<span class="kw">import </span><span class="dt">Control.Monad.Reader</span> (ask)

<span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span>
<span class="kw">import qualified</span> <span class="dt">Control.Monad.State</span> <span class="kw">as</span> <span class="dt">S</span>

<span class="kw">type</span> <span class="dt">Key</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">Value</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="kw">data</span> <span class="dt">Database</span> <span class="fu">=</span> <span class="dt">Database</span> <span class="fu">!</span>(<span class="dt">Map.Map</span> <span class="dt">Key</span> <span class="dt">Value</span>)
    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Ord</span>, <span class="dt">Eq</span>, <span class="dt">Typeable</span>)

<span class="fu">$</span>(deriveSafeCopy <span class="dv">0</span> <span class="ch">'base ''Database)</span>

<span class="ot">insertKey ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Update</span> <span class="dt">Database</span> ()
insertKey key value
    <span class="fu">=</span> <span class="kw">do</span> <span class="dt">Database</span> m <span class="ot">&lt;-</span> S.get
         S.put (<span class="dt">Database</span> (Map.insert key value m))

<span class="ot">lookupKey ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">Query</span> <span class="dt">Database</span> (<span class="dt">Maybe</span> <span class="dt">Value</span>)
lookupKey key
    <span class="fu">=</span> <span class="kw">do</span> <span class="dt">Database</span> m <span class="ot">&lt;-</span> ask
         return (Map.lookup key m)

<span class="ot">deleteKey ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">Update</span> <span class="dt">Database</span> ()
deleteKey key
    <span class="fu">=</span> <span class="kw">do</span> <span class="dt">Database</span> m <span class="ot">&lt;-</span> S.get
         S.put (<span class="dt">Database</span> (Map.delete key m))

<span class="ot">allKeys ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Query</span> <span class="dt">Database</span> [(<span class="dt">Key</span>, <span class="dt">Value</span>)]
allKeys limit
    <span class="fu">=</span> <span class="kw">do</span> <span class="dt">Database</span> m <span class="ot">&lt;-</span> ask
         return <span class="fu">$</span> take limit (Map.toList m)

<span class="fu">$</span>(makeAcidic <span class="ch">''</span><span class="dt">Database</span> [<span class="ch">'insertKey, '</span>lookupKey, <span class="ch">'allKeys, '</span>deleteKey])

<span class="ot">fixtures ::</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">String</span>
fixtures <span class="fu">=</span> Map.empty

<span class="ot">test ::</span>  <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
test key val <span class="fu">=</span> <span class="kw">do</span>
    database <span class="ot">&lt;-</span> openLocalStateFrom <span class="st">&quot;db/&quot;</span> (<span class="dt">Database</span> fixtures)
    result <span class="ot">&lt;-</span> update database (<span class="dt">InsertKey</span> key val)
    result <span class="ot">&lt;-</span> query database (<span class="dt">AllKeys</span> <span class="dv">10</span>)
    print result</code></pre></div>
<h4 id="digestive-functors">Digestive Functors</h4>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install digestive-functors digestive-functors-blaze</code></pre></div>
<p>Digestive functors solve the very mundane but mechanical task of validating forms. The library provides a way to specify views and validation logic and handle the control flow of validation between the end-user and the server. There are several backends to render the form and handle request/response cycles depending on your choice of framework For arbitrary reasons we’ll choose Happstack for this example.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install digestive-functors-happstack</code></pre></div>
<p>We’ll build a simple signup page with username and email validation logic.</p>
<div class="figure">
<img src="http://www.stephendiehl.com/images/functorform.png" alt />

</div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Data.Maybe</span>
<span class="kw">import </span><span class="dt">Text.Printf</span>
<span class="kw">import </span><span class="dt">Control.Applicative</span>
<span class="kw">import </span><span class="dt">Data.Text</span> (<span class="dt">Text</span>, find, splitOn)

<span class="kw">import </span><span class="dt">Text.Digestive</span>
<span class="kw">import </span><span class="dt">Text.Digestive.Happstack</span>
<span class="kw">import </span><span class="dt">Text.Digestive.Blaze.Html5</span>
<span class="kw">import qualified</span> <span class="dt">Text.Blaze.Html5</span> <span class="kw">as</span> <span class="dt">H</span>

<span class="kw">import qualified</span> <span class="dt">Happstack.Server</span> <span class="kw">as</span> <span class="dt">HS</span>

<span class="kw">data</span> <span class="dt">User</span> <span class="fu">=</span> <span class="dt">User</span>
    {<span class="ot"> userName ::</span> <span class="dt">Text</span>
    ,<span class="ot"> userMail ::</span> <span class="dt">Text</span>
    } <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="ot">userForm ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Form</span> <span class="dt">Text</span> m <span class="dt">User</span>
userForm <span class="fu">=</span> <span class="dt">User</span>
  <span class="fu">&lt;$&gt;</span> <span class="st">&quot;name&quot;</span> <span class="fu">.:</span> check <span class="st">&quot;Name must be two words&quot;</span> checkName (text <span class="dt">Nothing</span>)
  <span class="fu">&lt;*&gt;</span> <span class="st">&quot;email&quot;</span> <span class="fu">.:</span> check <span class="st">&quot;Not a valid email address&quot;</span> checkEmail (text <span class="dt">Nothing</span>)

<span class="ot">checkEmail ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
checkEmail <span class="fu">=</span> isJust <span class="fu">.</span> find (<span class="fu">==</span> <span class="ch">'@'</span>)

<span class="ot">checkName ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
checkName s <span class="fu">=</span> length (splitOn <span class="st">&quot; &quot;</span> s) <span class="fu">==</span> <span class="dv">2</span>

<span class="ot">signupView ::</span> <span class="dt">View</span> <span class="dt">H.Html</span> <span class="ot">-&gt;</span> <span class="dt">H.Html</span>
signupView view <span class="fu">=</span> form view <span class="st">&quot;/&quot;</span> <span class="fu">$</span> <span class="kw">do</span>

    label     <span class="st">&quot;name&quot;</span> view <span class="st">&quot;Full Name:&quot;</span>
    inputText <span class="st">&quot;name&quot;</span> view
    H.br

    label     <span class="st">&quot;email&quot;</span> view <span class="st">&quot;Email:&quot;</span>
    inputText <span class="st">&quot;email&quot;</span> view
    H.br

    childErrorList <span class="st">&quot;&quot;</span> view

    inputSubmit <span class="st">&quot;Signup&quot;</span>

<span class="ot">template ::</span> <span class="dt">H.Html</span> <span class="ot">-&gt;</span> <span class="dt">H.Html</span>
template body <span class="fu">=</span> H.docTypeHtml <span class="fu">$</span> <span class="kw">do</span>
    H.head <span class="fu">$</span> H.title <span class="st">&quot;Example form:&quot;</span>
    H.body body

reply m <span class="fu">=</span> HS.ok <span class="fu">$</span> HS.toResponse <span class="fu">$</span> template m

<span class="ot">page ::</span> <span class="dt">HS.ServerPart</span> <span class="dt">HS.Response</span>
page <span class="fu">=</span> <span class="kw">do</span>
  HS.decodeBody <span class="fu">$</span> HS.defaultBodyPolicy <span class="st">&quot;/tmp/&quot;</span> <span class="dv">0</span> <span class="dv">40960</span> <span class="dv">40960</span>
  r <span class="ot">&lt;-</span> runForm <span class="st">&quot;test&quot;</span> userForm
  <span class="kw">case</span> r <span class="kw">of</span>

      (view, <span class="dt">Nothing</span>) <span class="ot">-&gt;</span> <span class="kw">do</span>
          <span class="kw">let</span> view' <span class="fu">=</span> fmap H.toHtml view
          reply <span class="fu">$</span> form view' <span class="st">&quot;/&quot;</span> (signupView view')

      (_, <span class="dt">Just</span> response) <span class="ot">-&gt;</span>
          reply <span class="fu">$</span> <span class="kw">do</span>
            H.h1 <span class="st">&quot;Form is valid.&quot;</span>
            H.p <span class="fu">$</span> H.toHtml <span class="fu">$</span> show response

<span class="ot">config ::</span> <span class="dt">HS.Conf</span>
config <span class="fu">=</span> HS.nullConf { HS.port <span class="fu">=</span> <span class="dv">5000</span> }

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  printf <span class="st">&quot;Listening on port %d\n&quot;</span> (HS.port config)
  HS.simpleHTTP config page</code></pre></div>
<h4 id="servers">Servers</h4>
<p>A great deal of effort has been put into making the <a href="http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/pubs/archive/36841.pdf">Haskell runtime</a> implement efficient event driven programming such that applications can take advantage of the Haskell threading support.</p>
<p>A simple single-threaded Hello World might be written like the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Network</span>
<span class="kw">import </span><span class="dt">Data.ByteString.Char8</span>
<span class="kw">import </span><span class="dt">System.IO</span> (hClose, hSetBuffering, <span class="dt">Handle</span>, <span class="dt">BufferMode</span>(<span class="dt">LineBuffering</span>))

msg <span class="fu">=</span> <span class="st">&quot;HTTP/1.0 200 OK\r\nContent-Length: 12\r\n\r\nHello World!\r\n&quot;</span>
 
<span class="ot">handleClient ::</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
handleClient handle <span class="fu">=</span> <span class="kw">do</span>
  hSetBuffering handle <span class="dt">LineBuffering</span>
  hGetLine handle
  hPutStrLn handle msg
  hClose handle

<span class="ot">listenLoop ::</span> <span class="dt">Socket</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
listenLoop asock <span class="fu">=</span> <span class="kw">do</span>
  (handle, _, _) <span class="ot">&lt;-</span> accept asock
  handleClient handle
  listenLoop asock
 
<span class="ot">main ::</span>  <span class="dt">IO</span> ()
main <span class="fu">=</span> withSocketsDo <span class="fu">$</span> <span class="kw">do</span>
  sock <span class="ot">&lt;-</span> listenOn <span class="fu">$</span> <span class="dt">PortNumber</span> <span class="dv">5000</span>
  listenLoop sock</code></pre></div>
<p>To make this concurrent we use the function <code>forkIO</code> which utilizes the event-driven IO manager in GHC’s runtime system to spawn lightweight user threads which are distributed across multiple system threads. When compiled with <code>-threaded</code> the Haskell standard library also will use non-blocking system calls which are scheduled by the IO manager ( with <code>epoll()</code> under the hood ) and can transparently switch to threaded scheduling for other blocking operations.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Network</span>
<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Control.Concurrent</span>
<span class="kw">import </span><span class="dt">Data.ByteString.Char8</span>
<span class="kw">import </span><span class="dt">GHC.Conc</span> (numCapabilities)
<span class="kw">import </span><span class="dt">System.IO</span> (hClose, hSetBuffering, <span class="dt">Handle</span>, <span class="dt">BufferMode</span>(<span class="dt">LineBuffering</span>))

numCores <span class="fu">=</span> numCapabilities <span class="fu">-</span> <span class="dv">1</span>

msg <span class="fu">=</span> <span class="st">&quot;HTTP/1.0 200 OK\r\nContent-Length: 12\r\n\r\nHello World!\r\n&quot;</span>
 
<span class="ot">handleClient ::</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
handleClient handle <span class="fu">=</span> <span class="kw">do</span>
  hSetBuffering handle <span class="dt">LineBuffering</span>
  hGetLine handle
  hPutStrLn handle msg
  hClose handle

<span class="ot">listenLoop ::</span> <span class="dt">Socket</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
listenLoop asock <span class="fu">=</span> <span class="kw">do</span>
  (handle, _, _) <span class="ot">&lt;-</span> accept asock
  forkIO (handleClient handle)
  listenLoop asock
 
<span class="ot">main ::</span>  <span class="dt">IO</span> ()
main <span class="fu">=</span> withSocketsDo <span class="fu">$</span> <span class="kw">do</span>
  sock <span class="ot">&lt;-</span> listenOn <span class="fu">$</span> <span class="dt">PortNumber</span> <span class="dv">5000</span>
  forM_ [<span class="dv">0</span><span class="fu">..</span>numCores] <span class="fu">$</span> \n <span class="ot">-&gt;</span>
    forkOn n (listenLoop sock)
  threadDelay maxBound</code></pre></div>
<p>This example is admittedly very simple but does illustrate that we can switch from serial to concurrent code in Haskell while still preserving sequential logic. Notably this server isn’t really doing anything terribly clever to get performance, it’s simply just spawning threads and all the heavy lifting is handled by the RTS. Yet with only a three line change the server can utilize all available cores.</p>
<p>Compiling with <code>-O2</code> and running with <code>+RTS -N4 -qm -qa</code> I get the following numbers on my Intel Core i5:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">Requests</span> per second:    12446.25 [#/sec] (mean)</code></pre></div>
<p>There are other Haskell servers which do <a href="http://www.yesodweb.com/blog/2012/11/warp-posa">much more clever things</a> such as the Warp server.</p>
<h4 id="websockets">Websockets</h4>
<p>The Warp server can utilize the async event notification system to implement asynchronous applications using <code>Control.Concurrent</code> primitives. The prime example is so called “realtime web programming” using websockets. In this example we’ll implement a chat room with a mutable MVar which synchronizes messages across all threads in the server and broadcasts messages to the clients.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install wai-websockets</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Text.Printf</span>
<span class="kw">import </span><span class="dt">Data.Text</span> (<span class="dt">Text</span>)
<span class="kw">import </span><span class="dt">Control.Concurrent</span>
<span class="kw">import </span><span class="dt">Control.Monad.IO.Class</span> (liftIO)

<span class="kw">import </span><span class="dt">Data.Aeson</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text.IO</span> <span class="kw">as</span> <span class="dt">T</span>

<span class="kw">import qualified</span> <span class="dt">Network.Wai</span>
<span class="kw">import qualified</span> <span class="dt">Network.WebSockets</span> <span class="kw">as</span> <span class="dt">WS</span>
<span class="kw">import qualified</span> <span class="dt">Network.Wai.Handler.Warp</span> <span class="kw">as</span> <span class="dt">Warp</span>
<span class="kw">import qualified</span> <span class="dt">Network.Wai.Handler.WebSockets</span> <span class="kw">as</span> <span class="dt">WaiWS</span>
<span class="kw">import </span><span class="dt">Network.Wai.Application.Static</span> (defaultFileServerSettings, staticApp)

<span class="kw">type</span> <span class="dt">Msg</span> <span class="fu">=</span> <span class="dt">Text</span>
<span class="kw">type</span> <span class="dt">Room</span> <span class="fu">=</span> [<span class="dt">Client</span>]
<span class="kw">type</span> <span class="dt">Client</span> <span class="fu">=</span> (<span class="dt">Text</span>, <span class="dt">WS.Sink</span> <span class="dt">WS.Hybi00</span>)

<span class="ot">broadcast ::</span> <span class="dt">Msg</span> <span class="ot">-&gt;</span> <span class="dt">Room</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
broadcast message clients <span class="fu">=</span> <span class="kw">do</span>
  T.putStrLn message
  forM_ clients <span class="fu">$</span> \(_, sock) <span class="ot">-&gt;</span> WS.sendSink sock <span class="fu">$</span> WS.textData message

<span class="ot">app ::</span> <span class="dt">MVar</span> <span class="dt">Room</span> <span class="ot">-&gt;</span> <span class="dt">WS.Request</span> <span class="ot">-&gt;</span> <span class="dt">WS.WebSockets</span> <span class="dt">WS.Hybi00</span> ()
app state req <span class="fu">=</span> <span class="kw">do</span>
  WS.acceptRequest req
  sock <span class="ot">&lt;-</span> WS.getSink
  msg <span class="ot">&lt;-</span> WS.receiveData
  userHandler msg sock

  <span class="kw">where</span>
    userHandler msg sock <span class="fu">=</span> <span class="kw">do</span>
      <span class="kw">let</span> client <span class="fu">=</span> (msg, sock)
      liftIO <span class="fu">$</span> T.putStrLn msg
      liftIO <span class="fu">$</span> modifyMVar_ state <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">do</span>
          <span class="kw">let</span> s' <span class="fu">=</span> client <span class="fu">:</span> s
          WS.sendSink sock <span class="fu">$</span> WS.textData <span class="fu">$</span>
              encode <span class="fu">$</span> map fst s
          return s'
      userLoop state client

<span class="ot">userLoop ::</span> <span class="dt">WS.Protocol</span> p <span class="ot">=&gt;</span> <span class="dt">MVar</span> <span class="dt">Room</span> <span class="ot">-&gt;</span> <span class="dt">Client</span> <span class="ot">-&gt;</span> <span class="dt">WS.WebSockets</span> p ()
userLoop state client <span class="fu">=</span> forever <span class="fu">$</span> <span class="kw">do</span>
  msg <span class="ot">&lt;-</span> WS.receiveData
  liftIO <span class="fu">$</span> readMVar state <span class="fu">&gt;&gt;=</span> broadcast (T.concat [fst client, <span class="st">&quot; : &quot;</span>, msg])

<span class="ot">staticContent ::</span> <span class="dt">Network.Wai.Application</span>
staticContent <span class="fu">=</span> staticApp <span class="fu">$</span> defaultFileServerSettings <span class="st">&quot;.&quot;</span>

<span class="ot">config ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">MVar</span> <span class="dt">Room</span> <span class="ot">-&gt;</span> <span class="dt">Warp.Settings</span>
config port state <span class="fu">=</span> Warp.defaultSettings
    { Warp.settingsPort <span class="fu">=</span> port
    , Warp.settingsIntercept <span class="fu">=</span> WaiWS.intercept (app state)
    }

<span class="ot">port ::</span> <span class="dt">Int</span>
port <span class="fu">=</span> <span class="dv">5000</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  state <span class="ot">&lt;-</span> newMVar []
  printf <span class="st">&quot;Starting server on port %d\n&quot;</span> port
  Warp.runSettings (config <span class="dv">5000</span> state) staticContent</code></pre></div>
<p>In the browser we can connet to our server using Javascript:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">ws <span class="op">=</span> <span class="kw">new</span> <span class="at">WebSocket</span>(<span class="st">'ws://localhost:5000'</span>)

<span class="va">ws</span>.<span class="at">onmessage</span>(<span class="kw">function</span>(msg)<span class="op">{</span><span class="va">console</span>.<span class="at">log</span>(msg)<span class="op">}</span>)<span class="op">;</span>
<span class="va">ws</span>.<span class="at">send</span>(<span class="st">'User271828'</span>)
<span class="va">ws</span>.<span class="at">send</span>(<span class="st">'My message!'</span>)</code></pre></div>
<h4 id="cloud-haskell">Cloud Haskell</h4>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cabal</span> install distributed-process distributed-process-simplelocalnet</code></pre></div>
<p>One of the most exciting projects in Haskell is a collections of projects developed under the <a href="http://haskell-distributed.github.io/">Cloud Haskell</a> metaproject. Cloud haskell brings language integrated messaging passing capability to Haskell under a very simple API which provides a foundation to build all sorts of distributed computations on top of simple actor primitives.</p>
<p>The core mechanism of action is a <code>Process</code> monad which encapsulates a actor-like computation that can exchange messages across an abstract network backend. On top of this the <code>distributed-process</code> library provides the language-integrated ability to send arbitrary Haskell functions back and forth between processes much like one can move code in Erlang, but while still persiving Haskell type-safety across the message layer. The signatures for the messaging functions are:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">send ::</span> <span class="dt">Serializable</span> a <span class="ot">=&gt;</span> <span class="dt">ProcessId</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Process</span> ()
<span class="ot">expect ::</span> forall a<span class="fu">.</span> <span class="dt">Serializable</span> a <span class="ot">=&gt;</span> <span class="dt">Process</span> a</code></pre></div>
<p>The network backend is an abstract protocol that specific libraries ( i.e. <code>distributed-process-simplelocalnet</code>) can implement to provide the transport layer indepenent of the rest of the stack. Many other protocols like TCP, IPC, and ZeroMQ can be used for the network transport.</p>
<p>The simplest possible example is a simple ping and pong between between several <code>Process</code>. Notably we don’t encode any mechanism for binary serialization of code or data since Haskell can derive these for us.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TemplateHaskell, DeriveDataTypeable, DeriveGeneric, GeneralizedNewtypeDeriving #-}</span>

<span class="kw">import </span><span class="dt">Text.Printf</span>
<span class="kw">import </span><span class="dt">Data.Binary</span>
<span class="kw">import </span><span class="dt">Data.Typeable</span>
<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">System.Environment</span> (getArgs)
<span class="kw">import </span><span class="dt">Control.Concurrent</span> (threadDelay)

<span class="kw">import </span><span class="dt">Control.Distributed.Process</span>
<span class="kw">import </span><span class="dt">Control.Distributed.Process.Closure</span>
<span class="kw">import </span><span class="dt">Control.Distributed.Process.Backend.SimpleLocalnet</span>
<span class="kw">import </span><span class="dt">Control.Distributed.Process.Node</span> (initRemoteTable,)

<span class="kw">newtype</span> <span class="dt">Message</span> <span class="fu">=</span> <span class="dt">Ping</span> <span class="dt">ProcessId</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Binary</span>, <span class="dt">Typeable</span>)

<span class="ot">pingLoop ::</span> <span class="dt">Process</span> ()
pingLoop <span class="fu">=</span> <span class="kw">do</span>
  liftIO <span class="fu">$</span> putStrLn <span class="st">&quot;Connected with master node.&quot;</span>
  forever <span class="fu">$</span> <span class="kw">do</span>
    (<span class="dt">Ping</span> remote_pid) <span class="ot">&lt;-</span> expect
    say <span class="fu">$</span> printf <span class="st">&quot;Ping from %s&quot;</span> (show remote_pid)

    local_pid <span class="ot">&lt;-</span> getSelfPid
    send remote_pid (<span class="dt">Ping</span> local_pid)

    liftIO <span class="fu">$</span> putStrLn <span class="st">&quot;Pong!&quot;</span>

remotable [ <span class="ch">'pingLoop ]</span>

<span class="ot">master ::</span> [<span class="dt">NodeId</span>] <span class="ot">-&gt;</span> <span class="dt">Process</span> ()
master peers <span class="fu">=</span> <span class="kw">do</span>
  pids <span class="ot">&lt;-</span> forM peers <span class="fu">$</span> \nid <span class="ot">-&gt;</span> <span class="kw">do</span>
      say <span class="fu">$</span> printf <span class="st">&quot;Executing remote function on %s&quot;</span> (show nid)
      spawn nid <span class="fu">$</span>(mkStaticClosure <span class="ch">'pingLoop)</span>

  local_pid <span class="ot">&lt;-</span> getSelfPid

  forever <span class="fu">$</span> <span class="kw">do</span>
    forM_ pids <span class="fu">$</span> \pid <span class="ot">-&gt;</span> <span class="kw">do</span>
      say <span class="fu">$</span> printf <span class="st">&quot;Pinging remote node %s&quot;</span> (show pid)
      send pid (<span class="dt">Ping</span> local_pid)

    forM_ pids <span class="fu">$</span> \_ <span class="ot">-&gt;</span> <span class="kw">do</span>
      (<span class="dt">Ping</span> pid) <span class="ot">&lt;-</span> expect
      say <span class="fu">$</span> printf <span class="st">&quot;Received pong from %s&quot;</span>  (show pid)

    liftIO <span class="fu">$</span> threadDelay <span class="dv">1000000</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  args <span class="ot">&lt;-</span> getArgs

  <span class="kw">let</span> host <span class="fu">=</span> <span class="st">&quot;localhost&quot;</span>
  <span class="kw">let</span> rtable <span class="fu">=</span> <span class="dt">Main</span><span class="fu">.</span>__remoteTable initRemoteTable

  <span class="kw">case</span> args <span class="kw">of</span>
    [<span class="st">&quot;master&quot;</span>, port] <span class="ot">-&gt;</span> <span class="kw">do</span>
      printf <span class="st">&quot;Starting master on %s:%s\n&quot;</span> host port
      ctx <span class="ot">&lt;-</span> initializeBackend host port rtable
      startMaster ctx master

    [<span class="st">&quot;worker&quot;</span>, port] <span class="ot">-&gt;</span> <span class="kw">do</span>
      printf <span class="st">&quot;Starting client on %s:%s\n&quot;</span> host port

      ctx <span class="ot">&lt;-</span> initializeBackend host port rtable
      startSlave ctx 

    otherwise <span class="ot">-&gt;</span> error <span class="st">&quot;Invalid arguments: master|worker &lt;port&gt;&quot;</span></code></pre></div>
<p>We can then spawn any number of instances from the shell:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">runhaskell</span> cloud.hs worker 5001
$ <span class="kw">runhaskell</span> cloud.hs worker 5002
$ <span class="kw">runhaskell</span> cloud.hs master 5003</code></pre></div>
<h4 id="conclusion">Conclusion</h4>
<p>Hopefully you feel for what exists in the ecosystem and feel slightly more empowered to use the amazing tools we have.</p>
        </div>
    </div>

    <!-- JS
    ================================================== -->
    <script src="http://code.jquery.com/jquery-1.7.1.min.js"></script>

<!-- End Document
================================================== -->
</body>
