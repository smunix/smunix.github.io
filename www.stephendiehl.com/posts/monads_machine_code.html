<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->

<!-- Mirrored from www.stephendiehl.com/posts/monads_machine_code.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 23 Dec 2016 08:27:30 GMT -->
<head>

    <!-- Basic Page Needs
  ================================================== -->
    <meta charset="utf-8">
    <title>Monads to Machine Code</title>
    <meta name="description" content="{{description}}">
    <meta name="author" content="{{author}}">

    <!-- Mobile Specific Metas
  ================================================== -->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!-- CSS
  ================================================== -->
    <link rel="stylesheet" href="../css/base.css">
    <link rel="stylesheet" href="../css/skeleton.css">
    <link rel="stylesheet" href="../css/typography.css">
    <link rel="stylesheet" href="../css/layout.css">
    <link rel="stylesheet" href="../css/syntax.css">
    <link rel="stylesheet" href="../css/custom.css">

    <link href="http://fonts.googleapis.com/css?family=Droid+Sans:400,700|Droid+Serif:400,400italic|Inconsolata" rel="stylesheet">
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <script type="text/x-mathjax-config">
    </script>

    <!-- Google Analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-49839533-1', 'stephendiehl.com');
      ga('send', 'pageview');
    </script>

    <!--[if lt IE 9]>
        <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Favicons
    ================================================== -->
    <link rel="shortcut icon" href="images/favicon.html">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.html">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.html">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.html">

    <link rel="alternate" title="Stephen Diehl" type="application/atom+xml" href="feed.html">
    <link rel="alternate" title="Stephen Diehl" type="application/rss+xml" href="feed-2.html">
</head>
<body>

    <div class="container">
        <div class="three columns sidebar">
            <nav>
                <h3 id="logo">Stephen Diehl</h3>
                <ul>
                    <li><a href="../index.html">Index</a></li>
                    <li><a href="../posts.html">Blog</a></li>
                    <li><a href="../pages/writings.html">Writings</a></li>
                    <li><a href="../pages/hire.html">Contact Me</a></li>
                    <li><a href="../pages/pgp.html">PGP Key</a></li>
                    <li><a href="https://github.com/sdiehl">Github</a></li>
                    <li><a href="https://twitter.com/#!/smdiehl">Twitter</a></li>
                </ul>
            </nav>
            &nbsp;
        </div>

        <div class="twelve columns offset-by-one content">
            <h3 id="monads-to-machine-code">Monads to Machine Code</h3>
<p>Just-in-time or JIT compilation is compilation done by dynamically generating executable code. It’s a common technique used in many language runtimes to generate optimized code for hot code paths as well ahead of time compilation for various tasks.</p>
<p>So let’s build a small LLVM-like intermediate language and JIT execution engine in Haskell. This will only function with modern Linux and x86-64 architecture, although in principle this will work on any platform if you can make the appropriate FFI calls to <code>mmap</code> and <code>mprotect</code> syscalls on your respective platform.</p>
<p>Source code is <a href="https://github.com/sdiehl/tinyjit">available here</a>.</p>
<h4 id="types">Types</h4>
<p>The x86-x64 instruction set is the 64-bit revision of x86 instruction set which was first developed for the Intel 8086 CPU family. The base types which hardware operates over are integers and floating point types. Let us just consider the integral types for now, these come in four major varieties:</p>
<p><img src="../images/bits.png" /></p>
<p>On the Intel architecture numbers are represented <em>little endian</em> meaning lower significant bytes are stored in lower memory addresses. The whole memory representation for a value is partitioned into <em>high bits</em> and <em>low bits</em>. For example the hexadecimal number <code>0xc0ffee</code> as a DWORD is stored in memory as:</p>
<p><img src="../images/coffee.png" /></p>
<p>In Haskell unboxed integral machine types are provided by the <code>Data.Word</code> <a href="https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Word.html">module</a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Word8</span>  <span class="fu">=</span> <span class="dt">W8</span><span class="fu">#</span> <span class="dt">Word</span><span class="fu">#</span>
<span class="kw">data</span> <span class="dt">Word16</span> <span class="fu">=</span> <span class="dt">W16</span><span class="fu">#</span> <span class="dt">Word</span><span class="fu">#</span>
<span class="kw">data</span> <span class="dt">Word32</span> <span class="fu">=</span> <span class="dt">W32</span><span class="fu">#</span> <span class="dt">Word</span><span class="fu">#</span>
<span class="kw">data</span> <span class="dt">Word64</span> <span class="fu">=</span> <span class="dt">W64</span><span class="fu">#</span> <span class="dt">Word</span><span class="fu">#</span></code></pre></div>
<p>Pointers are simply literal addresses to main memory, where the underlying access and storage are managed by the Linux kernel. To model this abstractly in Haskell we’ll create a datatype containing the possible values we can operate over.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Val</span>
  <span class="fu">=</span> <span class="dt">I</span> <span class="dt">Int64</span>      <span class="co">-- Integer</span>
  <span class="fu">|</span> <span class="dt">R</span> <span class="dt">Reg</span>        <span class="co">-- Register</span>
  <span class="fu">|</span> <span class="dt">A</span> <span class="dt">Word32</span>     <span class="co">-- Addr</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>To convert from Haskell types into byte sequences we’ll use the binary library to convert integral types into little endian arrays of bytes.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bytes ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [<span class="dt">Word8</span>]
bytes x <span class="fu">=</span> fmap BS.c2w bs
  <span class="kw">where</span>
    bs <span class="fu">=</span> unpack <span class="fu">$</span> runPut <span class="fu">$</span> putWord32le (fromIntegral x)</code></pre></div>
<p>For example given a hexadecimal literal this will expand it out into an array of it’s bit components.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">val <span class="fu">=</span> bytes <span class="bn">0xc0ffee</span> <span class="co">-- [238,255,192,0]</span></code></pre></div>
<h4 id="registers">Registers</h4>
<p>The x64 architecture contains sixteen general purpose 64-bit registers capable of storing a quadword. They major ones are labeled <code>rax, rbx, rcx, rdx, rbp, rsi, rdi,</code> and <code>rsp</code>.</p>
<p>Each of the registers is given a specific index (<code>r</code>), which will be used in the binary representation of specific instructions that operate over these registers.</p>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">RAX</th>
<th align="left">RBX</th>
<th align="left">RCX</th>
<th align="left">RDX</th>
<th align="left">RBP</th>
<th align="left">RSI</th>
<th align="left">RDI</th>
<th align="left">RSP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">r =</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">5</td>
<td align="left">6</td>
<td align="left">7</td>
</tr>
</tbody>
</table>
<p>Each of these registers can be addressed as a smaller register containing a subset of the lower bits. The 32-bit register of <code>rax</code> is <code>eax</code>. These are shown in the table below.</p>
<p><img src="../images/registers.png" /></p>
<p>These smaller registers are given specific names with modified prefixes.</p>
<table>
<thead>
<tr class="header">
<th align="left">64-bit</th>
<th align="left">32-bit</th>
<th align="left">16-bit</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">rax</td>
<td align="left">eax</td>
<td align="left">ax</td>
</tr>
<tr class="even">
<td align="left">rbx</td>
<td align="left">ebx</td>
<td align="left">bx</td>
</tr>
<tr class="odd">
<td align="left">rcx</td>
<td align="left">ecx</td>
<td align="left">cx</td>
</tr>
<tr class="even">
<td align="left">rdx</td>
<td align="left">edx</td>
<td align="left">dx</td>
</tr>
<tr class="odd">
<td align="left">rsp</td>
<td align="left">esp</td>
<td align="left">sp</td>
</tr>
<tr class="even">
<td align="left">rbp</td>
<td align="left">ebp</td>
<td align="left">bp</td>
</tr>
<tr class="odd">
<td align="left">rsi</td>
<td align="left">esi</td>
<td align="left">si</td>
</tr>
<tr class="even">
<td align="left">rdi</td>
<td align="left">edi</td>
<td align="left">di</td>
</tr>
<tr class="odd">
<td align="left">rip</td>
<td align="left">eip</td>
<td align="left">ip</td>
</tr>
</tbody>
</table>
<p>In Haskell we model this a sum type for each of the 64-bit registers. Consider just the 64-bit registers for now.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Reg</span>
  <span class="fu">=</span> <span class="dt">RAX</span>  <span class="co">-- Accumulator</span>
  <span class="fu">|</span> <span class="dt">RCX</span>  <span class="co">-- Counter (Loop counters)</span>
  <span class="fu">|</span> <span class="dt">RDX</span>  <span class="co">-- Data</span>
  <span class="fu">|</span> <span class="dt">RBX</span>  <span class="co">-- Base / General Purpose</span>
  <span class="fu">|</span> <span class="dt">RSP</span>  <span class="co">-- Current stack pointer</span>
  <span class="fu">|</span> <span class="dt">RBP</span>  <span class="co">-- Previous Stack Frame Link</span>
  <span class="fu">|</span> <span class="dt">RSI</span>  <span class="co">-- Source Index Pointer</span>
  <span class="fu">|</span> <span class="dt">RDI</span>  <span class="co">-- Destination Index Pointer</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>The index for each register is defined by a simple pattern match case expression.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">index<span class="ot"> ::</span> <span class="dt">Reg</span> <span class="ot">-&gt;</span> <span class="dt">Word8</span>
index x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span>
  <span class="dt">RAX</span> <span class="ot">-&gt;</span> <span class="dv">0</span>
  <span class="dt">RCX</span> <span class="ot">-&gt;</span> <span class="dv">1</span>
  <span class="dt">RDX</span> <span class="ot">-&gt;</span> <span class="dv">2</span>
  <span class="dt">RBX</span> <span class="ot">-&gt;</span> <span class="dv">3</span>
  <span class="dt">RSP</span> <span class="ot">-&gt;</span> <span class="dv">4</span>
  <span class="dt">RBP</span> <span class="ot">-&gt;</span> <span class="dv">5</span>
  <span class="dt">RSI</span> <span class="ot">-&gt;</span> <span class="dv">6</span>
  <span class="dt">RDI</span> <span class="ot">-&gt;</span> <span class="dv">7</span></code></pre></div>
<h4 id="monads">Monads</h4>
<p>Monads are an algebraic structure with two functions (<code>bind</code>) and (<code>return</code>) and three laws.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bind ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b
return<span class="ot"> ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> m a</code></pre></div>
<p>The compiler will desugar do-blocks of the form into a canonical form involving generic bind and return statements.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Int</span>
f <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> x
  b <span class="ot">&lt;-</span> y
  return (a<span class="fu">+</span>b)</code></pre></div>
<p>Is transformed into:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Int</span>
f <span class="fu">=</span> 
  bind x (\a <span class="ot">-&gt;</span> 
    bind y (\b <span class="ot">-&gt;</span> 
      return (a<span class="fu">+</span>b))</code></pre></div>
<p>Monad is implemented as a typeclass indexed by a parameter <code>m</code>, that when instantiated with a typeclass instances replaces the bind and return functions with a specific implementation of the two functions (like State or Reader).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">State</span> <span class="dt">MyState</span> <span class="dt">Int</span>
f <span class="fu">=</span> 
  bindState x (\a <span class="ot">-&gt;</span> 
    bindState y (\b <span class="ot">-&gt;</span> 
      returnState (a<span class="fu">+</span>b))</code></pre></div>
<p>The State monad is an instance of Monad with several functions for composing stateful logic.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">get ::</span> <span class="dt">State</span> s s                   <span class="co">-- get the state</span>
<span class="ot">put ::</span> s <span class="ot">-&gt;</span> <span class="dt">State</span> s ()             <span class="co">-- set the state</span>
<span class="ot">modify ::</span> (s <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">State</span> s ()   <span class="co">-- apply a function over the state</span></code></pre></div>
<p>For example a little state machine that holds a single Int value would be written like the following.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">machine ::</span> <span class="dt">State</span> <span class="dt">Int</span> <span class="dt">Int</span>
machine <span class="fu">=</span> <span class="kw">do</span>
  put <span class="dv">3</span>
  modify (<span class="fu">+</span><span class="dv">1</span>)
  get

<span class="ot">val ::</span> <span class="dt">Int</span>
val <span class="fu">=</span> execState machine <span class="dv">0</span></code></pre></div>
<p>More common would be to have the state variable <code>s</code> be a record with multiple fields that can be modified. For managing our JIT memory we’ll create a struct with the several fields.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">JITMem</span> <span class="fu">=</span> <span class="dt">JITMem</span>
 { _<span class="ot">instrs ::</span> [<span class="dt">Instr</span>]
 , _<span class="ot">mach   ::</span> [<span class="dt">Word8</span>]
 , _<span class="ot">icount ::</span> <span class="dt">Word32</span>
 , _<span class="ot">memptr ::</span> <span class="dt">Word32</span>
 , _<span class="ot">memoff ::</span> <span class="dt">Word32</span>
 } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>This will be composed into our X86 monad which will hold the JIT memory as we assemble individual machine instructions and the pointer and memory offsets for the sequence of assembled instructions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">X86</span> a <span class="fu">=</span> <span class="dt">StateT</span> <span class="dt">JITMem</span> (<span class="dt">Except</span> <span class="dt">String</span>) a</code></pre></div>
<h4 id="jit-memory">JIT Memory</h4>
<p>To start creating the JIT we first need to create a block of memory with executable permissions. Inside of <a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=bits/mman.h;h=1d9f6f8d9caba842983f98ff2f2dd5a776df054c;hb=HEAD#l32">C runtime</a> we can get the flags needed to be passed to the various <code>mmap</code> syscall to create the necessary memory block.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define PROT_NONE       0x00    </span><span class="co">/* No access.  */</span>
<span class="ot">#define PROT_READ       0x04    </span><span class="co">/* pages can be read */</span>
<span class="ot">#define PROT_WRITE      0x02    </span><span class="co">/* pages can be written */</span>
<span class="ot">#define PROT_EXEC       0x01    </span><span class="co">/* pages can be executed */</span>

<span class="ot">#define MAP_FILE        0x0001  </span><span class="co">/* mapped from a file or device */</span>
<span class="ot">#define MAP_ANON        0x0002  </span><span class="co">/* allocated from memory, swap space */</span>
<span class="ot">#define MAP_TYPE        0x000f  </span><span class="co">/* mask for type field */</span></code></pre></div>
<p>Then we simply allocate a given block of memory off the Haskell heap via mmap with the executable flags.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">MmapOption</span> <span class="fu">=</span> <span class="dt">MmapOption</span> <span class="dt">CInt</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Ord</span>, <span class="dt">Num</span>, <span class="dt">Bits</span>)

protExec    <span class="fu">=</span> <span class="dt">ProtOption</span> <span class="bn">0x01</span>
protWrite   <span class="fu">=</span> <span class="dt">ProtOption</span> <span class="bn">0x02</span>
mmapAnon    <span class="fu">=</span> <span class="dt">MmapOption</span> <span class="bn">0x20</span>
mmapPrivate <span class="fu">=</span> <span class="dt">MmapOption</span> <span class="bn">0x02</span>

<span class="ot">allocateMemory ::</span> <span class="dt">CSize</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Ptr</span> <span class="dt">Word8</span>)
allocateMemory size <span class="fu">=</span> mmap nullPtr size pflags mflags (<span class="fu">-</span><span class="dv">1</span>) <span class="dv">0</span>
  <span class="kw">where</span>
    pflags <span class="fu">=</span> protRead <span class="fu">&lt;&gt;</span> protWrite
    mflags <span class="fu">=</span> mapAnon <span class="fu">.|.</span> mapPrivate</code></pre></div>
<p>Haskell pointers can be passed to our JIT’d code by simply casting them into their respective addresses on the Haskell heap.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">heapPtr ::</span> <span class="dt">Ptr</span> a <span class="ot">-&gt;</span> <span class="dt">Word32</span>
heapPtr <span class="fu">=</span> fromIntegral <span class="fu">.</span> ptrToIntPtr</code></pre></div>
<p>For example if we want allocate a null-terminated character array and pass a pointer to it’s memory to our JIT’d code we can write down a <code>asciz</code> to synthesize this memory from a Haskell string and grab the heap pointer.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">asciz ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Word32</span>
asciz str <span class="fu">=</span> <span class="kw">do</span>
  ptr <span class="ot">&lt;-</span> newCString (str <span class="fu">++</span> [<span class="ch">'\n'</span>])
  return <span class="fu">$</span> heapPtr ptr</code></pre></div>
<p>For C functions we simply use the dynamic linker to grab the function pointer the given symbol in the memory space of the process. The Haskell runtime links against glibc’s <code>stdio.h</code> and <code>math.h</code> so these symbols will all be floating around in memory.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">extern ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Word32</span>
extern name <span class="fu">=</span> <span class="kw">do</span>
  dl <span class="ot">&lt;-</span> dlopen <span class="st">&quot;&quot;</span> [<span class="dt">RTLD_LAZY</span>, <span class="dt">RTLD_GLOBAL</span>]
  fn <span class="ot">&lt;-</span> dlsym dl name
  return <span class="fu">$</span> heapPtr <span class="fu">$</span> castFunPtrToPtr fn</code></pre></div>
<p>When we’ve compiled our byte vector of machine code we’ll copy into executable memory.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">jit ::</span> <span class="dt">Ptr</span> <span class="dt">Word8</span> <span class="ot">-&gt;</span> [<span class="dt">Word8</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IO</span> <span class="dt">Int</span>)
jit mem machCode <span class="fu">=</span> <span class="kw">do</span>
  code <span class="ot">&lt;-</span> codePtr machCode
  withForeignPtr (vecPtr code) <span class="fu">$</span> \ptr <span class="ot">-&gt;</span> <span class="kw">do</span>
    copyBytes mem ptr (<span class="dv">8</span><span class="fu">*</span><span class="dv">6</span>)
  return (getFunction mem)</code></pre></div>
<p>Then we’ll use the FFI to synthesize a function pointer to the memory and invoke it.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class="kw">import </span>ccall &quot;dynamic&quot;
<span class="ot">  mkFun ::</span> <span class="dt">FunPtr</span> (<span class="dt">IO</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int</span>

<span class="ot">getFunction ::</span> <span class="dt">Ptr</span> <span class="dt">Word8</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int</span>
getFunction mem <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> fptr <span class="fu">=</span> unsafeCoerce<span class="ot"> mem ::</span> <span class="dt">FunPtr</span> (<span class="dt">IO</span> <span class="dt">Int</span>)
  mkFun fptr</code></pre></div>
<h4 id="assembly">Assembly</h4>
<p>Before we start manually populating our executable code with instructions, let’s look at <em>assembly</em> form of what we’ll write and create a small little DSL in Haskell make this process closer to the problem domain. Assembly is the intermediate human readable representation of machine code. Both clang and gcc are capable of dumping out this representation before compilation. For example for the following C program takes two integers passed in registers, multiplies them respectively and adds the result.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> f(<span class="dt">int</span> x, <span class="dt">int</span> y)
{
    <span class="kw">return</span> (x*x)^y;
}</code></pre></div>
<p>Internally the C compiler is condensing the Destructuring the expressions into a linear sequence instructions storing the intermediate results in scratch registers and writing the end computed result to return register. It then selects appropriate machine instruction for each of the abstract operations.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// pseudocode for intermediate C representation</span>
<span class="dt">int</span> f() {
    <span class="dt">int</span> x = <span class="dt">register</span>(rdi); 
    <span class="dt">int</span> y = <span class="dt">register</span>(rsi); 
    <span class="dt">int</span> tmp1 = x*x;
    <span class="dt">int</span> tmp2 = tmp1^y;
    <span class="kw">return</span> tmp2;
}</code></pre></div>
<p>We can output the assembly to a file <code>add.s</code>. We’ll use the Intel Syntax which puts the destination operand before other operands. The alternate AT&amp;T syntax reverses this convention.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">clang</span> -O2 -S --x86-asm-syntax=intel xor.c</code></pre></div>
<p>The generated code will resemble the following. Notice that there are two kinds of statements: <em>directives</em> and <em>instructions</em>. Directive are prefixed with a period while instructions are an operation together with a list operands. Statements of instructions are grouped into labeled blocks are suffixed with a colon for example <code>f:</code> is the label containing the logic for the function <code>f</code>.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl">        .file   <span class="kw">&quot;</span><span class="st">xor.c</span><span class="kw">&quot;</span>
        .text
        .globl  f
        .type   f, <span class="dt">@function</span>
        .intel_syntax noprefix
f:
        mov     eax, edi
        imul    eax, edi
        xor     eax, esi
        ret</code></pre></div>
<p>The assembler will then turn this sequence of instructions into either an executable or an object file containing the generated machine code. To disassemble the output we can use objdump to view the hex sequence of machine instructions and the offsets within the file.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">objdump</span> -M intel -d xor.o

<span class="kw">xor</span>:     file format elf64-x86-64

<span class="kw">Disassembly</span> of section .text:

<span class="kw">0000000000000000</span> <span class="kw">&lt;</span>f<span class="kw">&gt;</span>:
   <span class="kw">0</span>:	89 f8                	mov    eax,edi
   <span class="kw">2</span>:	0f af c7             	imul   eax,edi
   <span class="kw">5</span>:	31 f0                	xor    eax,esi
   <span class="kw">7</span>:	c3                   	ret   </code></pre></div>
<p>The compiled program in memory is then a contiguous array of bytes, which is evaluated by moving the instruction pointer at the start address.</p>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="dv">89</span> f8 0f af c7 <span class="dv">31</span> f0 c3</code></pre></div>
<h4 id="instructions">Instructions</h4>
<p>Instructions consist of two parts, an <em>opcode</em> and a set of <em>operands</em> which specify labels, registers, or addresses to memory which the CPU will execute over for the give instruction. We’ll consider a subset of interesting operations which operate over integers and manipulate the call stack.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Instr</span>
  <span class="fu">=</span> <span class="dt">Ret</span>
  <span class="fu">|</span> <span class="dt">Mov</span> <span class="dt">Val</span> <span class="dt">Val</span>
  <span class="fu">|</span> <span class="dt">Add</span> <span class="dt">Val</span> <span class="dt">Val</span>
  <span class="fu">|</span> <span class="dt">Sub</span> <span class="dt">Val</span> <span class="dt">Val</span>
  <span class="fu">|</span> <span class="dt">Mul</span> <span class="dt">Val</span>
  <span class="fu">|</span> <span class="dt">IMul</span> <span class="dt">Val</span> <span class="dt">Val</span>
  <span class="fu">|</span> <span class="dt">Xor</span> <span class="dt">Val</span> <span class="dt">Val</span>
  <span class="fu">|</span> <span class="dt">Inc</span> <span class="dt">Val</span>
  <span class="fu">|</span> <span class="dt">Dec</span> <span class="dt">Val</span>
  <span class="fu">|</span> <span class="dt">Push</span> <span class="dt">Val</span>
  <span class="fu">|</span> <span class="dt">Pop</span> <span class="dt">Val</span>
  <span class="fu">|</span> <span class="dt">Call</span> <span class="dt">Val</span>
  <span class="fu">|</span> <span class="dt">Loop</span> <span class="dt">Val</span>
  <span class="fu">|</span> <span class="dt">Nop</span>
  <span class="fu">|</span> <span class="dt">Syscall</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>To add to the JIT memory we’ll simply modify the state by appending an instruction to the <code>_mach</code> field and adjusting the memory offset pointer by the length of instructions added.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">emit ::</span> [<span class="dt">Word8</span>] <span class="ot">-&gt;</span> <span class="dt">X86</span> ()
emit i <span class="fu">=</span> modify <span class="fu">$</span> \s <span class="ot">-&gt;</span> s
  { _mach   <span class="fu">=</span> _mach s <span class="fu">++</span> i
  , _memoff <span class="fu">=</span> _memoff s <span class="fu">+</span> fromIntegral (length i)
  }</code></pre></div>
<h4 id="operands">Operands</h4>
<p><strong>Registers</strong></p>
<p>Registers are identified as lowercase (i.e. <code>rbp</code>, <code>rsp</code>). In our expression builder we’ll simply write down several functions which construct a register value type from an underlying Reg value.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rax ::</span> <span class="dt">Val</span>
rax <span class="fu">=</span> <span class="dt">R</span> <span class="dt">RAX</span>

<span class="ot">rsi ::</span> <span class="dt">Val</span>
rsi <span class="fu">=</span> <span class="dt">R</span> <span class="dt">RSI</span></code></pre></div>
<p><strong>Immediate Operands</strong></p>
<p>Immediate operands are direct references to constants (literals or memory addresses) or labels. For example:</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl">add    eax,<span class="dv">42</span>
add    eax,<span class="bn">0xff</span></code></pre></div>
<p>For immediate values we simply push the array of bytes for the number directly on the byte sequence.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">imm ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">X86</span> ()
imm <span class="fu">=</span> emit <span class="fu">.</span> bytes</code></pre></div>
<h4 id="opcodes">Opcodes</h4>
<p>The full instruction set for x86 is vast and including AVX, SSE and other specialized intrinsics there is an extraordinary amount of complexity and quirky specifications. Each of these abstract instructions can have multiple opcodes for each type of operands it may take. For example the <code>mov</code> instruction for register to register movement has opcode <code>0x89</code> while moving immediate data into a register has opcode <code>0xC7</code>.</p>
<p>The reference for the most common operations the <a href="http://ref.x86asm.net/coder64.html">x86asm.net</a> site has a very useful quick reference. For the full set of possible instructions on your modern Intel processor refer to the 1500 page <a href="https://www-ssl.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf">Intel Software Developer’s Manual</a>.</p>
<p>To lookup the numerical opcodes for a given instructions, we use a specific naming conventions for the operands.</p>
<table>
<thead>
<tr class="header">
<th align="left">Prefix</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>r&lt;size&gt;</code></td>
<td align="left">Register Operand</td>
</tr>
<tr class="even">
<td align="left"><code>imm&lt;size&gt;</code></td>
<td align="left">Immediate Operand</td>
</tr>
<tr class="odd">
<td align="left"><code>m&lt;size&gt;</code></td>
<td align="left">Memory Operand</td>
</tr>
</tbody>
</table>
<p>So for example:</p>
<table>
<thead>
<tr class="header">
<th align="left">Prefix</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>r64</code></td>
<td align="left">64 bit register</td>
</tr>
<tr class="even">
<td align="left"><code>imm8</code></td>
<td align="left">8 immediate operand</td>
</tr>
<tr class="odd">
<td align="left"><code>m32</code></td>
<td align="left">32 memory operand</td>
</tr>
</tbody>
</table>
<p>For opcodes that operate over a set of possible operands, these are demarcated with a slash, in the form <code>r8/r16/r32</code>.</p>
<p>For our limited set of instructions there are two types of opcodes.</p>
<ol style="list-style-type: decimal">
<li>1-Byte Opcodes</li>
<li>2-Byte Opcodes</li>
</ol>
<table>
<thead>
<tr class="header">
<th align="left">Instruction</th>
<th align="left">Opcode</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">CALL</td>
<td align="left">E8</td>
</tr>
<tr class="even">
<td align="left">RET</td>
<td align="left">C3</td>
</tr>
<tr class="odd">
<td align="left">NOP</td>
<td align="left">0D</td>
</tr>
<tr class="even">
<td align="left">MOV</td>
<td align="left">89</td>
</tr>
<tr class="odd">
<td align="left">PUSH</td>
<td align="left">50</td>
</tr>
<tr class="even">
<td align="left">POP</td>
<td align="left">58</td>
</tr>
<tr class="odd">
<td align="left">LOOP</td>
<td align="left">E2</td>
</tr>
<tr class="even">
<td align="left">ADD</td>
<td align="left">83</td>
</tr>
<tr class="odd">
<td align="left">SUB</td>
<td align="left">29</td>
</tr>
<tr class="even">
<td align="left">MUL</td>
<td align="left">F7</td>
</tr>
<tr class="odd">
<td align="left">DIV</td>
<td align="left">F7</td>
</tr>
<tr class="even">
<td align="left">INC</td>
<td align="left">FF</td>
</tr>
<tr class="odd">
<td align="left">DEC</td>
<td align="left">FF</td>
</tr>
<tr class="even">
<td align="left">NEG</td>
<td align="left">F7</td>
</tr>
<tr class="odd">
<td align="left">CMP</td>
<td align="left">39</td>
</tr>
<tr class="even">
<td align="left">AND</td>
<td align="left">21</td>
</tr>
<tr class="odd">
<td align="left">OR</td>
<td align="left">09</td>
</tr>
<tr class="even">
<td align="left">XOR</td>
<td align="left">31</td>
</tr>
<tr class="odd">
<td align="left">NOT</td>
<td align="left">F7</td>
</tr>
<tr class="even">
<td align="left">ADC</td>
<td align="left">11</td>
</tr>
<tr class="odd">
<td align="left">IDIV</td>
<td align="left">F7</td>
</tr>
<tr class="even">
<td align="left">IMUL</td>
<td align="left">F7</td>
</tr>
<tr class="odd">
<td align="left">XCHG</td>
<td align="left">87</td>
</tr>
<tr class="even">
<td align="left">BSWAP</td>
<td align="left">C8</td>
</tr>
<tr class="odd">
<td align="left">SHR</td>
<td align="left">C1</td>
</tr>
<tr class="even">
<td align="left">SHL</td>
<td align="left">C1</td>
</tr>
<tr class="odd">
<td align="left">ROR</td>
<td align="left">C0</td>
</tr>
<tr class="even">
<td align="left">RCR</td>
<td align="left">C0</td>
</tr>
<tr class="odd">
<td align="left">BT</td>
<td align="left">BA</td>
</tr>
<tr class="even">
<td align="left">BTS</td>
<td align="left">BA</td>
</tr>
<tr class="odd">
<td align="left">BTR</td>
<td align="left">B3</td>
</tr>
<tr class="even">
<td align="left">JMP</td>
<td align="left">EB</td>
</tr>
<tr class="odd">
<td align="left">JE</td>
<td align="left">84</td>
</tr>
<tr class="even">
<td align="left">JNE</td>
<td align="left">85</td>
</tr>
<tr class="odd">
<td align="left">SYSCALL</td>
<td align="left">05</td>
</tr>
</tbody>
</table>
<p>On top of this opcodes may have an additional prefixes which modify the sizes of arguments involved. These were added to allow 32-bit compatibility in the transition between 32-bit and 64-bit systems and preserve the underlying opcodes of the 32-bit system. For instance the following <code>mov</code> instructions all operate over registers and perform the same action but over different sizes.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl">mov al,<span class="dv">255</span>
mov ax,<span class="dv">255</span>
mov eax,<span class="dv">255</span>
mov rax,<span class="dv">255</span></code></pre></div>
<p>But translate into different opcodes depending on size.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl">b0 ff                   mov    al,<span class="bn">0xff</span>
<span class="dv">66</span> b8 ff <span class="dv">00</span>             mov    ax,<span class="bn">0xff</span>
b8 ff <span class="dv">00</span> <span class="dv">00</span> <span class="dv">00</span>          mov    eax,<span class="bn">0xff</span>
<span class="dv">48</span> c7 c0 ff <span class="dv">00</span> <span class="dv">00</span> <span class="dv">00</span>    mov    rax,<span class="bn">0xff</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">prefix</th>
<th align="left">opcode</th>
<th align="left">data</th>
<th align="left">assembly</th>
<th align="left">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">66</td>
<td align="left">b0</td>
<td align="left">ff</td>
<td align="left">mov al, 0xff</td>
<td align="left">8-bit load</td>
</tr>
<tr class="even">
<td align="left">66</td>
<td align="left">b8</td>
<td align="left">ff 00</td>
<td align="left">mov ax, 0xff</td>
<td align="left">load with a 16-bit prefix (0x66)</td>
</tr>
<tr class="odd">
<td align="left">66</td>
<td align="left">b8</td>
<td align="left">ff 00 00 00</td>
<td align="left">mov eax, 0xff</td>
<td align="left">load with default size of 32 bits</td>
</tr>
<tr class="even">
<td align="left">48</td>
<td align="left">c7 c0</td>
<td align="left">ff 00 00 00</td>
<td align="left">mov rax, 0xff</td>
<td align="left">Sign-extended load using REX 64-bit prefix (0x48)</td>
</tr>
</tbody>
</table>
<h4 id="machine-code">Machine Code</h4>
<p>Ok, let’s look at the full structure of an instruction. It consists of several parts.</p>
<p><img src="../images/opcode.png" width="100%" /></p>
<!--
- Prefix
  - W
  - R
  - X
  - B
- Opcode
  - Opcode 1
  - Opcode 2
- ModRm
  - mod
  - reg
  - r/m
- SIB
  - scale
  - index
  - base
- Displacement Data
- Immediate Data
-->
<p>The sizes of these parts depend on the size and type of the opcode as well as prefix modifiers.</p>
<table>
<thead>
<tr class="header">
<th align="left">Prefix</th>
<th align="left">Opcode</th>
<th align="left">Mod R/M</th>
<th align="left">Scale Index Base</th>
<th align="left">Displacement</th>
<th align="left">Immediate</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1-4 bytes</td>
<td align="left">1-3 bytes</td>
<td align="left">1 Byte</td>
<td align="left">1 Byte</td>
<td align="left">1-4 Bytes</td>
<td align="left">1-4 Bytes</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>Prefix</strong></p>
<p><img src="../images/Prefix.png" /></p>
<p>The header fixes the first four bits to be constant <code>0b0100</code> while the next four bits indicate the pretense of W/R/X/B extensions.</p>
<p>The W bit modifies the operation width. The R, X and B fields extend the register encodings.</p>
<ul>
<li>REX.W – Extends the operation width</li>
<li>REX.R – Extends ModRM.reg</li>
<li>REX.X – Extends SIB.index</li>
<li>REX.B – Extends SIB.base or ModRM.r/m</li>
</ul>
<!--
```
  7                           0
+---+---+---+---+---+---+---+---+
| 0   1   0   0 | W | R | X | B |
+---+---+---+---+---+---+---+---+
```
-->
<hr />
<p><strong>ModR/M byte</strong></p>
<p><img src="../images/ModRM.png" /></p>
<p>The Mod-Reg-R/M byte determines the instruction’s operands and the addressing modes. These are several variants of addressing modes.</p>
<ol style="list-style-type: decimal">
<li>Immediate mode - operand is part of the instruction</li>
<li>Register addressing - operand contained in register</li>
<li>Direct Mode - operand field of instruction contains address of the operand</li>
<li>Register Indirect Addressing - used for addressing data arrays with offsets</li>
<li>Indexing - constant base + register</li>
<li>Indexing With Scaling - Base + Register Offset * Scaling Factor</li>
<li>Stack Addressing - A variant of register indirect with auto increment/decrement using the RSP register implicitly</li>
<li>Jump relative addressing - RIP + offset</li>
</ol>
<!--
```
+---+---+---+
|mod|reg|r/m|
+---+---+---+
```
-->
<table>
<thead>
<tr class="header">
<th align="left">mod</th>
<th align="left">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">00</td>
<td align="left">Register indirect memory addressing mode</td>
</tr>
<tr class="even">
<td align="left">01</td>
<td align="left">Indexed or base/indexed/displacement addressing mode</td>
</tr>
<tr class="odd">
<td align="left">10</td>
<td align="left">Indexed or base/indexed/displacement addressing mode + displacement</td>
</tr>
<tr class="even">
<td align="left">11</td>
<td align="left">R/M denotes a register and uses the REG field</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th align="left">reg</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">rax</td>
<td align="left">000</td>
</tr>
<tr class="even">
<td align="left">rcx</td>
<td align="left">001</td>
</tr>
<tr class="odd">
<td align="left">rdx</td>
<td align="left">010</td>
</tr>
<tr class="even">
<td align="left">rbx</td>
<td align="left">011</td>
</tr>
<tr class="odd">
<td align="left">rsp</td>
<td align="left">100</td>
</tr>
<tr class="even">
<td align="left">rbp</td>
<td align="left">101</td>
</tr>
<tr class="odd">
<td align="left">rsi</td>
<td align="left">110</td>
</tr>
<tr class="even">
<td align="left">rdi</td>
<td align="left">111</td>
</tr>
</tbody>
</table>
<p>In the case of mod = 00, 01 or 10</p>
<table>
<thead>
<tr class="header">
<th align="left">r/m</th>
<th align="left">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">000</td>
<td align="left">[BX+SI] or DISP[BX][SI]</td>
</tr>
<tr class="even">
<td align="left">001</td>
<td align="left">[BX+DI] or DISP[BX+DI]</td>
</tr>
<tr class="odd">
<td align="left">010</td>
<td align="left">[BP+SI] or DISP[BP+SI]</td>
</tr>
<tr class="even">
<td align="left">011</td>
<td align="left">[BP+DI] or DISP[BP+DI]</td>
</tr>
<tr class="odd">
<td align="left">100</td>
<td align="left">[SI] or DISP[SI]</td>
</tr>
<tr class="even">
<td align="left">101</td>
<td align="left">[DI] or DISP[DI]</td>
</tr>
<tr class="odd">
<td align="left">110</td>
<td align="left">Displacement-only or DISP[BP]</td>
</tr>
<tr class="even">
<td align="left">111</td>
<td align="left">[BX] or DISP[BX]</td>
</tr>
</tbody>
</table>
<p>For example given the following instruction that uses register direct mode and specifies the register operand in r/m.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl">mov    rbx,rax</code></pre></div>
<p>We have:</p>
<pre><code>mod   = 0b11
reg   = 0b000
r/m   = rbx
r/m   = 0b011
ModRM = 0b11000011
ModRM = 0xc3</code></pre>
<p><img src="../images/ModRM_example.png" /></p>
<hr />
<p><strong>Scale Index Base</strong></p>
<p><img src="../images/Scale.png" /></p>
<p>Scale is the factor by which index is multipled before being added to base to specify the address of the operand. Scale can have value of 1, 2, 4, or 8. If scale is not specified, the default value is 1.</p>
<!--
```
  7                           0
+---+---+---+---+---+---+---+---+
| scale |   index   |    base   |
+---+---+---+---+---+---+---+---+
```
-->
<table>
<thead>
<tr class="header">
<th align="left">scale</th>
<th align="left">factor</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0b00</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left">0b01</td>
<td align="left">2</td>
</tr>
<tr class="odd">
<td align="left">0b10</td>
<td align="left">4</td>
</tr>
<tr class="even">
<td align="left">0b11</td>
<td align="left">8</td>
</tr>
</tbody>
</table>
<p>Both the index and base refer to register in the usual index scheme.</p>
<table>
<thead>
<tr class="header">
<th align="left">scale/base</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">rax</td>
<td align="left">000</td>
</tr>
<tr class="even">
<td align="left">rcx</td>
<td align="left">001</td>
</tr>
<tr class="odd">
<td align="left">rdx</td>
<td align="left">010</td>
</tr>
<tr class="even">
<td align="left">rbx</td>
<td align="left">011</td>
</tr>
<tr class="odd">
<td align="left">rsp</td>
<td align="left">100</td>
</tr>
<tr class="even">
<td align="left">rbp</td>
<td align="left">101</td>
</tr>
<tr class="odd">
<td align="left">rsi</td>
<td align="left">110</td>
</tr>
<tr class="even">
<td align="left">rdi</td>
<td align="left">111</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="instruction-builder">Instruction Builder</h4>
<p>Moving forward we’ll create several functions mapping to X86 monadic operators which assemble instructions in the state monad. Let’s do some simple arithmetic logic first.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">arith ::</span> <span class="dt">X86</span> ()
arith <span class="fu">=</span> <span class="kw">do</span>
  mov rax (<span class="dt">I</span> <span class="dv">18</span>)
  add rax (<span class="dt">I</span> <span class="dv">4</span>)
  sub rax (<span class="dt">I</span> <span class="dv">2</span>)
  imul rax (<span class="dt">I</span> <span class="dv">2</span>)
  ret</code></pre></div>
<p>Each of these functions takes in some set of operands given by the algebraic datatype <code>Val</code> and pattern matches on the values to figure out which x86 opcode to use and how to render the values to bytes.</p>
<p><strong><code>ret</code></strong></p>
<p>The simplest cases is simply the return function which takes no operands and is a 1-bit opcode.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ret ::</span> <span class="dt">X86</span> ()
ret <span class="fu">=</span> <span class="kw">do</span>
  emit [<span class="bn">0xc3</span>]</code></pre></div>
<p><strong><code>add &lt;r64&gt; &lt;imm32&gt;</code></strong></p>
<p>Add for immediate values extends the operand with a REX.W flag to handle 64-bit immediate data.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl"><span class="dv">0</span>:  <span class="dv">48</span> <span class="dv">83</span> c0 <span class="bn">01</span>             add    rax,<span class="bn">0x1</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> <span class="dt">Val</span> <span class="ot">-&gt;</span> <span class="dt">Val</span> <span class="ot">-&gt;</span> <span class="dt">X86</span> ()
add (<span class="dt">R</span> l) (<span class="dt">I</span> r) <span class="fu">=</span> <span class="kw">do</span>
  emit [<span class="bn">0x48</span>]              <span class="co">-- REX.W prefix</span>
  emit [<span class="bn">0x05</span>]              <span class="co">-- ADD</span>
  imm r</code></pre></div>
<p><strong><code>add &lt;r64&gt; &lt;r64&gt;</code></strong></p>
<p>Register to register add uses the REX.W flag in the same manor but passes the source register in the ModRM.reg field using register direct mode. We do bitwise <code>or</code> over the mode <code>0xc0</code> and then shift 3 bits to specify the register in register index in the <code>reg</code> bits.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl"><span class="dv">0</span>:  <span class="dv">48</span> <span class="bn">01</span> e0                add    rax,rsp</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">add (<span class="dt">R</span> l) (<span class="dt">R</span> r) <span class="fu">=</span> <span class="kw">do</span>
  emit [<span class="bn">0x48</span>]              <span class="co">-- REX prefix</span>
  emit [<span class="bn">0x01</span>]              <span class="co">-- ADD</span>
  emit [<span class="bn">0xc0</span> <span class="fu">.|.</span> opcode r <span class="ot">`shiftL`</span> <span class="dv">3</span> <span class="fu">.|.</span> opcode l]</code></pre></div>
<p><strong><code>mov &lt;r64&gt;, &lt;r64&gt;</code></strong></p>
<p>Same logic applies for the mov instruction for both the register-to-register and immediate data cases.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl"><span class="dv">0</span>:  <span class="dv">48</span> <span class="dv">89</span> d8                mov    rax,rbx</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mov ::</span> <span class="dt">Val</span> <span class="ot">-&gt;</span> <span class="dt">Val</span> <span class="ot">-&gt;</span> <span class="dt">X86</span> ()
mov (<span class="dt">R</span> dst) (<span class="dt">R</span> src) <span class="fu">=</span> <span class="kw">do</span>
  emit [<span class="bn">0x48</span>]              <span class="co">-- REX.W prefix</span>
  emit [<span class="bn">0x89</span>]              <span class="co">-- MOV</span>
  emit [<span class="bn">0xC0</span> <span class="fu">.|.</span> opcode src <span class="ot">`shiftL`</span> <span class="dv">3</span> <span class="fu">.|.</span> opcode dst]</code></pre></div>
<p><strong><code>mov &lt;r64&gt;, &lt;imm32&gt;</code></strong></p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl"><span class="dv">0</span>:  <span class="dv">48</span> c7 c0 2a <span class="dv">00</span> <span class="dv">00</span> <span class="dv">00</span>    mov    rax,<span class="bn">0x2a</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">mov (<span class="dt">R</span> dst) (<span class="dt">I</span> src) <span class="fu">=</span> <span class="kw">do</span>
  emit [<span class="bn">0x48</span>]              <span class="co">-- REX.W prefix</span>
  emit [<span class="bn">0xC7</span>]              <span class="co">-- MOV</span>
  emit [<span class="bn">0xC0</span> <span class="fu">.|.</span> (opcode dst <span class="fu">.&amp;.</span> <span class="dv">7</span>)]
  imm src</code></pre></div>
<p><strong><code>inc &lt;r64&gt;</code>, <code>dec &lt;r64&gt;</code></strong></p>
<p>The inc and dec functions are slightly different in that they share the same opcode but modify the ModRM bit to specify the operation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">inc ::</span> <span class="dt">Val</span> <span class="ot">-&gt;</span> <span class="dt">X86</span>()
inc (<span class="dt">R</span> dst) <span class="fu">=</span> <span class="kw">do</span>
  emit [<span class="bn">0x48</span>]              <span class="co">-- REX prefix</span>
  emit [<span class="bn">0xFF</span>]              <span class="co">-- INC</span>
  emit [<span class="bn">0xc0</span> <span class="fu">+</span> index dst]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">dec (<span class="dt">R</span> dst) <span class="fu">=</span> <span class="kw">do</span>
  emit [<span class="bn">0x48</span>]              <span class="co">-- REX prefix</span>
  emit [<span class="bn">0xFF</span>]              <span class="co">-- DEC</span>
  emit [<span class="bn">0xc0</span> <span class="fu">+</span> (index dst <span class="fu">+</span> <span class="dv">8</span>)]</code></pre></div>
<p>Putting everything together we’ll JIT our function and call it from Haskell.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  mem <span class="ot">&lt;-</span> allocateMemory jitsize                <span class="co">-- create jit memory</span>
  <span class="kw">let</span> <span class="dt">Right</span> st <span class="fu">=</span> assemble mem arith            <span class="co">-- assemble symbolic program</span>
  fn  <span class="ot">&lt;-</span> jit mem (_mach st)                    <span class="co">-- jit compile</span>
  res <span class="ot">&lt;-</span> fn                                    <span class="co">-- call function</span>
  putStrLn <span class="fu">$</span> <span class="st">&quot;Result: &quot;</span> <span class="fu">&lt;&gt;</span> show res</code></pre></div>
<p>And running it we get the result.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">stack</span> exec example
<span class="kw">Result</span>: 40</code></pre></div>
<h4 id="jumps-loops">Jumps &amp; Loops</h4>
<p>Now let’s write some logic that uses control flow and jumps between labeled blocks of instructions. Consider the factorial function that takes the value to compute in the <code>rcx</code> register and computes the result my repeatedly multiply the <code>rax</code> until reaching one. To do this we create a block <code>.factor</code> and use the <code>loop</code> instruction.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl">factorial:
        mov rcx, <span class="dt">$5</span>
        mov rax, <span class="dt">$1</span>
.factor:
        mul rax
        loop .factor
        ret</code></pre></div>
<p>Let’s look at the machine code for this assembly. Notice that the loop instruction takes a relative address in memory <code>fc</code> (i.e. go back 4 instructions) as it’s operand.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl">00000000004004ed &lt;main&gt;:
  4004ed:       b9 <span class="bn">05</span> <span class="dv">00</span> <span class="dv">00</span> <span class="dv">00</span>          mov    ecx,<span class="bn">0x5</span>
  4004f2:       b8 <span class="bn">01</span> <span class="dv">00</span> <span class="dv">00</span> <span class="dv">00</span>          mov    eax,<span class="bn">0x1</span>

00000000004004f7 &lt;.factor&gt;:
  4004f7:       f7 e1                   mul    ecx
  4004f9:       e2 fc                   loop   4004f7 &lt;.factor&gt;
  4004fb:       c3                      ret    </code></pre></div>
<p>So let’s create a label function which simply reaches into the monad and grabs the current pointer location in the JIT memory that we’re at.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">label ::</span> <span class="dt">X86</span> <span class="dt">Val</span>
label <span class="fu">=</span> <span class="kw">do</span>
  addr <span class="ot">&lt;-</span> gets _memoff
  ptr  <span class="ot">&lt;-</span> gets _memptr
  return (<span class="dt">A</span> addr)</code></pre></div>
<p>When given an memory address, the <code>loop</code> instruction then simply emits the instruction simply emits the <code>0xE2</code> opcode and calculates the delta of the source and destination and the emits it’s value as the immediate data for the instruction.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">loop ::</span> <span class="dt">Val</span> <span class="ot">-&gt;</span> <span class="dt">X86</span>()
loop (<span class="dt">A</span> dst) <span class="fu">=</span> <span class="kw">do</span>
  emit [<span class="bn">0xE2</span>]
  src <span class="ot">&lt;-</span> gets _memoff
  ptr <span class="ot">&lt;-</span> gets _memptr
  emit [fromIntegral <span class="fu">$</span> dst <span class="fu">-</span> src]</code></pre></div>
<p>Now we’ll create the symbolic representation of this factorial assembly our in Haskell DSL and parameterize it by a Haskell integer to compute.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">factorial ::</span> <span class="dt">Int64</span> <span class="ot">-&gt;</span> <span class="dt">X86</span> ()
factorial n <span class="fu">=</span> <span class="kw">do</span>
  mov rcx (<span class="dt">I</span> n)
  mov rax (<span class="dt">I</span> <span class="dv">1</span>)
  l1 <span class="ot">&lt;-</span> label
  mul rcx
  loop l1
  ret</code></pre></div>
<p>Putting everything together we’ll JIT our function and call it from Haskell.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  mem <span class="ot">&lt;-</span> allocateMemory jitsize
  <span class="kw">let</span> <span class="dt">Right</span> st <span class="fu">=</span> assemble mem (factorial <span class="dv">5</span>)
  fn  <span class="ot">&lt;-</span> jit mem (_mach st)
  res <span class="ot">&lt;-</span> fn
  putStrLn <span class="fu">$</span> <span class="st">&quot;Result: &quot;</span> <span class="fu">&lt;&gt;</span> show res</code></pre></div>
<p>And running it we get the result.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">stack</span> exec example
<span class="kw">Result</span>: 120</code></pre></div>
<h4 id="calling-convention">Calling Convention</h4>
<p>Final task is to be able to call out of the JIT into either Haskell runtime or a given C function pointer. To do this we need to look at the <em>calling convention</em> for moving in out of other logic and setting up the registers so we can hand them off to another subroutine and restore then when we jump back. In the 64 bit <a href="http://x86-64.org/documentation/abi.pdf">System V ABI</a> calling convention, the first 5 arguments get passed in registers in order <code>rdi</code>, <code>rsi</code>, <code>rdx</code> <code>rcx</code>, <code>r8</code>, and <code>r9</code>. Subsequent arguments get passed on the stack.</p>
<p>For our call function we simply compute the delta of our given position and the address of the function we want to jump into.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">call ::</span> <span class="dt">Val</span> <span class="ot">-&gt;</span> <span class="dt">X86</span> ()
call (<span class="dt">A</span> dst) <span class="fu">=</span> <span class="kw">do</span>
  emit [<span class="bn">0xE8</span>]
  src <span class="ot">&lt;-</span> gets _memoff
  imm (dst <span class="fu">-</span> (src <span class="fu">+</span> <span class="dv">5</span>))
call _ <span class="fu">=</span> nodef</code></pre></div>
<p>Before and after we call the function we are responsible for handling it’s arguments and the push and popping the stack frame on entry and exit. On entry we call the function <em>prologue</em> and on exit we call the <em>epilogue</em>, in between lies the function logic.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prologue ::</span> <span class="dt">X86</span> ()
prologue <span class="fu">=</span> <span class="kw">do</span>
  push rbp
  mov rbp rsp

<span class="ot">epilogue ::</span> <span class="dt">X86</span> ()
epilogue <span class="fu">=</span> <span class="kw">do</span>
  pop rax
  mov rsp rbp
  pop rbp
  ret</code></pre></div>
<p>So for example let’s call out to the libc <code>printf</code> function passing a string pointer to it from inside our JIT. To do this we use <code>dlsym</code> to grab the symbol reference and then pass it as an address to the <code>call</code> instruction after pushing the string pointer on the argument stack.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">printf ::</span> <span class="dt">Word32</span> <span class="ot">-&gt;</span> <span class="dt">Word32</span> <span class="ot">-&gt;</span> <span class="dt">X86</span> ()
printf fnptr msg <span class="fu">=</span> <span class="kw">do</span>
  push rbp
  mov rbp rsp
  mov rdi (<span class="dt">A</span> msg)
  call (<span class="dt">A</span> fnptr)
  pop rbp
  mov rax (<span class="dt">I</span> <span class="dv">0</span>)
  ret</code></pre></div>
<p>Putting everything together we invoke it by grabbing the <code>printf</code> address and passing a pointer to Haskell string using our <code>asciz</code> function.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> jitsize <span class="fu">=</span> <span class="dv">256</span><span class="fu">*</span><span class="dv">1024</span>

  fn  <span class="ot">&lt;-</span> extern <span class="st">&quot;printf&quot;</span>
  msg <span class="ot">&lt;-</span> asciz <span class="st">&quot;Hello Haskell&quot;</span>
  mem <span class="ot">&lt;-</span> allocateMemory jitsize

  <span class="kw">let</span> <span class="dt">Right</span> st <span class="fu">=</span> assemble mem (printf fn msg)
  join <span class="fu">$</span> jit mem (_mach st)</code></pre></div>
<p>Running it we get our friendly greeting by reaching outside the JIT.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">stack</span> exec example
<span class="kw">Hello</span> Haskell</code></pre></div>
<p>So that’s basic JIT compilation in a nutshell.</p>
        </div>
    </div>

    <!-- JS
    ================================================== -->
    <script src="http://code.jquery.com/jquery-1.7.1.min.js"></script>

<!-- End Document
================================================== -->
</body>
