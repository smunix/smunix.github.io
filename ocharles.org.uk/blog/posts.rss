<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Inside ocharles</title>
        <link>http://ocharles.org.uk/blog</link>
        <description><![CDATA[Haskell geek. Wannabe mathematician. Electronic music fanatic.]]></description>
        <atom:link href="http://ocharles.org.uk/blog/posts.rss" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Sat, 23 Apr 2016 00:00:00 UT</lastBuildDate>
        <item>
    <title>Announcing transformers-eff</title>
    <link>http://ocharles.org.uk/blog/posts/2016-04-23-transformers-eff.html</link>
    <description><![CDATA[<p>In my <a href="../posts/2016-01-26-transformers-free-monads-mtl-laws.html">last post</a>, I spent some time discussing a few different approaches to dealing with computational effects in Haskell - namely monad transformers, free monads, and the monad transformer library. I presented an approach to systematically building <code>mtl</code>-like type classes based on the idea of lifting languages for a given effect into larger monad transformer stacks. This approach felt so mechanical to me I set about exploring a way to formalise it, and am happy to announce a new experimental library – <a href="https://hackage.haskell.org/package/transformers-eff"><code>transformers-eff</code></a>.</p>
<p><code>transformers-eff</code> takes inspiration from the work of algebraic effects and handlers, and splits each effect into composable programs for introducing effects and handlers that eliminate these effects. As the name indicates, this work is also closely related to monad transformer stacks, as they provide the implementation of the specific effects. I believe the novelty in my approach is that we can do this entirely within the system of monad transformers, and this observation makes it very convenient to create re-usable effects.</p>
<h2 id="core-api">Core API</h2>
<p>Before looking at an example, I want to start by presenting the core API. First, we have the <code>Eff</code> monad transformer:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Eff</span> (<span class="ot">f ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) (<span class="ot">m ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) (<span class="ot">a ::</span> <span class="fu">*</span>)</code></pre></div>
<p>If you squint, you’ll see that <code>Eff</code> has the familiar shape of a <em>monad transformer</em> - it transforms a given monad <code>m</code>, providing it access to effects described by <code>f</code>. As <code>Eff f m</code> is itself a monad, it’s possible to stack <code>Eff</code>s together. The type parameter <code>f</code> is used to indicate which effects this <code>Eff</code> transformer talks about.</p>
<p>Next, the library provides a way to eliminate <code>Eff</code> by <em>translating</em> it into a concrete monad transformer:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">translate ::</span> (<span class="dt">Monad</span> m,<span class="dt">Monad</span> (t m),<span class="dt">MonadTrans</span> t)
          <span class="ot">=&gt;</span> (forall x r<span class="fu">.</span> f x <span class="ot">-&gt;</span> <span class="dt">ContT</span> r (t m) x)
          <span class="ot">-&gt;</span> <span class="dt">Eff</span> f m a
          <span class="ot">-&gt;</span> t m a</code></pre></div>
<p>Translations are defined by a single function that is very similar to the type of “lifts” we saw in my previous blog post. The difference here is that the homomorphism maps into <code>ContT</code>, which allows the translation to adjust control flow. For many effects it will be enough to simply <code>lift</code> directly into this, but it can be useful to inspect the continuation, for example to build non-deterministic computations.</p>
<p>Finally, we have one type class method:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">interpret ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> m a</code></pre></div>
<p>However, this type class is fairly constrained in its instances, so you should read <code>m</code> as actually being some sort of monad transformer stack containing <code>Eff f</code>.</p>
<h2 id="examples">Examples</h2>
<p>Let’s dive in and look at some examples.</p>
<h3 id="reader-effects">Reader effects</h3>
<p>Last post we spent a lot of time looking at various representations of the reader monad, so let’s see how this looks under <code>transformers-eff</code>.</p>
<p>We already have a definition for our language, <code>r -&gt; a</code> as we saw last week. While we could work directly with this, we’ll be interpreting into <code>ReaderT</code> so I’ll use the <code>Reader</code> newtype for a little extra readibility. Given this language, we just need to write a translation into a concrete monad transformer, which will be <code>ReaderT</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">effToReaderT ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Eff</span> (<span class="dt">Reader</span> e) m a <span class="ot">-&gt;</span> <span class="dt">ReaderT</span> e m a
effToReaderT <span class="fu">=</span> translate (\r <span class="ot">-&gt;</span> lift (hoist generalize r))</code></pre></div>
<p>This is a little dense, so let’s break it down. When we call <code>translate</code>, we have to provide a function with the type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">forall a m<span class="fu">.</span> <span class="dt">Reader</span> r a <span class="ot">-&gt;</span> <span class="dt">ContT</span> _ (<span class="dt">ReaderT</span> r m) a</code></pre></div>
<p>The <code>ReaderT r m</code> part is coming from the type we gave in the call to <code>translate</code>, that is – the type of <code>effToReaderT</code>. We don’t really need to concern outselves with continuations for this effect, as reading from a fixed environment does not change the flow of control - so we’ll begin with <code>lift</code>. We now have to produce a <code>ReaderT r m a</code> from a <code>Reader r a</code>. If we notice that <code>Reader r a = ReaderT r Identity a</code>, we can make use of the tools in the <code>mmorph</code> library, which lets us map that <code>Identity</code> to any <code>m</code> via <code>hoist generalize</code>.</p>
<p>We still need a way to easily introduce these effects into our programs, and that means writing an <code>mtl</code> type class. However, the instances require almost no work on our behalf <em>and</em> we only have to provide two, making this is a very quick process:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">EffReader</span> env m <span class="fu">|</span> m <span class="ot">-&gt;</span> env <span class="kw">where</span>
<span class="ot">  liftReader ::</span> <span class="dt">Reader</span> env a <span class="ot">-&gt;</span> m a

<span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">EffReader</span> env (<span class="dt">Eff</span> (<span class="dt">Reader</span> env) m) <span class="kw">where</span>
  liftReader <span class="fu">=</span> interpret

<span class="kw">instance</span> <span class="ot">{-# OVERLAPPABLE #-}</span> <span class="dt">EffReader</span> env m <span class="ot">=&gt;</span>
           <span class="dt">EffReader</span> env (<span class="dt">Eff</span> effects m) <span class="kw">where</span>
  liftReader <span class="fu">=</span> lift <span class="fu">.</span> liftReader</code></pre></div>
<p>I then provide a user-friendly API built on this lift operation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ask ::</span> <span class="dt">EffEnv</span> e m <span class="ot">=&gt;</span> m e
ask <span class="fu">=</span> liftReader (<span class="dt">Reader</span> id)</code></pre></div>
<p>Finally, most users are probably more interested in running the effect rather than just translating it to <code>ReaderT</code>, so let’s provide a convenience function to translate and run all in one go:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runReader ::</span> <span class="dt">Eff</span> (<span class="dt">Reader</span> r) m a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> m a
runReader eff r <span class="fu">=</span> runReaderT (effToReaderT eff) r</code></pre></div>
<p>In total, the reader effect is described as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">EffReader</span> env m <span class="fu">|</span> m <span class="ot">-&gt;</span> env <span class="kw">where</span>
<span class="ot">  liftReader ::</span> <span class="dt">Reader</span> env a <span class="ot">-&gt;</span> m a

<span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">EffReader</span> env (<span class="dt">Eff</span> (<span class="dt">Reader</span> env) m) <span class="kw">where</span>
  liftReader <span class="fu">=</span> interpret

<span class="kw">instance</span> <span class="ot">{-# OVERLAPPABLE #-}</span> <span class="dt">EffReader</span> env m <span class="ot">=&gt;</span>
           <span class="dt">EffReader</span> env (<span class="dt">Eff</span> effects m) <span class="kw">where</span>
  liftReader <span class="fu">=</span> lift <span class="fu">.</span> liftReader

<span class="ot">ask ::</span> <span class="dt">EffEnv</span> e m <span class="ot">=&gt;</span> m e
ask <span class="fu">=</span> liftReader (<span class="dt">Reader</span> id)

<span class="ot">effToReaderT ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Eff</span> (<span class="dt">Reader</span> e) m a <span class="ot">-&gt;</span> <span class="dt">ReaderT</span> e m a
effToReaderT <span class="fu">=</span> translate (\r <span class="ot">-&gt;</span> lift (hoist generalize r))</code></pre></div>
<h3 id="a-logging-effect">A logging effect</h3>
<p>We also looked at a logging effect last week, and this can also be built using <code>transformers-eff</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">LoggingF</span> message a <span class="fu">=</span> <span class="dt">Log</span> message <span class="kw">deriving</span> (<span class="dt">Functor</span>)

<span class="kw">class</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">EffLog</span> message m <span class="fu">|</span> m <span class="ot">-&gt;</span> message <span class="kw">where</span>
<span class="ot">  liftLog ::</span> <span class="dt">Free</span> (<span class="dt">LoggingF</span> message) a <span class="ot">-&gt;</span> m a

<span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">EffLog</span> env (<span class="dt">Eff</span> (<span class="dt">Free</span> (<span class="dt">LoggingF</span> message)) m) <span class="kw">where</span>
  liftLog <span class="fu">=</span> interpret

<span class="kw">instance</span> <span class="ot">{-# OVERLAPPABLE #-}</span> <span class="dt">EffLog</span> env m <span class="ot">=&gt;</span>
           <span class="dt">EffLog</span> env (<span class="dt">Eff</span> effects m) <span class="kw">where</span>
  liftLog <span class="fu">=</span> lift <span class="fu">.</span> liftLog

log<span class="ot"> ::</span> <span class="dt">EffLog</span> message m <span class="ot">=&gt;</span> message <span class="ot">-&gt;</span> m ()
log <span class="fu">=</span> liftLog <span class="fu">.</span> liftF <span class="fu">.</span> <span class="dt">Log</span>

<span class="ot">runLog ::</span> (<span class="dt">MonadIO</span> m)
       <span class="ot">=&gt;</span> <span class="dt">Eff</span> (<span class="dt">Free</span> (<span class="dt">LoggingF</span> message) e) m a
       <span class="ot">-&gt;</span> (message <span class="ot">-&gt;</span> <span class="dt">IO</span> ())
       <span class="ot">-&gt;</span> m a
runLog eff <span class="fu">=</span>
  runIdentityT (translate (iterM (\(<span class="dt">Log</span> msg) <span class="ot">-&gt;</span> liftIO (io msg))))</code></pre></div>
<p>The interpretation here is given an <code>IO</code> action to perform whenever a message is logged. I could have implemented this in a few ways - perhaps lifting the whole computation into <code>ReaderT (message -&gt; IO ())</code>, but instead I have just used <code>IdentityT</code> as the target monad transformer, and added a <code>MonadIO</code> constraint onto <code>m</code>. Whenever a message is logged, we’ll directly call the given <code>IO</code> action. As you can also see, I’ve used a free monad as the source language for the effect. This example demonstrates that we are free to mix a variety of tools (here free monads, <code>MonadIO</code> and the identity transformer) in order to get the job done.</p>
<h2 id="what-does-this-approach-bring">What does this approach bring?</h2>
<h3 id="less-type-class-instances">Less type class instances</h3>
<p>We saw above that when we introduced our <code>EffLog</code> type class, it was immediately available for use along side <code>EffReader</code> effects - and we didn’t have to do anything extra! To me, this is a huge win - I frequently find myself frustrated with the amount of work required to do when composing many different projects together with <code>mtl</code>, and this is not just a theoretical frustration. To provide just one example from today, I wanted to use <code>ListT</code> with some Yesod code that required <code>MonadLogger</code>. There is obviously no <code>MonadLogger</code> instance for <code>ListT</code>, and it’s almost unsolvable to provide such an instance withoutrs/o using orphan instances - neither one of those libraries should need to depend on the other, so we’re stuck! If you stay within <code>Eff</code>, this problem doesn’t occur.</p>
<p>Many will be quick to point out that in <code>mtl</code> it doesn’t necessary make sense to have all transformers compose due to laws (despite the lack of any laws actually being stated…), and I’m curious if this is true here. In this library, due to the limitation on having to write your effectful programs based on an underlying algebra, I’m not sure it’s possible to introduce the problematic type class methods like <code>local</code> and <code>catch</code>.</p>
<h3 id="one-effect-at-a-time">One effect at a time</h3>
<p>In the <code>mtl</code> approach a single monad transformer stack might be able to deal with a whole selection of effects in one go. However, I’ve found that this can actually make it quite difficult to reason about the flow of code. To provide an example, let’s consider this small API:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">findOllie ::</span> (<span class="dt">MonadDb</span> m, <span class="dt">MonadPlus</span> m) <span class="ot">=&gt;</span> m <span class="dt">Person</span>
findOllie <span class="fu">=</span>
  <span class="kw">do</span> x <span class="ot">&lt;-</span> dbLookup (<span class="dt">PersonId</span> <span class="dv">42</span>)
     guard (personName x <span class="fu">==</span> <span class="st">&quot;Ollie&quot;</span>)
     return x

<span class="kw">type</span> <span class="dt">QueryError</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="ot">dbLookup ::</span> (<span class="dt">MonadDb</span> m, <span class="dt">MonadError</span> <span class="dt">QueryError</span> m) <span class="ot">=&gt;</span> <span class="dt">PersonId</span> <span class="ot">-&gt;</span> m <span class="dt">Person</span>

<span class="kw">data</span> <span class="dt">DbT</span> m a
<span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">DbT</span> m)
<span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadDb</span> (<span class="dt">DbT</span> m)

<span class="ot">runDb ::</span> (<span class="dt">MonadIO</span> m)<span class="ot"> ::</span> <span class="dt">DbT</span> m a <span class="ot">-&gt;</span> m a</code></pre></div>
<p>If we just try and apply <code>runDb</code> to <code>findOllie</code>, we’ll get</p>
<pre><code>runDb findOllie :: (MonadError QueryError m, MonadIO m, MonadPlus m) =&gt; m Person</code></pre>
<p>We still need to take care of <code>MonadError</code> and <code>MonadPlus</code>. For <code>MonadError</code> I’ll use <code>ExceptT</code>, and for <code>MonadPlus</code> I’ll use <code>MaybeT</code>:</p>
<pre><code>runMaybeT (runExceptT (runDb findOllie)) :: IO (Maybe (Either QueryError Person))</code></pre>
<p>Next, let’s consider a few scenarios. Firstly, the case where everything succeeds -</p>
<pre><code>&gt; runMaybeT (runExceptT (runDb findOllie))
Just (Right Person ...)</code></pre>
<p>However, that query could fail, which would cause an error</p>
<pre><code>&gt; runMaybeT (runExceptT (runDb findOllie))
Just (Left &quot;Table `person` not found&quot;)</code></pre>
<p>Still as expected. Finally, person 42 might not actually be me, in which case we get</p>
<pre><code>&gt; runMaybeT (runExceptT (runDb findOllie))
Just (Left &quot;&quot;)</code></pre>
<p>Huh? What’s happened here is that we’ve hit the <code>MonadPlus</code> instance for <code>ExceptT</code>, and because our <code>QueryError</code> is a <code>String</code> we have a <code>Monoid</code> instance, so we were given an “empty” error. This is not at all what we were expecting!</p>
<p>While this example is a contrived one, I am very nervous that this accidental choice of instances could happen deep within another section of code, for example where I expect to do some local error handling and accidentally eliminate a chance of failure that I was expecting to deal with elsewhere.</p>
<p>In <code>transformers-eff</code> this is not possible, as each <code>Eff</code> deals with one <em>and only one</em> effect at a time. This could be done with <code>mtl</code> by introducing a separate type class for failure and only adding an instance for <code>MaybeT</code>, we are working around the problem by convention, and I would much rather bake that in to the types.</p>
<h3 id="fast-code">Fast code</h3>
<p>The underlying implementation of <code>Eff</code> is built on top of continuations, and due to aggressive inlineing, GHC is able to work some serious magic. In fact, in all the benchmarks I’ve produced so far, <code>Eff</code> is as fast as <code>transformers</code>, and even comes out slightly faster in one (though within the same order of magnitude).</p>
<h3 id="compatible-with-the-rest-of-hackage">Compatible with the rest of Hackage</h3>
<p>As <code>Eff</code> is just another monad transformer, you can stack in other monad transformers. Note that by doing this you may lack the type class instances you need, so explicit <code>lift</code>ing might be necessary. I mainly expect this being useful by putting <code>Eff</code> “on the top” - for example I can use <code>Eff</code> locally with in a <code>Snap</code> monad computation, provided I eventually run back down to just <code>Snap</code>. This is the same pattern as locally using <code>transformers</code>.</p>]]></description>
    <pubDate>Sat, 23 Apr 2016 00:00:00 UT</pubDate>
    <guid>http://ocharles.org.uk/blog/posts/2016-04-23-transformers-eff.html</guid>
    <dc:creator>Oliver Charles</dc:creator>
</item>
<item>
    <title>Monad transformers, free monads, mtl, laws and a new approach</title>
    <link>http://ocharles.org.uk/blog/posts/2016-01-26-transformers-free-monads-mtl-laws.html</link>
    <description><![CDATA[<p>If you’ve been following the hot topics of Haskell over the last few years, you’ll probably have noticed a lot of energy around the concepts of effects. By effects, we are generally talking about the types of computations we traditionally express using monads in Haskell – IO, non-determinism, exceptions, and so on. I believe the main reason that this has been a popular topic is that none of the existing solutions are particularly nice. Now “nice” isn’t a particularly well defined concept, but for something to fit in well with Haskell’s philosophy we’re looking for a system that is:</p>
<ol style="list-style-type: decimal">
<li><strong>Extensible</strong>. The approach we take should be <em>open</em>, allowing us to define new effects.</li>
<li><strong>Composable</strong>. It should be possible to mix different effects with well defined, predictable behaviour.</li>
<li><strong>Efficient</strong>. We should only have to pay a minimal cost for the use of the abstraction.</li>
<li><strong>Terse</strong>. Haskell is generally not verbose, and whatever system we use should allow us to avoid excessive verbosity. The system should work with us, we should not have to work for it.</li>
</ol>
<p>I would also add in a 5th point</p>
<ol start="5" style="list-style-type: decimal">
<li><strong>Inferable</strong>. Type annotations should not be required for successful compilation.</li>
</ol>
<p>With this list in mind, what are the current solutions, and how do they measure up?</p>
<h2 id="monad-transformers">Monad Transformers</h2>
<p>Starting with the most basic, we can simply choose a concrete monad that does everything we need and work entirely in that – which is usually going to be <code>IO</code>. In a sense this is composable – certainly all programs in one monad compose together – but it’s composable in the same sense that dynamically typed languages fit together. Often choosing a single monad for each individual computation is too much, and it becomes very difficult to work out exactly what effects are being used in our individual functions: does this computation use <code>IO</code>? Will it throw exceptions? Fork threads? You don’t know without reading the source code.</p>
<p>Building a concrete monad can also be a lot of work. Consider a computation that needs access to some local state, a fixed environment and arbitrary <code>IO</code>. This has a type such as</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">M</span> a <span class="fu">=</span> <span class="dt">M</span> (<span class="dt">Environment</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (a, <span class="dt">State</span>))</code></pre></div>
<p>However, to actually interact with the rest of the Haskell ecosystem we need to define (at least) instances of <code>Functor</code>, <code>Applicative</code> and <code>Monad</code>. This is boilerplate code and entirely determined by the choice of effects – and that means we should strive to have the compiler write it for us.</p>
<p>To combat this, we can make use of monad transformers. Unlike monads, monad transformers compose, which means we can build larger monads by stacking a collection of monad transformers together. The above monad <code>M</code> can now be defined using off-the-shelf components, but crucially we can derive all the necessary type classes in one fell swoop with the <code>GeneralizedNewtypeDeriving</code> language extension</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>

<span class="kw">newtype</span> <span class="dt">M</span> a <span class="fu">=</span> <span class="dt">M</span> (<span class="dt">ReaderT</span> <span class="dt">Environment</span> (<span class="dt">StateT</span> <span class="dt">State</span> <span class="dt">IO</span>) a)
  <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Applicative</span>, <span class="dt">Monad</span>)</code></pre></div>
<p>This saves typing considerably, and is a definite improvement. We’ve achieved more of points 1 and 2 (extenability and composability) by having both programs <em>and</em> effects compose. Point 4 (terseness) is improved by the use of <code>GeneralizedNewtypeDeriving</code>. There is a slight risk in terms of efficiency, but I believe if <code>transformers</code> would just <code>INLINE</code> a few more definitions, the cost can be entirely erased. All of this code will infer as we’d expect, as we’re working entirely with explicit types</p>
<p>However, while we had to type less to <em>define</em> the effects, we have to type more to <em>use</em> the effects! If we want to access the environment for example, we can use the <code>ask</code> operation from <code>Control.Monad.Trans.Reader</code>, but we have to wrap this up in the <code>M</code> <code>newtype</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">env ::</span> <span class="dt">M</span> <span class="dt">Environment</span>
env <span class="fu">=</span> <span class="dt">M</span> ask</code></pre></div>
<p>However, if we want to retrieve the current state in the computation, we can use <code>get</code> from <code>Control.Monad.Trans.State</code>, but we also have to <code>lift</code> that into the <code>ReaderT</code> monad that is wrapping <code>StateT</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">currentState ::</span> <span class="dt">M</span> <span class="dt">State</span>
currentState <span class="fu">=</span> <span class="dt">M</span> (lift get)</code></pre></div>
<p>This is unfortunate – <code>lift</code> is mostly noise that we don’t want to be concerned with. There is also the problem in that the amount of <code>lift</code>s to perform is tied directly to the underlying definition of <code>M</code>. If I later decide I want to layer in the chance of failure (perhaps with <code>MaybeT</code>), I now have to change almost <em>all</em> code using <code>lift</code>, by adding an extra one in!</p>
<p><code>lift</code> is a mechanical operation that is determined by the type of monad transformer stack and the operation that we want to perform. As we noted, for different stacks, the amount of <code>lift</code>ing will vary, but it is determined by the type of stack. This suggests that these <code>lift</code>s could be inferred by the use of type classes, and this is the purpose of the monad transformer library – <code>mtl</code>.</p>
<h2 id="the-monad-transformer-library-mtl">The Monad Transformer Library (mtl)</h2>
<p>The <code>mtl</code> is a library consisting of type classes that abstract over the operations provided by each monad transformer. For <code>ReaderT</code>, we have the <code>ask</code> operation, and likewise for <code>StateT</code> we have <code>get</code> and <code>put</code> operations. The novelty in this library is that the instances for these type classes are defined inductively over monad transformer stacks. A subset of the instances for <code>MonadReader</code> for example, show</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">MonadReader</span> r m <span class="fu">|</span> m <span class="ot">-&gt;</span> r <span class="kw">where</span>
<span class="ot">  ask ::</span> m r

<span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadReader</span> r (<span class="dt">ReaderT</span> r m) <span class="kw">where</span>
  ask <span class="fu">=</span> Control.Monad.Trans.ReaderT.ask

<span class="kw">instance</span> (<span class="dt">MonadReader</span> r m) <span class="ot">=&gt;</span> <span class="dt">MonadReader</span> r (<span class="dt">StateT</span> s) <span class="kw">where</span>
  ask <span class="fu">=</span> lift ask</code></pre></div>
<p>We can read this as:</p>
<ul>
<li><p>a <em>base case</em> if the outermost transformer is <code>ReaderT</code>, in which case no <code>lift</code>ing has to be performed.</p></li>
<li><p>an <em>inductive case</em>, stating that <em>if</em> we know there is a <code>MonadReader</code> instance somewhere within the stack (that is, somewhere in the stack we are using <code>ReaderT</code>), then the outer monad transformer (in this case <code>StateT</code>) is also an instance of <code>MonadReader</code> by simply passing those operations through to the underlying instance via one application of <code>lift</code>.</p></li>
</ul>
<p>With these instances the lifting now becomes automatic entirely at the use of the respective operations. But not only does it become easier to use the operations, our programs also become more generic and easier to reason about. For example, while <code>env</code> previously had the type <code>M Environment</code>, it could now generalise to simply</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">env ::</span> (<span class="dt">MonadReader</span> <span class="dt">Environment</span> m) <span class="ot">=&gt;</span> m <span class="dt">Environment</span>
env <span class="fu">=</span> ask</code></pre></div>
<p>Stating that <code>env</code> is reusable in <em>any</em> computation that has access to <code>Environment</code>. This leads to both more options for composition (we’re not tied to working in <code>M</code>), but also types that are more expressive of what effects are actually being used by the computation. In this case, we didn’t use <code>StateT</code>, so we didn’t incur a <code>MonadState</code> type class constraint on <code>m</code>.</p>
<p>Type classes open up a risk of losing type inference, and the approach in <code>mtl</code> is to use functional dependencies. <code>mtl</code> makes use of functional dependencies in order to retain type inference, but this comes at a compositional cost – the selected effect proceeds by induction from the outer most monad transformer until we reach the <em>first</em> matching instance. This means that even if there are multiple possible matches, the first one encountered will be selected. The following program demonstrates this, and will fail to type check:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getTheString ::</span> <span class="dt">ReaderT</span> <span class="dt">Int</span> (<span class="dt">ReaderT</span> <span class="dt">String</span> <span class="dt">IO</span>) <span class="dt">String</span>
getTheString <span class="fu">=</span> ask</code></pre></div>
<pre><code>    Couldn't match type ‘Int’ with ‘[Char]’
    arising from a functional dependency between:
      constraint ‘MonadReader String (ReaderT Int (ReaderT String IO))’
        arising from a use of ‘ask’</code></pre>
<p>When we used <code>ask</code> induction proceeded from the outermost transformer - <code>ReaderT Int</code>. This is an instance of <code>MonadReader</code>, and due to the functional dependency will be selected even though it doesn’t contain the <code>String</code> that we’re looking for. This manifests as a type error, which can be frustrating.</p>
<p>In practice, I’m not convinced this is really a problem, but in the scenario where environments don’t match up we have a few options:</p>
<ol style="list-style-type: decimal">
<li><p>Adapt the environment with tools like <code>mapReaderT</code> or <code>magnify</code> (from <code>lens</code>).</p></li>
<li><p>Use <code>monad-classes</code> which uses a little more type level computation to allow this to work. I’m not entirely sure what the story for inference is here, but I think there <em>may</em> be a risk of less inference.</p></li>
<li><p>Forgo the functional dependencies, as in <code>mtl-unleashed</code>. In this case you really do give up type inference, and I don’t consider it a viable option (it fails to satisfy point 5 in my criteria in the intro).</p></li>
</ol>
<p>Interestingly, the generality we gained by being polymorphic over our choice of monad also opens the door to something we couldn’t do with monad transformers, which is to choose a different implementation of the type class. For example, here’s a different implementation of <code>MonadReader</code> for <code>M</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">MonadReader</span> <span class="dt">Environment</span> <span class="dt">M</span> <span class="kw">where</span>
  ask <span class="fu">=</span> <span class="kw">do</span>
    env <span class="ot">&lt;-</span> <span class="dt">M</span> ask
    liftIO (putStrLn <span class="st">&quot;Requesting environment&quot;</span>)
    liftIO (putStrLn (<span class="st">&quot;It is currently &quot;</span> <span class="fu">++</span> show env)
    return env</code></pre></div>
<p>While a slightly contrived example, we see that we now have the ability to provide a different interpretation for <code>ask</code> which makes use of the underlying <code>IO</code> in <code>M</code> by logging whenever a computation looks at the environment. This technique is even more useful when you start defining domain specific effects, as it gives you the option to provide a pure variant that uses mock data, which can be useful for unit testing.</p>
<h2 id="free-monads">Free monads</h2>
<p>Let’s move away from monad transformer stacks and see what the other options are. One option that’s getting a lot of attention is the use of <em>free monads</em>. A free monad is essentially a type of construction that adds just enough structure over some data in order to have the structure of a monad – and nothing extra. We spend our days working with monads, and the reason the approach afforded by free monads is appealing is due to the way that we build them – namely, we just specify the syntax! To illustrate this, let me the consider the almost traditional example of free monads, the syntax of “teletype” programs.</p>
<p>To begin with, I have to define the syntax of teletype programs. These programs have access to two operations - printing a line to the screen, and reading a line from the operator.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">TeletypeF</span> a <span class="fu">=</span> <span class="dt">PrintLine</span> <span class="dt">String</span> a
                 <span class="fu">|</span> <span class="dt">GetLine</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> a)
  <span class="kw">deriving</span> (<span class="dt">Functor</span>)</code></pre></div>
<p>This functor defines the syntax of our programs - namely programs that read and write to the terminal. The parameter <code>a</code> allows us to chain programs together, such as this <code>echo</code> program that prints whatever the user types:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">echo ::</span> <span class="dt">TeletypeF</span> (<span class="dt">TeletypeF</span> ())
echo <span class="fu">=</span> <span class="dt">GetLine</span> (\line <span class="ot">-&gt;</span> <span class="dt">PrintLine</span> line ())</code></pre></div>
<p>However, this is kind of messy. The free monad construction allows us to generate a monad out of this functor, which provides the following presentation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">echo ::</span> <span class="dt">Free</span> <span class="dt">TeletypeF</span> ()
echo <span class="fu">=</span> <span class="kw">do</span>
  l <span class="ot">&lt;-</span> getLine
  printLine l

getLine<span class="ot"> ::</span> <span class="dt">Free</span> <span class="dt">TeletypeF</span> <span class="dt">String</span>
getLine <span class="fu">=</span> liftF (<span class="dt">GetLine</span> id)

<span class="ot">printLine ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Free</span> <span class="dt">TeletypeF</span> ()
printLine l <span class="fu">=</span> liftF (<span class="dt">PrintLine</span> l ())</code></pre></div>
<p>This definition of <code>echo</code> looks much more like the programs we are used to writing.</p>
<p>The remaining step is to provide an interpretation of these programs, which means we can actually run them. We can interpret our teletype programs by using <code>STDOUT</code> and <code>STDIN</code> from <code>IO</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runTeletype ::</span> <span class="dt">Free</span> <span class="dt">TeletypeF</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
runTeletype <span class="fu">=</span>
  iterM (\op <span class="ot">-&gt;</span>
           <span class="kw">case</span> op <span class="kw">of</span>
             <span class="dt">GetLine</span> k <span class="ot">-&gt;</span> readLine <span class="fu">&gt;&gt;=</span> k
             <span class="dt">PrintLine</span> l k <span class="ot">-&gt;</span> putStrLn l <span class="fu">&gt;&gt;</span> k)</code></pre></div>
<p>This rather elegant separation between syntax and semantics suggests a new approach to writing programs – rather than working under a specific monad, we can instead work under a free monad for some suitable functor that encodes all the operations we can perform in our programs.</p>
<p>That said, the approach we’ve looked at so far is not particularly extensible between different classes of effects, as everything is currently required to be in a single functor. Knowing that free monads are generated by functors, we can start to look at the constructions we can perform on functors. One very nice property of functors is that given <em>any</em> two functors, we can compose them. The following functors below witness three possible ways to compose functors:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Sum</span> f g a <span class="fu">=</span> <span class="dt">InL</span> (f a) <span class="fu">|</span> <span class="dt">InR</span> (g a) <span class="kw">deriving</span> (<span class="dt">Functor</span>)
<span class="kw">data</span> <span class="dt">Product</span> f g a <span class="fu">=</span> <span class="dt">Product</span> (f a) (g a) <span class="kw">deriving</span> (<span class="dt">Functor</span>)
<span class="kw">data</span> <span class="dt">Compose</span> f g a <span class="fu">=</span> g (f a) <span class="kw">deriving</span> (<span class="dt">Functor</span>)</code></pre></div>
<p>Assuming <code>f</code> and <code>g</code> are <code>Functor</code>s, all of these are also <code>Functor</code>s - which means we can use them to build monads with <code>Free</code>.</p>
<p>The most interesting of these constructions (for our purposes) is <code>Sum</code>, which lets us choose between two different <code>Functor</code>s. Taking a more concrete example, I’ll repeat part of <a href="http://degoes.net/articles/modern-fp">John A. De Goes “Modern FP”</a> article. In this, he defines two independent functors for programs that can access files in the cloud, and another for programs that can perform basic logging.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">CloudFilesF</span> a
  <span class="fu">=</span> <span class="dt">SaveFile</span> <span class="dt">Path</span> <span class="dt">Bytes</span> a
  <span class="fu">|</span> <span class="dt">ListFiles</span> <span class="dt">Path</span> (<span class="dt">List</span> <span class="dt">Path</span> <span class="ot">-&gt;</span> a)
  <span class="kw">deriving</span> (<span class="dt">Functor</span>)

<span class="kw">data</span> <span class="dt">LoggingF</span> a
  <span class="fu">=</span> <span class="dt">Log</span> <span class="dt">Level</span> <span class="dt">String</span> a
  <span class="kw">deriving</span> (<span class="dt">Functor</span>)</code></pre></div>
<p>Both of these can now be turned into monads with <code>Free</code> as we saw before, but we can also combine both of these to write programs that have access to both the <code>CloudFilesF</code> API <em>and</em> <code>LoggingF</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">M</span> a <span class="fu">=</span> <span class="dt">Free</span> (<span class="dt">Sum</span> <span class="dt">CloudFilesF</span> <span class="dt">LoggingF</span>) a</code></pre></div>
<p>However, in order to use our previous API, we’ll have to perform another round of lifting:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- API specific to individual functors</span>
log<span class="ot"> ::</span> <span class="dt">Level</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Free</span> <span class="dt">LoggingF</span> ()
log l s <span class="fu">=</span> liftF (<span class="dt">Log</span> l s ())

<span class="ot">saveFile ::</span> <span class="dt">Path</span> <span class="ot">-&gt;</span> <span class="dt">Bytes</span> <span class="ot">-&gt;</span> <span class="dt">Free</span> <span class="dt">CloudFilesF</span> ()
saveFile p b <span class="fu">=</span> lift (<span class="dt">SaveFile</span> p b ())

<span class="co">-- A program using multiple effects</span>
<span class="ot">saveAndLog ::</span> <span class="dt">Free</span> (<span class="dt">Sum</span> <span class="dt">CloudFilesF</span> <span class="dt">LoggingF</span>) ()
saveAndLog <span class="fu">=</span> <span class="kw">do</span>
  liftLeft (log <span class="dt">Info</span> <span class="st">&quot;Saving...&quot;</span>)
  liftRight (saveFile <span class="st">&quot;/data&quot;</span> <span class="st">&quot;\0x42&quot;</span>)

<span class="co">-- Lifting operations</span>
<span class="ot">liftLeft ::</span> <span class="dt">Free</span> f a <span class="ot">-&gt;</span> <span class="dt">Free</span> (<span class="dt">Sum</span> f g) a
liftLeft <span class="fu">=</span> hoistFree <span class="dt">InL</span>

<span class="ot">liftRight ::</span> <span class="dt">Free</span> g a <span class="ot">-&gt;</span> <span class="dt">Free</span> (<span class="dt">Sum</span> f g) a
liftRight <span class="fu">=</span> hoistFree <span class="dt">InR</span></code></pre></div>
<p>This is a slightly unfortunate outcome - while we’ve witnessed that there is extensiblity, without more work the approaches don’t compose particularly well.</p>
<p>To solve the problem of having to lift everything leads us to the need for an <code>mtl</code>-like solution in the realm of free monads - that is, a system that automatically knows how to lift individual functors into our composite functor. This is essentially what’s happening in the <code>extensible-effects</code> library - as a user you define each individual <code>Functor</code>, and then <code>extensible-effects</code> provides the necessary type class magic to combine everything together.</p>
<p>We should also mention something on efficiency while we’re here. Free monads have at least two presentations that have different use cases. One of these is extremely easy to inspect (that is, write interpters) but has a costly implementation of <code>&gt;&gt;=</code>. We know how to solve this problem, but the trade off switches over to being costly to inspect. Recently, we learnt how to perform reads and binds in linear time, but the constant factors are apparently a little too high to be competative with raw <code>transformers</code>. So all in all, there is an efficiency cost of <em>just working with</em> a free monad approach.</p>
<h2 id="mtl-and-laws"><code>mtl</code> and laws</h2>
<p>I want to now return to the monad transformer library. To recap, the definition of <code>MonadReader</code> is –</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">MonadReader</span> r m <span class="fu">|</span> m <span class="ot">-&gt;</span> r <span class="kw">where</span>
<span class="ot">  ask ::</span> m r</code></pre></div>
<p>But this alone makes me a little uneasy. Why? I am in the class of Haskellers who consider a type class without a law a smell, as it leaves us unable to reason about what the type class is even doing. For example, it doesn’t require much imagination to come up with nonsense implementations of <code>ask</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">SomeM</span> a <span class="fu">=</span> <span class="dt">SomeM</span> (<span class="dt">StateT</span> <span class="dt">Int</span> <span class="dt">IO</span> a)
  <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Applicative</span>, <span class="dt">Monad</span>)

<span class="kw">instance</span> <span class="dt">MonadReader</span> <span class="dt">Int</span> <span class="dt">SomeM</span> <span class="kw">where</span>
  ask <span class="fu">=</span> <span class="dt">SomeM</span> <span class="fu">$</span> <span class="kw">do</span>
    i <span class="ot">&lt;-</span> get
    put (i <span class="fu">+</span> <span class="dv">1</span>)
    return i</code></pre></div>
<p>But then again – who’s to say this is nonsense? Given that we were never given a specification for what <code>ask</code> should do in the first place, this is actually perfectly reasonable! For this reason, I set out searching for a way to reason about <code>mtl</code>-style effects, such that we could at least get <em>some</em> laws.</p>
<h2 id="a-different-approach">A different approach</h2>
<p>The <code>transformers</code> library also give us <code>mtl</code>-like type classes, one of which is <code>MonadIO</code>. However, this type class does have laws as well:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- liftIO . return = return</span>
<span class="co">-- liftIO (f &gt;&gt;= g) = liftIO f &gt;&gt;= liftIO . g</span>
<span class="kw">class</span> <span class="dt">MonadIO</span> m <span class="kw">where</span>
<span class="ot">  liftIO ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> m a</code></pre></div>
<p>This law is an example of a <em>homomorphism</em>. To quote <a href="https://en.wikipedia.org/wiki/Homomorphism">Wikipedia on the subject</a>:</p>
<blockquote>
<p>A homomorphism is a structure-preserving map between two algebraic structures (such as groups, rings, or vector spaces).</p>
</blockquote>
<p>In this case the algebraic structure is the monad structure of <code>IO</code>. We see that any monad that is an instance of <code>MonadIO</code> has the ability to lift <code>IO</code> operations, and as this is a homomorphism, the laws state that it will preserve the underlying structure of <code>IO</code>.</p>
<p>It’s currently unclear how to apply this type of reasing to <code>MonadReader</code>, given its current definition – <code>ask</code> is just a value, it doesn’t even take an argument – so how can we even try and preserve anything?</p>
<p>Let’s take some inspiration from free monads, and consider the effect language for <code>MonadReader</code>. If we only have <code>(Monad m, MonadReader r m)</code>, then the only thing we can do on top of the normal monad operations is <code>ask</code> the environment. This suggests a suitable functor would be:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">AskF</span> r a <span class="fu">=</span> <span class="dt">Ask</span> (r <span class="ot">-&gt;</span> a)
  <span class="kw">deriving</span> (<span class="dt">Functor</span>)</code></pre></div>
<p>I can now wrap this up in <code>Free</code> in order to write programs with the ability to <code>ask</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Ask</span> r a <span class="fu">=</span> <span class="dt">Free</span> (<span class="dt">AskF</span> r) a</code></pre></div>
<p>Now we have an algebraic structure with properties (<code>Ask r</code> is a <code>Monad</code>) that we would like to preserve, so we can write this alternative form of <code>MonadReader</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- liftAsk . return = return</span>
<span class="co">-- liftAsk (f &gt;&gt;= g) = liftAsk f &gt;&gt;= liftAsk . g</span>
<span class="kw">class</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadReader</span> r m <span class="fu">|</span> m <span class="ot">-&gt;</span> r <span class="kw">where</span>
<span class="ot">  liftAsk ::</span> <span class="dt">Ask</span> r a <span class="ot">-&gt;</span> m a

<span class="ot">ask ::</span> <span class="dt">MonadReader</span> r m <span class="ot">=&gt;</span> m r
ask <span class="fu">=</span> liftAsk (liftF (<span class="dt">Ask</span> id))</code></pre></div>
<p>Et voilà! We now have an equally powerful <code>MonadReader</code> type class, except this time we have the ability to reason about it and its instances. If we return to the instance that I was questioning earlier, we can redefine it under the new API:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">MonadReader</span> <span class="dt">Int</span> <span class="dt">SomeM</span> <span class="kw">where</span>
  liftAsk askProgram <span class="fu">=</span> <span class="dt">SomeM</span> <span class="fu">$</span> <span class="kw">do</span>
    x <span class="ot">&lt;-</span> get
    out <span class="ot">&lt;-</span> iterM (\(<span class="dt">Ask</span> k) <span class="ot">-&gt;</span> return (k t)) askProgram
    put (x <span class="fu">+</span> <span class="dv">1</span>)
    return out</code></pre></div>
<p>Now that we have some laws, we can ask: is this a <em>valid</em> definition of <code>MonadReader</code>? To check, we’ll use equational reasoning. Working through the first law, we have</p>
<pre><code>liftAsk (return a)
  = { definition of return for Free }
liftAsk (Pure a)
  = { definition of liftAsk for SomeM }
SomeM $ do
  x &lt;- get
  out &lt;- iterM (\(Ask k) -&gt; return (k t)) (Pure a)
  put (x + 1)
  return out
  = { evaluate iterM for Pure a }
SomeM $ do
  x &lt;- get
  out &lt;- return a
  put (x + 1)
  return out
  = { monad laws }
SomeM $ do
  x &lt;- get
  put (x + 1)
  return a</code></pre>
<p>Already we have a problem. While we can see that this does return the original <code>a</code> it was given, it does so in a way that also incurred some side effects. That is, <code>liftAsk (return a)</code> is <em>not</em> the same as <code>return a</code>, so this isn’t a valid definition of <code>MonadReader</code>. Back to the drawing board… Now, it’s worth noting that there is an instance that <em>is</em> law abiding, but might still be considered as surprising:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">MonadReader</span> <span class="dt">Int</span> <span class="dt">SomeM</span> <span class="kw">where</span>
  liftAsk askProgram <span class="fu">=</span>
    iterM (\(<span class="dt">Ask</span> k) <span class="ot">-&gt;</span> <span class="dt">SomeM</span> <span class="fu">$</span> <span class="kw">do</span>
      x <span class="ot">&lt;-</span> get
      put (x <span class="fu">+</span> <span class="dv">1</span>)
      k x )</code></pre></div>
<p>Applying the same equational reasoning to this is much easier, and shows that the first law is satisfied</p>
<pre><code>liftAsk (return a)
  = { definition of liftAsk }
iterM (\(Ask k) -&gt; SomeM $ do
  x &lt;- get
  put (x + 1)
  k x)
  (return a)
  = { definition of return for Free }
iterM (\(Ask k) -&gt; SomeM $ do
  x &lt;- get
  put (x + 1)
  k x)
  (Pure a)
  = { definition of iterM given Pure}
return a</code></pre>
<p>For the second law, I’ll omit the proof, but I want to demonstrate to sessions in GHCI:</p>
<pre><code>&gt; let runSomeM (M m) = evalState m 0

&gt; runSomeM (liftAsk (ask &gt;&gt;= \r1 -&gt; ask &gt;&gt;= \r2 -&gt; return (r1, r2))
(1, 2)

&gt; runSomeM (liftAsk ask &gt;&gt;= \r1 -&gt; liftAsk &gt;&gt;= \r2 -&gt; return (r1, r2)
(1, 2)</code></pre>
<p>So while the answers agree - they probably don’t agree with your intuition! This is only surprising in that we have some assumption of how =Ask= programs should behave. Knowing more about =Ask=, we might seek this further law:</p>
<blockquote>
<p><code>ask &gt;&gt; ask = ask</code></p>
</blockquote>
<p>This law can also be seen as a reduction step in the classification of our <code>Ask</code> programs, but a <code>Free</code> monad is not powerful enough to capture that. Indeed, the documentation of <code>Free</code> mentions exactly this:</p>
<blockquote>
<p>A free <code>Monad</code> is one that does no work during the normalisation step beyond simply grafting the two monadic values together. <code>[]</code> is not a free <code>Monad</code> (in this sense) because <code>join [[a]]</code> smashes the lists flat.</p>
</blockquote>
<p>The law <code>ask &gt;&gt; ask = ask</code> follows by normalisation of our “reader” programs, so a free monad will be unable to capture that by construction – the best we can do is add an extra law to our type class. However, what we can also do is play a game of <a href="http://gallium.inria.fr/blog/lawvere-theories-and-monads/">normalisation by evaluation</a>. First, we write an evaluator for <code>Free (AskF r)</code> programs:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runAsk ::</span> <span class="dt">Free</span> (<span class="dt">AskF</span> r) a <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> a)
runAsk f r <span class="fu">=</span> iterM (\(<span class="dt">AskF</span> k) <span class="ot">-&gt;</span> k r) f</code></pre></div>
<p>and then witness that we can reify these <code>r -&gt; a</code> terms back into <code>Free (Ask r) a</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">reify ::</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Free</span> (<span class="dt">Ask</span> r) a
reify <span class="fu">=</span> <span class="dt">AskF</span></code></pre></div>
<p>You should also convince yourself that <code>(r -&gt; a)</code> really is a normal form, and you may find the above linked article on this useful for formal proofs (search for “normalisation”). What we’ve essentially shown is that <em>every</em> <code>Free (AskF r) a</code> program can be expressed as a single <code>r -&gt; a</code> function. The normal form of <code>ask &gt;&gt; ask</code> is now - by definition - a single <code>ask</code>, which is the law we were originally having to state.</p>
<p>As we’ve witnessed that <code>r -&gt; a</code> is the normal form of <code>Free (AskF r) a</code>, this suggests that we could just as well write:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- liftAsk . return = return</span>
<span class="co">-- liftAsk (f &gt;&gt;= g) = liftAsk f &gt;&gt;= liftAsk . g</span>
<span class="kw">class</span> <span class="dt">MonadReader</span> r m <span class="fu">|</span> m <span class="ot">-&gt;</span> r <span class="kw">where</span>
<span class="ot">  liftAsk ::</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> m a</code></pre></div>
<p>(The structure being preserved by the homomorphism is assuming that <code>(r -&gt; a)</code> is a reader monad).</p>
<p>Our strange instance now becomes</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">MonadReader</span> <span class="dt">UTCTime</span> <span class="dt">SomeM</span> <span class="kw">where</span>
  liftAsk f <span class="fu">=</span> <span class="dt">SomeM</span> <span class="fu">$</span> <span class="kw">do</span>
    x <span class="ot">&lt;-</span> get
    put (x <span class="fu">+</span> <span class="dv">1</span>)
    return (f x)</code></pre></div>
<p>With a little scrutiny, we can see that this is not going to satisfy the homomorphism laws. Not only does it fail to satisfy the <code>return</code> law (for the same reason), the second law states that <code>liftAsk (f &gt;&gt;= g) = liftAsk f &gt;&gt;= liftAsk . g</code>. Looking at our implementation this would mean that we would have to increase the state based on the amount of binds performed in <code>f &gt;&gt;= g</code>. However, we also know that <code>&gt;&gt;=</code> for <code>r -&gt; a</code> simply reduces to another <code>r -&gt; a</code> function - the implication being that it’s impossible to know how many binds were performed.</p>
<p>Here a counter example will help convince us that the above is wrong. First, we know</p>
<blockquote>
<p><code>liftAsk (ask &gt;&gt; ask) = liftAsk ask</code></p>
</blockquote>
<p>because <code>ask &gt;&gt; ask = ask</code> by definition.</p>
<p>By the homomorphism laws, we must also have</p>
<blockquote>
<p><code>liftAsk (ask &gt;&gt; ask) = liftAsk ask &gt;&gt; liftAsk ask</code></p>
</blockquote>
<p>Combining these, we expect</p>
<blockquote>
<p><code>liftAsk ask = liftAsk (ask &gt;&gt; ask) = liftAsk ask &gt;&gt; liftAsk ask</code></p>
</blockquote>
<p>However…</p>
<pre><code>&gt; runSomeM (liftAsk ask)
1

&gt; runSomeM (liftAsk (ask &gt;&gt; ask))
1

&gt; runSomeM (liftAsk ask &gt;&gt; liftAsk ask)
2</code></pre>
<p>Now we can see that <code>SomeM</code>’s current definition of <code>MonadReader</code> fails. It’s much harder to write a law abiding form of <code>MonadReader Int SomeM</code> - but it will essentially require some <em>fixed</em> data throughout the scope of the computation. The easiest is of course to change the definition of <code>SomeM</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">SomeM</span> a <span class="fu">=</span> <span class="dt">SomeM</span> (<span class="dt">ReaderT</span> <span class="dt">Int</span> <span class="dt">IO</span> a)

<span class="kw">instance</span> <span class="dt">MonadReader</span> <span class="dt">UTCTime</span> <span class="dt">SomeM</span> <span class="kw">where</span>
  liftAsk f <span class="fu">=</span> <span class="dt">SomeM</span> (fmap f ask)</code></pre></div>
<p>You should convince yourself that this instance is now law abiding - for example by considering the above counter-example, or by performing equational reasoning.</p>
<h2 id="a-pattern-for-effect-design">A pattern for effect design</h2>
<p>The process we underwent to reach the new form of a =MonadReader= type class, extends well to many different type classes and suggests a new pattern for <code>mtl</code>-like type class operations. Here’s a rough framework that I’m having a lot of success with:</p>
<h3 id="define-the-operations-as-data">1. Define the operations as data</h3>
<p>To begin, think about the language that your effect will talk about. For the reader monad, we defined the <code>AskF</code> functor, and the same can be done for the exception monad, the failure monad, the state monad, and so on. For more “domain specific” operations, a free monad also scales well - one could imagine a language for interacting with general relational databases, with operations to <code>SELECT</code>, <code>UPDATE</code>, <code>DELETE</code>, and so on.</p>
<h3 id="find-a-suitable-way-to-compose-operations">2. Find a suitable way to compose operations</h3>
<p>Individual operations are not enough, we also need a way to write programs using this language. This amounts to finding a suitable way to compose these operations together. An easy first approximation is to use a free structure, again – as we started with for the reader monad. In the case of the aforementioned domain specific relational database example, the free monad might be as far as we want to go.</p>
<p>It’s also worth exploring if there is a normal form that more succinctly captures the operations in your language along with equational reasoning. We saw that the normal form of <code>Free (AskF r) a</code> was <code>r -&gt; a</code>, and the same process can be ran for <code>Free (StateF s) a</code> - reaching <code>s -&gt; (a, s)</code> as a normal form. It’s important to note that if you go through the process of normalisation by evaluation, that you also make sure you can reify your evaluation result back into the original language. To illustrate why, consider the hypothetical relational database language:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">DatabaseF</span> a <span class="fu">=</span> <span class="dt">Query</span> <span class="dt">SqlQuery</span> (<span class="dt">Results</span> <span class="ot">-&gt;</span> a)

<span class="ot">runDb ::</span> <span class="dt">Free</span> <span class="dt">DatabaseF</span> a <span class="ot">-&gt;</span> (<span class="dt">DatabaseHandle</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> a)
runDb h <span class="fu">=</span> iterM (\(<span class="dt">Query</span> q k) <span class="ot">-&gt;</span> query h q <span class="fu">&gt;&gt;=</span> k)</code></pre></div>
<p>This is fine for an interpreter, but <code>DatabaseHandle -&gt; IO a</code> is not a normal form because we can’t reify these terms <em>back</em> into <code>DatabaseF</code>. This is important, because by working with a normal form it means that you can define a whole range of interpreters that see the necessary structure of the original programs. To illustrate one problem with <code>DatabaseHandle -&gt; IO a</code>, if we attempted to write a pure interpreter, we would be unable to see which queries were performed in order to produce the data under <code>a</code> (not to mention the limitation that working in <code>IO</code> would cause).</p>
<h3 id="introduce-a-type-class-for-homomorphisms">3. Introduce a type class for homomorphisms</h3>
<p>With your effect language defined, the next step is to define a type class for homomorphisms from this effect language into larger monad stacks. Often this will be a monad homomorphism – much as we saw with <code>MonadReader</code> and <code>MonadIO</code> – but the homomorphism need not be a monad homomorphism. For example, if your source effect language is a simple monoid, then the homomorphism will be a monoid homomorphism. We’ll see an example of this shortly.</p>
<h3 id="export-polymorphic-operations">4. Export polymorphic operations</h3>
<p>With a type class of homomorphisms, we can now export a cleaner API. For <code>MonadReader</code>, this means exporting convenience <code>ask</code> operations that are defined in terms of <code>liftAsk</code> with the appropriate program in our <code>AskF</code> language.</p>
<h3 id="provide-a-reference-implementation">5. Provide a reference implementation</h3>
<p>I also suggest providing a “reference” implementation of this type class. For <code>MonadReader</code>, this reference implementation is <code>ReaderT</code>. The idea is that users can immediately take advantage of the effect we’re defining by introducing the appropriate monad transformer into their monad stack.</p>
<p>The type class allows them to more efficiently define the operations in terms of existing monadic capabilities (e.g., <code>IO</code>), but for many simply reusing a transformer will be sufficient.</p>
<h2 id="a-worked-example-for-logging">A worked example for logging</h2>
<p>To conclude this article I want to explore one more application of this pattern applied to building a logging effect. In fact, it is this very problem that motivated the research for this blog post, and so we’ll end up building the foundations of my <code>logging-effect</code> library.</p>
<p>The first step is to identify a language for programs that can perform logging. There’s not much involved here, simply the ability to append to the log at any point in time. Let’s formalise that idea with the appropriate functor:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">LoggingF</span> message a <span class="fu">=</span> <span class="dt">AppendLogMessage</span> message a
  <span class="kw">deriving</span> (<span class="dt">Functor</span>)</code></pre></div>
<p>This functor is parameterised by the type of log messages. The only constructor for <code>LoggingF</code> takes a log message and the rest of the computation to run. We could stop here and lift <code>Free (LoggingF message) a</code> programs, but I want to go a bit further and see are any other ways to express this. I’ll use normalisation by evaluation again, and see what happens.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runFreeLogging ::</span> <span class="dt">Free</span> (<span class="dt">LoggingF</span> message) a <span class="ot">-&gt;</span> (a, [message])
runFreeLogging (<span class="dt">Pure</span> a) <span class="fu">=</span> (a, [])
runFreeLogging (<span class="dt">Free</span> (<span class="dt">AppendLogMessage</span> m next)) <span class="fu">=</span>
  <span class="kw">case</span> runFreeLogging next <span class="kw">of</span>
    (a, messages) <span class="ot">-&gt;</span> (a, m<span class="fu">:</span>messages)</code></pre></div>
<p>We can also take a <code>(a, [message])</code> and turn it back into the equivalent <code>Free (LoggingF message) a</code>, so <code>(a, [message])</code> is another candidate for the language of our logging programs.</p>
<p>But this <code>a</code> bothers me. It occurs only in <code>LoggingF message</code> to capture the rest of the computation, but never does the result of logging affect the choice of what that next computation is. This suggests that it’s mostly noise, and maybe we can just erase it. This would lead us to have logging programs of the type <code>[message]</code>. This type is no longer the right kind for our lifting operation to be a monad homomorphism, which means we have to identify another algebraic structure. Well, lists are certainly a composable structure - they have all the properties of a <em>monoid</em>.</p>
<p>With that in mind, we need to consider what it means to be a monoid homomorphism into some monad. First, observe that monads also have a monoid-like operations:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">monadMempty ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> ()
monadMempty <span class="fu">=</span> return ()

<span class="ot">monadMappend ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m () <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()
monadMappend l r <span class="fu">=</span> l <span class="fu">&gt;&gt;</span> r</code></pre></div>
<p>We can now write our lifting type class with the laws of a monoid homomorphism:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">liftLog mempty   <span class="fu">=</span> mempty                 <span class="co">-- = return ()</span>
liftLog (x <span class="fu">&lt;&gt;</span> y) <span class="fu">=</span> liftLog x <span class="fu">&lt;&gt;</span> liftLog y <span class="co">-- = liftLog x &gt;&gt; liftLog y</span>
<span class="kw">class</span> <span class="dt">MonadLog</span> message m <span class="fu">|</span> m <span class="ot">-&gt;</span> message <span class="kw">where</span>
<span class="ot">  liftLog ::</span> [message] <span class="ot">-&gt;</span> m ()</code></pre></div>
<p>While we reached this type by normalisation-by-evaluation and then a little bit of fudging, there is another way we could have got here. In a sense, <code>[]</code> can be seen as another construction like <code>Free</code> - given any type <code>a</code>, <code>[a]</code> is a free monoid generated by <code>a</code>. An easier route to this type class would have been to describe the individual operations in our logging programs by:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">LoggingOp</span> message <span class="fu">=</span> <span class="dt">LogMessage</span> message</code></pre></div>
<p>and then using <code>[]</code> as our free construction. As <code>LoggingOp message</code> ~ <code>Identity message</code> ~ <code>message</code>, we know we could also use <code>[message]</code>, and we’re back at the type class above.</p>
<p>(In my <code>logging-effect</code> library I chose a slightly different representation of the free monoid. <a href="http://comonad.com/reader/2015/free-monoids-in-haskell/">Theoretically, this is a sounder way to talk about free monoids</a>, but I’m mostly interested in the slight efficiency win by not having to build up lists only to immediately deconstruct them.)</p>
<p>The last steps are to provide polymorphic operations and a reference implementation that satisfies the laws:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">logMessage ::</span> (<span class="dt">MonadLog</span> message m) <span class="ot">=&gt;</span> message <span class="ot">-&gt;</span> m ()
logMessage message <span class="fu">=</span> liftLog [message]

<span class="kw">newtype</span> <span class="dt">LoggingT</span> message m a <span class="fu">=</span> <span class="dt">LoggingT</span> (<span class="dt">ReaderT</span> (message <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) m a)

<span class="kw">instance</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">MonadLog</span> message (<span class="dt">LoggingT</span> message m) <span class="kw">where</span>
  liftLog messages <span class="fu">=</span> <span class="dt">LoggingT</span> (\dispatchLog <span class="ot">-&gt;</span> liftIO (for_ messages dispatchLog))</code></pre></div>
<p>Does this reference implementation satisfy the monoid homomorphism laws that is required by <code>MonadLog</code>?</p>
<pre><code>liftLog mempty
  = { definition of mempty for lists }
liftLog []
  = { definition of liftLog for LoggingT }
LoggingT (\dispatchLog -&gt; liftIO (for_ [] dispatchLog))
  = { definition of for_ for [] }
LoggingT (\dispatchLog -&gt; liftIO (return ()))
  = { liftIO . return = return }
LoggingT (\dispatchLog -&gt; return ())
  = { definition of return for LoggingT }
return ()</code></pre>
<p>So far so good!</p>
<pre><code>liftLog (x &lt;&gt; y)
  = { definition of liftLog for LoggingT }
LoggingT (\dispatchLog -&gt; liftIO (for_ (x ++ y) dispatchLog))
  = { for_ distributes over ++ }
LoggingT (\dispatchLog -&gt; liftIO (for_ x dispatchLog &gt;&gt; for_ y dispatchLog)
  = { liftIO (f &gt;&gt;= g) = liftIO f &gt;&gt;= liftIO . g }
LoggingT (\dispatchLog -&gt; liftIO (for_ x dispatchLog) &gt;&gt; liftIO (for_ y dispatchLog))
  = { definition of (&gt;&gt;=) for LoggingT }
LoggingT (\dispatchLog -&gt; liftIO (for_ x dispatchLog)) &gt;&gt;
LoggingT (\dispatchLog -&gt; liftIO (for_ y dispatchLog)) &gt;&gt;
  = { definition of liftLog for LoggingT }
liftLog x &gt;&gt; liftLog y</code></pre>
<p>Bingo!</p>
<h2 id="further-thoughts">Further thoughts</h2>
<p>In this post I presented a pattern for building <code>mtl</code>-like type classes in a mechanical fashion, and this suggests that maybe some of the details can be automatically dealt with. In the next few days I’ll be presenting my <code>algebraic-transformers</code> library which will show exactly that.</p>]]></description>
    <pubDate>Tue, 26 Jan 2016 00:00:00 UT</pubDate>
    <guid>http://ocharles.org.uk/blog/posts/2016-01-26-transformers-free-monads-mtl-laws.html</guid>
    <dc:creator>Oliver Charles</dc:creator>
</item>
<item>
    <title>Announcing a new set of high-level SDL2 bindings</title>
    <link>http://ocharles.org.uk/blog/posts/2015-09-07-announcing-sdl2.html</link>
    <description><![CDATA[<p>It’s with great pleasure that on behalf of the haskell-game group, I’d like to announce the release of <a href="http://hackage.haskell.org/package/sdl2">a new set of high-level bindings</a> to the <a href="http://libsdl.org">SDL</a> library. SDL is a C library providing a set of cross-platform functions for handling graphics, window management, audio, joystick/gamepad interaction, and more.</p>
<p>For a while, we’ve had bindings to SDL 2 on Hackage, but these bindings are as close to 1:1 as you can get in Haskell. This results in a library that certainly <em>can</em> be used in Haskell, but does not feel particularly like writing ordinary Haskell! A real concern here is that this raises the barrier to entry for those new to either game programming or writing games in Haskell (or both!) - a barrier that I would certainly like to see lowered. To address this, myself and many others have spent the last year working on high-level bindings to abstract away the C-like feel of the existing library, and to present a more Haskell interface.</p>
<p>To give you an idea of how things look, here’s a basic application that opens a window, clears the screen, and quits when the user presses ‘q’:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">SDL</span>
<span class="kw">import </span><span class="dt">Linear</span> (<span class="dt">V4</span>(..))
<span class="kw">import </span><span class="dt">Control.Monad</span> (unless)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  initialize [<span class="dt">InitEverything</span>]
  window <span class="ot">&lt;-</span> createWindow <span class="st">&quot;My SDL Application&quot;</span> defaultWindow
  renderer <span class="ot">&lt;-</span> createRenderer window (<span class="fu">-</span><span class="dv">1</span>) defaultRenderer
  appLoop renderer

<span class="ot">appLoop ::</span> <span class="dt">Renderer</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
appLoop renderer <span class="fu">=</span> <span class="kw">do</span>
  events <span class="ot">&lt;-</span> pollEvents
  <span class="kw">let</span> eventIsQPress event <span class="fu">=</span>
        <span class="kw">case</span> eventPayload event <span class="kw">of</span>
          <span class="dt">KeyboardEvent</span> keyboardEvent <span class="ot">-&gt;</span>
            keyboardEventKeyMotion keyboardEvent <span class="fu">==</span> <span class="dt">Pressed</span> <span class="fu">&amp;&amp;</span>
            keysymKeycode (keyboardEventKeysym keyboardEvent) <span class="fu">==</span> <span class="dt">KeycodeQ</span>
          _ <span class="ot">-&gt;</span> <span class="dt">False</span>
      qPressed <span class="fu">=</span> not (null (filter eventIsQPress events))
  rendererDrawColor renderer <span class="fu">$=</span> <span class="dt">V4</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">255</span> <span class="dv">255</span>
  clear renderer
  present renderer
  unless qPressed (appLoop renderer)</code></pre></div>
<p>Hopefully you’ll agree that the code above is close to idiomatic Haskell.</p>
<p>We’ve tried to be extensive with the bindings, and at the moment the following should (!) all be working:</p>
<ul>
<li>Graphics routines have been our highest priority. The bindings should give you full control over window management, access to SDL’s new hardware-accelerated 2D rendering routines, and also the ability to set up an OpenGL context (which is compatible with the <code>OpenGL</code> and <code>gl</code> libraries).</li>
<li>SDL’s audio abstraction is available, and the bindings allow you to open audio devices and stream audio data.</li>
<li>A clean implementation of SDL’s event system, designed for use with pattern matching.</li>
<li>Access to input devices, including keyboard, mouse, pointer devices, and joysticks.</li>
<li>A large collection of example code, ported from the popular “lazyfoo” and “twinklebear” tutorials.</li>
</ul>
<p>The bindings are not 100% exhaustive - we’ve omitted some routines that are already provided by the Haskell runtime, but we also currently lack bindings to the following:</p>
<ul>
<li>Force-feedback (SDL’s “haptic” functionality). While we do have some code in the repository here, none of the contributors own a device that is compatible with SDL2 to actually test this work. If you do, please drop us a line and help out!</li>
<li>Gesture recording for touch screens. We’re currently targetting desktops and laptops, but SDL has support for Android and iOS. Hopefully when GHC is easier to target these devices, we can start to explore these SDL bindings.</li>
<li>Other SDL2 compatible libraries, such as <code>SDL2_net</code> and <code>SDL2_ttf</code>. We’d love for these projects to have the same treatment, and are more than happy to host them under the <code>haskell-game</code> Github account.</li>
</ul>
<p>We hope this enables more people to begin building interactive software and games in Haskell. It’s still early days for these bindings, so if you find any bugs (runtime problems or API bugs), or if you find the bindings lacking in anyway, please don’t hesitate to <a href="https://github.com/haskell-game/sdl2">open an issue</a> on our issue tracker.</p>
<p>Happy hacking!</p>]]></description>
    <pubDate>Mon, 07 Sep 2015 00:00:00 UT</pubDate>
    <guid>http://ocharles.org.uk/blog/posts/2015-09-07-announcing-sdl2.html</guid>
    <dc:creator>Oliver Charles</dc:creator>
</item>
<item>
    <title>Another Approach to Default Function Parameters</title>
    <link>http://ocharles.org.uk/blog/posts/2015-07-23-another-approach-to-default-variables.html</link>
    <description><![CDATA[<p>Recently, there has been some new discussion around the issue of providing default values for function parameters in Haskell. First, <a href="http://www.haskellforall.com">Gabriel Gonzalez</a> showed us his new <a href="http://www.haskellforall.com/2015/06/optional-args-100-optional-function.html"><code>optional-args</code></a> library, which provides new types for optional arguments along with heavy syntactic overloading. To follow that, <a href="http://phaazon.blogspot.fr">Dimitri Sabadie</a> published a blog post <a href="http://phaazon.blogspot.fr/2015/07/dont-use-default.html">discouraging the use</a> of the currently popular <a href="https://hackage.haskell.org/package/data-default-0.5.3/docs/Data-Default.html"><code>Default</code></a> type class. These are both good discussions, and as with any good discussion have been lingering around in the back of my head.</p>
<p>Since those discussions took place, I’ve been playing with my point in the FRP-web-framework design space - <a href="https://github.com/ocharles/Francium">Francium</a>. I made some big refactorings on an application using Francium, mostly extending so called “component” data types (buttons, checkboxes, etc), and was frustrated with how much code broke just from introducing new record fields. The <a href="http://commercialhaskell.com">Commercial Haskell</a> group published an article on <a href="https://github.com/commercialhaskell/haskelldocumentation/blob/master/content/designing-apis-for-extensibility.md">how to design for extensibility</a> back in March, so I decided to revisit that.</p>
<p>It turns out that with a little bit of modification, the approach proposed in designing for extensibility also covers optional arguments pretty well!</p>
<p>First, let’s recap what it means to design for extensibility. The key points are:</p>
<ol style="list-style-type: decimal">
<li>Functions take <code>Settings</code> values, which specify a general configuration.</li>
<li>These <code>Settings</code> values are opaque, meaning they cannot be constructed by a data constructor, but they have a smart constructor instead. This smart constructor allows you to provide default values.</li>
<li>Provide get/set functions for all configurable fields in your <code>Settings</code> data type, preventing the use of record syntax for updates (which leaks implementation details).</li>
</ol>
<p>Regular Haskell users will already be familiar a pattern that can be seen in point 3: we often use a different piece of technology to solve this problem - lenses. Lenses are nice here because they reduce the surface area of our API - two exports can be reduced to just one, which I believe reduces the time to learn a new library. They also compose very nicely, in that they can be embedded into other computations with ease.</p>
<p>With point 3 amended to use some form of lens, we end up with the following type of presentation. Take a HTTP library for example. Our hypothetical library would have the following exports:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">HTTPSettings</span>

<span class="ot">httpKeepAlive ::</span> <span class="dt">Lens</span> <span class="dt">HTTPSettings</span> <span class="dt">Bool</span>
<span class="ot">httpCookieJar ::</span> <span class="dt">Lens</span> <span class="dt">HTTPSettings</span> <span class="dt">CookieJar</span>

<span class="ot">defaultHTTPSettings ::</span> <span class="dt">HTTPSettings</span>

<span class="ot">httpRequest ::</span> <span class="dt">HTTPSettings</span> <span class="ot">-&gt;</span> <span class="dt">HTTPRequest</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Response</span></code></pre></div>
<p>which might have usage</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">httpRequest
  (defaultHTTPSettings <span class="fu">&amp;</span> httpKeepAlive <span class="fu">.~</span> <span class="dt">True</span>)
  aRequest</code></pre></div>
<p>This is an improvement, but I’ve never particularly liked the reverse function application stuff with <code>&amp;</code>. The repeated use of <code>&amp;</code> is essentially working in an <code>Endo</code> <code>Writer</code> monad, or more generally - a state monad. The <code>lens</code> library ships with operators for working specifically in state monads (of course it does), so let’s use that:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="ot">httpRequest ::</span> <span class="dt">State</span> <span class="dt">HTTPSettings</span> x <span class="ot">-&gt;</span> <span class="dt">HTTPRequest</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Response</span>

<span class="fu">....</span>

httpRequest
  (<span class="kw">do</span> httpKeepAlive <span class="fu">.=</span> <span class="dt">True</span>)
  aRequest</code></pre></div>
<p>It’s a small change here, but when you are overriding a lot of parameters, the sugar offered by the use of <code>do</code> is hard to give up - especially when you throw in more monadic combinators like <code>when</code> and <code>unless</code>.</p>
<p>With this seemingly simple syntactic change, something interesting has happened; something which is easier to see if we break open <code>httpRequest</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">httpRequest ::</span> <span class="dt">State</span> <span class="dt">HTTPSettings</span> x <span class="ot">-&gt;</span> <span class="dt">HTTPRequest</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Response</span>
httpRequest mkConfig request <span class="fu">=</span>
  <span class="kw">let</span> config <span class="fu">=</span> execState mkConfig defaultHttpSettings
  <span class="kw">in</span> <span class="fu">...</span></code></pre></div>
<p>Now the default configuration has moved <em>inside</em> the HTTP module, rather than being supplied by the user. All the user provides is essentially a function <code>HTTPSettings -&gt; HTTPSettings</code>, dressed up in a state monad. This means that to use the default configuration, we simply provide a do-nothing state composition: <code>return ()</code>. We can even give this a name</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">def ::</span> <span class="dt">State</span> a ()
def <span class="fu">=</span> return ()</code></pre></div>
<p>and voila, we now have the lovely name-overloading offered by <code>Data.Default</code>, but without the need to introduce a lawless type class!</p>
<p>To conclude, in this post I’ve shown that by slightly modifying the presentation of an approach to build APIs with extensibility in mind, we the main benefit of <code>Data.Default</code>. This main benefit - the <em>raison d’être</em> of <code>Data.Default</code> - is the ability to use the single symbol <code>def</code> whenever you just want <em>a</em> configuration, but don’t care what it is. We still have that ability, and we didn’t have to rely on an ad hoc type class to get there.</p>
<p>However, it’s not all rainbows and puppies: we did have to give something up to get here, and what we’ve given up is a compiler enforced consistency. With <code>Data.Default</code>, there is only a single choice of default configuration for a given type, so you know that <code>def :: HTTPSettings</code> will be the same set of defaults <em>everywhere</em>. With my approach, exactly what <code>def</code> means is down to the function you’re calling and how they want to interpret <code>def</code>. In practice, due to the lack of laws on <code>def</code>, there wasn’t much reasoning you could do about what that single instance was anyway, so I’m not sure much is given up in practice. I try and keep to a single interpretation of <code>def</code> in my libraries by still exporting <code>defaultHTTPSettings</code>, and then using <code>execState mkConfig defaultHTTPSettings</code> whenever I need to interpret a <code>State HTTPConfig</code>.</p>]]></description>
    <pubDate>Thu, 23 Jul 2015 00:00:00 UT</pubDate>
    <guid>http://ocharles.org.uk/blog/posts/2015-07-23-another-approach-to-default-variables.html</guid>
    <dc:creator>Oliver Charles</dc:creator>
</item>
<item>
    <title>24 Days of GHC Extensions: Thanks!</title>
    <link>http://ocharles.org.uk/blog/posts/2014-12-24-conclusion.html</link>
    <description><![CDATA[<p>Wow, another year out! After 24 days of frantic blogging, Christmas is finally upon us, and I’d like to take a moment to send a huge thank you to this years guest posters. To recap, the following authors submitted their work to this year’s series:</p>
<ul>
<li><a href="http://kovach.me/">Benjamin Kovach</a> wrote about <a href="../guest-posts/2014-12-06-rebindable-syntax.html">rebindable syntax</a> and <a href="../guest-posts/2014-12-07-list-comprehensions.html">list comprehensions</a>.</li>
<li><a href="http://www.edofic.com/">Andraz Bajt</a> wrote about GHC’s various <a href="../guest-posts/2014-12-15-deriving.html">“deriving”</a> mechanisms.</li>
<li><a href="https://twitter.com/ertesx">ertes</a> took us through the concept of <a href="../guest-posts/2014-12-18-rank-n-types.html">higher rank types</a>, and their implementation in GHC.</li>
<li><a href="http://ro-che.info/">Roman Cheplyaka</a> explained how to use <a href="../guest-posts/2014-12-19-existential-quantification.html">existential quantification</a>.</li>
<li><a href="http://twdkz.wordpress.com/">Tim Docker</a> showed us how the apparently simple <a href="../guest-posts/2014-12-20-scoped-type-variables.html">“scoped type variables”</a> extension is both useful and necessary.</li>
<li><a href="http://web.jaguarpaw.co.uk/~tom/blog/">Tom Ellis</a> showed us GHC’s special support for <a href="../guest-posts/2014-12-21-arrows.html">arrow notation</a>.</li>
<li><a href="http://fieldsofgoldfish.posthaven.com/">Sean Westfall</a> showed us how to use <a href="../guest-posts/2014-12-22-template-haskell.html">Template Haskell</a>.</li>
<li>Mathieu Boespflug showed us the brand new <a href="../guest-posts/2014-12-23-static-pointers.html">static pointers</a> extension. forthcoming in future GHC versions.</li>
<li>Everyone else who submitted pull requests or otherwise informed me of minor typos.</li>
</ul>
<p>I feel the guest posts have added a lot of variety to the series, and this year each post has consistently gone above and beyond my expectations, delivering incredibly high quality content. Once again, thank you all for your hard work - 24 DOGE wouldn’t be the same without you!</p>
<p>Over the course of the month, we’ve looked at just over 20 extensions - but as I mentioned in the opening post, the story certainly doesn’t stop there. GHC is full of many more interesting extensions - I was hoping to get on to looking at GADTs and data kinds, but alas - there are only so many days in the month. For an example of how these extensions all interact when we write “real-world” software, readers may be interested in viewing my recent Skills Matter talk - <a href="https://skillsmatter.com/skillscasts/5356-oliver-charles">strongly typed publish/subscribe over websockets via singleton types</a>.</p>
<p>I’ve been really happy to see comments this year from people who have learnt about new extensions, seen previous extensions in a different light, or simply formed a deeper understanding of extensions they were already using. While I was a little nervous about the series at the start, I’m now confident it’s been a great success. A huge thank you to everyone who participated in the discussions - as with 24 Days of Hackage in previous years, I feel the discussion around these posts is just as important.</p>
<p>Finally, a thank you to everyone who donated during the series - these tokens of appreciate are greatly appreciated.</p>
<p>To close 24 DOGE, well… a picture speaks a thousand words.</p>
<div class="figure">
<img src="../img/24-doge.jpg" alt="Thanks!" />
<p class="caption">Thanks!</p>
</div>]]></description>
    <pubDate>Wed, 24 Dec 2014 00:00:00 UT</pubDate>
    <guid>http://ocharles.org.uk/blog/posts/2014-12-24-conclusion.html</guid>
    <dc:creator>Oliver Charles</dc:creator>
</item>
<item>
    <title>24 Days of GHC Extensions: Static Pointers</title>
    <link>http://ocharles.org.uk/blog/guest-posts/2014-12-23-static-pointers.html</link>
    <description><![CDATA[<p>Today we start to wrap up 24 Days of GHC Extensions with the final guest post, this time from Mathieu Boespflug of <a href="http://www.tweag.io/">Tweag I/O</a>. Mathieu, along with his colleagues Facundo Domínguez and Alexander Vershilov, has been working with the GHC team on a new extension - in fact, so new, you won’t even find this in a stable release of GHC! In today’s post, we’ll have a look at a new type of pointer that can be useful for distributed programming.</p>
<h2 id="distributed-static-programming">Distributed <code>Static</code> Programming</h2>
<p>GHC already features quite the zoo of pointer types. There are bare <code>Ptr</code>’s (for marshalling to and from foreign objects), <code>ForeignPtr</code>’s (smart pointers that allow automatic memory management of the target object), weak pointers (references to objects that are ignored by the garbage collector), and <code>StablePtr</code>’s (pointers to objects that are pinned to a specific location in memory). GHC 7.10 will add a new beast to this list: <code>StaticPtr</code>, the type of pointers whose value never changes across program runs, even across program runs on different machines. The objects pointed to by static pointers are <em>static</em>, much in the same sense of the word as in other programming languages: their value is known at compile time and their lifetime extends across the entire run of the program. GHC 7.10 also comes with a new language extension to <em>safely</em> create static pointers: <code>StaticPointers</code>.</p>
<p>Why yet another pointer type? And why grace it with yet another extension?</p>
<p>Static pointers turn out to be incredibly useful for distributed programming. Imagine that you have a fleet of networked computers, abstractly called <em>nodes</em>. You’d like these nodes to collaborate, say because you also have a fair amount of data you’d like to crunch through, or because some of these nodes provide services to other nodes. Static pointers help solve the age-old question of distributed programming: how can nodes easily delegate tasks to each other?</p>
<p>For most programming languages, this is a thorny question to ask: support for distributing computations comes as an afterthought, so there is no first class support. But there are exceptions: Erlang is one example of a language that has escaped from research labs one way or another and natively speaks distributed. Erlang supports literally sending the code for any native (non-foreign) function from node to node. Delegating a task called <code>myfun</code> is a case of saying:</p>
<div class="sourceCode"><pre class="sourceCode erlang"><code class="sourceCode erlang"><span class="fu">spawn(</span><span class="dt">There</span><span class="fu">,</span> <span class="ch">myfun</span><span class="fu">)</span></code></pre></div>
<p>where <code>There</code> is a variable containing some node identifier. This capability comes at a cost, however. It is in general hard to share optimized compiled code across a cluster of machines, which may not be running the exact same operating system or have the same system libraries available. So Erlang keeps to comparatively slow but easy to handle and easy to distribute interpreted bytecode instead. Moreover, if new code can be loaded into a running program at any moment or existing code monkey patched on-the-go, what tools do we have to reason about the resulting state of the program?</p>
<p>Haskell too natively speaks distributed, at least in its bleeding edge GHC variant. But at much lower cost. In a world where complete systems can be containerized using language agnostic technology, and shipped and deployed within minutes across a full scale cluster, do we really need our language runtimes to distribute <em>code</em>? Are we willing to accept the compromises involved? Perhaps that is a problem best solved once, for all programs in any language, using the likes of <a href="https://www.docker.com/">Docker</a> or <a href="https://github.com/coreos/rocket">Rocket</a>. And once our entire cluster is running instances of the same program by dint of distributing containers, all we need is a means to control which computations happen when, and where, by sharing <em>references</em> to functions. This works because, if all nodes are running the same program, then they all have access to the same functions.</p>
<p>Turning on <code>-XStaticPointers</code> adds a new keyword <code>static</code> and a new syntactic form to the language for <em>safely</em> creating such references: if expression <code>e</code> has type <code>a</code>, then <code>static e</code> has type <code>StaticPtr a</code>.</p>
<h2 id="static-pointers-in-practice">Static pointers in practice</h2>
<p>For example, here’s a program that obtains a static pointer to <code>f</code>, and prints the info record associated with it:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">GHC.StaticPtr</span>

<span class="ot">fact ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
fact <span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span>
fact n <span class="fu">=</span> n <span class="fu">*</span> fact (n <span class="fu">-</span> <span class="dv">1</span>)

main <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span><span class="ot"> sptr ::</span> <span class="dt">StaticPtr</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>)
      sptr <span class="fu">=</span> static fact
  print <span class="fu">$</span> staticPtrInfo sptr
  print <span class="fu">$</span> deRefStaticPtr sptr <span class="dv">10</span></code></pre></div>
<p>The body of a static form can be any top-level identifier, but also arbitrary expressions, <em>so long as the expression is closed</em>, meaning that all variable names are either bound within the expression itself, or are top-level identifiers. That is, so long as the value of the expression could in principle be computed statically.</p>
<p>Given a static pointer, we can get back the value it points to using</p>
<pre><code>deRefStaticPtr :: StaticPtr a -&gt; a</code></pre>
<p>Notice that we could as well have used a simple string to refer to <code>fact</code> in the above program, construct a string table, so that if the program were distributed we could have each process communicate strings in lieu of functions to commuicate tasks to run remotely, using the string table to map strings back to functions. Something like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">GHC.StaticPtr</span>
<span class="kw">import </span><span class="dt">Data.Dynamic</span>

<span class="ot">fact ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
fact <span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span>
fact n <span class="fu">=</span> n <span class="fu">*</span> fact (n <span class="fu">-</span> <span class="dv">1</span>)

<span class="ot">computation1 ::</span> <span class="dt">IO</span> ()
computation1 <span class="fu">=</span> print <span class="fu">$</span> fact <span class="dv">10</span>

stringTable <span class="fu">=</span>
  [ (<span class="st">&quot;fact&quot;</span>, toDynamic fact)
  , (<span class="st">&quot;computation1&quot;</span>, toDynamic computation1)
  ]

main <span class="fu">=</span> <span class="kw">do</span>
  send <span class="st">&quot;some-node&quot;</span> <span class="st">&quot;computation1&quot;</span></code></pre></div>
<p>where one could imagine node “some-node” running something like</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">serverLoop ::</span> <span class="dt">IO</span> ()
serverLoop <span class="fu">=</span> forever <span class="fu">$</span> <span class="kw">do</span>
  sptr <span class="ot">&lt;-</span> expect
  fromDynamic (stringTable <span class="fu">!!</span> sptr)</code></pre></div>
<p>assuming we have a <code>send</code> function for sending serializable values as messages to nodes and a <code>expect</code> function to receive them available.</p>
<p>Values in the string table are wrapped into <code>Dynamic</code> to make them all have uniform type (that way a simple homegeneous list can do just fine as a datastructure). But there are three problems with this approach:</p>
<ol style="list-style-type: decimal">
<li><p>Constructing the string table is error prone: we might accidentally map the string <code>&quot;fact&quot;</code> to an entirely different function.</p></li>
<li><p>No type safety. <code>fromDynamic</code> performs a type cast. This cast might fail if the type of value in the string table doesn’t match the expected type, making the program partial.</p></li>
<li><p>It is antimodular: each module needs its own string table, which we then need to combine into a global string table for the whole program. If we add a any new module anywhere in the program, we need to also modify the construction of the string table, or accidentally forget to do so, which would constitute a bug.</p></li>
</ol>
<p>(Some of these properties can be obtained with some clever Template Haskell hackery, but that solution is still fundamentally anti-modular, as well as contrived to use.)</p>
<p>It is for these three reasons that the <code>StaticPointers</code> language extension comes in handy. There is no need for manually constructing tables. Constructing and dereferencing static pointers is type safe because the type of a static pointer is related to the type of the value that it points to. Separate modules are not a problem, because the compiler takes care of collecting the set of all static pointers in a program into its own internal table that it embeds in the binary.</p>
<h2 id="pointer-serialization">Pointer serialization</h2>
<p>This all sounds rather nice, but the static pointer type is kept abstract, as it should to ensure safety, so how can we serialize a static pointer to send over the wire, and deserialize it on the remote end to reconstruct the static pointer? The <code>GHC.StaticPtr</code> module exports a few primitives to deal with just that. The idea is that each static pointer in a program is assigned a unique key (a <code>StaticKey</code>). We can obtain the key for a static pointer using</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">StaticKey</span> <span class="fu">=</span> <span class="dt">Fingerprint</span>

<span class="co">-- Defined in GHC.Fingerprint.</span>
<span class="kw">data</span> <span class="dt">Fingerprint</span> <span class="fu">=</span> <span class="dt">Fingerprint</span> <span class="ot">{-# UNPACK #-} !Word64 {-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Word64</span>
  <span class="kw">deriving</span> (<span class="dt">Generic</span>, <span class="dt">Typeable</span>)

<span class="ot">staticKey ::</span> <span class="dt">StaticPtr</span> a <span class="ot">-&gt;</span> <span class="dt">StaticKey</span></code></pre></div>
<p>The type of keys is concrete (a key is a 128-bit hash), so keys can easily be encoded and decoded on the wire, using the <code>Binary</code> type class provided by the <a href="http://hackage.haskell.org/package/binary-0.7.2.3/docs/Data-Binary.html">binary package</a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Automatically derived instance, using `DeriveGeneric`.</span>
<span class="kw">instance</span> <span class="dt">Binary</span> <span class="dt">Fingerprint</span></code></pre></div>
<p>Provided a key, we can map it to a <code>StaticPtr</code> using</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">unsafeLookupStaticPtr ::</span> <span class="dt">StaticKey</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">StaticPtr</span> a)</code></pre></div>
<p>Hold on a minute! This type is telling us that using <code>unsafeLookupStaticPtr</code> we can map the key to a static pointer of any type, which we can then <code>deRefStaticPtr</code> to a value of arbitrary type… Have we just lost type safety? In GHC 7.10, yes we have! In GHC 7.12, we will have a much safer lookup function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lookupStaticPtr ::</span> <span class="dt">StaticKey</span>
                <span class="ot">-&gt;</span> (forall a<span class="fu">.</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> <span class="dt">StaticPtr</span> a <span class="ot">-&gt;</span> b)
                <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</code></pre></div>
<p>(observe that this is a rank-2 type,) or equivalently</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">DynStaticPtr</span> <span class="fu">=</span> forall a<span class="fu">.</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> <span class="dt">DynStaticPtr</span> (<span class="dt">StaticPtr</span> a)

<span class="ot">lookupStaticPtr ::</span> <span class="dt">StaticKey</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">DynStaticPtr</span></code></pre></div>
<p>This type says, provided a key and a continuation, <code>lookupStaticPtr</code> will resolve the key to a static pointer and if successful feed it to the continuation. The type of the static key is not known a priori, but we can query the type inside the continuation using the supplied <code>Typeable</code> constraint. The reason only the unsafe variant will ship in GHC 7.10 is because the safe variant will require a change to the <code>Data.Typeable</code> API to be truly safe (see <a href="https://ghc.haskell.org/trac/ghc/wiki/Typeable">here</a> for details), and because we do not yet store <code>Typeable</code> constraints in the internal compiler-generated table mentioned above. In the meantime, this shouldn’t be a problem in practice: higher level libraries like Cloud Haskell and HdPH hide all uses of <code>lookupStaticPtr</code> behind an API that does guarantee type safety - it’s just that we have to <em>trust</em> that their implementations always call <code>lookupStaticPtr</code> at the right type, when ideally we wouldn’t need to entrust type safety to any library code at all, just the compiler.</p>
<h2 id="static-closures">Static closures</h2>
<p>Static pointers turn out to be suprisingly powerful. As it stands, the language extension nominally only allows sharing references to static values across the wire. But it’s easy to build a lot more power on top. In particular, it would be nice if programs could transmit not just static values over the wire, but indeed (nearly) any odd closure. Consider the following <code>main</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
  putStrLn <span class="st">&quot;Hi! Give me a number...&quot;</span>
  x <span class="ot">&lt;-</span> read <span class="fu">&lt;$&gt;</span> getLine
  send <span class="st">&quot;some-node&quot;</span> <span class="fu">$</span> closure (static fact) <span class="ot">`closureAp`</span> closurePure <span class="dv">10</span></code></pre></div>
<p>The idea (first found in the “Towards Haskell in the Cloud” <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/remote.pdf">paper</a>) is to introduce a datatype of closures (which we’ll define concretely later), along with three combinators to create <code>Closure</code>s from <code>StaticPtr</code>s and from other <code>Closure</code>s:</p>
<pre><code>data Closure a

closure :: StaticPtr a -&gt; Closure a
closurePure :: Serializable a =&gt; a -&gt; Closure a
closureAp :: Closure (a -&gt; b) -&gt; Closure a -&gt; Closure b</code></pre>
<p>Notice that this datatype is nearly, but not quite, an applicative functor. We can only lift “serializable” values to a closure, not just any value. Given two existing <code>Closure</code>s, we can create a new <code>Closure</code> by “applying” one to another. Morally, we are making it possible to pass around not just static pointers to top-level values or purely static expressions, but things that represent (partially) applied static pointers. <code>Closure</code>s are not always static: their value may depend on values known only at runtime, as in the example above.</p>
<p>Come to think of it, a <code>Closure</code> very much acts like the closures that one would find deep in the bowels of GHC for representing partially applied functions during program execution. A closure is morally a code pointer paired with an <em>environment</em>, i.e. a list of actual arguments. Closures accumulate arguments as they are applied. In our case, the <code>StaticPtr</code> represents a code pointer, and the environment grows everytime we <code>closureAp</code> a <code>Closure</code> to something else.</p>
<p>We’ll turn to how <code>Closure</code> is defined in a minute, but first let’s talk about what it really means to be “serializable”:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Dict</span> c <span class="fu">=</span> c <span class="ot">=&gt;</span> <span class="dt">Dict</span>

<span class="kw">class</span> (<span class="dt">Binary</span> a, <span class="dt">Typeable</span> a) <span class="ot">=&gt;</span> <span class="dt">Serializable</span> a <span class="kw">where</span>
<span class="ot">  serializableDict ::</span> <span class="dt">StaticPtr</span> (<span class="dt">Dict</span> (<span class="dt">Serializable</span> a))</code></pre></div>
<p>This class definition says that if a value can be encoded/decoded to a <code>ByteString</code> (see the <a href="http://hackage.haskell.org/package/binary-0.7.2.3/docs/Data-Binary.html">binary package</a>), and it can be queried for a representation of its type at runtime, then the value is <em>serializable</em>. However, serializable values also need to make it possible to obtain concrete “evidence” that the value really is serializable, in the form of a <em>static dictionary</em>. The idea is a neat trick. For all serializable values, we want to be able to obtain a static pointer to the evidence (or “dictionary”) associated with a class constraint. Because if we do, then we can “send” class dictionaries across the wire (or at least references to them)! But we can only take the static pointer of a value, so how does one make dictionary a first class value? The trick is to define a proxy datatype of dictionaries, using the <code>ConstraintKinds</code> extension (the <code>Dict</code> datatype). Any <code>Dict</code> value is a value like any other, but it embeds a constraint in it, which at runtime corresponds to a dictionary.</p>
<p>For example, any concrete value of <code>Dict (Eq Int)</code> carries a dictionary that can be seen as providing evidence that values of <code>Int</code> type can indeed be compared for equality. For any type <code>a</code>, <code>Dict (Serializable a)</code> carries evidence that values of type <code>a</code> are serializable. Any instance of <code>Serializable</code> makes it possible to query for this evidence - for example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Serializable</span> <span class="dt">Int</span> <span class="kw">where</span>
  serializableDict <span class="fu">=</span> static <span class="dt">Dict</span></code></pre></div>
<p>Now we can turn to the definition of <code>Closure</code> and its combinators:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Closure</span> a <span class="kw">where</span>
  <span class="dt">StaticPtr</span><span class="ot"> ::</span> <span class="dt">StaticPtr</span> b <span class="ot">-&gt;</span> <span class="dt">Closure</span> b
  <span class="dt">Encoded</span><span class="ot"> ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Closure</span> <span class="dt">ByteString</span>
  <span class="dt">Ap</span><span class="ot"> ::</span> <span class="dt">Closure</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Closure</span> b <span class="ot">-&gt;</span> <span class="dt">Closure</span> c
  <span class="kw">deriving</span> (<span class="dt">Typeable</span>)

<span class="ot">closure ::</span> <span class="dt">StaticPtr</span> a <span class="ot">-&gt;</span> <span class="dt">Closure</span> a
closure <span class="fu">=</span> <span class="dt">StaticPtr</span>

<span class="ot">closureAp ::</span> <span class="dt">Closure</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Closure</span> a <span class="ot">-&gt;</span> <span class="dt">Closure</span> b
closureAp <span class="fu">=</span> <span class="dt">Ap</span>

<span class="ot">closurePure ::</span> <span class="dt">Serializable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Closure</span> a
closurePure x <span class="fu">=</span>
    <span class="dt">StaticPtr</span> (static decodeD) <span class="ot">`closureAp`</span>
    closure serializableDict <span class="ot">`closureAp`</span>
    <span class="dt">Encoded</span> (encode x)
  <span class="kw">where</span>
<span class="ot">    decodeD ::</span> <span class="dt">Dict</span> (<span class="dt">Serializable</span> a) <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> a
    decodeD <span class="dt">Dict</span> <span class="fu">=</span> decode</code></pre></div>
<p>(There are many ways to define <code>Closure</code>, but this definition is perhaps most intuitive.)</p>
<p>As we can see from the definition, a <code>Closure</code> is not only a (quasi) applicative functor, but in fact a (quasi) <em>free</em> applicative functor. Using the <code>Ap</code> constructor, we can chain closures into long sequences (i.e. build environments). Using <code>StaticPtr</code> and <code>Encoded</code>, we can further make any serializable value a <code>Closure</code> of the following shape:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Ap</span> (<span class="dt">Ap</span> (<span class="dt">StaticPtr</span> sptr_decodeD) csdict) bs</code></pre></div>
<p>where <code>sptr_decodeD</code> is the static pointer to <code>decodeD</code>, <code>csdict</code> is a static serialization dictionary, and <code>bs</code> is a value encoded as a byte string.</p>
<p>Notice that any concrete <code>Closure</code> type is itself serializable:</p>
<pre><code>instance Binary (Closure a) where
  put (Ap (Ap (StaticPtr sptr) dict) (Encoded bs)) =
      putWord8 0 &gt;&gt; put sptr &gt;&gt; put dict &gt;&gt; put bs
  put (StaticPtr sptr) = putWord8 1 &gt;&gt; put sptr
  put (Ap cf cx) = putWord8 2 &gt;&gt; put cf &gt;&gt; put cx

  get = do
    hdr &lt;- getWord8
    case hdr of
      0 -&gt; do sptr &lt;- get
              dict &lt;- get
              bs &lt;- get
              return $ Ap (Ap (StaticPtr sptr) dict) (Encoded bs)
      1 -&gt; StaticPtr &lt;$&gt; get
      2 -&gt; Ap &lt;$&gt; get &lt;*&gt; get

instance Serializable (Closure Int)
  serializableDict = static Dict</code></pre>
<p>(Note that for most types, manually defined <code>Binary</code> instances as above are unnecessary - any datatype with a <code>Generic</code> instance can have its <code>Binary</code> instance derived automatically).</p>
<p>Therefore, suprisingly, adding just static pointers as a primitive datatype in the compiler is all that’s necessary to be able to conveniently send even nearly arbitrary closures down the wire. It turns out that we don’t need to add full blown support for serializing arbitrary closures as an extra primitive to the compiler. That can all be done in user space, and with better control by the user on exactly how. The only limitation is that in effect the environment part of the closure needs to be serializable, but that’s a feature: it means that we can statically rule out accidentally serializing closures that capture gnarly things that we <em>don’t</em> want to serialize down the wire: think file handles, locks, sockets and other system resources, none of which the remote end would be able to make any sense of.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Static pointers are a lightweight extension to GHC, with direct applications to distributed programming, or in general, any form of pointer sharing across processes with distinct address spaces. As first observed in a <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/remote.pdf">seminal paper</a> about distributed programming in Haskell, this extension adds just enough power to the GHC compiler and runtime to conveniently and safely send arbitrary serializable closures across the wire.</p>
<p>Distributed programming in Haskell is a reality today: there are <a href="https://hackage.haskell.org/package/hdph">several</a> <a href="http://hackage.haskell.org/package/courier">frameworks</a>, most prominently <a href="http://haskell-distributed.github.io/">Cloud Haskell</a>, with several industrial applications. But the <code>StaticPointers</code> extension is brand new, and in fact no compiler release including it has shipped yet! Framework and application support for it is still lagging behind, but you can help. In particular, adding support to distributed-static and distributed-process would be a great step forward in the usability Cloud Haskell. Other next steps include: adding support for interoperating multiple versions of a program in a cluster, fully implementing <code>lookupStaticPtr</code> (see above), or improving the robustness and speed of message serialization (see for example <a href="http://code.haskell.org/~duncan/binary-experiment/binary.pdf">these great results</a> for an idea of what’s possible here). Those are just some ideas. If you’re interested in participating, the [GHC wiki][ghc-wiki-dH] contains quite a few pointers, and the cloud-haskell-developers@ and distributed-haskell@ mailing lists are good places to coordinate efforts. See you there!</p>]]></description>
    <pubDate>Tue, 23 Dec 2014 00:00:00 UT</pubDate>
    <guid>http://ocharles.org.uk/blog/guest-posts/2014-12-23-static-pointers.html</guid>
    <dc:creator>Oliver Charles</dc:creator>
</item>
<item>
    <title>24 Days of GHC Extensions: Template Haskell</title>
    <link>http://ocharles.org.uk/blog/guest-posts/2014-12-22-template-haskell.html</link>
    <description><![CDATA[<p>Today I’m happy to announce another guest post; this time <a href="http://fieldsofgoldfish.posthaven.com/">Sean Westfall</a> is going to give us an extensive run down on Template Haskell. Template Haskell is a somewhat contentious extension, but still remains an important tool in the Haskellers toolbox, allowing us to solve problems concisely. Sean’s gone in to a great amount of detail in this post, and you’ll be sure to take something away with you.</p>
<hr />
<p>Template Haskell is an extension of Haskell 98 that allows for compile-time metaprogramming – allowing one to directly convert back and forth between concrete Haskell syntax and the underlying abstract syntax tree (AST) of GHC. Anyone familiar with Lisp’s macro system will immediately recognize the similarities – though in Haskell, specific datatypes are used to represent an AST that is used to draw and splice back in code fragments. The ability to generate code at compile time allows one to implement macro-like expansions, polytypic programs, user directed optimization (such as inlining), and the generation of supporting data structures and functions from existing data structures and functions.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<p>In brief, Oxford brackets <code>[|</code> and <code>|]</code> are used to get the abstract syntax tree for the enclosed expression and ‘splice’ brackets <code>$(</code> and <code>)</code> are used to convert from the abstract syntax tree back into Haskell. The Quotation Monad is used to give unique names to the parsed tokens from the supplied Haskell code, and reification can be used to look up the name, type, constructor, and state of expression, and as well as the AST of Haskell types.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<p>Template Haskell was introduced by Tim Sheard and Simon Peyton Jones in their paper “Template Meta-Programming for Haskell” (The original paper can be found <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/meta-haskell/meta-haskell.pdf">here</a>) in 2002, though its changed quite a bit since (see <a href="http://research.microsoft.com/en-us/um/people/simonpj/tmp/notes2.ps">here</a>). It was inspired by C++ templates, though TH is functionally more similar to a macro system. <a href="http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH-Quote.html">Quasiquotation</a> is often used in conjunction with Template Haskell, but makes up a pretty big section, so I will only briefly describe it here. Only another full article of its own, could do quasiquotation justice.</p>
<p>In the wild, Template Haskell is used extensively by Yesod for routing and HTML template binding.<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> Outside of Haskell, compile-time metaprogramming is used for the creation of Domain Specific Languages (DSLs), typically in the domains of testing and modeling, and generative metaprogramming (compile-time or not) for object relational mapping, typically for mapping database schemas to non-compiled code. And within Lisp, which is famous for it’s macro system, metaprogramming is used to create syntax extensions (syntactic sugar), such as the syntax used in lisp comprehensions.<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a></p>
<hr />
<p><em>All code in this guide was executed with GHCi version 7.6.3 and Template Haskell version 2.9.0.0</em></p>
<p>To get started, start up GHCi with the Template Haskell extension by including <code>-XTemplateHaskell</code>, then load the AST datatypes:</p>
<pre><code>$ ghci -XTemplateHaskell
Prelude&gt; :m + Language.Haskell.TH
Prelude Language.Haskell.TH&gt;</code></pre>
<p>To see the AST syntax of some Haskell code insert valid Haskell syntax into oxford brackets and run it through <code>runQ</code> which stands for the Q monad (quotation monad):</p>
<pre><code>&gt; runQ [| 1 + 2 |]
InfixE (Just (LitE (IntegerL 1))) (VarE GHC.Num.+) (Just (LitE (IntegerL 2)))</code></pre>
<p>If you parse through the parentheses you’ll see the return expression forms a tree – an abstract syntax tree!</p>
<div class="figure">
<img src="https://raw.githubusercontent.com/seanwestfall/templatehaskell/master/syntax_tree.png" alt="abstract syntax tree" />
<p class="caption">abstract syntax tree</p>
</div>
<p>Checkout the lift class <a href="http://hackage.haskell.org/package/template-haskell-2.7.0.0/docs/src/Language-Haskell-TH-Syntax.html#Lift">source</a>, which is what’s being invoked by the oxford brackets. The Language.Haskell.TH.Syntax contains the definitions of all the types used in the AST. Using these types, it’s possible to construct any fragment of the Haskell language. Have a look at the <a href="http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH-Syntax.html#t:Lit">Lit</a> data type as an example. Lit stands for literal,</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Lit</span> <span class="fu">=</span> <span class="dt">CharL</span> <span class="dt">Char</span>
         <span class="fu">|</span> <span class="dt">StringL</span> <span class="dt">String</span>
         <span class="fu">|</span> <span class="dt">IntegerL</span> <span class="dt">Integer</span>     <span class="co">-- ^ Used for overloaded and non-overloaded</span>
                                <span class="co">-- literals. We don't have a good way to</span>
                                <span class="co">-- represent non-overloaded literals at</span>
                                <span class="co">-- the moment. Maybe that doesn't matter?</span>
         <span class="fu">|</span> <span class="dt">RationalL</span> <span class="dt">Rational</span>   <span class="co">-- Ditto</span>
         <span class="fu">|</span> <span class="dt">IntPrimL</span> <span class="dt">Integer</span>
         <span class="fu">|</span> <span class="dt">WordPrimL</span> <span class="dt">Integer</span>
         <span class="fu">|</span> <span class="dt">FloatPrimL</span> <span class="dt">Rational</span>
         <span class="fu">|</span> <span class="dt">DoublePrimL</span> <span class="dt">Rational</span>
         <span class="fu">|</span> <span class="dt">StringPrimL</span> <span class="dt">String</span>	<span class="co">-- ^ A primitive C-style string, type Addr#</span>
    <span class="kw">deriving</span>( <span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Data</span>, <span class="dt">Typeable</span> )</code></pre></div>
<p>tokens represented by it make up literals defined throughout your syntax in the AST, as you can see in our example AST above. Within Language.Haskell.TH.syntax, 35 generic data types are declared with the <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Data.html">Data.Data</a> module. If you’re curious about what the AST syntax is referring to study the <a href="http://hackage.haskell.org/package/template-haskell-2.7.0.0/docs/src/Language-Haskell-TH-Syntax.html#line-716">source</a>.</p>
<p>The <a href="http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH-Syntax.html#t:Q">Q</a> monad handles the expression’s typing via context, and also gives it a unique <a href="http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/src/Language-Haskell-TH-Syntax.html#newName">name</a> by appending an integer at the end of the expression name to handle scoping distinction. Quotations are lexically scoped and the Q monad handles this using it’s naming scheme. (see the user’s guide <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/template-haskell.html">wiki</a> for a more in depth explanation of TH’s lexical scoping).</p>
<p>Let’s bind the returned AST expression from the example above to Haskell and evaluate it, using the splice brackets:</p>
<pre><code>&gt; $( return (InfixE (Just (LitE (IntegerL 1))) (VarE (mkName &quot;+&quot;)) (Just (LitE (IntegerL 2)))))
3</code></pre>
<p>Ta da, you converted concrete Haskell to AST and then evaluated it. Though, as you can see, identifiers have to be defined with the <code>mkName</code> type in the AST to evaluate properly.</p>
<p>It’s possible to avoid having to modify the AST to splice it back, but you’ll have to bind it to a variable, as my next example illustrates:</p>
<p>In this example, the Fibonacci sequence is generated using zipWith:<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span><span class="ot"> fibs ::</span> [<span class="dt">Integer</span>]
    fibs <span class="fu">=</span> <span class="dv">0</span> <span class="fu">:</span> <span class="dv">1</span> <span class="fu">:</span> zipWith (<span class="fu">+</span>) fibs (tail fibs)

<span class="kw">let</span><span class="ot"> fibQ ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span>
    fibQ n <span class="fu">=</span> [<span class="fu">|</span> fibs <span class="fu">!!</span> n <span class="fu">|</span>]</code></pre></div>
<p>Now run <code>$( ... )</code> to excute the expansion:</p>
<pre><code>&gt; $(fibQ 22)
17711</code></pre>
<p>TH splices in the expression that <code>fibQ</code> represents along with the variable (that is <code>fibs !! n</code>).</p>
<p>Note, expressions and splices can be nested:</p>
<pre><code>&gt; $(runQ [| fibs !! $( [| 8 |]) |])
21</code></pre>
<p>I’ll explain TH’s syntax next – but after, I’ll show some more impressive examples that show the possibilities of splicing and ASTs.</p>
<h4 id="syntax">Syntax</h4>
<p>Template Haskell quotation expression come with 4 different parser types, and an extensive 5th optional type that allows one to define their own types of quotations, called quasi-quotations.</p>
<ul>
<li><p><code>[| ... |]</code>, or <code>[e| ... |]</code>, generates expression AST syntax; it has the type <code>Q Exp</code>.</p>
<pre><code>&gt; runQ [| 1 + 2 |]
InfixE (Just (LitE (IntegerL 1))) (VarE GHC.Num.+) (Just (LitE (IntegerL 2)))</code></pre></li>
<li><p><code>[d| ... |]</code>, generates a list of top-level declaration AST sytnax; it has the type <code>Q [Dec]</code>.</p>
<pre><code>&gt; runQ [d|x = 5|]
[ValD (VarP x_4) (NormalB (LitE (IntegerL 5))) []]</code></pre></li>
<li><p><code>[t| ... |]</code>, generates a type AST syntax; it has the type <code>Q Type</code>.</p>
<pre><code>&gt; runQ [t|Int|]
ConT GHC.Types.Int</code></pre></li>
<li><p><code>[p| ... |]</code>, generates a pattern AST syntax; it has the type <code>Q Pat</code>.</p>
<pre><code>&gt; runQ [p|(x,y)|]
TupP [VarP x_5,VarP y_6]</code></pre></li>
<li><p>Custom “quasi-quotations”, have the form <code>[&quot;quoter&quot;| ... |]</code>. The “quoter” can be anything except e, d, t, and p, and the token cannot contain spaces. Though, all GHC is doing is determining which parser to use based on the context within the oxford brackets.<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a></p>
<p>Quasi-quotations is a big second part to meta-programming. They’re essentially what makes it possible to write DSLs. I’m not going to cover it here since this guide is pretty long as it is, but if you’re interested, there are many guides to using quasi-quotations, find them <a href="https://www.cs.drexel.edu/~mainland/publications/mainland07quasiquoting.pdf">here</a>, <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/template-haskell.html#th-quasiquotation">here</a>, and <a href="https://www.fpcomplete.com/user/marcin/quasiquotation-101">here</a> (this one assumes you’re familiar with Parsec parsing).</p></li>
</ul>
<p>An important restriction on Template Haskell to remember is <em>when inside a splice you can only call functions defined in imported modules, not functions defined elsewhere in the same module.</em> Quotations and splice have to be defined in separate modules, otherwise you’ll see this error:</p>
<pre><code>GHC stage restriction:
  `...' is used in a top-level splice or annotation,
  and must be imported, not defined locally</code></pre>
<p>Though, if you’re just binding variables in GHCi with <code>let</code>, you don’t have to worry about this – only when you’re compiling Haskell.</p>
<h4 id="debugging-and-reification">Debugging and Reification</h4>
<p>You’re probably wondering if you can evaluate a Q expression the other way, to see what the splice is evaluating. Of course you can – run <code>runQ(Q exp) &gt;&gt;= putStrLn.pprint</code> to see what an expression with a <code>Q Exp</code> type will evaluate to:</p>
<pre><code>&gt; let myExp :: Q Exp; myExp = runQ [| 1 + 2 |]
&gt; runQ(myExp) &gt;&gt;= putStrLn.pprint
1 GHC.Num.+ 2</code></pre>
<p>If you want to see the expansion of splices, use the flag <code>-ddump-splices</code> when starting GHCi : <code>ghci -XTemplateHaskell -ddump-splices</code>.</p>
<p>Now let’s test it on another fun example with primes:<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span><span class="ot"> isPrime ::</span> (<span class="dt">Integral</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
    isPrime k <span class="fu">|</span> k <span class="fu">&lt;=</span><span class="dv">1</span> <span class="fu">=</span> <span class="dt">False</span> <span class="fu">|</span> otherwise <span class="fu">=</span> not <span class="fu">$</span> elem <span class="dv">0</span> (map (mod k)[<span class="dv">2</span><span class="fu">..</span>k<span class="fu">-</span><span class="dv">1</span>])

<span class="kw">let</span><span class="ot"> nextPrime ::</span> (<span class="dt">Integral</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a
    nextPrime n <span class="fu">|</span> isPrime n <span class="fu">=</span> n <span class="fu">|</span> otherwise <span class="fu">=</span> nextPrime (n<span class="fu">+</span><span class="dv">1</span>)

<span class="co">-- returns a list of all primes between n and m, using the nextPrime function</span>
<span class="kw">let</span><span class="ot"> doPrime ::</span> (<span class="dt">Integral</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]
    doPrime n m
        <span class="fu">|</span> curr <span class="fu">&gt;</span> m <span class="fu">=</span> []
        <span class="fu">|</span> otherwise <span class="fu">=</span> curr<span class="fu">:</span>doPrime (curr<span class="fu">+</span><span class="dv">1</span>) m
        <span class="kw">where</span> curr <span class="fu">=</span> nextPrime n

<span class="co">-- and our Q expression</span>
<span class="kw">let</span><span class="ot"> primeQ ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span>
    primeQ n m <span class="fu">=</span> [<span class="fu">|</span> doPrime n m <span class="fu">|</span>]</code></pre></div>
<pre><code>&gt; $(primeQ 0 67)
&lt;interactive&gt;:18:3-13: Splicing expression
    primeQ 0 67 ======&gt; doPrime 0 67
[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67]</code></pre>
<p>Try it on a nested expression, to really see how useful the dump-splices flag is:</p>
<pre><code>&gt; $(primeQ ($(primeQ 0 23) !! 3) 167)
&lt;interactive&gt;:20:13-23: Splicing expression
    primeQ 0 23 ======&gt; doPrime 0 23
&lt;interactive&gt;:20:3-34: Splicing expression
    primeQ ($(primeQ 0 23) !! 3) 167 ======&gt; doPrime 7 167
[7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167]</code></pre>
<p><code>-ddump-splices</code> and <code>&gt;&gt;= putStrLn.pprint</code> should come in handy when debugging.</p>
<p>Now for probably, what I consider to be the hardest aspect of Template Haskell to understand – reification.</p>
<p>Reification allows one to query the state of Haskell <a href="http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH-Syntax.html#t:Name"><code>Name</code></a>s and get information about them. Specifically, reify returns a data type called <a href="http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH-Syntax.html#t:Info"><code>info</code></a> – which returns data in a specific format on any <code>Name</code> in Haskell, where the format and information depends on whether it’s being interpreted in a type context or an expression context.</p>
<p>TH introduces two new identifiers specifically for reification: Prefix <code>Name</code>s to be evaluted in an expression context with a single quote, and prefix <code>Name</code>s to be evaluated in a type context with a double quote. Though, <code>Name</code>s must be interpretable within those contexts to be reified. (If you intend to use reify on expressions, don’t use quotes in the names of those expressions – otherwise it won’t parse correctly.)</p>
<p>To use reify on a type, use double quotes:</p>
<pre><code>&gt; $(stringE . show =&lt;&lt; reify ''Bool)
&quot;TyConI (DataD [] GHC.Types.Bool [] [NormalC GHC.Types.False [],NormalC GHC.Types.True []] [])&quot;</code></pre>
<p>Reifying a type returns the AST as represented by TH, here’s the AST in a diagram of the boolean type from above:</p>
<div class="figure">
<img src="https://raw.githubusercontent.com/seanwestfall/templatehaskell/master/syntax_tree_bool.png" alt="abstract syntax tree boolean" />
<p class="caption">abstract syntax tree boolean</p>
</div>
<p>The AST of a simple primitive type like Bool produces a small tree, but when used on types deeper down the module chain, relatively large ASTs will be generated. Try reify on <code>''Lit</code> or <code>''Exp</code> to know what I mean, though reify can work on any Haskell type.</p>
<p>To reify an expression, use single quotes, here’s an example with our <code>primeQ</code> expression from above:</p>
<pre><code>&gt; $(stringE . show =&lt;&lt; reify 'primeQ)
&quot;VarI primeQ_1627395913 (AppT (AppT ArrowT (ConT GHC.Types.Int)) (AppT (AppT ArrowT (ConT GHC.Types.Int)) (AppT (ConT Language.Haskell.TH.Syntax.Q) (ConT Language.Haskell.TH.Syntax.Exp)))) Nothing (Fixity 9 InfixL)&quot;</code></pre>
<p>As you can see <code>info</code> returns different information depending on whether it’s a type or an expression. A type returns its structure in TH’s AST semantics. An expression returns information regarding its name, type, it’s constructor, and it’s fixity.</p>
<p>Use reification of expressions to extract the types associated with the construction of an expression, then reify those types to get its structure in an AST. This allows one to generate the AST of any data type in Haskell – no matter how deep into Haskell it gets.</p>
<p>Reification is very useful from the standpoint of what one can do with an AST to draw and splice back in code fragments within a programming language. Below, in Examples, the second example shows how one can use reify to extract the types from a record’s constructor to write a generic Show function that can generate a <code>Show</code> for any record.</p>
<h4 id="examples">Examples</h4>
<p>A good example to show what one can do with Template Haskell is a type safe Haskell version of c’s printf function (from <a href="http://www.gnu.org/software/libc/manual/html_node/Formatted-Output-Functions.html">stdio.h</a>):<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a></p>
<p><em>Main.hs</em></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>

<span class="co">-- Import our template &quot;printf&quot;</span>
<span class="kw">import </span><span class="dt">PrintF</span> (printf)

<span class="co">-- The splice operator $ takes the Haskell source code</span>
<span class="co">-- generated at compile time by &quot;printf&quot; and splices it into</span>
<span class="co">-- the argument of &quot;putStrLn&quot;.</span>
main <span class="fu">=</span> <span class="kw">do</span>
    putStrLn <span class="fu">$</span> <span class="fu">$</span>(printf <span class="st">&quot;Hello %s %%x%% %d %%x%%&quot;</span>) <span class="st">&quot;World&quot;</span> <span class="dv">12</span>
    putStrLn <span class="fu">$</span> <span class="fu">$</span>(printf <span class="st">&quot;Hello %s %s %s %d&quot;</span>) <span class="st">&quot;Russian&quot;</span> <span class="st">&quot;with&quot;</span> <span class="st">&quot;Love&quot;</span> <span class="dv">5000</span></code></pre></div>
<p><em>PrintF.hs</em></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>
<span class="kw">module</span> <span class="dt">PrintF</span> <span class="kw">where</span>

<span class="co">-- NB: printf needs to be in a separate module to the one where</span>
<span class="co">-- you intend to use it.</span>

<span class="co">-- Import some Template Haskell syntax</span>
<span class="kw">import </span><span class="dt">Language.Haskell.TH</span>

<span class="co">-- Possible string tokens: %d %s and literal strings</span>
<span class="kw">data</span> <span class="dt">Format</span> <span class="fu">=</span> <span class="dt">D</span> <span class="fu">|</span> <span class="dt">S</span> <span class="fu">|</span> <span class="dt">L</span> <span class="dt">String</span>
    <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="co">-- a poor man's tokenizer</span>
<span class="ot">tokenize ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Format</span>]
tokenize [] <span class="fu">=</span> []
tokenize (<span class="ch">'%'</span><span class="fu">:</span>c<span class="fu">:</span>rest) <span class="fu">|</span> c <span class="fu">==</span> <span class="ch">'d'</span> <span class="fu">=</span> <span class="dt">D</span> <span class="fu">:</span> tokenize rest
                      <span class="fu">|</span> c <span class="fu">==</span> <span class="ch">'s'</span> <span class="fu">=</span> <span class="dt">S</span> <span class="fu">:</span> tokenize rest
tokenize (s<span class="fu">:</span>str) <span class="fu">=</span> <span class="dt">L</span> (s<span class="fu">:</span>p) <span class="fu">:</span> tokenize rest <span class="co">-- so we don't get stuck on weird '%'</span>
    <span class="kw">where</span> (p,rest) <span class="fu">=</span> span (<span class="fu">/=</span> <span class="ch">'%'</span>) str

<span class="co">-- generate argument list for the function</span>
<span class="ot">args ::</span> [<span class="dt">Format</span>] <span class="ot">-&gt;</span> [<span class="dt">PatQ</span>]
args fmt <span class="fu">=</span> concatMap (\(f,n) <span class="ot">-&gt;</span> <span class="kw">case</span> f <span class="kw">of</span>
                                  <span class="dt">L</span> _ <span class="ot">-&gt;</span> []
                                  _   <span class="ot">-&gt;</span> [varP n]) <span class="fu">$</span> zip fmt names
    <span class="kw">where</span> names <span class="fu">=</span> [ mkName <span class="fu">$</span> <span class="ch">'x'</span> <span class="fu">:</span> show i <span class="fu">|</span> i <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="fu">..</span>] ]

<span class="co">-- generate body of the function</span>
<span class="ot">body ::</span> [<span class="dt">Format</span>] <span class="ot">-&gt;</span> <span class="dt">ExpQ</span>
body fmt <span class="fu">=</span> foldr (\ e e' <span class="ot">-&gt;</span> infixApp e [<span class="fu">|</span> (<span class="fu">++</span>) <span class="fu">|</span>] e') (last exps) (init exps)
    <span class="kw">where</span> exps <span class="fu">=</span> [ <span class="kw">case</span> f <span class="kw">of</span>
                    <span class="dt">L</span> s <span class="ot">-&gt;</span> stringE s
                    <span class="dt">D</span>   <span class="ot">-&gt;</span> appE [<span class="fu">|</span> show <span class="fu">|</span>] (varE n)
                    <span class="dt">S</span>   <span class="ot">-&gt;</span> varE n
                 <span class="fu">|</span> (f,n) <span class="ot">&lt;-</span> zip fmt names ]
          names <span class="fu">=</span> [ mkName <span class="fu">$</span> <span class="ch">'x'</span> <span class="fu">:</span> show i <span class="fu">|</span> i <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="fu">..</span>] ]

<span class="co">-- glue the argument list and body together into a lambda</span>
<span class="co">-- this is what gets spliced into the haskell code at the call</span>
<span class="co">-- site of &quot;printf&quot;</span>
<span class="ot">printf ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span>
printf format <span class="fu">=</span> lamE (args fmt) (body fmt)
    <span class="kw">where</span> fmt <span class="fu">=</span> tokenize format</code></pre></div>
<p>Notice that we had to separate the splicing and the expression definitions in separate modules, as mentioned in the syntax section above.</p>
<p>Compile the following with:</p>
<pre><code>$ ghc --make Main.hs -o main</code></pre>
<p>running main will print out:</p>
<pre><code>$ ./main
Hello World %%x%% 22 %%x%%
Hello Russian with Love 5000</code></pre>
<p>Now for an example that shows what one can do with reify – a Generic Show that can produce a <code>Show</code> for any record type:<a href="#fn9" class="footnoteRef" id="fnref9"><sup>9</sup></a></p>
<p><em>Main.hs</em></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">{- Main.hs -}</span>
<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>
<span class="kw">import </span><span class="dt">Derive</span>

<span class="kw">data</span> <span class="dt">T</span> <span class="fu">=</span> <span class="dt">A</span> <span class="dt">Int</span> <span class="dt">String</span> <span class="fu">|</span> <span class="dt">B</span> <span class="dt">Integer</span> <span class="fu">|</span> <span class="dt">C</span>
<span class="fu">$</span>(deriveShow <span class="ch">''</span><span class="dt">T</span>)

main <span class="fu">=</span> print [<span class="dt">A</span> <span class="dv">1</span> <span class="st">&quot;s&quot;</span>, <span class="dt">B</span> <span class="dv">2</span>, <span class="dt">C</span>]  <span class="co">-- prints exactly &lt;&lt;[A 1 &quot;s&quot;,B 2,C]&gt;&gt;</span></code></pre></div>
<p><em>Derive.hs</em></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">{- Derive.hs -}</span>
<span class="kw">module</span> <span class="dt">Derive</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Language.Haskell.TH</span>
<span class="kw">import </span><span class="dt">Control.Monad</span>

<span class="kw">data</span> <span class="dt">T1</span> <span class="fu">=</span> <span class="dt">T1</span>
<span class="kw">data</span> <span class="dt">T2</span> a <span class="fu">=</span> <span class="dt">T2</span> a

deriveShow t <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- Get list of constructors for type t</span>
  <span class="dt">TyConI</span> (<span class="dt">DataD</span> _ _ _ constructors _)  <span class="ot">&lt;-</span>  reify t

  <span class="co">-- Make `show` clause for one constructor:</span>
  <span class="co">--   show (A x1 x2) = &quot;A &quot;++show x1++&quot; &quot;++show x2</span>
  <span class="kw">let</span> showClause (<span class="dt">NormalC</span> name fields) <span class="fu">=</span> <span class="kw">do</span>
        <span class="co">-- Name of constructor, i.e. &quot;A&quot;. Will become string literal in generated code</span>
        <span class="kw">let</span> constructorName <span class="fu">=</span> nameBase name
        <span class="co">-- Get variables for left and right side of function definition</span>
        (pats,vars) <span class="ot">&lt;-</span> genPE (length fields)
        <span class="co">-- Recursively build (&quot; &quot;++show x1++...++&quot;&quot;) expression from [x1...] variables list</span>
        <span class="kw">let</span> f []       <span class="fu">=</span> [<span class="fu">|</span> <span class="st">&quot;&quot;</span> <span class="fu">|</span>]
            f (v<span class="fu">:</span>vars) <span class="fu">=</span> [<span class="fu">|</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> show <span class="fu">$</span>v <span class="fu">++</span> <span class="fu">$</span>(f vars) <span class="fu">|</span>]
        <span class="co">-- Generate function clause for one constructor</span>
        clause [conP name pats]                                 <span class="co">-- (A x1 x2)</span>
               (normalB [<span class="fu">|</span> constructorName <span class="fu">++</span> <span class="fu">$</span>(f vars) <span class="fu">|</span>]) []  <span class="co">-- &quot;A &quot;++show x1++&quot; &quot;++show x2</span>

  <span class="co">-- Make body for function `show`:</span>
  <span class="co">--   show (A x1 x2) = &quot;A &quot;++show x1++&quot; &quot;++show x2</span>
  <span class="co">--   show (B x1)    = &quot;B &quot;++show x1</span>
  <span class="co">--   show C         = &quot;C&quot;</span>
  showbody <span class="ot">&lt;-</span> mapM showClause constructors

  <span class="co">-- Generate template instance declaration and then replace</span>
  <span class="co">--   type name (T1) and function body (\x -&gt; &quot;text&quot;) with our data</span>
  d <span class="ot">&lt;-</span> [d<span class="fu">|</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">T1</span> <span class="kw">where</span>
             show x <span class="fu">=</span> <span class="st">&quot;text&quot;</span>
       <span class="fu">|</span>]
  <span class="kw">let</span>    [<span class="dt">InstanceD</span> [] (<span class="dt">AppT</span> showt (<span class="dt">ConT</span> _<span class="dt">T1</span>)) [<span class="dt">FunD</span> showf _text]] <span class="fu">=</span> d
  return [<span class="dt">InstanceD</span> [] (<span class="dt">AppT</span> showt (<span class="dt">ConT</span> t  )) [<span class="dt">FunD</span> showf showbody]]


<span class="co">-- Generate n unique variables and return them in form of patterns and expressions</span>
genPE n <span class="fu">=</span> <span class="kw">do</span>
  ids <span class="ot">&lt;-</span> replicateM n (newName <span class="st">&quot;x&quot;</span>)
  return (map varP ids, map varE ids)</code></pre></div>
<p>Compile the following with:</p>
<pre><code>$ ghc --make Main.hs -o main</code></pre>
<p>running main will print out:</p>
<pre><code>$ ./main
[A 1 &quot;s&quot;,B 2,C]</code></pre>
<h4 id="conclusion">Conclusion</h4>
<p>This guide was for the most part written from collecting information written in other guides on Template Haskell, quasi-quoting, and Lisp macros – from online, wiki, and academic sources. Please check my bibliography to see where what came from what so credit can be properly given where it’s due.</p>
<p>Meta-programming is a powerful programming technique that can allow for the generation of user generated syntax extensions and DSLs. This is useful in that it can allow a programmer to generate custom code generating syntax extensions without otherwise having to change the core language. Template Haskell in particular is especially powerful over similar programming language constructs (i.e. The C Preprocessor, Lisp’s Macro system) in that it makes use of ASTs, reification (through a specific function), and – much in the spirit of Haskell – type-safety. The examples presented above only scratch the surface of what’s possible with reification – imagine the ability to construction entire systems, and then use reify to build ASTs, then swap in and out entire modules, entirely with the use of Template Haskell.</p>
<p>Some questions that have arisen within me from writing this article are: What are the limits of TH’s data type system? Is it truly possible for TH to represent all of Haskell with the finite set of data types written into the module? Is it possible for future language features to defy this set? What are the limits of meta-programming – TH, macros, and similar meta-prorgramming constructs make it possible to write code that writes code – but are there limits to this – is it possible to write a macro that can generate a macro, and so on indefinitely?</p>
<p>Don’t forget to checkout the API. Everything you need to know, you can for the most part find in the <a href="http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH-Syntax.html#t:Lit">source</a>. Also TH does in fact have bugs, check the issue tracking page if you’re dealing with a known issue: see <a href="https://ghc.haskell.org/trac/ghc/query?status=new&amp;status=assigned&amp;status=reopened&amp;component=Template+Haskell&amp;order=priority">here</a>.</p>
<h4 id="bibliography">Bibliography</h4>
<h4 id="license">License</h4>
<p>(The MIT License)</p>
<p>Copyright (c) 2014 Sean Westfall</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ‘Software’), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED ‘AS IS’, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Tim Sheard and Simon Peyton Jones, “<a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/meta-haskell/meta-haskell.pdf">Template meta-programming for Haskell</a>,” ACM SIGPLAN 2002 Haskell Workshop 3 (October 2002): 1-6, doi: 10.1145/581690.581691<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/template-haskell.html">The Glorious Glasgow Haskell Compilation System User’s Guide</a>, Version 7.8.3, 2007<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Greg Weber, <a href="http://www.yesodweb.com/blog/2011/10/code-generation-conversation">Code that writes code and conversation about conversations</a>, 2011:<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Peter Seibel, <a href="http://www.gigamonkeys.com/book/macros-defining-your-own.html"><em>Practical Common Lisp</em></a> (Apress, 2005)<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>Mike Ledger, “<a href="http://quasimal.com/posts/2012-05-25-quasitext-and-quasiquoting.html">A look at QuasiQuotation</a>,” 2012.<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>Sami Hangaslammi, <a href="https://github.com/leonidas/codeblog/blob/master/2011/2011-12-27-template-haskell.md">Basic Tutorial of Template Haskell</a>, 2011:<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>Peter Seibel, <a href="http://www.gigamonkeys.com/book/macros-defining-your-own.html"><em>Practical Common Lisp</em></a> (Apress, 2005)<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p><a href="https://www.haskell.org/haskellwiki/Template_Haskell">Template Haskell, Haskell Wiki</a>, last updated October 2014: https://www.haskell.org/haskellwiki/Template_Haskell<a href="#fnref8">↩</a></p></li>
<li id="fn9"><p><a href="http://web.archive.org/web/20100703060856/http://www.haskell.org/bz/thdoc.htm">Unknown Author, Template Haskell doc</a><a href="#fnref9">↩</a></p></li>
</ol>
</div>]]></description>
    <pubDate>Mon, 22 Dec 2014 00:00:00 UT</pubDate>
    <guid>http://ocharles.org.uk/blog/guest-posts/2014-12-22-template-haskell.html</guid>
    <dc:creator>Oliver Charles</dc:creator>
</item>
<item>
    <title>24 Days of GHC Extensions: Arrows</title>
    <link>http://ocharles.org.uk/blog/guest-posts/2014-12-21-arrows.html</link>
    <description><![CDATA[<p>Today’s guest post comes from <a href="http://web.jaguarpaw.co.uk/~tom/blog/">Tom Ellis</a>. If you haven’t heard, Tom released a novel library for interacting with relational databases this year - <a href="http://hackage.haskell.org/package/opaleye">Opaleye</a>. While similar to HaskellDB in some respects, Opaleye is distinct in its extensive use of arrows in order to guarantee safety of queries. In this post, Tom’s going to guide us through GHC’s special syntax support for the <code>Arrow</code> type class.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE Arrows #-}</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Monad</span> (guard)
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Monad.Identity</span> (<span class="dt">Identity</span>, runIdentity)
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Arrow</span> (returnA, <span class="dt">Kleisli</span>(<span class="dt">Kleisli</span>), runKleisli)</code></pre></div>
<p>In Haskell we use the <code>Monad</code> typeclass to provide an interface for encoding certain forms of computation. The <code>Arrow</code> typeclass provides an interface that is in many ways similar. Everything that can be made an instance of <code>Monad</code> (in a law-abiding way) can also be adapted to be an <code>Arrow</code> (in a law-abiding way). This means that the <code>Arrow</code> interface is less powerful than <code>Monad</code>, but that more things can be made instances of <code>Arrow</code>.</p>
<p>Working directly with <code>Monad</code> combinators like <code>&gt;&gt;=</code> and <code>&gt;&gt;</code> can sometimes be awkward so Haskell provides “<code>do</code> notation” as an alternative way of writing monad expressions in a way that can often be clearer. Likewise there is an “arrow notation” for writing arrow expressions. It is not enabled in GHC by default but can be turned on with the <code>Arrows</code> language extension.</p>
<p>The subject of this blog post is how to understand and use arrow notation. It will also serve as an introduction to the <code>Arrow</code> typeclass whilst keeping mention of the arrow combinators to a minimum. We will use develop our intuition for arrow computation rather than learn any technical and formal definitions!</p>
<p>Let’s kick off by refreshing our memory of <code>do</code> notation. A very basic way to think of <code>do</code> notation is that it is similar to a sequence of let bindings. For example, a basic Haskell expression to perform a numerical calculation might be</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
<span class="ot">&gt;</span> f <span class="fu">=</span> \x <span class="ot">-&gt;</span>
<span class="ot">&gt;</span>   <span class="kw">let</span> y  <span class="fu">=</span> <span class="dv">2</span> <span class="fu">*</span> x
<span class="ot">&gt;</span>       z1 <span class="fu">=</span> y <span class="fu">+</span> <span class="dv">3</span>
<span class="ot">&gt;</span>       z2 <span class="fu">=</span> y <span class="fu">-</span> <span class="dv">5</span>
<span class="ot">&gt;</span>   <span class="kw">in</span> (z1, z2)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- ghci&gt; f 10</span>
<span class="ot">&gt;</span> <span class="co">-- (23, 15)</span></code></pre></div>
<p><code>do</code> notation supports expressing the exact same computation inside the <code>Identity</code> monad, that is, a monad that has no “side effects”.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fM ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Identity</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
<span class="ot">&gt;</span> fM <span class="fu">=</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   y  <span class="ot">&lt;-</span> return (<span class="dv">2</span> <span class="fu">*</span> x)
<span class="ot">&gt;</span>   z1 <span class="ot">&lt;-</span> return (y <span class="fu">+</span> <span class="dv">3</span>)
<span class="ot">&gt;</span>   z2 <span class="ot">&lt;-</span> return (y <span class="fu">-</span> <span class="dv">5</span>)
<span class="ot">&gt;</span>   return (z1, z2)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- ghci&gt; runIdentity (fM 10)</span>
<span class="ot">&gt;</span> <span class="co">-- (23,15)</span></code></pre></div>
<p>The <code>let</code> bindings in <code>f</code> become <code>&lt;-</code> under <code>do</code> notation. (For technical reasons we have to wrap every intermediate expression in <code>return</code> to lift them into the <code>Identity</code> monad.) Arrow notation supports a similar translation:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fA ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
<span class="ot">&gt;</span> fA <span class="fu">=</span> proc x <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   y  <span class="ot">&lt;-</span> (<span class="dv">2</span> <span class="fu">*</span>) <span class="fu">-&lt;</span> x
<span class="ot">&gt;</span>   z1 <span class="ot">&lt;-</span> (<span class="fu">+</span> <span class="dv">3</span>) <span class="fu">-&lt;</span> y
<span class="ot">&gt;</span>   z2 <span class="ot">&lt;-</span> (subtract <span class="dv">5</span>) <span class="fu">-&lt;</span> y
<span class="ot">&gt;</span>   returnA <span class="fu">-&lt;</span> (z1, z2)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- ghci&gt; fA 10</span>
<span class="ot">&gt;</span> <span class="co">-- (23,15)</span></code></pre></div>
<p>In arrow notation <code>proc</code> plays the part of “lambda”, i.e. backslash, <code>\</code>, <code>&lt;-</code> plays the part of <code>=</code> and <code>-&lt;</code> feeds an argument into a “function”. We use <code>returnA</code> instead of <code>return</code>.</p>
<p>The benefit of <code>do</code> notation comes when we want to encode a computation that can’t be written using pure <code>let</code> bindings alone. Here’s an example that uses the list monad to generate all coordinates within a given radius of the origin:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; range ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
<span class="ot">&gt;</span> range r <span class="fu">=</span> [<span class="fu">-</span>r<span class="fu">..</span>r]
<span class="ot">&gt;</span> 
<span class="ot">&gt; cM ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>)]
<span class="ot">&gt;</span> cM <span class="fu">=</span> \r <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   x <span class="ot">&lt;-</span> range <span class="dv">5</span>
<span class="ot">&gt;</span>   y <span class="ot">&lt;-</span> range <span class="dv">5</span>
<span class="ot">&gt;</span>   guard (x<span class="fu">*</span>x <span class="fu">+</span> y<span class="fu">*</span>y <span class="fu">&lt;=</span> r<span class="fu">*</span>r)
<span class="ot">&gt;</span>   return (x, y)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- ghci&gt; take 10 (cM 5)</span>
<span class="ot">&gt;</span> <span class="co">-- [(-5,0),(-4,-3),(-4,-2),(-4,-1),(-4,0),(-4,1),(-4,2),(-4,3),(-3,-4),(-3,-3)]</span></code></pre></div>
<p>We read this as</p>
<ul>
<li>for each <code>x</code> in -5 to 5</li>
<li>for each <code>y</code> in -5 to 5</li>
<li>where <code>x*x + y*y &lt;= r*r</code></li>
<li>return the pair of <code>x</code> and <code>y</code></li>
</ul>
<p>Now let’s see how to use arrow notation to express the same computation. For trivial technical reasons we need to wrap the list monad to make it suitable for use with arrow notation. The wrapping and unwrapping don’t actually do anything except shuffle some type parameters around. In arrow computations we will use <code>K [] a b</code> where instead of <code>a -&gt; [b]</code>. We’ll use abbreviated versions of the relevant wrapping and unwrapping functions:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">K</span> <span class="fu">=</span> <span class="dt">Kleisli</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; k ::</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> <span class="dt">Kleisli</span> m a b
<span class="ot">&gt;</span> k <span class="fu">=</span> <span class="dt">Kleisli</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; runK ::</span> <span class="dt">Kleisli</span> m a b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b)
<span class="ot">&gt;</span> runK <span class="fu">=</span> runKleisli</code></pre></div>
<p>Then we can use arrow notation to implement the radius list computation as follows:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; cA ::</span> <span class="dt">Kleisli</span> [] <span class="dt">Int</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
<span class="ot">&gt;</span> cA <span class="fu">=</span> proc r <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   x <span class="ot">&lt;-</span> k range <span class="fu">-&lt;</span> <span class="dv">5</span>
<span class="ot">&gt;</span>   y <span class="ot">&lt;-</span> k range <span class="fu">-&lt;</span> <span class="dv">5</span>
<span class="ot">&gt;</span>   k guard <span class="fu">-&lt;</span> (x<span class="fu">*</span>x <span class="fu">+</span> y<span class="fu">*</span>y <span class="fu">&lt;=</span> r<span class="fu">*</span>r)
<span class="ot">&gt;</span>   returnA <span class="fu">-&lt;</span> (x, y)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- ghci&gt; take 10 (runK cA 5)</span>
<span class="ot">&gt;</span> <span class="co">-- [(-5,0),(-4,-3),(-4,-2),(-4,-1),(-4,0),(-4,1),(-4,2),(-4,3),(-3,-4),(-3,-3)]</span></code></pre></div>
<p>What’s the point of arrow notation? So far we have only seen that it is able to replicate some examples in <code>do</code> notation. Well, the point is that arrow notation forbids some computations that <code>do</code> notation allows. In particular all “arrow actions” must be “statically” known“. That sentence was a mouthful! What does it mean? I am calling the expression that comes between <code>&lt;-</code> and <code>-&lt;</code> in a row of arrow notation the”arrow action“.”Statically known&quot; means that if we have a couple of rows of arrow notation</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">--    y &lt;- action1 -&lt; x</span>
<span class="ot">&gt;</span> <span class="co">--    z &lt;- action2 -&lt; y</span></code></pre></div>
<p>then the expression <code>action2</code> cannot depend on <code>x</code> or indeed anything bound on the left hand side of an arrow notation row.</p>
<p>This restriction has important practical consequences. For example, our Haskell IO system might be based on the following primitives</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; getLineM ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span>
<span class="ot">&gt;</span> getLineM prompt <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   print prompt
<span class="ot">&gt;</span>   getLine
<span class="ot">&gt;</span> 
<span class="ot">&gt; printM ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> printM <span class="fu">=</span> print
<span class="ot">&gt;</span> 
<span class="ot">&gt; writeFileM ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> writeFileM (filePath, string) <span class="fu">=</span> writeFile filePath string</code></pre></div>
<p>then we could use <code>do</code> notation to write a procedure which reads a line of user input and either prints something out or writes to a file based on that input.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; procedureM ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> procedureM <span class="fu">=</span> \prompt <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   input <span class="ot">&lt;-</span> getLineM prompt
<span class="ot">&gt;</span>   <span class="kw">if</span> input <span class="fu">==</span> <span class="st">&quot;Hello&quot;</span>
<span class="ot">&gt;</span>     <span class="kw">then</span> printM <span class="st">&quot;You said 'Hello'&quot;</span>
<span class="ot">&gt;</span>     <span class="kw">else</span> writeFileM (<span class="st">&quot;/tmp/output&quot;</span>, <span class="st">&quot;The user said '&quot;</span> <span class="fu">++</span> input <span class="fu">++</span> <span class="st">&quot;'&quot;</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- ghci&gt; procedureM &quot;Say something&quot;</span>
<span class="ot">&gt;</span> <span class="co">-- &quot;Say something&quot;</span>
<span class="ot">&gt;</span> <span class="co">-- Hello</span>
<span class="ot">&gt;</span> <span class="co">-- &quot;You said 'Hello'&quot;</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- ghci&gt; procedureM &quot;Say something&quot;</span>
<span class="ot">&gt;</span> <span class="co">-- &quot;Say something&quot;</span>
<span class="ot">&gt;</span> <span class="co">-- Bye bye</span>
<span class="ot">&gt;</span> <span class="co">-- (Writes to /tmp/output)</span></code></pre></div>
<p>However, there is no way to express this in arrow notation using only the same primitives.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">-- procedureA :: K IO String ()</span>
<span class="ot">&gt;</span> <span class="co">-- procedureA = proc prompt -&gt; do</span>
<span class="ot">&gt;</span> <span class="co">--  input &lt;- k getLineM -&lt; prompt</span>
<span class="ot">&gt;</span> <span class="co">--  if input == &quot;Hello&quot;</span>
<span class="ot">&gt;</span> <span class="co">--   then printM</span>
<span class="ot">&gt;</span> <span class="co">--   else writeFileM &quot;/tmp/output&quot; ...</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- Oh no!  This won't work because we were trying to refer to a &lt;-</span>
<span class="ot">&gt;</span> <span class="co">-- bound variable on the left hand side of a -&lt;</span></code></pre></div>
<p>Why do we want to use arrows when they have these restrictions? Going into details would take a whole other blog post of its own, but I will mention briefly a few places where the full generality of monads is too much.</p>
<p>Firstly, an arrow-only interface can often allow you to take advantage of opmizations that a monadic interface could not. For example parsers written using parser combinators can be made more memory efficient if we know statically the parsing action they are going to perform. Similarly it can help to reduce the chance of memory leaks in functional reactive programming (e.g. with <code>netwire</code>) if actions cannot depend in an unrestrained way on the result of previous actions.</p>
<p>In embedded domain specific languages this forcing non-dependence can make code generation more easily match a target language. For example in the SQL-generating relational query language Opaleye queries are built up from arrows called <code>QueryArr</code>. Using an arrow rather than a monad allows the semantics of the domain specific language to more closely match the semantics of the underlying SQL language.</p>
<p>So in summary, arrows are a Haskell abstraction, similar to monads, and arrow notation is a way of writing arrow expressions which is similar to to <code>do</code> notation. However, there are some restrictions on what you can do with arrows that are not shared by monads. The benefit of the restriction is you can often receive a performance benefit or use your more specific knowledge about the structure of an arrow computation to your advantage.</p>
<hr />
<p><em>This post is part of <a href="../pages/2014-12-01-24-days-of-ghc-extensions.html">24 Days of GHC Extensions</a> - for more posts like this, check out the <a href="../pages/2014-12-01-24-days-of-ghc-extensions.html">calendar</a></em>.</p>]]></description>
    <pubDate>Sun, 21 Dec 2014 00:00:00 UT</pubDate>
    <guid>http://ocharles.org.uk/blog/guest-posts/2014-12-21-arrows.html</guid>
    <dc:creator>Oliver Charles</dc:creator>
</item>
<item>
    <title>24 Days of GHC Extensions: Scoped Type Variables</title>
    <link>http://ocharles.org.uk/blog/guest-posts/2014-12-20-scoped-type-variables.html</link>
    <description><![CDATA[<p>Today I’m happy to announce that we have another guest blog post. Today, <a href="http://twdkz.wordpress.com/">Tim Docker</a> is going to give us a slighty different perspective (different for me, at least!) on the <em>scoped type variables</em> extension. Over to you, Tim!</p>
<hr />
<p>I’m a fairly conservative haskell developer. Most of my code is close to haskell 2010, with just the odd extension enabled here and there. I like learning new language features, but I’m hesitant to use them in day to day coding until I feel I understand them well.</p>
<p><a href="https://downloads.haskell.org/~ghc/7.8.2/docs/html/users_guide/other-type-extensions.html#scoped-type-variables">ScopedTypeVariables</a> is a straightforward extension that I use often. In this post, I’ll explain why.</p>
<p>Type inference is one of haskell’s many appealing features. But writing explicit type signatures is still important, for several reasons:</p>
<ul>
<li><p>Type signatures are excellent documentation</p></li>
<li><p>Type signatures are a way to confirm that the compiler’s “understanding” of the code matches my mental model.</p></li>
<li><p>Certain type system extensions require type signatures.</p></li>
</ul>
<p>It is considered good haskell style to write type signatures for all top level definitions. And, in complex code it’s often beneficial to write signatures for key subterms. The issue is that, in haskell 2010, explicit type signatures cannot be written for all well typed subterms.</p>
<p>Hence the motivation for ghc’s ScopedTypeVariables extension, as quoted from the <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/scoped-tyvars/">original paper</a>:</p>
<blockquote>
<p>it should be possible for the programmer to write an explicit type signature for any sub-term of the program.</p>
</blockquote>
<p>I am a lazy coder - sometimes the code just flows through my fingers into emacs, but as function types get more complex, I have to think harder. Hence, I like to use the compiler as an assistant, moving from an empty edit buffer to working code, with ghc checking each step along the way. I’ll work through a short example showing this.</p>
<p>For some reason, calls to <code>foldr</code> and <code>foldl</code> have never flowed easily for me - the intuition of folding is natural enough, but the code always needs a little thought, particularly when the folds are nested.</p>
<p>Consider a function where I want to insert a list of values into a map, combining new values with existing ones. Our function will look like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span>

<span class="ot">insertMany ::</span>  <span class="dt">Ord</span> k <span class="ot">=&gt;</span> (v <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> v) <span class="ot">-&gt;</span> [(k,v)] <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> k v <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> k v
insertMany acc vs m <span class="fu">=</span> undefined</code></pre></div>
<p>Now, clearly this is a fold of some function over <code>vs</code>, so lets write it as such, and get ghc to check it:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insertMany ::</span>  <span class="dt">Ord</span> k <span class="ot">=&gt;</span> (v <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> v) <span class="ot">-&gt;</span> [(k,v)] <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> k v <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> k v
insertMany accf vs m <span class="fu">=</span> foldr f1 m vs
  <span class="kw">where</span>
    f1 <span class="fu">=</span> undefined</code></pre></div>
<p>All good. So, what is the type of f1? I could read the documentation for <code>foldr</code>, but given the above code type checks, the compiler already knows the type. Let’s have it tell us, by forcing a type error:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insertMany ::</span>  <span class="dt">Ord</span> k <span class="ot">=&gt;</span> (v <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> v) <span class="ot">-&gt;</span> [(k,v)] <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> k v <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> k v
insertMany accf vs m <span class="fu">=</span> foldr f1 m vs
  <span class="kw">where</span>
<span class="ot">    f1 ::</span> <span class="dt">Int</span>
    f1 <span class="fu">=</span> undefined</code></pre></div>
<p>results in the error:</p>
<pre><code>    Couldn't match expected type ‘(k, v) -&gt; Map.Map k v -&gt; Map.Map k v’
            with actual type ‘Int’
Relevant bindings include
  ...
In the first argument of ‘foldr’, namel</code></pre>
<p>Let’s paste that type in:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insertMany ::</span>  <span class="dt">Ord</span> k <span class="ot">=&gt;</span> (v <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> v) <span class="ot">-&gt;</span> [(k,v)] <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> k v <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> k v
insertMany accf vs m <span class="fu">=</span> foldr f1 m vs
  <span class="kw">where</span>
<span class="ot">    f1 ::</span> (k, v) <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> k v <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> k v
    f1 <span class="fu">=</span> undefined</code></pre></div>
<p>Again, ghc is happy, and now we can clearly see what we need to implement. Conveniently, Map has the <code>insertWith</code> function, which look fit for the task:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insertMany ::</span>  <span class="dt">Ord</span> k <span class="ot">=&gt;</span> (v <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> v) <span class="ot">-&gt;</span> [(k,v)] <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> k v <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> k v
insertMany accf vs m <span class="fu">=</span> foldr f1 m vs
  <span class="kw">where</span>
<span class="ot">    f1 ::</span> (k, v) <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> k v <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> k v
    f1 (k,v) m <span class="fu">=</span> Map.insertWith accf k v m</code></pre></div>
<p>But now, ghc is not happy at all:</p>
<pre><code>Could not deduce (v ~ v1)
from the context (Ord k)
  bound by the type signature for
             insertMany :: Ord k =&gt;
                           (v -&gt; v -&gt; v) -&gt; [(k, v)] -&gt; Map.Map k v -&gt; Map.Map k v
  at /Users/timd/annex/blog/scoped-type-variables/Test.hs:3:16-78
  ‘v’ is a rigid type variable bound by
      the type signature for
        insertMany :: Ord k =&gt;
                      (v -&gt; v -&gt; v) -&gt; [(k, v)] -&gt; Map.Map k v -&gt; Map.Map k v
      at /Users/timd/annex/blog/scoped-type-variables/Test.hs:3:16
  ‘v1’ is a rigid type variable bound by
       the type signature for
         f1 :: (k1, v1) -&gt; Map.Map k1 v1 -&gt; Map.Map k1 v1
       at /Users/timd/annex/blog/scoped-type-variables/Test.hs:6:11
Expected type: v1 -&gt; v1 -&gt; v1
  Actual type: v -&gt; v -&gt; v
Relevant bindings include
   ...
In the first argument of ‘Map.insertWith’, namely ‘accf’
In the expression: Map.insertWith accf k v m</code></pre>
<p>Yikes! Yet it compiles if I comment out the type annotation on f1:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insertMany ::</span>  <span class="dt">Ord</span> k <span class="ot">=&gt;</span> (v <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> v) <span class="ot">-&gt;</span> [(k,v)] <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> k v <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> k v
insertMany accf vs m <span class="fu">=</span> foldr f1 m vs
  <span class="kw">where</span>
<span class="co">--    f1 :: (k, v) -&gt; Map.Map k v -&gt; Map.Map k v</span>
    f1 (k,v) m <span class="fu">=</span> Map.insertWith accf k v m</code></pre></div>
<p>and it works too:</p>
<pre><code>&gt; insertMany (+) [(&quot;a&quot;,5),(&quot;b&quot;,4),(&quot;c&quot;,2),(&quot;b&quot;,11)] Map.empty
fromList [(&quot;a&quot;,5),(&quot;b&quot;,15),(&quot;c&quot;,2)]
&gt;</code></pre>
<p>I could delete the signature and get on with coding, but it makes useful documentation. And why doesn’t it type check anyway? The key lines from the error message are:</p>
<pre><code>Could not deduce (v ~ v1)
  ‘v’ is a rigid type variable bound by
      the type signature for
        insertMany :: Ord k =&gt; (v -&gt; v -&gt; v) -&gt; [(k, v)] -&gt; Map.Map k v -&gt; Map.Map k v
 ‘v1’ is a rigid type variable bound by
       the type signature for
         f1 :: (k1, v1) -&gt; Map.Map k1 v1 -&gt; Map.Map k1 v1</code></pre>
<p>Note that it has reproduced my two type signatures, but the signature for f1 has different type variables. The compiler is telling me that, as written, v and v1 are not the same type. This is the crux of the problem - by writing</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f1 ::</span> (k, v) <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> k v <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> k v</code></pre></div>
<p>I have promised that this function will work for <em>any</em> types k and v. But as I use accf within the implementation of f1, v in f1 is constrained to match the v in insertMany.</p>
<p>The code type checks if I delete the type signature because haskell 2010 can <em>infer</em> the correct type for the f1. But there is no facility to directly express this type in a signature. In haskell 2010, a type variable is only scoped over the type signature in which it appears - I can’t directly “connect” type variables in different type signatures.</p>
<p>The ScopedTypeVariables extension lets us extend the scope of type variables into the corresponding expression, and hence to internal type signatures. Here’s the example, making use of the extension:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span>

<span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span>

<span class="ot">insertMany ::</span>  forall k v <span class="fu">.</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> (v <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> v) <span class="ot">-&gt;</span> [(k,v)] <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> k v <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> k v
insertMany f vs m <span class="fu">=</span> foldr f1 m vs
  <span class="kw">where</span>
<span class="ot">    f1 ::</span> (k, v) <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> k v <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> k v
    f1 (k,v) m <span class="fu">=</span> Map.insertWith f k v m</code></pre></div>
<p>We enable the extension with the <code>LANGUAGE</code> pragma, and then declare that the type variables in the <code>insertMany</code> signature are to be scoped over the corresponding expression with the <code>forall k v</code> quantifier. Hence, <code>v</code> now means the same type wherever it appears in the implementation of <code>insertMany</code>. And hence we have our completed code, annotated as desired.</p>
<p>This is a relatively simple example where I have incrementally written the code whilst using the compiler to ensure that, at each stage, I am proceeding towards a correct solution. It’s longwinded to describe the process, but in practice, with fast error checking from <a href="https://hackage.haskell.org/package/ghc-mod">ghc-mod</a>, the sequence of steps above takes only a minute or two. As the types become more complex, I find this technique very helpful. Using types to guide the writing of the code is sometimes referred to as “hole-driven development”. Mathew Brecknell has created a nice <a href="http://matthew.brecknell.net/post/hole-driven-haskell/">demonstration</a> that shows the process in more detail.</p>
<p>A key part of this technique is writing the type signatures before the code. The ScopedTypeVariables extension makes it possible to write type signatures which cannot be expressed in haskell 2010.</p>
<p>One thing that I didn’t know until I wrote this post is that the <code>forall</code> syntax is not the only way of introducing a scoped type variable. It turns out there are 3 other ways - see the <a href="https://downloads.haskell.org/~ghc/7.8.2/docs/html/users_guide/other-type-extensions.html#scoped-type-variables">ghc documentation</a> for details.</p>
<p>A final note - the forall keyword is not part of haskell 2010, but is used by several different extensions (including ScopedTypeVariables, ExistentialQuantification, RankNTypes). So when you see it in code, it’s worth checking which of these extensions are active.</p>
<h2 id="section">1</h2>
<p><em>This post is part of <a href="../pages/2014-12-01-24-days-of-ghc-extensions.html">24 Days of GHC Extensions</a> - for more posts like this, check out the <a href="../pages/2014-12-01-24-days-of-ghc-extensions.html">calendar</a></em>.</p>]]></description>
    <pubDate>Sat, 20 Dec 2014 00:00:00 UT</pubDate>
    <guid>http://ocharles.org.uk/blog/guest-posts/2014-12-20-scoped-type-variables.html</guid>
    <dc:creator>Oliver Charles</dc:creator>
</item>
<item>
    <title>24 Days of GHC Extensions: Existential Quantification</title>
    <link>http://ocharles.org.uk/blog/guest-posts/2014-12-19-existential-quantification.html</link>
    <description><![CDATA[<p>I’m happy to announce that today <a href="http://ro-che.info/">Roman Cheplyaka</a> is going to take over 24 Days of GHC Extensions, and guide us through the very interesting idea of <em>existential quantification</em>. Like <a href="../guest-posts/2014-12-18-rank-n-types.html">yesterday</a>, this extension is much more than mere syntax sugar - it changes the landscape as to how we can write programs. Roman, the stage is yours!</p>
<hr />
<p>Today we are going to look at existential types, also known as the <a href="https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/data-type-extensions.html#existential-quantification"><code>ExistentialQuantification</code></a> extension. I won’t explain the theory of existential types here; it is admittedly somewhat complex, and good books exist on the subject, to which I’ll refer at the end of this post.</p>
<p>Instead, I want to show one small example of existential types, which hopefully will make you interested enough to go and read those books!</p>
<p>Our example will be a HashMap module similar to <a href="http://hackage.haskell.org/package/unordered-containers-0.2.5.1/docs/Data-HashMap-Lazy.html">Data.HashMap</a>. Specifically, what should an API for such a module look like?</p>
<p>We’ll piggyback on the idea that Ollie described earlier in the series, in the post about <a href="https://ocharles.org.uk/blog/posts/2014-12-04-record-wildcards.html">Record Wildcards</a>, namely: representing modules as records. In that vein, let’s represent our HashMap module as a record:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">HashMap</span> k v <span class="fu">=</span> <span class="fu">...</span> <span class="co">-- actual implementation</span>

<span class="kw">data</span> <span class="dt">HashMapM</span> <span class="fu">=</span> <span class="dt">HashMapM</span>
  {<span class="ot"> empty  ::</span> forall k v <span class="fu">.</span> <span class="dt">HashMap</span> k v
  ,<span class="ot"> lookup ::</span> <span class="dt">Hashable</span> k <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">HashMap</span> k v <span class="ot">-&gt;</span> <span class="dt">Maybe</span> v
  ,<span class="ot"> insert ::</span> <span class="dt">Hashable</span> k <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> <span class="dt">HashMap</span> k v <span class="ot">-&gt;</span> <span class="dt">HashMap</span> k v
  ,<span class="ot"> union  ::</span> <span class="dt">Hashable</span> k <span class="ot">=&gt;</span> <span class="dt">HashMap</span> k v <span class="ot">-&gt;</span> <span class="dt">HashMap</span> k v <span class="ot">-&gt;</span> <span class="dt">HashMap</span> k v
  }</code></pre></div>
<p>One advantage of doing so is the ability to parameterize this module on a (possibly random) salt, which is important for <a href="http://www.serpentine.com/blog/2012/12/13/a-major-new-release-of-the-haskell-hashable-library/">security reasons</a>. Instead of having one static value of the <code>HashMapM</code> type, we’ll have a function that takes a salt and returns a record/module where each operation hashes keys based on that salt:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkHashMapM ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">HashMapM</span></code></pre></div>
<p>Unfortunately, if we do that, bad things may happen. Here’s a recent example. Santa’s junior elf, who only recently got into programming, wanted to give Ollie a giraffe for Christmas, so he wrote this code:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">addGift ::</span> <span class="dt">HashMap</span> <span class="dt">Name</span> <span class="dt">Gift</span> <span class="ot">-&gt;</span> <span class="dt">HashMap</span> <span class="dt">Name</span> <span class="dt">Gift</span>
addGift gifts <span class="fu">=</span>
  <span class="kw">let</span>
    <span class="co">-- locally bring HashMapM functions into scope</span>
    <span class="dt">HashMapM</span>{<span class="fu">..</span>} <span class="fu">=</span> mkHashMapM <span class="dv">42</span>
  <span class="kw">in</span>
    insert <span class="st">&quot;Ollie&quot;</span> giraffe gifts</code></pre></div>
<p>The code compiled, and therefore it worked, or so the elf thought.</p>
<p>Later, when Santa looked up a gift for Ollie, he used his own instantiation of <code>HashMapM</code> with a different salt, and the lookup turned up Nothing. (Which maybe isn’t that bad — keeping a giraffe ain’t easy.)</p>
<p>Could we design the HashMap module to prevent such a rookie mistake? Yes, with existential types!</p>
<p>First, we replace the concrete type <code>HashMap</code> with a type variable <code>hm</code> in the record/module definition:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">HashMapM</span> hm <span class="fu">=</span> <span class="dt">HashMapM</span>
  {<span class="ot"> empty  ::</span> forall k v <span class="fu">.</span> hm k v
  ,<span class="ot"> lookup ::</span> <span class="dt">Hashable</span> k <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> hm k v <span class="ot">-&gt;</span> <span class="dt">Maybe</span> v
  ,<span class="ot"> insert ::</span> <span class="dt">Hashable</span> k <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> hm k v <span class="ot">-&gt;</span> hm k v
  ,<span class="ot"> union  ::</span> <span class="dt">Hashable</span> k <span class="ot">=&gt;</span> hm k v <span class="ot">-&gt;</span> hm k v <span class="ot">-&gt;</span> hm k v
  }</code></pre></div>
<p>Next, we existentially quantify that <code>hm</code> variable by creating a wrapper:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">HashMapE</span> <span class="kw">where</span>
  <span class="dt">HashMapE</span><span class="ot"> ::</span> <span class="dt">HashMapM</span> hm <span class="ot">-&gt;</span> <span class="dt">HashMapE</span></code></pre></div>
<p>Here I used the GADTs syntax, since it makes it easier to see what’s going on. When we wrap a module in the <code>HashMapE</code> constructor, we erase, or forget, the <code>hm</code> type variable — notice how <code>hm</code> is not part of the result type. There’s also equivalent forall-syntax:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">HashMapE</span> <span class="fu">=</span> forall hm <span class="fu">.</span> <span class="dt">HashMapE</span> (<span class="dt">HashMapM</span> hm)</code></pre></div>
<p>The only way to create <code>HashMapM</code> should be through this existential wrapper:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- public</span>
<span class="ot">mkHashMapE ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">HashMapE</span>
mkHashMapE <span class="fu">=</span> <span class="dt">HashMapE</span> <span class="fu">.</span> mkHashMapM

<span class="co">-- private</span>
<span class="ot">mkHashMapM ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">HashMapM</span> <span class="dt">HashMap</span>
mkHashMapM salt <span class="fu">=</span> <span class="dt">HashMapM</span> { <span class="co">{- implementation -}</span> }</code></pre></div>
<p>Now, the important thing about existential types is that every time we unpack <code>HashMapE</code>, we get a fresh <code>hm</code> type. Operationally, the <em>implementation</em> of <code>hm</code> is still <code>HashMap</code> (at least until we write another one, which we could also pack into <code>HashMapE</code>), but from the type system’s perspective, nothing about <code>hm</code> is known.</p>
<p>Let’s try again that elfin code (a variation of it, since we are not allowed to use an existential pattern inside <code>let</code>; we need to use <code>case</code> instead):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">addGift ::</span> <span class="dt">HashMap</span> <span class="dt">Name</span> <span class="dt">Gift</span> <span class="ot">-&gt;</span> <span class="dt">HashMap</span> <span class="dt">Name</span> <span class="dt">Gift</span>
addGift gifts <span class="fu">=</span>
  <span class="kw">case</span> mkHashMapE <span class="dv">42</span> <span class="kw">of</span>
    <span class="dt">HashMapE</span> (<span class="dt">HashMapM</span>{<span class="fu">..</span>}) <span class="ot">-&gt;</span>
      insert <span class="st">&quot;Ollie&quot;</span> giraffe gifts</code></pre></div>
<p>We’ll get the following error:</p>
<pre><code>    Couldn't match type ‘hm’ with ‘HashMap’
      ‘hm’ is a rigid type variable bound by
           a pattern with constructor
             HashMapE :: forall (hm :: * -&gt; * -&gt; *). HashMapM hm -&gt; HashMapE,
           in a case alternative
    Expected type: HashMap Name Gift
      Actual type: hm Name Gift</code></pre>
<p>(In fact, we shouldn’t expose our implementation type <code>HashMap</code> at all; it’s now completely useless.)</p>
<p>But what if we replace <code>HashMap</code> with <code>hm</code>, just as the error message suggests?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">addGift ::</span> hm <span class="dt">Name</span> <span class="dt">Gift</span> <span class="ot">-&gt;</span> hm <span class="dt">Name</span> <span class="dt">Gift</span>
addGift gifts <span class="fu">=</span>
  <span class="kw">case</span> mkHashMapE <span class="dv">42</span> <span class="kw">of</span>
    <span class="dt">HashMapE</span> (<span class="dt">HashMapM</span>{<span class="fu">..</span>}) <span class="ot">-&gt;</span>
      insert <span class="st">&quot;Ollie&quot;</span> giraffe gifts</code></pre></div>
<p>Still no luck:</p>
<pre><code>    Couldn't match type ‘hm1’ with ‘hm’
      ‘hm1’ is a rigid type variable bound by
            a pattern with constructor
              HashMapE :: forall (hm :: * -&gt; * -&gt; *). HashMapM hm -&gt; HashMapE,
            in a case alternative
      ‘hm’ is a rigid type variable bound by
           the type signature for addGift :: hm Name Gift -&gt; hm Name Gift
    Expected type: hm Name Gift
      Actual type: hm1 Name Gift</code></pre>
<p>The compiler is too clever to be tricked by our choice of names; it’ll always create a <em>fresh</em> type each time it unpacks <code>HashMapE</code>. So the elf has no choice but to write code the right way, which is of course to take a module as an argument:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">addGift ::</span> <span class="dt">HashMapM</span> hm <span class="ot">-&gt;</span> hm <span class="dt">Name</span> <span class="dt">Gift</span> <span class="ot">-&gt;</span> hm <span class="dt">Name</span> <span class="dt">Gift</span>
addGift mod gifts <span class="fu">=</span>
  <span class="kw">let</span>
    <span class="dt">HashMapM</span>{<span class="fu">..</span>} <span class="fu">=</span> mod
  <span class="kw">in</span>
    insert <span class="st">&quot;Ollie&quot;</span> giraffe gifts</code></pre></div>
<p>Notice how in the type signature <code>hm</code> of the record/module is the same as <code>hm</code> of the gift map. That makes the type checker happy.</p>
<p>And here’s how Santa might use the function his elf has just written:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">sendGifts <span class="fu">=</span>
  <span class="kw">case</span> mkHashMapE santa'sSecretSalt <span class="kw">of</span>
    <span class="dt">HashMapE</span> (mod<span class="fu">@</span><span class="dt">HashMapM</span>{<span class="fu">..</span>}) <span class="ot">-&gt;</span>
      <span class="kw">let</span>
        gifts <span class="fu">=</span> addGift mod empty
      <span class="kw">in</span>
        traverse_ sendGiftToOllie <span class="fu">$</span> lookup <span class="st">&quot;Ollie&quot;</span> gifts</code></pre></div>
<p>Unlike some other extensions, <code>ExistentialQuantification</code> wasn’t introduced for some specific purpose. Existential quantification is a concept from logic and type theory which turned out to be quite useful in practice. Existential types help model and implement:</p>
<ul>
<li><a href="https://dl.acm.org/citation.cfm?id=45065">abstract data types</a></li>
<li>ML-style packages</li>
<li>object-oriented programming (see «Existential Objects» in <a href="http://www.cis.upenn.edu/~bcpierce/tapl/">TAPL</a>)</li>
<li><a href="http://community.haskell.org/~simonmar/papers/ext-exceptions.pdf">extensible exceptions</a></li>
<li>dynamic typing (as in <code>Data.Dynamic</code>)</li>
<li>type-aligned sequences, such as <a href="http://ro-che.info/articles/2013-03-31-flavours-of-free-applicative-functors">free applicative functors</a> or <a href="http://homepages.cwi.nl/~ploeg/papers/zseq.pdf">bind chains</a></li>
</ul>
<p>If you plan to use existential types, I advise you to gain a deeper understanding of them from a book on programming languages, such as Pierce’s <a href="http://www.cis.upenn.edu/~bcpierce/tapl/">Types and Programming Languages</a> (recommended), Mitchell’s <a href="https://mitpress.mit.edu/books/foundations-programming-languages">Foundations for Programming Languages</a>, or <a href="http://www.cambridge.org/us/knowledge/discountpromotion/?site_locale=en_US&amp;code=L2PFPL">Practical Foundations for Programming Languages</a> (available <a href="http://www.cs.cmu.edu/~rwh/plbook/book.pdf">online</a> for free).</p>
<hr />
<p><em>This post is part of <a href="../pages/2014-12-01-24-days-of-ghc-extensions.html">24 Days of GHC Extensions</a> - for more posts like this, check out the <a href="../pages/2014-12-01-24-days-of-ghc-extensions.html">calendar</a></em>.</p>]]></description>
    <pubDate>Fri, 19 Dec 2014 00:00:00 UT</pubDate>
    <guid>http://ocharles.org.uk/blog/guest-posts/2014-12-19-existential-quantification.html</guid>
    <dc:creator>Oliver Charles</dc:creator>
</item>

    </channel>
</rss>
